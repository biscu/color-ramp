/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fdavidebiscuso%2FDocuments%2FGitHub%2Fcolor-ramp%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!********************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fdavidebiscuso%2FDocuments%2FGitHub%2Fcolor-ramp%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \********************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.tsx */ \"(app-pages-browser)/./app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZkYXZpZGViaXNjdXNvJTJGRG9jdW1lbnRzJTJGR2l0SHViJTJGY29sb3ItcmFtcCUyRmFwcCUyRnBhZ2UudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsc0pBQWtHIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvZGF2aWRlYmlzY3Vzby9Eb2N1bWVudHMvR2l0SHViL2NvbG9yLXJhbXAvYXBwL3BhZ2UudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fdavidebiscuso%2FDocuments%2FGitHub%2Fcolor-ramp%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@k-vyn/coloralgorithm/dist/bundle.js":
/*!***********************************************************!*\
  !*** ./node_modules/@k-vyn/coloralgorithm/dist/bundle.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generate: () => (/* binding */ generate)\n/* harmony export */ });\n// Originally from https://github.com/koenbok/Framer/blob/master/framer/Utils.coffee\n// Translated to Typescript\nfunction distribute({ value, rangeA, rangeB, limit, }) {\n    if (limit === undefined) {\n        limit = false;\n    }\n    const [fromLow, fromHigh] = Array.from(rangeA);\n    const [toLow, toHigh] = Array.from(rangeB);\n    const result = toLow + ((value - fromLow) / (fromHigh - fromLow)) * (toHigh - toLow);\n    if (limit === true) {\n        if (toLow < toHigh) {\n            if (result < toLow) {\n                return toLow;\n            }\n            if (result > toHigh) {\n                return toHigh;\n            }\n        }\n        else {\n            if (result > toLow) {\n                return toLow;\n            }\n            if (result < toHigh) {\n                return toHigh;\n            }\n        }\n    }\n    return result;\n}\n\nconst bezier$2 = __webpack_require__(/*! bezier-easing */ \"(app-pages-browser)/./node_modules/bezier-easing/src/index.js\");\nfunction generateNumberOfSteps({ curve, steps, }) {\n    const arrayOfSteps = Array.from(Array(steps).keys());\n    var array = [];\n    for (const step in arrayOfSteps) {\n        const stepNumber = parseInt(step, 10);\n        const easing = bezier$2(...curve);\n        const value = easing(stepNumber / (steps - 1));\n        array.push(value);\n    }\n    return array;\n}\n\nconst defaultCurves = {\n    linear: {\n        name: \"linear\",\n        formatted_name: \"Linear\",\n        value: [0.5, 0.5, 0.5, 0.5],\n    },\n    easeInCubic: {\n        name: \"easeInCubic\",\n        formatted_name: \"Cubic - EaseIn\",\n        value: [0.55, 0.055, 0.675, 0.19],\n    },\n    easeOutCubic: {\n        name: \"easeOutCubic\",\n        formatted_name: \"Cubic - EaseOut\",\n        value: [0.215, 0.61, 0.355, 1],\n    },\n    easeInOutCubic: {\n        name: \"easeInOutCubic\",\n        formatted_name: \"Cubic - EaseInOut\",\n        value: [0.645, 0.045, 0.355, 1],\n    },\n    easeInSine: {\n        name: \"easeInSine\",\n        formatted_name: \"Sine - EaseIn\",\n        value: [0.47, 0, 0.745, 0.715],\n    },\n    easeOutSine: {\n        name: \"easeOutSine\",\n        formatted_name: \"Sine - EaseOut\",\n        value: [0.39, 0.575, 0.565, 1],\n    },\n    easeInOutSine: {\n        name: \"easeInOutSine\",\n        formatted_name: \"Sine - EaseInOut\",\n        value: [0.445, 0.05, 0.55, 0.95],\n    },\n    easeInQuad: {\n        name: \"easeInQuad\",\n        formatted_name: \"Quad - EaseIn\",\n        value: [0.55, 0.085, 0.68, 0.53],\n    },\n    easeOutQuad: {\n        name: \"easeOutQuad\",\n        formatted_name: \"Quad - EaseOut\",\n        value: [0.25, 0.46, 0.45, 0.94],\n    },\n    easeInOutQuad: {\n        name: \"easeInOutQuad\",\n        formatted_name: \"Quad - EaseInOut\",\n        value: [0.455, 0.03, 0.515, 0.955],\n    },\n    easeInQuart: {\n        name: \"easeInQuart\",\n        formatted_name: \"Quart - EaseIn\",\n        value: [0.895, 0.03, 0.685, 0.22],\n    },\n    easeOutQuart: {\n        name: \"easeOutQuart\",\n        formatted_name: \"Quart - EaseOut\",\n        value: [0.165, 0.84, 0.44, 1],\n    },\n    easeInOutQuart: {\n        name: \"easeInOutQuart\",\n        formatted_name: \"Quart - EaseInOut\",\n        value: [0.77, 0, 0.175, 1],\n    },\n    easeInQuint: {\n        name: \"easeInQuint\",\n        formatted_name: \"Quint - EaseIn\",\n        value: [0.755, 0.05, 0.855, 0.06],\n    },\n    easeOutQuint: {\n        name: \"easeOutQuint\",\n        formatted_name: \"Quint - EaseOut\",\n        value: [0.23, 1, 0.32, 1],\n    },\n    easeInOutQuint: {\n        name: \"easeInOutQuint\",\n        formatted_name: \"Quint - EaseInOut\",\n        value: [0.86, 0, 0.07, 1],\n    },\n    easeInCirc: {\n        name: \"easeInCirc\",\n        formatted_name: \"Circ - EaseIn\",\n        value: [0.6, 0.04, 0.98, 0.335],\n    },\n    easeOutCirc: {\n        name: \"easeOutCirc\",\n        formatted_name: \"Circ - EaseOut\",\n        value: [0.075, 0.82, 0.165, 1],\n    },\n    easeInOutCirc: {\n        name: \"easeInOutCirc\",\n        formatted_name: \"Circ - EaseInOut\",\n        value: [0.785, 0.135, 0.15, 0.86],\n    },\n    easeInExpo: {\n        name: \"easeInExpo\",\n        formatted_name: \"Expo - EaseIn\",\n        value: [0.95, 0.05, 0.795, 0.035],\n    },\n    easeOutExpo: {\n        name: \"easeOutExpo\",\n        formatted_name: \"Expo - EaseOut\",\n        value: [0.19, 1, 0.22, 1],\n    },\n    easeInOutExpo: {\n        name: \"easeInOutExpo\",\n        formatted_name: \"Expo - EaseInOut\",\n        value: [1, 0, 0, 1],\n    },\n    easeInBack: {\n        name: \"easeInBack\",\n        formatted_name: \"Back - EaseIn\",\n        value: [0.6, -0.28, 0.735, 0.045],\n    },\n    easeOutBack: {\n        name: \"easeOutBack\",\n        formatted_name: \"Back - EaseOut\",\n        value: [0.175, 0.885, 0.32, 1.275],\n    },\n    easeInOutBack: {\n        name: \"easeInOutBack\",\n        formatted_name: \"Back - EaseInOut\",\n        value: [0.68, -0.55, 0.265, 1.55],\n    },\n};\n\nfunction getCoordinates(curve, invert) {\n    if (typeof curve === \"string\") {\n        const coordinates = defaultCurves[curve];\n        if (coordinates) {\n            return invert === true\n                ? coordinates.value.slice().reverse()\n                : coordinates.value;\n        }\n        else {\n            throw Error(\"provided incorrect curve\");\n        }\n    }\n    if (typeof curve === \"object\") {\n        if (curve.length === 4) {\n            if (!curve.some(isNaN)) {\n                return curve;\n            }\n            else {\n                throw Error(\"incompatible curve\");\n            }\n        }\n        else {\n            throw Error(\"curve is neither a string or a compatible array\");\n        }\n    }\n    throw Error(\"curve was neither a string or an object\");\n}\n\nfunction generateColors(props, options, invert) {\n    const { steps, hue, saturation, brightness } = props;\n    const { minorSteps } = options;\n    // default rotation is clockwise\n    const rotation = options.rotation === \"counterclockwise\" || options.rotation === \"ccw\"\n        ? \"ccw\"\n        : \"cw\";\n    // generate steps 0 to 1 based on curve\n    const hueSteps = generateNumberOfSteps({\n        curve: getCoordinates(hue.curve, invert),\n        steps,\n    });\n    const saturationSteps = generateNumberOfSteps({\n        curve: getCoordinates(saturation.curve, invert),\n        steps,\n    });\n    const brightnessSteps = generateNumberOfSteps({\n        curve: getCoordinates(brightness.curve, invert),\n        steps,\n    });\n    // adjust hue start/end to get the intended rotation\n    if (rotation === \"cw\") {\n        if (hue.start > hue.end) {\n            hue.start -= 360;\n        }\n    }\n    else if (rotation === \"ccw\") {\n        if (hue.end > hue.start) {\n            hue.end -= 360;\n        }\n    }\n    // Distribute the generated steps between hue, saturation, brightness ranges\n    const hueValues = hueSteps.map(function (s) {\n        return distribute({\n            value: s,\n            rangeA: [0, 1],\n            rangeB: [\n                invert === true ? hue.end : hue.start,\n                invert === true ? hue.start : hue.end,\n            ],\n            limit: true,\n        });\n    });\n    const saturationValues = saturationSteps.map(function (s) {\n        const value = distribute({\n            value: s,\n            rangeA: [0, 1],\n            rangeB: [\n                invert === true ? saturation.end : saturation.start,\n                invert === true ? saturation.start : saturation.end,\n            ],\n            limit: true,\n        });\n        const valueWithRate = value * saturation.rate;\n        return valueWithRate < 1 ? valueWithRate : 1; // prevent too much satuartion saturation\n    });\n    const brightnessValues = brightnessSteps.map(function (s) {\n        return distribute({\n            value: s,\n            rangeA: [0, 1],\n            rangeB: [\n                invert === true ? brightness.end : brightness.start,\n                invert === true ? brightness.start : brightness.end,\n            ],\n        });\n    });\n    // Merge values into color steps\n    const colorSteps = hueValues.map(function (hue, i) {\n        const step = {\n            hue: {\n                step: hueSteps[i],\n                value: hueValues[i],\n            },\n            saturation: {\n                step: saturationSteps[i],\n                value: saturationValues[i],\n            },\n            brightness: {\n                step: brightnessSteps[i],\n                value: brightnessValues[i],\n            },\n            step: i,\n            isMajor: true,\n            isLocked: false,\n        };\n        return step;\n    });\n    // generate minor steps\n    if (minorSteps) {\n        minorSteps.forEach(function (o, i) {\n            const defaultStep = {\n                hue: {\n                    step: 0,\n                    value: 0,\n                },\n                saturation: {\n                    step: 0,\n                    value: 0,\n                },\n                brightness: {\n                    step: 0,\n                    value: 0,\n                },\n                isMajor: true,\n                isLocked: false,\n                step: 0,\n            };\n            let insertPreviousStep = defaultStep;\n            let insertNextStep = defaultStep;\n            let insertAtIndex = 0;\n            colorSteps.forEach(function (p, j) {\n                if (o === p.step) {\n                    insertAtIndex = j + 1;\n                    insertPreviousStep = p;\n                    insertNextStep = colorSteps[j + 1];\n                }\n            });\n            const hueStep = (insertPreviousStep.hue.step + insertNextStep.hue.step) / 2;\n            const hueValue = distribute({\n                value: hueStep,\n                rangeA: [0, 1],\n                rangeB: [\n                    invert === true ? hue.end : hue.start,\n                    invert === true ? hue.start : hue.end,\n                ],\n            });\n            const saturationStep = (insertPreviousStep.saturation.step + insertNextStep.saturation.step) /\n                2;\n            let saturationValue = distribute({\n                value: saturationStep,\n                rangeA: [0, 1],\n                rangeB: [\n                    invert === true ? saturation.end : saturation.start,\n                    invert === true ? saturation.start : saturation.end,\n                ],\n            }) * saturation.rate;\n            saturationValue = saturationValue < 1 ? saturationValue : 1;\n            const brightnessStep = (insertPreviousStep.brightness.step + insertNextStep.brightness.step) /\n                2;\n            const brightnessValue = distribute({\n                value: brightnessStep,\n                rangeA: [0, 1],\n                rangeB: [\n                    invert === true ? brightness.end : brightness.start,\n                    invert === true ? brightness.start : brightness.end,\n                ],\n            });\n            if (insertAtIndex !== undefined) {\n                const insertItem = {\n                    hue: {\n                        step: hueStep,\n                        value: hueValue,\n                    },\n                    saturation: {\n                        step: saturationStep,\n                        value: saturationValue,\n                    },\n                    brightness: {\n                        step: brightnessStep,\n                        value: brightnessValue,\n                    },\n                    isLocked: false,\n                    isMajor: false,\n                    step: (insertPreviousStep.step + insertNextStep.step) / 2,\n                };\n                colorSteps.splice(insertAtIndex, 0, insertItem);\n            }\n        });\n    }\n    return colorSteps;\n}\n\nconst chroma$1 = __webpack_require__(/*! chroma-js */ \"(app-pages-browser)/./node_modules/chroma-js/dist/chroma.cjs\");\nfunction convertToColors(props, options, algorithmResult) {\n    const results = algorithmResult.map(function (set, i) {\n        const colors = set.map(function ({ hue, saturation, brightness, isMajor, isLocked, step, }) {\n            const color = chroma$1.hsv(hue.value, saturation.value, brightness.value);\n            function replaceNaN(array) {\n                // fixes a NaN for 0 values in ChromaJS\n                array[0] = 0;\n                return array;\n            }\n            const convertedColor = {\n                step,\n                hue: hue.value,\n                saturation: saturation.value,\n                brightness: brightness.value,\n                isMajor,\n                isLocked,\n                hex: color.hex(),\n                hsl: isNaN(color.hsl()[0]) ? replaceNaN(color.hsl()) : color.hsl(),\n                hsv: isNaN(color.hsv()[0]) ? replaceNaN(color.hsv()) : color.hsv(),\n                lab: isNaN(color.lab()[0]) ? replaceNaN(color.lab()) : color.lab(),\n                rgbString: color.rgb().join(),\n                rgbArray: color.rgb(),\n                rgbaString: color.rgba().join(),\n                rgbaArray: color.rgba(),\n            };\n            return convertedColor;\n        });\n        return {\n            inverted: i > 0 ? true : false,\n            colors: colors,\n            name: options.name,\n        };\n    });\n    return results;\n}\n\nvar limit = (x, low = 0, high = 1) => {\n    return min$3(max$3(low, x), high);\n};\n\nvar clip_rgb = (rgb) => {\n    rgb._clipped = false;\n    rgb._unclipped = rgb.slice(0);\n    for (let i = 0; i <= 3; i++) {\n        if (i < 3) {\n            if (rgb[i] < 0 || rgb[i] > 255) rgb._clipped = true;\n            rgb[i] = limit(rgb[i], 0, 255);\n        } else if (i === 3) {\n            rgb[i] = limit(rgb[i], 0, 1);\n        }\n    }\n    return rgb;\n};\n\n// ported from jQuery's $.type\nconst classToType = {};\nfor (let name of [\n    'Boolean',\n    'Number',\n    'String',\n    'Function',\n    'Array',\n    'Date',\n    'RegExp',\n    'Undefined',\n    'Null'\n]) {\n    classToType[`[object ${name}]`] = name.toLowerCase();\n}\nfunction type (obj) {\n    return classToType[Object.prototype.toString.call(obj)] || 'object';\n}\n\nvar unpack = (args, keyOrder = null) => {\n    // if called with more than 3 arguments, we return the arguments\n    if (args.length >= 3) return Array.prototype.slice.call(args);\n    // with less than 3 args we check if first arg is object\n    // and use the keyOrder string to extract and sort properties\n    if (type(args[0]) == 'object' && keyOrder) {\n        return keyOrder\n            .split('')\n            .filter((k) => args[0][k] !== undefined)\n            .map((k) => args[0][k]);\n    }\n    // otherwise we just return the first argument\n    // (which we suppose is an array of args)\n    return args[0].slice(0);\n};\n\nvar last = (args) => {\n    if (args.length < 2) return null;\n    const l = args.length - 1;\n    if (type(args[l]) == 'string') return args[l].toLowerCase();\n    return null;\n};\n\nconst { PI: PI$2, min: min$3, max: max$3 } = Math;\n\nconst rnd2 = (a) => Math.round(a * 100) / 100;\nconst rnd3 = (a) => Math.round(a * 100) / 100;\n\nconst TWOPI = PI$2 * 2;\nconst PITHIRD = PI$2 / 3;\nconst DEG2RAD = PI$2 / 180;\nconst RAD2DEG = 180 / PI$2;\n\nvar input = {\n    format: {},\n    autodetect: []\n};\n\nclass Color {\n    constructor(...args) {\n        const me = this;\n        if (\n            type(args[0]) === 'object' &&\n            args[0].constructor &&\n            args[0].constructor === this.constructor\n        ) {\n            // the argument is already a Color instance\n            return args[0];\n        }\n        // last argument could be the mode\n        let mode = last(args);\n        let autodetect = false;\n        if (!mode) {\n            autodetect = true;\n\n            if (!input.sorted) {\n                input.autodetect = input.autodetect.sort((a, b) => b.p - a.p);\n                input.sorted = true;\n            }\n\n            // auto-detect format\n            for (let chk of input.autodetect) {\n                mode = chk.test(...args);\n                if (mode) break;\n            }\n        }\n        if (input.format[mode]) {\n            const rgb = input.format[mode].apply(\n                null,\n                autodetect ? args : args.slice(0, -1)\n            );\n            me._rgb = clip_rgb(rgb);\n        } else {\n            throw new Error('unknown format: ' + args);\n        }\n        // add alpha channel\n        if (me._rgb.length === 3) me._rgb.push(1);\n    }\n    toString() {\n        if (type(this.hex) == 'function') return this.hex();\n        return `[${this._rgb.join(',')}]`;\n    }\n}\n\n// this gets updated automatically\nconst version = '3.0.0';\n\nconst chroma = (...args) => {\n    return new Color(...args);\n};\n\nchroma.version = version;\n\n/**\n\tX11 color names\n\n\thttp://www.w3.org/TR/css3-color/#svg-color\n*/\n\nconst w3cx11 = {\n    aliceblue: '#f0f8ff',\n    antiquewhite: '#faebd7',\n    aqua: '#00ffff',\n    aquamarine: '#7fffd4',\n    azure: '#f0ffff',\n    beige: '#f5f5dc',\n    bisque: '#ffe4c4',\n    black: '#000000',\n    blanchedalmond: '#ffebcd',\n    blue: '#0000ff',\n    blueviolet: '#8a2be2',\n    brown: '#a52a2a',\n    burlywood: '#deb887',\n    cadetblue: '#5f9ea0',\n    chartreuse: '#7fff00',\n    chocolate: '#d2691e',\n    coral: '#ff7f50',\n    cornflowerblue: '#6495ed',\n    cornsilk: '#fff8dc',\n    crimson: '#dc143c',\n    cyan: '#00ffff',\n    darkblue: '#00008b',\n    darkcyan: '#008b8b',\n    darkgoldenrod: '#b8860b',\n    darkgray: '#a9a9a9',\n    darkgreen: '#006400',\n    darkgrey: '#a9a9a9',\n    darkkhaki: '#bdb76b',\n    darkmagenta: '#8b008b',\n    darkolivegreen: '#556b2f',\n    darkorange: '#ff8c00',\n    darkorchid: '#9932cc',\n    darkred: '#8b0000',\n    darksalmon: '#e9967a',\n    darkseagreen: '#8fbc8f',\n    darkslateblue: '#483d8b',\n    darkslategray: '#2f4f4f',\n    darkslategrey: '#2f4f4f',\n    darkturquoise: '#00ced1',\n    darkviolet: '#9400d3',\n    deeppink: '#ff1493',\n    deepskyblue: '#00bfff',\n    dimgray: '#696969',\n    dimgrey: '#696969',\n    dodgerblue: '#1e90ff',\n    firebrick: '#b22222',\n    floralwhite: '#fffaf0',\n    forestgreen: '#228b22',\n    fuchsia: '#ff00ff',\n    gainsboro: '#dcdcdc',\n    ghostwhite: '#f8f8ff',\n    gold: '#ffd700',\n    goldenrod: '#daa520',\n    gray: '#808080',\n    green: '#008000',\n    greenyellow: '#adff2f',\n    grey: '#808080',\n    honeydew: '#f0fff0',\n    hotpink: '#ff69b4',\n    indianred: '#cd5c5c',\n    indigo: '#4b0082',\n    ivory: '#fffff0',\n    khaki: '#f0e68c',\n    laserlemon: '#ffff54',\n    lavender: '#e6e6fa',\n    lavenderblush: '#fff0f5',\n    lawngreen: '#7cfc00',\n    lemonchiffon: '#fffacd',\n    lightblue: '#add8e6',\n    lightcoral: '#f08080',\n    lightcyan: '#e0ffff',\n    lightgoldenrod: '#fafad2',\n    lightgoldenrodyellow: '#fafad2',\n    lightgray: '#d3d3d3',\n    lightgreen: '#90ee90',\n    lightgrey: '#d3d3d3',\n    lightpink: '#ffb6c1',\n    lightsalmon: '#ffa07a',\n    lightseagreen: '#20b2aa',\n    lightskyblue: '#87cefa',\n    lightslategray: '#778899',\n    lightslategrey: '#778899',\n    lightsteelblue: '#b0c4de',\n    lightyellow: '#ffffe0',\n    lime: '#00ff00',\n    limegreen: '#32cd32',\n    linen: '#faf0e6',\n    magenta: '#ff00ff',\n    maroon: '#800000',\n    maroon2: '#7f0000',\n    maroon3: '#b03060',\n    mediumaquamarine: '#66cdaa',\n    mediumblue: '#0000cd',\n    mediumorchid: '#ba55d3',\n    mediumpurple: '#9370db',\n    mediumseagreen: '#3cb371',\n    mediumslateblue: '#7b68ee',\n    mediumspringgreen: '#00fa9a',\n    mediumturquoise: '#48d1cc',\n    mediumvioletred: '#c71585',\n    midnightblue: '#191970',\n    mintcream: '#f5fffa',\n    mistyrose: '#ffe4e1',\n    moccasin: '#ffe4b5',\n    navajowhite: '#ffdead',\n    navy: '#000080',\n    oldlace: '#fdf5e6',\n    olive: '#808000',\n    olivedrab: '#6b8e23',\n    orange: '#ffa500',\n    orangered: '#ff4500',\n    orchid: '#da70d6',\n    palegoldenrod: '#eee8aa',\n    palegreen: '#98fb98',\n    paleturquoise: '#afeeee',\n    palevioletred: '#db7093',\n    papayawhip: '#ffefd5',\n    peachpuff: '#ffdab9',\n    peru: '#cd853f',\n    pink: '#ffc0cb',\n    plum: '#dda0dd',\n    powderblue: '#b0e0e6',\n    purple: '#800080',\n    purple2: '#7f007f',\n    purple3: '#a020f0',\n    rebeccapurple: '#663399',\n    red: '#ff0000',\n    rosybrown: '#bc8f8f',\n    royalblue: '#4169e1',\n    saddlebrown: '#8b4513',\n    salmon: '#fa8072',\n    sandybrown: '#f4a460',\n    seagreen: '#2e8b57',\n    seashell: '#fff5ee',\n    sienna: '#a0522d',\n    silver: '#c0c0c0',\n    skyblue: '#87ceeb',\n    slateblue: '#6a5acd',\n    slategray: '#708090',\n    slategrey: '#708090',\n    snow: '#fffafa',\n    springgreen: '#00ff7f',\n    steelblue: '#4682b4',\n    tan: '#d2b48c',\n    teal: '#008080',\n    thistle: '#d8bfd8',\n    tomato: '#ff6347',\n    turquoise: '#40e0d0',\n    violet: '#ee82ee',\n    wheat: '#f5deb3',\n    white: '#ffffff',\n    whitesmoke: '#f5f5f5',\n    yellow: '#ffff00',\n    yellowgreen: '#9acd32'\n};\n\nconst RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;\nconst RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;\n\nconst hex2rgb = (hex) => {\n    if (hex.match(RE_HEX)) {\n        // remove optional leading #\n        if (hex.length === 4 || hex.length === 7) {\n            hex = hex.substr(1);\n        }\n        // expand short-notation to full six-digit\n        if (hex.length === 3) {\n            hex = hex.split('');\n            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n        }\n        const u = parseInt(hex, 16);\n        const r = u >> 16;\n        const g = (u >> 8) & 0xff;\n        const b = u & 0xff;\n        return [r, g, b, 1];\n    }\n\n    // match rgba hex format, eg #FF000077\n    if (hex.match(RE_HEXA)) {\n        if (hex.length === 5 || hex.length === 9) {\n            // remove optional leading #\n            hex = hex.substr(1);\n        }\n        // expand short-notation to full eight-digit\n        if (hex.length === 4) {\n            hex = hex.split('');\n            hex =\n                hex[0] +\n                hex[0] +\n                hex[1] +\n                hex[1] +\n                hex[2] +\n                hex[2] +\n                hex[3] +\n                hex[3];\n        }\n        const u = parseInt(hex, 16);\n        const r = (u >> 24) & 0xff;\n        const g = (u >> 16) & 0xff;\n        const b = (u >> 8) & 0xff;\n        const a = Math.round(((u & 0xff) / 0xff) * 100) / 100;\n        return [r, g, b, a];\n    }\n\n    // we used to check for css colors here\n    // if _input.css? and rgb = _input.css hex\n    //     return rgb\n\n    throw new Error(`unknown hex color: ${hex}`);\n};\n\nconst { round: round$5 } = Math;\n\nconst rgb2hex = (...args) => {\n    let [r, g, b, a] = unpack(args, 'rgba');\n    let mode = last(args) || 'auto';\n    if (a === undefined) a = 1;\n    if (mode === 'auto') {\n        mode = a < 1 ? 'rgba' : 'rgb';\n    }\n    r = round$5(r);\n    g = round$5(g);\n    b = round$5(b);\n    const u = (r << 16) | (g << 8) | b;\n    let str = '000000' + u.toString(16); //#.toUpperCase();\n    str = str.substr(str.length - 6);\n    let hxa = '0' + round$5(a * 255).toString(16);\n    hxa = hxa.substr(hxa.length - 2);\n    switch (mode.toLowerCase()) {\n        case 'rgba':\n            return `#${str}${hxa}`;\n        case 'argb':\n            return `#${hxa}${str}`;\n        default:\n            return `#${str}`;\n    }\n};\n\nColor.prototype.name = function () {\n    const hex = rgb2hex(this._rgb, 'rgb');\n    for (let n of Object.keys(w3cx11)) {\n        if (w3cx11[n] === hex) return n.toLowerCase();\n    }\n    return hex;\n};\n\ninput.format.named = (name) => {\n    name = name.toLowerCase();\n    if (w3cx11[name]) return hex2rgb(w3cx11[name]);\n    throw new Error('unknown color name: ' + name);\n};\n\ninput.autodetect.push({\n    p: 5,\n    test: (h, ...rest) => {\n        if (!rest.length && type(h) === 'string' && w3cx11[h.toLowerCase()]) {\n            return 'named';\n        }\n    }\n});\n\nColor.prototype.alpha = function (a, mutate = false) {\n    if (a !== undefined && type(a) === 'number') {\n        if (mutate) {\n            this._rgb[3] = a;\n            return this;\n        }\n        return new Color([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');\n    }\n    return this._rgb[3];\n};\n\nColor.prototype.clipped = function () {\n    return this._rgb._clipped || false;\n};\n\nconst labConstants = {\n    // Corresponds roughly to RGB brighter/darker\n    Kn: 18,\n\n    // D65 standard referent\n    labWhitePoint: 'd65',\n    Xn: 0.95047,\n    Yn: 1,\n    Zn: 1.08883,\n\n    t0: 0.137931034, // 4 / 29\n    t1: 0.206896552, // 6 / 29\n    t2: 0.12841855, // 3 * t1 * t1\n    t3: 0.008856452, // t1 * t1 * t1,\n\n    kE: 216.0 / 24389.0,\n    kKE: 8.0,\n    kK: 24389.0 / 27.0,\n\n    RefWhiteRGB: {\n        // sRGB\n        X: 0.95047,\n        Y: 1,\n        Z: 1.08883\n    },\n\n    MtxRGB2XYZ: {\n        m00: 0.4124564390896922,\n        m01: 0.21267285140562253,\n        m02: 0.0193338955823293,\n        m10: 0.357576077643909,\n        m11: 0.715152155287818,\n        m12: 0.11919202588130297,\n        m20: 0.18043748326639894,\n        m21: 0.07217499330655958,\n        m22: 0.9503040785363679\n    },\n\n    MtxXYZ2RGB: {\n        m00: 3.2404541621141045,\n        m01: -0.9692660305051868,\n        m02: 0.055643430959114726,\n        m10: -1.5371385127977166,\n        m11: 1.8760108454466942,\n        m12: -0.2040259135167538,\n        m20: -0.498531409556016,\n        m21: 0.041556017530349834,\n        m22: 1.0572251882231791\n    },\n\n    // used in rgb2xyz\n    As: 0.9414285350000001,\n    Bs: 1.040417467,\n    Cs: 1.089532651,\n\n    MtxAdaptMa: {\n        m00: 0.8951,\n        m01: -0.7502,\n        m02: 0.0389,\n        m10: 0.2664,\n        m11: 1.7135,\n        m12: -0.0685,\n        m20: -0.1614,\n        m21: 0.0367,\n        m22: 1.0296\n    },\n\n    MtxAdaptMaI: {\n        m00: 0.9869929054667123,\n        m01: 0.43230526972339456,\n        m02: -0.008528664575177328,\n        m10: -0.14705425642099013,\n        m11: 0.5183602715367776,\n        m12: 0.04004282165408487,\n        m20: 0.15996265166373125,\n        m21: 0.0492912282128556,\n        m22: 0.9684866957875502\n    }\n};\n\n// taken from https://de.mathworks.com/help/images/ref/whitepoint.html\nconst ILLUMINANTS = new Map([\n    // ASTM E308-01\n    ['a', [1.0985, 0.35585]],\n    // Wyszecki & Stiles, p. 769\n    ['b', [1.0985, 0.35585]],\n    // C ASTM E308-01\n    ['c', [0.98074, 1.18232]],\n    // D50 (ASTM E308-01)\n    ['d50', [0.96422, 0.82521]],\n    // D55 (ASTM E308-01)\n    ['d55', [0.95682, 0.92149]],\n    // D65 (ASTM E308-01)\n    ['d65', [0.95047, 1.08883]],\n    // E (ASTM E308-01)\n    ['e', [1, 1, 1]],\n    // F2 (ASTM E308-01)\n    ['f2', [0.99186, 0.67393]],\n    // F7 (ASTM E308-01)\n    ['f7', [0.95041, 1.08747]],\n    // F11 (ASTM E308-01)\n    ['f11', [1.00962, 0.6435]],\n    ['icc', [0.96422, 0.82521]]\n]);\n\nfunction setLabWhitePoint(name) {\n    const ill = ILLUMINANTS.get(String(name).toLowerCase());\n    if (!ill) {\n        throw new Error('unknown Lab illuminant ' + name);\n    }\n    labConstants.labWhitePoint = name;\n    labConstants.Xn = ill[0];\n    labConstants.Zn = ill[1];\n}\n\nfunction getLabWhitePoint() {\n    return labConstants.labWhitePoint;\n}\n\n/*\n * L* [0..100]\n * a [-100..100]\n * b [-100..100]\n */\nconst lab2rgb = (...args) => {\n    args = unpack(args, 'lab');\n    const [L, a, b] = args;\n    const [x, y, z] = lab2xyz(L, a, b);\n    const [r, g, b_] = xyz2rgb(x, y, z);\n    return [r, g, b_, args.length > 3 ? args[3] : 1];\n};\n\nconst lab2xyz = (L, a, b) => {\n    const { kE, kK, kKE, Xn, Yn, Zn } = labConstants;\n\n    const fy = (L + 16.0) / 116.0;\n    const fx = 0.002 * a + fy;\n    const fz = fy - 0.005 * b;\n\n    const fx3 = fx * fx * fx;\n    const fz3 = fz * fz * fz;\n\n    const xr = fx3 > kE ? fx3 : (116.0 * fx - 16.0) / kK;\n    const yr = L > kKE ? Math.pow((L + 16.0) / 116.0, 3.0) : L / kK;\n    const zr = fz3 > kE ? fz3 : (116.0 * fz - 16.0) / kK;\n\n    const x = xr * Xn;\n    const y = yr * Yn;\n    const z = zr * Zn;\n\n    return [x, y, z];\n};\n\nconst compand = (linear) => {\n    /* sRGB */\n    const sign = Math.sign(linear);\n    linear = Math.abs(linear);\n    return (\n        (linear <= 0.0031308\n            ? linear * 12.92\n            : 1.055 * Math.pow(linear, 1.0 / 2.4) - 0.055) * sign\n    );\n};\n\nconst xyz2rgb = (x, y, z) => {\n    const { MtxAdaptMa, MtxAdaptMaI, MtxXYZ2RGB, RefWhiteRGB, Xn, Yn, Zn } =\n        labConstants;\n\n    const As = Xn * MtxAdaptMa.m00 + Yn * MtxAdaptMa.m10 + Zn * MtxAdaptMa.m20;\n    const Bs = Xn * MtxAdaptMa.m01 + Yn * MtxAdaptMa.m11 + Zn * MtxAdaptMa.m21;\n    const Cs = Xn * MtxAdaptMa.m02 + Yn * MtxAdaptMa.m12 + Zn * MtxAdaptMa.m22;\n\n    const Ad =\n        RefWhiteRGB.X * MtxAdaptMa.m00 +\n        RefWhiteRGB.Y * MtxAdaptMa.m10 +\n        RefWhiteRGB.Z * MtxAdaptMa.m20;\n    const Bd =\n        RefWhiteRGB.X * MtxAdaptMa.m01 +\n        RefWhiteRGB.Y * MtxAdaptMa.m11 +\n        RefWhiteRGB.Z * MtxAdaptMa.m21;\n    const Cd =\n        RefWhiteRGB.X * MtxAdaptMa.m02 +\n        RefWhiteRGB.Y * MtxAdaptMa.m12 +\n        RefWhiteRGB.Z * MtxAdaptMa.m22;\n\n    const X1 =\n        (x * MtxAdaptMa.m00 + y * MtxAdaptMa.m10 + z * MtxAdaptMa.m20) *\n        (Ad / As);\n    const Y1 =\n        (x * MtxAdaptMa.m01 + y * MtxAdaptMa.m11 + z * MtxAdaptMa.m21) *\n        (Bd / Bs);\n    const Z1 =\n        (x * MtxAdaptMa.m02 + y * MtxAdaptMa.m12 + z * MtxAdaptMa.m22) *\n        (Cd / Cs);\n\n    const X2 =\n        X1 * MtxAdaptMaI.m00 + Y1 * MtxAdaptMaI.m10 + Z1 * MtxAdaptMaI.m20;\n    const Y2 =\n        X1 * MtxAdaptMaI.m01 + Y1 * MtxAdaptMaI.m11 + Z1 * MtxAdaptMaI.m21;\n    const Z2 =\n        X1 * MtxAdaptMaI.m02 + Y1 * MtxAdaptMaI.m12 + Z1 * MtxAdaptMaI.m22;\n\n    const r = compand(\n        X2 * MtxXYZ2RGB.m00 + Y2 * MtxXYZ2RGB.m10 + Z2 * MtxXYZ2RGB.m20\n    );\n    const g = compand(\n        X2 * MtxXYZ2RGB.m01 + Y2 * MtxXYZ2RGB.m11 + Z2 * MtxXYZ2RGB.m21\n    );\n    const b = compand(\n        X2 * MtxXYZ2RGB.m02 + Y2 * MtxXYZ2RGB.m12 + Z2 * MtxXYZ2RGB.m22\n    );\n\n    return [r * 255, g * 255, b * 255];\n};\n\nconst rgb2lab = (...args) => {\n    const [r, g, b, ...rest] = unpack(args, 'rgb');\n    const [x, y, z] = rgb2xyz(r, g, b);\n    const [L, a, b_] = xyz2lab(x, y, z);\n    return [L, a, b_, ...(rest.length > 0 && rest[0] < 1 ? [rest[0]] : [])];\n};\n\nfunction xyz2lab(x, y, z) {\n    const { Xn, Yn, Zn, kE, kK } = labConstants;\n    const xr = x / Xn;\n    const yr = y / Yn;\n    const zr = z / Zn;\n\n    const fx = xr > kE ? Math.pow(xr, 1.0 / 3.0) : (kK * xr + 16.0) / 116.0;\n    const fy = yr > kE ? Math.pow(yr, 1.0 / 3.0) : (kK * yr + 16.0) / 116.0;\n    const fz = zr > kE ? Math.pow(zr, 1.0 / 3.0) : (kK * zr + 16.0) / 116.0;\n\n    return [116.0 * fy - 16.0, 500.0 * (fx - fy), 200.0 * (fy - fz)];\n}\n\nfunction gammaAdjustSRGB(companded) {\n    const sign = Math.sign(companded);\n    companded = Math.abs(companded);\n    const linear =\n        companded <= 0.04045\n            ? companded / 12.92\n            : Math.pow((companded + 0.055) / 1.055, 2.4);\n    return linear * sign;\n}\n\nconst rgb2xyz = (r, g, b) => {\n    // normalize and gamma adjust\n    r = gammaAdjustSRGB(r / 255);\n    g = gammaAdjustSRGB(g / 255);\n    b = gammaAdjustSRGB(b / 255);\n\n    const { MtxRGB2XYZ, MtxAdaptMa, MtxAdaptMaI, Xn, Yn, Zn, As, Bs, Cs } =\n        labConstants;\n\n    let x = r * MtxRGB2XYZ.m00 + g * MtxRGB2XYZ.m10 + b * MtxRGB2XYZ.m20;\n    let y = r * MtxRGB2XYZ.m01 + g * MtxRGB2XYZ.m11 + b * MtxRGB2XYZ.m21;\n    let z = r * MtxRGB2XYZ.m02 + g * MtxRGB2XYZ.m12 + b * MtxRGB2XYZ.m22;\n\n    const Ad = Xn * MtxAdaptMa.m00 + Yn * MtxAdaptMa.m10 + Zn * MtxAdaptMa.m20;\n    const Bd = Xn * MtxAdaptMa.m01 + Yn * MtxAdaptMa.m11 + Zn * MtxAdaptMa.m21;\n    const Cd = Xn * MtxAdaptMa.m02 + Yn * MtxAdaptMa.m12 + Zn * MtxAdaptMa.m22;\n\n    let X = x * MtxAdaptMa.m00 + y * MtxAdaptMa.m10 + z * MtxAdaptMa.m20;\n    let Y = x * MtxAdaptMa.m01 + y * MtxAdaptMa.m11 + z * MtxAdaptMa.m21;\n    let Z = x * MtxAdaptMa.m02 + y * MtxAdaptMa.m12 + z * MtxAdaptMa.m22;\n\n    X *= Ad / As;\n    Y *= Bd / Bs;\n    Z *= Cd / Cs;\n\n    x = X * MtxAdaptMaI.m00 + Y * MtxAdaptMaI.m10 + Z * MtxAdaptMaI.m20;\n    y = X * MtxAdaptMaI.m01 + Y * MtxAdaptMaI.m11 + Z * MtxAdaptMaI.m21;\n    z = X * MtxAdaptMaI.m02 + Y * MtxAdaptMaI.m12 + Z * MtxAdaptMaI.m22;\n\n    return [x, y, z];\n};\n\nColor.prototype.lab = function () {\n    return rgb2lab(this._rgb);\n};\n\nconst lab$1 = (...args) => new Color(...args, 'lab');\nObject.assign(chroma, { lab: lab$1, getLabWhitePoint, setLabWhitePoint });\n\ninput.format.lab = lab2rgb;\n\ninput.autodetect.push({\n    p: 2,\n    test: (...args) => {\n        args = unpack(args, 'lab');\n        if (type(args) === 'array' && args.length === 3) {\n            return 'lab';\n        }\n    }\n});\n\nColor.prototype.darken = function (amount = 1) {\n    const me = this;\n    const lab = me.lab();\n    lab[0] -= labConstants.Kn * amount;\n    return new Color(lab, 'lab').alpha(me.alpha(), true);\n};\n\nColor.prototype.brighten = function (amount = 1) {\n    return this.darken(-amount);\n};\n\nColor.prototype.darker = Color.prototype.darken;\nColor.prototype.brighter = Color.prototype.brighten;\n\nColor.prototype.get = function (mc) {\n    const [mode, channel] = mc.split('.');\n    const src = this[mode]();\n    if (channel) {\n        const i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);\n        if (i > -1) return src[i];\n        throw new Error(`unknown channel ${channel} in mode ${mode}`);\n    } else {\n        return src;\n    }\n};\n\nconst { pow: pow$6 } = Math;\n\nconst EPS = 1e-7;\nconst MAX_ITER = 20;\n\nColor.prototype.luminance = function (lum, mode = 'rgb') {\n    if (lum !== undefined && type(lum) === 'number') {\n        if (lum === 0) {\n            // return pure black\n            return new Color([0, 0, 0, this._rgb[3]], 'rgb');\n        }\n        if (lum === 1) {\n            // return pure white\n            return new Color([255, 255, 255, this._rgb[3]], 'rgb');\n        }\n        // compute new color using...\n        let cur_lum = this.luminance();\n        let max_iter = MAX_ITER;\n\n        const test = (low, high) => {\n            const mid = low.interpolate(high, 0.5, mode);\n            const lm = mid.luminance();\n            if (Math.abs(lum - lm) < EPS || !max_iter--) {\n                // close enough\n                return mid;\n            }\n            return lm > lum ? test(low, mid) : test(mid, high);\n        };\n\n        const rgb = (\n            cur_lum > lum\n                ? test(new Color([0, 0, 0]), this)\n                : test(this, new Color([255, 255, 255]))\n        ).rgb();\n        return new Color([...rgb, this._rgb[3]]);\n    }\n    return rgb2luminance(...this._rgb.slice(0, 3));\n};\n\nconst rgb2luminance = (r, g, b) => {\n    // relative luminance\n    // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n    r = luminance_x(r);\n    g = luminance_x(g);\n    b = luminance_x(b);\n    return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n};\n\nconst luminance_x = (x) => {\n    x /= 255;\n    return x <= 0.03928 ? x / 12.92 : pow$6((x + 0.055) / 1.055, 2.4);\n};\n\nvar index = {};\n\nvar mix = (col1, col2, f = 0.5, ...rest) => {\n    let mode = rest[0] || 'lrgb';\n    if (!index[mode] && !rest.length) {\n        // fall back to the first supported mode\n        mode = Object.keys(index)[0];\n    }\n    if (!index[mode]) {\n        throw new Error(`interpolation mode ${mode} is not defined`);\n    }\n    if (type(col1) !== 'object') col1 = new Color(col1);\n    if (type(col2) !== 'object') col2 = new Color(col2);\n    return index[mode](col1, col2, f).alpha(\n        col1.alpha() + f * (col2.alpha() - col1.alpha())\n    );\n};\n\nColor.prototype.mix = Color.prototype.interpolate = function (\n    col2,\n    f = 0.5,\n    ...rest\n) {\n    return mix(this, col2, f, ...rest);\n};\n\nColor.prototype.premultiply = function (mutate = false) {\n    const rgb = this._rgb;\n    const a = rgb[3];\n    if (mutate) {\n        this._rgb = [rgb[0] * a, rgb[1] * a, rgb[2] * a, a];\n        return this;\n    } else {\n        return new Color([rgb[0] * a, rgb[1] * a, rgb[2] * a, a], 'rgb');\n    }\n};\n\nconst { sin: sin$3, cos: cos$4 } = Math;\n\nconst lch2lab = (...args) => {\n    /*\n    Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.\n    These formulas were invented by David Dalrymple to obtain maximum contrast without going\n    out of gamut if the parameters are in the range 0-1.\n\n    A saturation multiplier was added by Gregor Aisch\n    */\n    let [l, c, h] = unpack(args, 'lch');\n    if (isNaN(h)) h = 0;\n    h = h * DEG2RAD;\n    return [l, cos$4(h) * c, sin$3(h) * c];\n};\n\nconst lch2rgb = (...args) => {\n    args = unpack(args, 'lch');\n    const [l, c, h] = args;\n    const [L, a, b_] = lch2lab(l, c, h);\n    const [r, g, b] = lab2rgb(L, a, b_);\n    return [r, g, b, args.length > 3 ? args[3] : 1];\n};\n\nconst hcl2rgb = (...args) => {\n    const hcl = unpack(args, 'hcl').reverse();\n    return lch2rgb(...hcl);\n};\n\nconst { sqrt: sqrt$4, atan2: atan2$2, round: round$4 } = Math;\n\nconst lab2lch = (...args) => {\n    const [l, a, b] = unpack(args, 'lab');\n    const c = sqrt$4(a * a + b * b);\n    let h = (atan2$2(b, a) * RAD2DEG + 360) % 360;\n    if (round$4(c * 10000) === 0) h = Number.NaN;\n    return [l, c, h];\n};\n\nconst rgb2lch = (...args) => {\n    const [r, g, b, ...rest] = unpack(args, 'rgb');\n    const [l, a, b_] = rgb2lab(r, g, b);\n    const [L, c, h] = lab2lch(l, a, b_);\n    return [L, c, h, ...(rest.length > 0 && rest[0] < 1 ? [rest[0]] : [])];\n};\n\nColor.prototype.lch = function () {\n    return rgb2lch(this._rgb);\n};\nColor.prototype.hcl = function () {\n    return rgb2lch(this._rgb).reverse();\n};\n\nconst lch$1 = (...args) => new Color(...args, 'lch');\nconst hcl = (...args) => new Color(...args, 'hcl');\n\nObject.assign(chroma, { lch: lch$1, hcl });\n\ninput.format.lch = lch2rgb;\ninput.format.hcl = hcl2rgb;\n['lch', 'hcl'].forEach((m) =>\n    input.autodetect.push({\n        p: 2,\n        test: (...args) => {\n            args = unpack(args, m);\n            if (type(args) === 'array' && args.length === 3) {\n                return m;\n            }\n        }\n    })\n);\n\nColor.prototype.saturate = function (amount = 1) {\n    const me = this;\n    const lch = me.lch();\n    lch[1] += labConstants.Kn * amount;\n    if (lch[1] < 0) lch[1] = 0;\n    return new Color(lch, 'lch').alpha(me.alpha(), true);\n};\n\nColor.prototype.desaturate = function (amount = 1) {\n    return this.saturate(-amount);\n};\n\nColor.prototype.set = function (mc, value, mutate = false) {\n    const [mode, channel] = mc.split('.');\n    const src = this[mode]();\n    if (channel) {\n        const i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);\n        if (i > -1) {\n            if (type(value) == 'string') {\n                switch (value.charAt(0)) {\n                    case '+':\n                        src[i] += +value;\n                        break;\n                    case '-':\n                        src[i] += +value;\n                        break;\n                    case '*':\n                        src[i] *= +value.substr(1);\n                        break;\n                    case '/':\n                        src[i] /= +value.substr(1);\n                        break;\n                    default:\n                        src[i] = +value;\n                }\n            } else if (type(value) === 'number') {\n                src[i] = value;\n            } else {\n                throw new Error(`unsupported value for Color.set`);\n            }\n            const out = new Color(src, mode);\n            if (mutate) {\n                this._rgb = out._rgb;\n                return this;\n            }\n            return out;\n        }\n        throw new Error(`unknown channel ${channel} in mode ${mode}`);\n    } else {\n        return src;\n    }\n};\n\nColor.prototype.tint = function (f = 0.5, ...rest) {\n    return mix(this, 'white', f, ...rest);\n};\n\nColor.prototype.shade = function (f = 0.5, ...rest) {\n    return mix(this, 'black', f, ...rest);\n};\n\nconst rgb$1 = (col1, col2, f) => {\n    const xyz0 = col1._rgb;\n    const xyz1 = col2._rgb;\n    return new Color(\n        xyz0[0] + f * (xyz1[0] - xyz0[0]),\n        xyz0[1] + f * (xyz1[1] - xyz0[1]),\n        xyz0[2] + f * (xyz1[2] - xyz0[2]),\n        'rgb'\n    );\n};\n\n// register interpolator\nindex.rgb = rgb$1;\n\nconst { sqrt: sqrt$3, pow: pow$5 } = Math;\n\nconst lrgb = (col1, col2, f) => {\n    const [x1, y1, z1] = col1._rgb;\n    const [x2, y2, z2] = col2._rgb;\n    return new Color(\n        sqrt$3(pow$5(x1, 2) * (1 - f) + pow$5(x2, 2) * f),\n        sqrt$3(pow$5(y1, 2) * (1 - f) + pow$5(y2, 2) * f),\n        sqrt$3(pow$5(z1, 2) * (1 - f) + pow$5(z2, 2) * f),\n        'rgb'\n    );\n};\n\n// register interpolator\nindex.lrgb = lrgb;\n\nconst lab = (col1, col2, f) => {\n    const xyz0 = col1.lab();\n    const xyz1 = col2.lab();\n    return new Color(\n        xyz0[0] + f * (xyz1[0] - xyz0[0]),\n        xyz0[1] + f * (xyz1[1] - xyz0[1]),\n        xyz0[2] + f * (xyz1[2] - xyz0[2]),\n        'lab'\n    );\n};\n\n// register interpolator\nindex.lab = lab;\n\nvar interpolate_hsx = (col1, col2, f, m) => {\n    let xyz0, xyz1;\n    if (m === 'hsl') {\n        xyz0 = col1.hsl();\n        xyz1 = col2.hsl();\n    } else if (m === 'hsv') {\n        xyz0 = col1.hsv();\n        xyz1 = col2.hsv();\n    } else if (m === 'hcg') {\n        xyz0 = col1.hcg();\n        xyz1 = col2.hcg();\n    } else if (m === 'hsi') {\n        xyz0 = col1.hsi();\n        xyz1 = col2.hsi();\n    } else if (m === 'lch' || m === 'hcl') {\n        m = 'hcl';\n        xyz0 = col1.hcl();\n        xyz1 = col2.hcl();\n    } else if (m === 'oklch') {\n        xyz0 = col1.oklch().reverse();\n        xyz1 = col2.oklch().reverse();\n    }\n\n    let hue0, hue1, sat0, sat1, lbv0, lbv1;\n    if (m.substr(0, 1) === 'h' || m === 'oklch') {\n        [hue0, sat0, lbv0] = xyz0;\n        [hue1, sat1, lbv1] = xyz1;\n    }\n\n    let sat, hue, lbv, dh;\n\n    if (!isNaN(hue0) && !isNaN(hue1)) {\n        // both colors have hue\n        if (hue1 > hue0 && hue1 - hue0 > 180) {\n            dh = hue1 - (hue0 + 360);\n        } else if (hue1 < hue0 && hue0 - hue1 > 180) {\n            dh = hue1 + 360 - hue0;\n        } else {\n            dh = hue1 - hue0;\n        }\n        hue = hue0 + f * dh;\n    } else if (!isNaN(hue0)) {\n        hue = hue0;\n        if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') sat = sat0;\n    } else if (!isNaN(hue1)) {\n        hue = hue1;\n        if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') sat = sat1;\n    } else {\n        hue = Number.NaN;\n    }\n\n    if (sat === undefined) sat = sat0 + f * (sat1 - sat0);\n    lbv = lbv0 + f * (lbv1 - lbv0);\n    return m === 'oklch'\n        ? new Color([lbv, sat, hue], m)\n        : new Color([hue, sat, lbv], m);\n};\n\nconst lch = (col1, col2, f) => {\n    return interpolate_hsx(col1, col2, f, 'lch');\n};\n\n// register interpolator\nindex.lch = lch;\nindex.hcl = lch;\n\nconst num2rgb = (num) => {\n    if (type(num) == 'number' && num >= 0 && num <= 0xffffff) {\n        const r = num >> 16;\n        const g = (num >> 8) & 0xff;\n        const b = num & 0xff;\n        return [r, g, b, 1];\n    }\n    throw new Error('unknown num color: ' + num);\n};\n\nconst rgb2num = (...args) => {\n    const [r, g, b] = unpack(args, 'rgb');\n    return (r << 16) + (g << 8) + b;\n};\n\nColor.prototype.num = function () {\n    return rgb2num(this._rgb);\n};\n\nconst num$1 = (...args) => new Color(...args, 'num');\n\nObject.assign(chroma, { num: num$1 });\n\ninput.format.num = num2rgb;\n\ninput.autodetect.push({\n    p: 5,\n    test: (...args) => {\n        if (\n            args.length === 1 &&\n            type(args[0]) === 'number' &&\n            args[0] >= 0 &&\n            args[0] <= 0xffffff\n        ) {\n            return 'num';\n        }\n    }\n});\n\nconst num = (col1, col2, f) => {\n    const c1 = col1.num();\n    const c2 = col2.num();\n    return new Color(c1 + f * (c2 - c1), 'num');\n};\n\n// register interpolator\nindex.num = num;\n\nconst { floor: floor$3 } = Math;\n\n/*\n * this is basically just HSV with some minor tweaks\n *\n * hue.. [0..360]\n * chroma .. [0..1]\n * grayness .. [0..1]\n */\n\nconst hcg2rgb = (...args) => {\n    args = unpack(args, 'hcg');\n    let [h, c, _g] = args;\n    let r, g, b;\n    _g = _g * 255;\n    const _c = c * 255;\n    if (c === 0) {\n        r = g = b = _g;\n    } else {\n        if (h === 360) h = 0;\n        if (h > 360) h -= 360;\n        if (h < 0) h += 360;\n        h /= 60;\n        const i = floor$3(h);\n        const f = h - i;\n        const p = _g * (1 - c);\n        const q = p + _c * (1 - f);\n        const t = p + _c * f;\n        const v = p + _c;\n        switch (i) {\n            case 0:\n                [r, g, b] = [v, t, p];\n                break;\n            case 1:\n                [r, g, b] = [q, v, p];\n                break;\n            case 2:\n                [r, g, b] = [p, v, t];\n                break;\n            case 3:\n                [r, g, b] = [p, q, v];\n                break;\n            case 4:\n                [r, g, b] = [t, p, v];\n                break;\n            case 5:\n                [r, g, b] = [v, p, q];\n                break;\n        }\n    }\n    return [r, g, b, args.length > 3 ? args[3] : 1];\n};\n\nconst rgb2hcg = (...args) => {\n    const [r, g, b] = unpack(args, 'rgb');\n    const minRgb = min$3(r, g, b);\n    const maxRgb = max$3(r, g, b);\n    const delta = maxRgb - minRgb;\n    const c = (delta * 100) / 255;\n    const _g = (minRgb / (255 - delta)) * 100;\n    let h;\n    if (delta === 0) {\n        h = Number.NaN;\n    } else {\n        if (r === maxRgb) h = (g - b) / delta;\n        if (g === maxRgb) h = 2 + (b - r) / delta;\n        if (b === maxRgb) h = 4 + (r - g) / delta;\n        h *= 60;\n        if (h < 0) h += 360;\n    }\n    return [h, c, _g];\n};\n\nColor.prototype.hcg = function () {\n    return rgb2hcg(this._rgb);\n};\n\nconst hcg$1 = (...args) => new Color(...args, 'hcg');\nchroma.hcg = hcg$1;\n\ninput.format.hcg = hcg2rgb;\n\ninput.autodetect.push({\n    p: 1,\n    test: (...args) => {\n        args = unpack(args, 'hcg');\n        if (type(args) === 'array' && args.length === 3) {\n            return 'hcg';\n        }\n    }\n});\n\nconst hcg = (col1, col2, f) => {\n    return interpolate_hsx(col1, col2, f, 'hcg');\n};\n\n// register interpolator\nindex.hcg = hcg;\n\nconst { cos: cos$3 } = Math;\n\n/*\n * hue [0..360]\n * saturation [0..1]\n * intensity [0..1]\n */\nconst hsi2rgb = (...args) => {\n    /*\n    borrowed from here:\n    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp\n    */\n    args = unpack(args, 'hsi');\n    let [h, s, i] = args;\n    let r, g, b;\n\n    if (isNaN(h)) h = 0;\n    if (isNaN(s)) s = 0;\n    // normalize hue\n    if (h > 360) h -= 360;\n    if (h < 0) h += 360;\n    h /= 360;\n    if (h < 1 / 3) {\n        b = (1 - s) / 3;\n        r = (1 + (s * cos$3(TWOPI * h)) / cos$3(PITHIRD - TWOPI * h)) / 3;\n        g = 1 - (b + r);\n    } else if (h < 2 / 3) {\n        h -= 1 / 3;\n        r = (1 - s) / 3;\n        g = (1 + (s * cos$3(TWOPI * h)) / cos$3(PITHIRD - TWOPI * h)) / 3;\n        b = 1 - (r + g);\n    } else {\n        h -= 2 / 3;\n        g = (1 - s) / 3;\n        b = (1 + (s * cos$3(TWOPI * h)) / cos$3(PITHIRD - TWOPI * h)) / 3;\n        r = 1 - (g + b);\n    }\n    r = limit(i * r * 3);\n    g = limit(i * g * 3);\n    b = limit(i * b * 3);\n    return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];\n};\n\nconst { min: min$2, sqrt: sqrt$2, acos } = Math;\n\nconst rgb2hsi = (...args) => {\n    /*\n    borrowed from here:\n    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp\n    */\n    let [r, g, b] = unpack(args, 'rgb');\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    let h;\n    const min_ = min$2(r, g, b);\n    const i = (r + g + b) / 3;\n    const s = i > 0 ? 1 - min_ / i : 0;\n    if (s === 0) {\n        h = NaN;\n    } else {\n        h = (r - g + (r - b)) / 2;\n        h /= sqrt$2((r - g) * (r - g) + (r - b) * (g - b));\n        h = acos(h);\n        if (b > g) {\n            h = TWOPI - h;\n        }\n        h /= TWOPI;\n    }\n    return [h * 360, s, i];\n};\n\nColor.prototype.hsi = function () {\n    return rgb2hsi(this._rgb);\n};\n\nconst hsi$1 = (...args) => new Color(...args, 'hsi');\nchroma.hsi = hsi$1;\n\ninput.format.hsi = hsi2rgb;\n\ninput.autodetect.push({\n    p: 2,\n    test: (...args) => {\n        args = unpack(args, 'hsi');\n        if (type(args) === 'array' && args.length === 3) {\n            return 'hsi';\n        }\n    }\n});\n\nconst hsi = (col1, col2, f) => {\n    return interpolate_hsx(col1, col2, f, 'hsi');\n};\n\n// register interpolator\nindex.hsi = hsi;\n\nconst hsl2rgb = (...args) => {\n    args = unpack(args, 'hsl');\n    const [h, s, l] = args;\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l * 255;\n    } else {\n        const t3 = [0, 0, 0];\n        const c = [0, 0, 0];\n        const t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const t1 = 2 * l - t2;\n        const h_ = h / 360;\n        t3[0] = h_ + 1 / 3;\n        t3[1] = h_;\n        t3[2] = h_ - 1 / 3;\n        for (let i = 0; i < 3; i++) {\n            if (t3[i] < 0) t3[i] += 1;\n            if (t3[i] > 1) t3[i] -= 1;\n            if (6 * t3[i] < 1) c[i] = t1 + (t2 - t1) * 6 * t3[i];\n            else if (2 * t3[i] < 1) c[i] = t2;\n            else if (3 * t3[i] < 2) c[i] = t1 + (t2 - t1) * (2 / 3 - t3[i]) * 6;\n            else c[i] = t1;\n        }\n        [r, g, b] = [c[0] * 255, c[1] * 255, c[2] * 255];\n    }\n    if (args.length > 3) {\n        // keep alpha channel\n        return [r, g, b, args[3]];\n    }\n    return [r, g, b, 1];\n};\n\n/*\n * supported arguments:\n * - rgb2hsl(r,g,b)\n * - rgb2hsl(r,g,b,a)\n * - rgb2hsl([r,g,b])\n * - rgb2hsl([r,g,b,a])\n * - rgb2hsl({r,g,b,a})\n */\nconst rgb2hsl$1 = (...args) => {\n    args = unpack(args, 'rgba');\n    let [r, g, b] = args;\n\n    r /= 255;\n    g /= 255;\n    b /= 255;\n\n    const minRgb = min$3(r, g, b);\n    const maxRgb = max$3(r, g, b);\n\n    const l = (maxRgb + minRgb) / 2;\n    let s, h;\n\n    if (maxRgb === minRgb) {\n        s = 0;\n        h = Number.NaN;\n    } else {\n        s =\n            l < 0.5\n                ? (maxRgb - minRgb) / (maxRgb + minRgb)\n                : (maxRgb - minRgb) / (2 - maxRgb - minRgb);\n    }\n\n    if (r == maxRgb) h = (g - b) / (maxRgb - minRgb);\n    else if (g == maxRgb) h = 2 + (b - r) / (maxRgb - minRgb);\n    else if (b == maxRgb) h = 4 + (r - g) / (maxRgb - minRgb);\n\n    h *= 60;\n    if (h < 0) h += 360;\n    if (args.length > 3 && args[3] !== undefined) return [h, s, l, args[3]];\n    return [h, s, l];\n};\n\nColor.prototype.hsl = function () {\n    return rgb2hsl$1(this._rgb);\n};\n\nconst hsl$1 = (...args) => new Color(...args, 'hsl');\nchroma.hsl = hsl$1;\n\ninput.format.hsl = hsl2rgb;\n\ninput.autodetect.push({\n    p: 2,\n    test: (...args) => {\n        args = unpack(args, 'hsl');\n        if (type(args) === 'array' && args.length === 3) {\n            return 'hsl';\n        }\n    }\n});\n\nconst hsl = (col1, col2, f) => {\n    return interpolate_hsx(col1, col2, f, 'hsl');\n};\n\n// register interpolator\nindex.hsl = hsl;\n\nconst { floor: floor$2 } = Math;\n\nconst hsv2rgb = (...args) => {\n    args = unpack(args, 'hsv');\n    let [h, s, v] = args;\n    let r, g, b;\n    v *= 255;\n    if (s === 0) {\n        r = g = b = v;\n    } else {\n        if (h === 360) h = 0;\n        if (h > 360) h -= 360;\n        if (h < 0) h += 360;\n        h /= 60;\n\n        const i = floor$2(h);\n        const f = h - i;\n        const p = v * (1 - s);\n        const q = v * (1 - s * f);\n        const t = v * (1 - s * (1 - f));\n\n        switch (i) {\n            case 0:\n                [r, g, b] = [v, t, p];\n                break;\n            case 1:\n                [r, g, b] = [q, v, p];\n                break;\n            case 2:\n                [r, g, b] = [p, v, t];\n                break;\n            case 3:\n                [r, g, b] = [p, q, v];\n                break;\n            case 4:\n                [r, g, b] = [t, p, v];\n                break;\n            case 5:\n                [r, g, b] = [v, p, q];\n                break;\n        }\n    }\n    return [r, g, b, args.length > 3 ? args[3] : 1];\n};\n\nconst { min: min$1, max: max$2 } = Math;\n\n/*\n * supported arguments:\n * - rgb2hsv(r,g,b)\n * - rgb2hsv([r,g,b])\n * - rgb2hsv({r,g,b})\n */\nconst rgb2hsl = (...args) => {\n    args = unpack(args, 'rgb');\n    let [r, g, b] = args;\n    const min_ = min$1(r, g, b);\n    const max_ = max$2(r, g, b);\n    const delta = max_ - min_;\n    let h, s, v;\n    v = max_ / 255.0;\n    if (max_ === 0) {\n        h = Number.NaN;\n        s = 0;\n    } else {\n        s = delta / max_;\n        if (r === max_) h = (g - b) / delta;\n        if (g === max_) h = 2 + (b - r) / delta;\n        if (b === max_) h = 4 + (r - g) / delta;\n        h *= 60;\n        if (h < 0) h += 360;\n    }\n    return [h, s, v];\n};\n\nColor.prototype.hsv = function () {\n    return rgb2hsl(this._rgb);\n};\n\nconst hsv$1 = (...args) => new Color(...args, 'hsv');\nchroma.hsv = hsv$1;\n\ninput.format.hsv = hsv2rgb;\n\ninput.autodetect.push({\n    p: 2,\n    test: (...args) => {\n        args = unpack(args, 'hsv');\n        if (type(args) === 'array' && args.length === 3) {\n            return 'hsv';\n        }\n    }\n});\n\nconst hsv = (col1, col2, f) => {\n    return interpolate_hsx(col1, col2, f, 'hsv');\n};\n\n// register interpolator\nindex.hsv = hsv;\n\n// from https://www.w3.org/TR/css-color-4/multiply-matrices.js\nfunction multiplyMatrices(A, B) {\n    let m = A.length;\n\n    if (!Array.isArray(A[0])) {\n        // A is vector, convert to [[a, b, c, ...]]\n        A = [A];\n    }\n\n    if (!Array.isArray(B[0])) {\n        // B is vector, convert to [[a], [b], [c], ...]]\n        B = B.map((x) => [x]);\n    }\n\n    let p = B[0].length;\n    let B_cols = B[0].map((_, i) => B.map((x) => x[i])); // transpose B\n    let product = A.map((row) =>\n        B_cols.map((col) => {\n            if (!Array.isArray(row)) {\n                return col.reduce((a, c) => a + c * row, 0);\n            }\n\n            return row.reduce((a, c, i) => a + c * (col[i] || 0), 0);\n        })\n    );\n\n    if (m === 1) {\n        product = product[0]; // Avoid [[a, b, c, ...]]\n    }\n\n    if (p === 1) {\n        return product.map((x) => x[0]); // Avoid [[a], [b], [c], ...]]\n    }\n\n    return product;\n}\n\nconst oklab2rgb = (...args) => {\n    args = unpack(args, 'lab');\n    const [L, a, b, ...rest] = args;\n    const [X, Y, Z] = OKLab_to_XYZ([L, a, b]);\n    const [r, g, b_] = xyz2rgb(X, Y, Z);\n    return [r, g, b_, ...(rest.length > 0 && rest[0] < 1 ? [rest[0]] : [])];\n};\n\n// from https://www.w3.org/TR/css-color-4/#color-conversion-code\nfunction OKLab_to_XYZ(OKLab) {\n    // Given OKLab, convert to XYZ relative to D65\n    var LMStoXYZ = [\n        [1.2268798758459243, -0.5578149944602171, 0.2813910456659647],\n        [-0.0405757452148008, 1.112286803280317, -0.0717110580655164],\n        [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]\n    ];\n    var OKLabtoLMS = [\n        [1.0, 0.3963377773761749, 0.2158037573099136],\n        [1.0, -0.1055613458156586, -0.0638541728258133],\n        [1.0, -0.0894841775298119, -1.2914855480194092]\n    ];\n\n    var LMSnl = multiplyMatrices(OKLabtoLMS, OKLab);\n    return multiplyMatrices(\n        LMStoXYZ,\n        LMSnl.map((c) => c ** 3)\n    );\n}\n\nconst rgb2oklab = (...args) => {\n    const [r, g, b, ...rest] = unpack(args, 'rgb');\n    const xyz = rgb2xyz(r, g, b);\n    const oklab = XYZ_to_OKLab(xyz);\n    return [...oklab, ...(rest.length > 0 && rest[0] < 1 ? [rest[0]] : [])];\n};\n\n// from https://www.w3.org/TR/css-color-4/#color-conversion-code\nfunction XYZ_to_OKLab(XYZ) {\n    // Given XYZ relative to D65, convert to OKLab\n    const XYZtoLMS = [\n        [0.819022437996703, 0.3619062600528904, -0.1288737815209879],\n        [0.0329836539323885, 0.9292868615863434, 0.0361446663506424],\n        [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]\n    ];\n    const LMStoOKLab = [\n        [0.210454268309314, 0.7936177747023054, -0.0040720430116193],\n        [1.9779985324311684, -2.4285922420485799, 0.450593709617411],\n        [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]\n    ];\n\n    const LMS = multiplyMatrices(XYZtoLMS, XYZ);\n    // JavaScript Math.cbrt returns a sign-matched cube root\n    // beware if porting to other languages\n    // especially if tempted to use a general power function\n    return multiplyMatrices(\n        LMStoOKLab,\n        LMS.map((c) => Math.cbrt(c))\n    );\n    // L in range [0,1]. For use in CSS, multiply by 100 and add a percent\n}\n\nColor.prototype.oklab = function () {\n    return rgb2oklab(this._rgb);\n};\n\nconst oklab$1 = (...args) => new Color(...args, 'oklab');\nObject.assign(chroma, { oklab: oklab$1 });\n\ninput.format.oklab = oklab2rgb;\n\ninput.autodetect.push({\n    p: 2,\n    test: (...args) => {\n        args = unpack(args, 'oklab');\n        if (type(args) === 'array' && args.length === 3) {\n            return 'oklab';\n        }\n    }\n});\n\nconst oklab = (col1, col2, f) => {\n    const xyz0 = col1.oklab();\n    const xyz1 = col2.oklab();\n    return new Color(\n        xyz0[0] + f * (xyz1[0] - xyz0[0]),\n        xyz0[1] + f * (xyz1[1] - xyz0[1]),\n        xyz0[2] + f * (xyz1[2] - xyz0[2]),\n        'oklab'\n    );\n};\n\n// register interpolator\nindex.oklab = oklab;\n\nconst oklch$1 = (col1, col2, f) => {\n    return interpolate_hsx(col1, col2, f, 'oklch');\n};\n\n// register interpolator\nindex.oklch = oklch$1;\n\nconst { pow: pow$4, sqrt: sqrt$1, PI: PI$1, cos: cos$2, sin: sin$2, atan2: atan2$1 } = Math;\n\nvar average = (colors, mode = 'lrgb', weights = null) => {\n    const l = colors.length;\n    if (!weights) weights = Array.from(new Array(l)).map(() => 1);\n    // normalize weights\n    const k =\n        l /\n        weights.reduce(function (a, b) {\n            return a + b;\n        });\n    weights.forEach((w, i) => {\n        weights[i] *= k;\n    });\n    // convert colors to Color objects\n    colors = colors.map((c) => new Color(c));\n    if (mode === 'lrgb') {\n        return _average_lrgb(colors, weights);\n    }\n    const first = colors.shift();\n    const xyz = first.get(mode);\n    const cnt = [];\n    let dx = 0;\n    let dy = 0;\n    // initial color\n    for (let i = 0; i < xyz.length; i++) {\n        xyz[i] = (xyz[i] || 0) * weights[0];\n        cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);\n        if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {\n            const A = (xyz[i] / 180) * PI$1;\n            dx += cos$2(A) * weights[0];\n            dy += sin$2(A) * weights[0];\n        }\n    }\n\n    let alpha = first.alpha() * weights[0];\n    colors.forEach((c, ci) => {\n        const xyz2 = c.get(mode);\n        alpha += c.alpha() * weights[ci + 1];\n        for (let i = 0; i < xyz.length; i++) {\n            if (!isNaN(xyz2[i])) {\n                cnt[i] += weights[ci + 1];\n                if (mode.charAt(i) === 'h') {\n                    const A = (xyz2[i] / 180) * PI$1;\n                    dx += cos$2(A) * weights[ci + 1];\n                    dy += sin$2(A) * weights[ci + 1];\n                } else {\n                    xyz[i] += xyz2[i] * weights[ci + 1];\n                }\n            }\n        }\n    });\n\n    for (let i = 0; i < xyz.length; i++) {\n        if (mode.charAt(i) === 'h') {\n            let A = (atan2$1(dy / cnt[i], dx / cnt[i]) / PI$1) * 180;\n            while (A < 0) A += 360;\n            while (A >= 360) A -= 360;\n            xyz[i] = A;\n        } else {\n            xyz[i] = xyz[i] / cnt[i];\n        }\n    }\n    alpha /= l;\n    return new Color(xyz, mode).alpha(alpha > 0.99999 ? 1 : alpha, true);\n};\n\nconst _average_lrgb = (colors, weights) => {\n    const l = colors.length;\n    const xyz = [0, 0, 0, 0];\n    for (let i = 0; i < colors.length; i++) {\n        const col = colors[i];\n        const f = weights[i] / l;\n        const rgb = col._rgb;\n        xyz[0] += pow$4(rgb[0], 2) * f;\n        xyz[1] += pow$4(rgb[1], 2) * f;\n        xyz[2] += pow$4(rgb[2], 2) * f;\n        xyz[3] += rgb[3] * f;\n    }\n    xyz[0] = sqrt$1(xyz[0]);\n    xyz[1] = sqrt$1(xyz[1]);\n    xyz[2] = sqrt$1(xyz[2]);\n    if (xyz[3] > 0.9999999) xyz[3] = 1;\n    return new Color(clip_rgb(xyz));\n};\n\n// minimal multi-purpose interface\n\n\nconst { pow: pow$3 } = Math;\n\nfunction scale (colors) {\n    // constructor\n    let _mode = 'rgb';\n    let _nacol = chroma('#ccc');\n    let _spread = 0;\n    // const _fixed = false;\n    let _domain = [0, 1];\n    let _pos = [];\n    let _padding = [0, 0];\n    let _classes = false;\n    let _colors = [];\n    let _out = false;\n    let _min = 0;\n    let _max = 1;\n    let _correctLightness = false;\n    let _colorCache = {};\n    let _useCache = true;\n    let _gamma = 1;\n\n    // private methods\n\n    const setColors = function (colors) {\n        colors = colors || ['#fff', '#000'];\n        if (\n            colors &&\n            type(colors) === 'string' &&\n            chroma.brewer &&\n            chroma.brewer[colors.toLowerCase()]\n        ) {\n            colors = chroma.brewer[colors.toLowerCase()];\n        }\n        if (type(colors) === 'array') {\n            // handle single color\n            if (colors.length === 1) {\n                colors = [colors[0], colors[0]];\n            }\n            // make a copy of the colors\n            colors = colors.slice(0);\n            // convert to chroma classes\n            for (let c = 0; c < colors.length; c++) {\n                colors[c] = chroma(colors[c]);\n            }\n            // auto-fill color position\n            _pos.length = 0;\n            for (let c = 0; c < colors.length; c++) {\n                _pos.push(c / (colors.length - 1));\n            }\n        }\n        resetCache();\n        return (_colors = colors);\n    };\n\n    const getClass = function (value) {\n        if (_classes != null) {\n            const n = _classes.length - 1;\n            let i = 0;\n            while (i < n && value >= _classes[i]) {\n                i++;\n            }\n            return i - 1;\n        }\n        return 0;\n    };\n\n    let tMapLightness = (t) => t;\n    let tMapDomain = (t) => t;\n\n    // const classifyValue = function(value) {\n    //     let val = value;\n    //     if (_classes.length > 2) {\n    //         const n = _classes.length-1;\n    //         const i = getClass(value);\n    //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class\n    //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class\n    //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));\n    //     }\n    //     return val;\n    // };\n\n    const getColor = function (val, bypassMap) {\n        let col, t;\n        if (bypassMap == null) {\n            bypassMap = false;\n        }\n        if (isNaN(val) || val === null) {\n            return _nacol;\n        }\n        if (!bypassMap) {\n            if (_classes && _classes.length > 2) {\n                // find the class\n                const c = getClass(val);\n                t = c / (_classes.length - 2);\n            } else if (_max !== _min) {\n                // just interpolate between min/max\n                t = (val - _min) / (_max - _min);\n            } else {\n                t = 1;\n            }\n        } else {\n            t = val;\n        }\n\n        // domain map\n        t = tMapDomain(t);\n\n        if (!bypassMap) {\n            t = tMapLightness(t); // lightness correction\n        }\n\n        if (_gamma !== 1) {\n            t = pow$3(t, _gamma);\n        }\n\n        t = _padding[0] + t * (1 - _padding[0] - _padding[1]);\n\n        t = limit(t, 0, 1);\n\n        const k = Math.floor(t * 10000);\n\n        if (_useCache && _colorCache[k]) {\n            col = _colorCache[k];\n        } else {\n            if (type(_colors) === 'array') {\n                //for i in [0.._pos.length-1]\n                for (let i = 0; i < _pos.length; i++) {\n                    const p = _pos[i];\n                    if (t <= p) {\n                        col = _colors[i];\n                        break;\n                    }\n                    if (t >= p && i === _pos.length - 1) {\n                        col = _colors[i];\n                        break;\n                    }\n                    if (t > p && t < _pos[i + 1]) {\n                        t = (t - p) / (_pos[i + 1] - p);\n                        col = chroma.interpolate(\n                            _colors[i],\n                            _colors[i + 1],\n                            t,\n                            _mode\n                        );\n                        break;\n                    }\n                }\n            } else if (type(_colors) === 'function') {\n                col = _colors(t);\n            }\n            if (_useCache) {\n                _colorCache[k] = col;\n            }\n        }\n        return col;\n    };\n\n    var resetCache = () => (_colorCache = {});\n\n    setColors(colors);\n\n    // public interface\n\n    const f = function (v) {\n        const c = chroma(getColor(v));\n        if (_out && c[_out]) {\n            return c[_out]();\n        } else {\n            return c;\n        }\n    };\n\n    f.classes = function (classes) {\n        if (classes != null) {\n            if (type(classes) === 'array') {\n                _classes = classes;\n                _domain = [classes[0], classes[classes.length - 1]];\n            } else {\n                const d = chroma.analyze(_domain);\n                if (classes === 0) {\n                    _classes = [d.min, d.max];\n                } else {\n                    _classes = chroma.limits(d, 'e', classes);\n                }\n            }\n            return f;\n        }\n        return _classes;\n    };\n\n    f.domain = function (domain) {\n        if (!arguments.length) {\n            return _domain;\n        }\n        _min = domain[0];\n        _max = domain[domain.length - 1];\n        _pos = [];\n        const k = _colors.length;\n        if (domain.length === k && _min !== _max) {\n            // update positions\n            for (let d of Array.from(domain)) {\n                _pos.push((d - _min) / (_max - _min));\n            }\n        } else {\n            for (let c = 0; c < k; c++) {\n                _pos.push(c / (k - 1));\n            }\n            if (domain.length > 2) {\n                // set domain map\n                const tOut = domain.map((d, i) => i / (domain.length - 1));\n                const tBreaks = domain.map((d) => (d - _min) / (_max - _min));\n                if (!tBreaks.every((val, i) => tOut[i] === val)) {\n                    tMapDomain = (t) => {\n                        if (t <= 0 || t >= 1) return t;\n                        let i = 0;\n                        while (t >= tBreaks[i + 1]) i++;\n                        const f =\n                            (t - tBreaks[i]) / (tBreaks[i + 1] - tBreaks[i]);\n                        const out = tOut[i] + f * (tOut[i + 1] - tOut[i]);\n                        return out;\n                    };\n                }\n            }\n        }\n        _domain = [_min, _max];\n        return f;\n    };\n\n    f.mode = function (_m) {\n        if (!arguments.length) {\n            return _mode;\n        }\n        _mode = _m;\n        resetCache();\n        return f;\n    };\n\n    f.range = function (colors, _pos) {\n        setColors(colors);\n        return f;\n    };\n\n    f.out = function (_o) {\n        _out = _o;\n        return f;\n    };\n\n    f.spread = function (val) {\n        if (!arguments.length) {\n            return _spread;\n        }\n        _spread = val;\n        return f;\n    };\n\n    f.correctLightness = function (v) {\n        if (v == null) {\n            v = true;\n        }\n        _correctLightness = v;\n        resetCache();\n        if (_correctLightness) {\n            tMapLightness = function (t) {\n                const L0 = getColor(0, true).lab()[0];\n                const L1 = getColor(1, true).lab()[0];\n                const pol = L0 > L1;\n                let L_actual = getColor(t, true).lab()[0];\n                const L_ideal = L0 + (L1 - L0) * t;\n                let L_diff = L_actual - L_ideal;\n                let t0 = 0;\n                let t1 = 1;\n                let max_iter = 20;\n                while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {\n                    (function () {\n                        if (pol) {\n                            L_diff *= -1;\n                        }\n                        if (L_diff < 0) {\n                            t0 = t;\n                            t += (t1 - t) * 0.5;\n                        } else {\n                            t1 = t;\n                            t += (t0 - t) * 0.5;\n                        }\n                        L_actual = getColor(t, true).lab()[0];\n                        return (L_diff = L_actual - L_ideal);\n                    })();\n                }\n                return t;\n            };\n        } else {\n            tMapLightness = (t) => t;\n        }\n        return f;\n    };\n\n    f.padding = function (p) {\n        if (p != null) {\n            if (type(p) === 'number') {\n                p = [p, p];\n            }\n            _padding = p;\n            return f;\n        } else {\n            return _padding;\n        }\n    };\n\n    f.colors = function (numColors, out) {\n        // If no arguments are given, return the original colors that were provided\n        if (arguments.length < 2) {\n            out = 'hex';\n        }\n        let result = [];\n\n        if (arguments.length === 0) {\n            result = _colors.slice(0);\n        } else if (numColors === 1) {\n            result = [f(0.5)];\n        } else if (numColors > 1) {\n            const dm = _domain[0];\n            const dd = _domain[1] - dm;\n            result = __range__(0, numColors).map((i) =>\n                f(dm + (i / (numColors - 1)) * dd)\n            );\n        } else {\n            // returns all colors based on the defined classes\n            colors = [];\n            let samples = [];\n            if (_classes && _classes.length > 2) {\n                for (\n                    let i = 1, end = _classes.length, asc = 1 <= end;\n                    asc ? i < end : i > end;\n                    asc ? i++ : i--\n                ) {\n                    samples.push((_classes[i - 1] + _classes[i]) * 0.5);\n                }\n            } else {\n                samples = _domain;\n            }\n            result = samples.map((v) => f(v));\n        }\n\n        if (chroma[out]) {\n            result = result.map((c) => c[out]());\n        }\n        return result;\n    };\n\n    f.cache = function (c) {\n        if (c != null) {\n            _useCache = c;\n            return f;\n        } else {\n            return _useCache;\n        }\n    };\n\n    f.gamma = function (g) {\n        if (g != null) {\n            _gamma = g;\n            return f;\n        } else {\n            return _gamma;\n        }\n    };\n\n    f.nodata = function (d) {\n        if (d != null) {\n            _nacol = chroma(d);\n            return f;\n        } else {\n            return _nacol;\n        }\n    };\n\n    return f;\n}\n\nfunction __range__(left, right, inclusive) {\n    let range = [];\n    let ascending = left < right;\n    let end = right ;\n    for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n        range.push(i);\n    }\n    return range;\n}\n\n//\n// interpolates between a set of colors uzing a bezier spline\n//\n\n\n// nth row of the pascal triangle\nconst binom_row = function (n) {\n    let row = [1, 1];\n    for (let i = 1; i < n; i++) {\n        let newrow = [1];\n        for (let j = 1; j <= row.length; j++) {\n            newrow[j] = (row[j] || 0) + row[j - 1];\n        }\n        row = newrow;\n    }\n    return row;\n};\n\nconst bezier = function (colors) {\n    let I, lab0, lab1, lab2;\n    colors = colors.map((c) => new Color(c));\n    if (colors.length === 2) {\n        // linear interpolation\n        [lab0, lab1] = colors.map((c) => c.lab());\n        I = function (t) {\n            const lab = [0, 1, 2].map((i) => lab0[i] + t * (lab1[i] - lab0[i]));\n            return new Color(lab, 'lab');\n        };\n    } else if (colors.length === 3) {\n        // quadratic bezier interpolation\n        [lab0, lab1, lab2] = colors.map((c) => c.lab());\n        I = function (t) {\n            const lab = [0, 1, 2].map(\n                (i) =>\n                    (1 - t) * (1 - t) * lab0[i] +\n                    2 * (1 - t) * t * lab1[i] +\n                    t * t * lab2[i]\n            );\n            return new Color(lab, 'lab');\n        };\n    } else if (colors.length === 4) {\n        // cubic bezier interpolation\n        let lab3;\n        [lab0, lab1, lab2, lab3] = colors.map((c) => c.lab());\n        I = function (t) {\n            const lab = [0, 1, 2].map(\n                (i) =>\n                    (1 - t) * (1 - t) * (1 - t) * lab0[i] +\n                    3 * (1 - t) * (1 - t) * t * lab1[i] +\n                    3 * (1 - t) * t * t * lab2[i] +\n                    t * t * t * lab3[i]\n            );\n            return new Color(lab, 'lab');\n        };\n    } else if (colors.length >= 5) {\n        // general case (degree n bezier)\n        let labs, row, n;\n        labs = colors.map((c) => c.lab());\n        n = colors.length - 1;\n        row = binom_row(n);\n        I = function (t) {\n            const u = 1 - t;\n            const lab = [0, 1, 2].map((i) =>\n                labs.reduce(\n                    (sum, el, j) =>\n                        sum + row[j] * u ** (n - j) * t ** j * el[i],\n                    0\n                )\n            );\n            return new Color(lab, 'lab');\n        };\n    } else {\n        throw new RangeError('No point in running bezier with only one color.');\n    }\n    return I;\n};\n\nvar bezier$1 = (colors) => {\n    const f = bezier(colors);\n    f.scale = () => scale(f);\n    return f;\n};\n\nconst { round: round$3 } = Math;\n\nColor.prototype.rgb = function (rnd = true) {\n    if (rnd === false) return this._rgb.slice(0, 3);\n    return this._rgb.slice(0, 3).map(round$3);\n};\n\nColor.prototype.rgba = function (rnd = true) {\n    return this._rgb.slice(0, 4).map((v, i) => {\n        return i < 3 ? (rnd === false ? v : round$3(v)) : v;\n    });\n};\n\nconst rgb = (...args) => new Color(...args, 'rgb');\nObject.assign(chroma, { rgb });\n\ninput.format.rgb = (...args) => {\n    const rgba = unpack(args, 'rgba');\n    if (rgba[3] === undefined) rgba[3] = 1;\n    return rgba;\n};\n\ninput.autodetect.push({\n    p: 3,\n    test: (...args) => {\n        args = unpack(args, 'rgba');\n        if (\n            type(args) === 'array' &&\n            (args.length === 3 ||\n                (args.length === 4 &&\n                    type(args[3]) == 'number' &&\n                    args[3] >= 0 &&\n                    args[3] <= 1))\n        ) {\n            return 'rgb';\n        }\n    }\n});\n\n/*\n * interpolates between a set of colors uzing a bezier spline\n * blend mode formulas taken from https://web.archive.org/web/20180110014946/http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/\n */\n\n\nconst blend = (bottom, top, mode) => {\n    if (!blend[mode]) {\n        throw new Error('unknown blend mode ' + mode);\n    }\n    return blend[mode](bottom, top);\n};\n\nconst blend_f = (f) => (bottom, top) => {\n    const c0 = chroma(top).rgb();\n    const c1 = chroma(bottom).rgb();\n    return chroma.rgb(f(c0, c1));\n};\n\nconst each = (f) => (c0, c1) => {\n    const out = [];\n    out[0] = f(c0[0], c1[0]);\n    out[1] = f(c0[1], c1[1]);\n    out[2] = f(c0[2], c1[2]);\n    return out;\n};\n\nconst normal = (a) => a;\nconst multiply = (a, b) => (a * b) / 255;\nconst darken = (a, b) => (a > b ? b : a);\nconst lighten = (a, b) => (a > b ? a : b);\nconst screen = (a, b) => 255 * (1 - (1 - a / 255) * (1 - b / 255));\nconst overlay = (a, b) =>\n    b < 128 ? (2 * a * b) / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));\nconst burn = (a, b) => 255 * (1 - (1 - b / 255) / (a / 255));\nconst dodge = (a, b) => {\n    if (a === 255) return 255;\n    a = (255 * (b / 255)) / (1 - a / 255);\n    return a > 255 ? 255 : a;\n};\n\n// # add = (a,b) ->\n// #     if (a + b > 255) then 255 else a + b\n\nblend.normal = blend_f(each(normal));\nblend.multiply = blend_f(each(multiply));\nblend.screen = blend_f(each(screen));\nblend.overlay = blend_f(each(overlay));\nblend.darken = blend_f(each(darken));\nblend.lighten = blend_f(each(lighten));\nblend.dodge = blend_f(each(dodge));\nblend.burn = blend_f(each(burn));\n\n// cubehelix interpolation\n// based on D.A. Green \"A colour scheme for the display of astronomical intensity images\"\n// http://astron-soc.in/bulletin/11June/289392011.pdf\nconst { pow: pow$2, sin: sin$1, cos: cos$1 } = Math;\n\nfunction cubehelix (\n    start = 300,\n    rotations = -1.5,\n    hue = 1,\n    gamma = 1,\n    lightness = [0, 1]\n) {\n    let dh = 0,\n        dl;\n    if (type(lightness) === 'array') {\n        dl = lightness[1] - lightness[0];\n    } else {\n        dl = 0;\n        lightness = [lightness, lightness];\n    }\n    const f = function (fract) {\n        const a = TWOPI * ((start + 120) / 360 + rotations * fract);\n        const l = pow$2(lightness[0] + dl * fract, gamma);\n        const h = dh !== 0 ? hue[0] + fract * dh : hue;\n        const amp = (h * l * (1 - l)) / 2;\n        const cos_a = cos$1(a);\n        const sin_a = sin$1(a);\n        const r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);\n        const g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);\n        const b = l + amp * (+1.97294 * cos_a);\n        return chroma(clip_rgb([r * 255, g * 255, b * 255, 1]));\n    };\n    f.start = function (s) {\n        if (s == null) {\n            return start;\n        }\n        start = s;\n        return f;\n    };\n    f.rotations = function (r) {\n        if (r == null) {\n            return rotations;\n        }\n        rotations = r;\n        return f;\n    };\n    f.gamma = function (g) {\n        if (g == null) {\n            return gamma;\n        }\n        gamma = g;\n        return f;\n    };\n    f.hue = function (h) {\n        if (h == null) {\n            return hue;\n        }\n        hue = h;\n        if (type(hue) === 'array') {\n            dh = hue[1] - hue[0];\n            if (dh === 0) {\n                hue = hue[1];\n            }\n        } else {\n            dh = 0;\n        }\n        return f;\n    };\n    f.lightness = function (h) {\n        if (h == null) {\n            return lightness;\n        }\n        if (type(h) === 'array') {\n            lightness = h;\n            dl = h[1] - h[0];\n        } else {\n            lightness = [h, h];\n            dl = 0;\n        }\n        return f;\n    };\n    f.scale = () => chroma.scale(f);\n    f.hue(hue);\n    return f;\n}\n\nconst digits = '0123456789abcdef';\n\nconst { floor: floor$1, random } = Math;\n\nvar random$1 = () => {\n    let code = '#';\n    for (let i = 0; i < 6; i++) {\n        code += digits.charAt(floor$1(random() * 16));\n    }\n    return new Color(code, 'hex');\n};\n\nconst { log: log$1, pow: pow$1, floor, abs: abs$1 } = Math;\n\nfunction analyze(data, key = null) {\n    const r = {\n        min: Number.MAX_VALUE,\n        max: Number.MAX_VALUE * -1,\n        sum: 0,\n        values: [],\n        count: 0\n    };\n    if (type(data) === 'object') {\n        data = Object.values(data);\n    }\n    data.forEach((val) => {\n        if (key && type(val) === 'object') val = val[key];\n        if (val !== undefined && val !== null && !isNaN(val)) {\n            r.values.push(val);\n            r.sum += val;\n            if (val < r.min) r.min = val;\n            if (val > r.max) r.max = val;\n            r.count += 1;\n        }\n    });\n\n    r.domain = [r.min, r.max];\n\n    r.limits = (mode, num) => limits(r, mode, num);\n\n    return r;\n}\n\nfunction limits(data, mode = 'equal', num = 7) {\n    if (type(data) == 'array') {\n        data = analyze(data);\n    }\n    const { min, max } = data;\n    const values = data.values.sort((a, b) => a - b);\n\n    if (num === 1) {\n        return [min, max];\n    }\n\n    const limits = [];\n\n    if (mode.substr(0, 1) === 'c') {\n        // continuous\n        limits.push(min);\n        limits.push(max);\n    }\n\n    if (mode.substr(0, 1) === 'e') {\n        // equal interval\n        limits.push(min);\n        for (let i = 1; i < num; i++) {\n            limits.push(min + (i / num) * (max - min));\n        }\n        limits.push(max);\n    } else if (mode.substr(0, 1) === 'l') {\n        // log scale\n        if (min <= 0) {\n            throw new Error(\n                'Logarithmic scales are only possible for values > 0'\n            );\n        }\n        const min_log = Math.LOG10E * log$1(min);\n        const max_log = Math.LOG10E * log$1(max);\n        limits.push(min);\n        for (let i = 1; i < num; i++) {\n            limits.push(pow$1(10, min_log + (i / num) * (max_log - min_log)));\n        }\n        limits.push(max);\n    } else if (mode.substr(0, 1) === 'q') {\n        // quantile scale\n        limits.push(min);\n        for (let i = 1; i < num; i++) {\n            const p = ((values.length - 1) * i) / num;\n            const pb = floor(p);\n            if (pb === p) {\n                limits.push(values[pb]);\n            } else {\n                // p > pb\n                const pr = p - pb;\n                limits.push(values[pb] * (1 - pr) + values[pb + 1] * pr);\n            }\n        }\n        limits.push(max);\n    } else if (mode.substr(0, 1) === 'k') {\n        // k-means clustering\n        /*\n        implementation based on\n        http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n        simplified for 1-d input values\n        */\n        let cluster;\n        const n = values.length;\n        const assignments = new Array(n);\n        const clusterSizes = new Array(num);\n        let repeat = true;\n        let nb_iters = 0;\n        let centroids = null;\n\n        // get seed values\n        centroids = [];\n        centroids.push(min);\n        for (let i = 1; i < num; i++) {\n            centroids.push(min + (i / num) * (max - min));\n        }\n        centroids.push(max);\n\n        while (repeat) {\n            // assignment step\n            for (let j = 0; j < num; j++) {\n                clusterSizes[j] = 0;\n            }\n            for (let i = 0; i < n; i++) {\n                const value = values[i];\n                let mindist = Number.MAX_VALUE;\n                let best;\n                for (let j = 0; j < num; j++) {\n                    const dist = abs$1(centroids[j] - value);\n                    if (dist < mindist) {\n                        mindist = dist;\n                        best = j;\n                    }\n                    clusterSizes[best]++;\n                    assignments[i] = best;\n                }\n            }\n\n            // update centroids step\n            const newCentroids = new Array(num);\n            for (let j = 0; j < num; j++) {\n                newCentroids[j] = null;\n            }\n            for (let i = 0; i < n; i++) {\n                cluster = assignments[i];\n                if (newCentroids[cluster] === null) {\n                    newCentroids[cluster] = values[i];\n                } else {\n                    newCentroids[cluster] += values[i];\n                }\n            }\n            for (let j = 0; j < num; j++) {\n                newCentroids[j] *= 1 / clusterSizes[j];\n            }\n\n            // check convergence\n            repeat = false;\n            for (let j = 0; j < num; j++) {\n                if (newCentroids[j] !== centroids[j]) {\n                    repeat = true;\n                    break;\n                }\n            }\n\n            centroids = newCentroids;\n            nb_iters++;\n\n            if (nb_iters > 200) {\n                repeat = false;\n            }\n        }\n\n        // finished k-means clustering\n        // the next part is borrowed from gabrielflor.it\n        const kClusters = {};\n        for (let j = 0; j < num; j++) {\n            kClusters[j] = [];\n        }\n        for (let i = 0; i < n; i++) {\n            cluster = assignments[i];\n            kClusters[cluster].push(values[i]);\n        }\n        let tmpKMeansBreaks = [];\n        for (let j = 0; j < num; j++) {\n            tmpKMeansBreaks.push(kClusters[j][0]);\n            tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);\n        }\n        tmpKMeansBreaks = tmpKMeansBreaks.sort((a, b) => a - b);\n        limits.push(tmpKMeansBreaks[0]);\n        for (let i = 1; i < tmpKMeansBreaks.length; i += 2) {\n            const v = tmpKMeansBreaks[i];\n            if (!isNaN(v) && limits.indexOf(v) === -1) {\n                limits.push(v);\n            }\n        }\n    }\n    return limits;\n}\n\nvar contrast = (a, b) => {\n    // WCAG contrast ratio\n    // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n    a = new Color(a);\n    b = new Color(b);\n    const l1 = a.luminance();\n    const l2 = b.luminance();\n    return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);\n};\n\nconst { sqrt, pow, min, max: max$1, atan2, abs, cos, sin, exp, PI } = Math;\n\nfunction deltaE (a, b, Kl = 1, Kc = 1, Kh = 1) {\n    // Delta E (CIE 2000)\n    // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE2000.html\n    var rad2deg = function (rad) {\n        return (360 * rad) / (2 * PI);\n    };\n    var deg2rad = function (deg) {\n        return (2 * PI * deg) / 360;\n    };\n    a = new Color(a);\n    b = new Color(b);\n    const [L1, a1, b1] = Array.from(a.lab());\n    const [L2, a2, b2] = Array.from(b.lab());\n    const avgL = (L1 + L2) / 2;\n    const C1 = sqrt(pow(a1, 2) + pow(b1, 2));\n    const C2 = sqrt(pow(a2, 2) + pow(b2, 2));\n    const avgC = (C1 + C2) / 2;\n    const G = 0.5 * (1 - sqrt(pow(avgC, 7) / (pow(avgC, 7) + pow(25, 7))));\n    const a1p = a1 * (1 + G);\n    const a2p = a2 * (1 + G);\n    const C1p = sqrt(pow(a1p, 2) + pow(b1, 2));\n    const C2p = sqrt(pow(a2p, 2) + pow(b2, 2));\n    const avgCp = (C1p + C2p) / 2;\n    const arctan1 = rad2deg(atan2(b1, a1p));\n    const arctan2 = rad2deg(atan2(b2, a2p));\n    const h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;\n    const h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;\n    const avgHp =\n        abs(h1p - h2p) > 180 ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;\n    const T =\n        1 -\n        0.17 * cos(deg2rad(avgHp - 30)) +\n        0.24 * cos(deg2rad(2 * avgHp)) +\n        0.32 * cos(deg2rad(3 * avgHp + 6)) -\n        0.2 * cos(deg2rad(4 * avgHp - 63));\n    let deltaHp = h2p - h1p;\n    deltaHp =\n        abs(deltaHp) <= 180\n            ? deltaHp\n            : h2p <= h1p\n              ? deltaHp + 360\n              : deltaHp - 360;\n    deltaHp = 2 * sqrt(C1p * C2p) * sin(deg2rad(deltaHp) / 2);\n    const deltaL = L2 - L1;\n    const deltaCp = C2p - C1p;\n    const sl = 1 + (0.015 * pow(avgL - 50, 2)) / sqrt(20 + pow(avgL - 50, 2));\n    const sc = 1 + 0.045 * avgCp;\n    const sh = 1 + 0.015 * avgCp * T;\n    const deltaTheta = 30 * exp(-pow((avgHp - 275) / 25, 2));\n    const Rc = 2 * sqrt(pow(avgCp, 7) / (pow(avgCp, 7) + pow(25, 7)));\n    const Rt = -Rc * sin(2 * deg2rad(deltaTheta));\n    const result = sqrt(\n        pow(deltaL / (Kl * sl), 2) +\n            pow(deltaCp / (Kc * sc), 2) +\n            pow(deltaHp / (Kh * sh), 2) +\n            Rt * (deltaCp / (Kc * sc)) * (deltaHp / (Kh * sh))\n    );\n    return max$1(0, min(100, result));\n}\n\n// simple Euclidean distance\nfunction distance (a, b, mode = 'lab') {\n    // Delta E (CIE 1976)\n    // see http://www.brucelindbloom.com/index.html?Equations.html\n    a = new Color(a);\n    b = new Color(b);\n    const l1 = a.get(mode);\n    const l2 = b.get(mode);\n    let sum_sq = 0;\n    for (let i in l1) {\n        const d = (l1[i] || 0) - (l2[i] || 0);\n        sum_sq += d * d;\n    }\n    return Math.sqrt(sum_sq);\n}\n\nvar valid = (...args) => {\n    try {\n        new Color(...args);\n        return true;\n        // eslint-disable-next-line\n    } catch (e) {\n        return false;\n    }\n};\n\n// some pre-defined color scales:\n\nvar scales = {\n    cool() {\n        return scale([chroma.hsl(180, 1, 0.9), chroma.hsl(250, 0.7, 0.4)]);\n    },\n    hot() {\n        return scale(['#000', '#f00', '#ff0', '#fff']).mode(\n            'rgb'\n        );\n    }\n};\n\n/**\n    ColorBrewer colors for chroma.js\n\n    Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The\n    Pennsylvania State University.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software distributed\n    under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n    CONDITIONS OF ANY KIND, either express or implied. See the License for the\n    specific language governing permissions and limitations under the License.\n*/\n\nconst colorbrewer = {\n    // sequential\n    OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],\n    PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],\n    BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],\n    Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],\n    BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],\n    YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],\n    YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],\n    Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],\n    RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],\n    Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],\n    YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],\n    Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],\n    GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],\n    Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],\n    YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],\n    PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],\n    Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],\n    PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],\n    Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],\n\n    // diverging\n    Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],\n    RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],\n    RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],\n    PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],\n    PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],\n    RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],\n    BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],\n    RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],\n    PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],\n\n    // qualitative\n    Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],\n    Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],\n    Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],\n    Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],\n    Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],\n    Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],\n    Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],\n    Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2']\n};\n\n// add lowercase aliases for case-insensitive matches\nfor (let key of Object.keys(colorbrewer)) {\n    colorbrewer[key.toLowerCase()] = colorbrewer[key];\n}\n\nconst cmyk2rgb = (...args) => {\n    args = unpack(args, 'cmyk');\n    const [c, m, y, k] = args;\n    const alpha = args.length > 4 ? args[4] : 1;\n    if (k === 1) return [0, 0, 0, alpha];\n    return [\n        c >= 1 ? 0 : 255 * (1 - c) * (1 - k), // r\n        m >= 1 ? 0 : 255 * (1 - m) * (1 - k), // g\n        y >= 1 ? 0 : 255 * (1 - y) * (1 - k), // b\n        alpha\n    ];\n};\n\nconst { max } = Math;\n\nconst rgb2cmyk = (...args) => {\n    let [r, g, b] = unpack(args, 'rgb');\n    r = r / 255;\n    g = g / 255;\n    b = b / 255;\n    const k = 1 - max(r, max(g, b));\n    const f = k < 1 ? 1 / (1 - k) : 0;\n    const c = (1 - r - k) * f;\n    const m = (1 - g - k) * f;\n    const y = (1 - b - k) * f;\n    return [c, m, y, k];\n};\n\nColor.prototype.cmyk = function () {\n    return rgb2cmyk(this._rgb);\n};\n\nconst cmyk = (...args) => new Color(...args, 'cmyk');\nObject.assign(chroma, { cmyk });\n\ninput.format.cmyk = cmyk2rgb;\n\ninput.autodetect.push({\n    p: 2,\n    test: (...args) => {\n        args = unpack(args, 'cmyk');\n        if (type(args) === 'array' && args.length === 4) {\n            return 'cmyk';\n        }\n    }\n});\n\n/*\n * supported arguments:\n * - hsl2css(h,s,l)\n * - hsl2css(h,s,l,a)\n * - hsl2css([h,s,l], mode)\n * - hsl2css([h,s,l,a], mode)\n * - hsl2css({h,s,l,a}, mode)\n */\nconst hsl2css = (...args) => {\n    const hsla = unpack(args, 'hsla');\n    let mode = last(args) || 'lsa';\n    hsla[0] = rnd2(hsla[0] || 0) + 'deg';\n    hsla[1] = rnd2(hsla[1] * 100) + '%';\n    hsla[2] = rnd2(hsla[2] * 100) + '%';\n    if (mode === 'hsla' || (hsla.length > 3 && hsla[3] < 1)) {\n        hsla[3] = '/ ' + (hsla.length > 3 ? hsla[3] : 1);\n        mode = 'hsla';\n    } else {\n        hsla.length = 3;\n    }\n    return `${mode.substr(0, 3)}(${hsla.join(' ')})`;\n};\n\n/*\n * supported arguments:\n * - lab2css(l,a,b)\n * - lab2css(l,a,b,alpha)\n * - lab2css([l,a,b], mode)\n * - lab2css([l,a,b,alpha], mode)\n */\nconst lab2css = (...args) => {\n    const laba = unpack(args, 'lab');\n    let mode = last(args) || 'lab';\n    laba[0] = rnd2(laba[0]) + '%';\n    laba[1] = rnd2(laba[1]);\n    laba[2] = rnd2(laba[2]);\n    if (mode === 'laba' || (laba.length > 3 && laba[3] < 1)) {\n        laba[3] = '/ ' + (laba.length > 3 ? laba[3] : 1);\n    } else {\n        laba.length = 3;\n    }\n    return `lab(${laba.join(' ')})`;\n};\n\n/*\n * supported arguments:\n * - lab2css(l,a,b)\n * - lab2css(l,a,b,alpha)\n * - lab2css([l,a,b], mode)\n * - lab2css([l,a,b,alpha], mode)\n */\nconst lch2css = (...args) => {\n    const lcha = unpack(args, 'lch');\n    let mode = last(args) || 'lab';\n    lcha[0] = rnd2(lcha[0]) + '%';\n    lcha[1] = rnd2(lcha[1]);\n    lcha[2] = rnd2(lcha[2]) + 'deg'; // add deg unit to hue\n    if (mode === 'lcha' || (lcha.length > 3 && lcha[3] < 1)) {\n        lcha[3] = '/ ' + (lcha.length > 3 ? lcha[3] : 1);\n    } else {\n        lcha.length = 3;\n    }\n    return `lch(${lcha.join(' ')})`;\n};\n\nconst oklab2css$1 = (...args) => {\n    const laba = unpack(args, 'lab');\n    laba[0] = rnd2(laba[0] * 100) + '%';\n    laba[1] = rnd3(laba[1]);\n    laba[2] = rnd3(laba[2]);\n    if (laba.length > 3 && laba[3] < 1) {\n        laba[3] = '/ ' + (laba.length > 3 ? laba[3] : 1);\n    } else {\n        laba.length = 3;\n    }\n    return `oklab(${laba.join(' ')})`;\n};\n\nconst rgb2oklch = (...args) => {\n    const [r, g, b, ...rest] = unpack(args, 'rgb');\n    const [l, a, b_] = rgb2oklab(r, g, b);\n    const [L, c, h] = lab2lch(l, a, b_);\n    return [L, c, h, ...(rest.length > 0 && rest[0] < 1 ? [rest[0]] : [])];\n};\n\nconst oklab2css = (...args) => {\n    const laba = unpack(args, 'lab');\n    laba[0] = rnd2(laba[0] * 100) + '%';\n    laba[1] = rnd3(laba[1]);\n    laba[2] = rnd2(laba[2]) + 'deg';\n    if (laba.length > 3 && laba[3] < 1) {\n        laba[3] = '/ ' + (laba.length > 3 ? laba[3] : 1);\n    } else {\n        laba.length = 3;\n    }\n    return `oklch(${laba.join(' ')})`;\n};\n\nconst { round: round$2 } = Math;\n\n/*\n * supported arguments:\n * - rgb2css(r,g,b)\n * - rgb2css(r,g,b,a)\n * - rgb2css([r,g,b], mode)\n * - rgb2css([r,g,b,a], mode)\n * - rgb2css({r,g,b,a}, mode)\n */\nconst rgb2css = (...args) => {\n    const rgba = unpack(args, 'rgba');\n    let mode = last(args) || 'rgb';\n    if (mode.substr(0, 3) === 'hsl') {\n        return hsl2css(rgb2hsl$1(rgba), mode);\n    }\n    if (mode.substr(0, 3) === 'lab') {\n        // change to D50 lab whitepoint since this is what W3C is using for CSS Lab colors\n        const prevWhitePoint = getLabWhitePoint();\n        setLabWhitePoint('d50');\n        const cssColor = lab2css(rgb2lab(rgba), mode);\n        setLabWhitePoint(prevWhitePoint);\n        return cssColor;\n    }\n    if (mode.substr(0, 3) === 'lch') {\n        // change to D50 lab whitepoint since this is what W3C is using for CSS Lab colors\n        const prevWhitePoint = getLabWhitePoint();\n        setLabWhitePoint('d50');\n        const cssColor = lch2css(rgb2lch(rgba), mode);\n        setLabWhitePoint(prevWhitePoint);\n        return cssColor;\n    }\n    if (mode.substr(0, 5) === 'oklab') {\n        return oklab2css$1(rgb2oklab(rgba));\n    }\n    if (mode.substr(0, 5) === 'oklch') {\n        return oklab2css(rgb2oklch(rgba));\n    }\n    rgba[0] = round$2(rgba[0]);\n    rgba[1] = round$2(rgba[1]);\n    rgba[2] = round$2(rgba[2]);\n    if (mode === 'rgba' || (rgba.length > 3 && rgba[3] < 1)) {\n        rgba[3] = '/ ' + (rgba.length > 3 ? rgba[3] : 1);\n        mode = 'rgba';\n    }\n    return `${mode.substr(0, 3)}(${rgba.slice(0, mode === 'rgb' ? 3 : 4).join(' ')})`;\n};\n\nconst oklch2rgb = (...args) => {\n    args = unpack(args, 'lch');\n    const [l, c, h, ...rest] = args;\n    const [L, a, b_] = lch2lab(l, c, h);\n    const [r, g, b] = oklab2rgb(L, a, b_);\n    return [r, g, b, ...(rest.length > 0 && rest[0] < 1 ? [rest[0]] : [])];\n};\n\nconst RE_RGB = /^rgb\\(\\s*(-?\\d+) \\s*(-?\\d+)\\s* \\s*(-?\\d+)\\s*\\)$/;\nconst RE_RGB_LEGACY = /^rgb\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*\\)$/;\n\nconst RE_RGBA =\n    /^rgba?\\(\\s*(-?\\d+) \\s*(-?\\d+)\\s* \\s*(-?\\d+)\\s*\\/\\s*([01]|[01]?\\.\\d+)\\)$/;\nconst RE_RGBA_LEGACY =\n    /^rgba\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n\nconst RE_RGB_PCT =\n    /^rgb\\(\\s*(-?\\d+(?:\\.\\d+)?)% \\s*(-?\\d+(?:\\.\\d+)?)%\\s* \\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\nconst RE_RGB_PCT_LEGACY =\n    /^rgb\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n\nconst RE_RGBA_PCT =\n    /^rgba?\\(\\s*(-?\\d+(?:\\.\\d+)?)% \\s*(-?\\d+(?:\\.\\d+)?)%\\s* \\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\/\\s*([01]|[01]?\\.\\d+)\\)$/;\nconst RE_RGBA_PCT_LEGACY =\n    /^rgba\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n\nconst RE_HSL =\n    /^hsl\\(\\s*(-?\\d+(?:\\.\\d+)?)deg \\s*(-?\\d+(?:\\.\\d+)?)%\\s* \\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\nconst RE_HSL_LEGACY =\n    /^hsl\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n\nconst RE_HSLA =\n    /^hsla?\\(\\s*(-?\\d+(?:\\.\\d+)?)deg \\s*(-?\\d+(?:\\.\\d+)?)%\\s* \\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\/\\s*([01]|[01]?\\.\\d+)\\)$/;\nconst RE_HSLA_LEGACY =\n    /^hsla\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n\nconst RE_LAB =\n    /^lab\\(\\s*(-?\\d+(?:\\.\\d+)?%?) \\s*(-?\\d+(?:\\.\\d+)?%?) \\s*(-?\\d+(?:\\.\\d+)?%?)\\s*(?:\\/\\s*(\\d+(?:\\.\\d+)?))?\\)?$/;\nconst RE_LCH =\n    /^lch\\(\\s*(-?\\d+(?:\\.\\d+)?%?) \\s*((?:-?\\d+(?:\\.\\d+)?%?)|none) \\s*(-?\\d+(?:\\.\\d+)?(?:deg)?|none)\\s*(?:\\/\\s*(\\d+(?:\\.\\d+)?))?\\)?$/;\nconst RE_OKLAB =\n    /^oklab\\(\\s*(-?\\d+(?:\\.\\d+)?%?) \\s*(-?\\d+(?:\\.\\d+)?%?) \\s*(-?\\d+(?:\\.\\d+)?%?)\\s*(?:\\/\\s*(\\d+(?:\\.\\d+)?))?\\)?$/;\nconst RE_OKLCH =\n    /^oklch\\(\\s*(-?\\d+(?:\\.\\d+)?%?) \\s*(?:(-?\\d+(?:\\.\\d+)?%?)|none) \\s*(-?\\d+(?:\\.\\d+)?(?:deg)?|none)\\s*(?:\\/\\s*(\\d+(?:\\.\\d+)?))?\\)?$/;\n\nconst { round: round$1 } = Math;\n\nconst roundRGB = (rgb) => {\n    return rgb.map((v, i) => (i <= 2 ? limit(round$1(v), 0, 255) : v));\n};\n\nconst percentToAbsolute = (pct, min = 0, max = 100, signed = false) => {\n    if (typeof pct === 'string' && pct.endsWith('%')) {\n        pct = parseFloat(pct.substring(0, pct.length - 1)) / 100;\n        if (signed) {\n            // signed percentages are in the range -100% to 100%\n            pct = min + (pct + 1) * 0.5 * (max - min);\n        } else {\n            pct = min + pct * (max - min);\n        }\n    }\n    return +pct;\n};\n\nconst noneToValue = (v, noneValue) => {\n    return v === 'none' ? noneValue : v;\n};\n\nconst css2rgb = (css) => {\n    css = css.toLowerCase().trim();\n    let m;\n\n    if (input.format.named) {\n        try {\n            return input.format.named(css);\n            // eslint-disable-next-line\n        } catch (e) {}\n    }\n\n    // rgb(250 20 0) or rgb(250,20,0)\n    if ((m = css.match(RE_RGB)) || (m = css.match(RE_RGB_LEGACY))) {\n        const rgb = m.slice(1, 4);\n        for (let i = 0; i < 3; i++) {\n            rgb[i] = +rgb[i];\n        }\n        rgb[3] = 1; // default alpha\n        return rgb;\n    }\n\n    // rgba(250,20,0,0.4)\n    if ((m = css.match(RE_RGBA)) || (m = css.match(RE_RGBA_LEGACY))) {\n        const rgb = m.slice(1, 5);\n        for (let i = 0; i < 4; i++) {\n            rgb[i] = +rgb[i];\n        }\n        return rgb;\n    }\n\n    // rgb(100%,0%,0%)\n    if ((m = css.match(RE_RGB_PCT)) || (m = css.match(RE_RGB_PCT_LEGACY))) {\n        const rgb = m.slice(1, 4);\n        for (let i = 0; i < 3; i++) {\n            rgb[i] = round$1(rgb[i] * 2.55);\n        }\n        rgb[3] = 1; // default alpha\n        return rgb;\n    }\n\n    // rgba(100%,0%,0%,0.4)\n    if ((m = css.match(RE_RGBA_PCT)) || (m = css.match(RE_RGBA_PCT_LEGACY))) {\n        const rgb = m.slice(1, 5);\n        for (let i = 0; i < 3; i++) {\n            rgb[i] = round$1(rgb[i] * 2.55);\n        }\n        rgb[3] = +rgb[3];\n        return rgb;\n    }\n\n    // hsl(0,100%,50%)\n    if ((m = css.match(RE_HSL)) || (m = css.match(RE_HSL_LEGACY))) {\n        const hsl = m.slice(1, 4);\n        hsl[1] *= 0.01;\n        hsl[2] *= 0.01;\n        const rgb = hsl2rgb(hsl);\n        for (let i = 0; i < 3; i++) {\n            rgb[i] = round$1(rgb[i]);\n        }\n        rgb[3] = 1;\n        return rgb;\n    }\n\n    // hsla(0,100%,50%,0.5)\n    if ((m = css.match(RE_HSLA)) || (m = css.match(RE_HSLA_LEGACY))) {\n        const hsl = m.slice(1, 4);\n        hsl[1] *= 0.01;\n        hsl[2] *= 0.01;\n        const rgb = hsl2rgb(hsl);\n        for (let i = 0; i < 3; i++) {\n            rgb[i] = round$1(rgb[i]);\n        }\n        rgb[3] = +m[4]; // default alpha = 1\n        return rgb;\n    }\n\n    if ((m = css.match(RE_LAB))) {\n        const lab = m.slice(1, 4);\n        lab[0] = percentToAbsolute(lab[0], 0, 100);\n        lab[1] = percentToAbsolute(lab[1], -125, 125, true);\n        lab[2] = percentToAbsolute(lab[2], -125, 125, true);\n        // convert to D50 Lab whitepoint\n        const wp = getLabWhitePoint();\n        setLabWhitePoint('d50');\n        const rgb = roundRGB(lab2rgb(lab));\n        // convert back to original Lab whitepoint\n        setLabWhitePoint(wp);\n        rgb[3] = m[4] !== undefined ? +m[4] : 1;\n        return rgb;\n    }\n\n    if ((m = css.match(RE_LCH))) {\n        const lch = m.slice(1, 4);\n        lch[0] = percentToAbsolute(lch[0], 0, 100);\n        lch[1] = percentToAbsolute(noneToValue(lch[1], 0), 0, 150, false);\n        lch[2] = +noneToValue(lch[2].replace('deg', ''), 0);\n        // convert to D50 Lab whitepoint\n        const wp = getLabWhitePoint();\n        setLabWhitePoint('d50');\n        const rgb = roundRGB(lch2rgb(lch));\n        // convert back to original Lab whitepoint\n        setLabWhitePoint(wp);\n        rgb[3] = m[4] !== undefined ? +m[4] : 1;\n        return rgb;\n    }\n\n    if ((m = css.match(RE_OKLAB))) {\n        const oklab = m.slice(1, 4);\n        oklab[0] = percentToAbsolute(oklab[0], 0, 1);\n        oklab[1] = percentToAbsolute(oklab[1], -0.4, 0.4, true);\n        oklab[2] = percentToAbsolute(oklab[2], -0.4, 0.4, true);\n        const rgb = roundRGB(oklab2rgb(oklab));\n        rgb[3] = m[4] !== undefined ? +m[4] : 1;\n        return rgb;\n    }\n\n    if ((m = css.match(RE_OKLCH))) {\n        const oklch = m.slice(1, 4);\n        oklch[0] = percentToAbsolute(oklch[0], 0, 1);\n        oklch[1] = percentToAbsolute(noneToValue(oklch[1], 0), 0, 0.4, false);\n        oklch[2] = +noneToValue(oklch[2].replace('deg', ''), 0);\n        const rgb = roundRGB(oklch2rgb(oklch));\n        rgb[3] = m[4] !== undefined ? +m[4] : 1;\n        return rgb;\n    }\n};\n\ncss2rgb.test = (s) => {\n    return (\n        // modern\n        RE_RGB.test(s) ||\n        RE_RGBA.test(s) ||\n        RE_RGB_PCT.test(s) ||\n        RE_RGBA_PCT.test(s) ||\n        RE_HSL.test(s) ||\n        RE_HSLA.test(s) ||\n        RE_LAB.test(s) ||\n        RE_LCH.test(s) ||\n        RE_OKLAB.test(s) ||\n        RE_OKLCH.test(s) ||\n        // legacy\n        RE_RGB_LEGACY.test(s) ||\n        RE_RGBA_LEGACY.test(s) ||\n        RE_RGB_PCT_LEGACY.test(s) ||\n        RE_RGBA_PCT_LEGACY.test(s) ||\n        RE_HSL_LEGACY.test(s) ||\n        RE_HSLA_LEGACY.test(s)\n    );\n};\n\nColor.prototype.css = function (mode) {\n    return rgb2css(this._rgb, mode);\n};\n\nconst css = (...args) => new Color(...args, 'css');\nchroma.css = css;\n\ninput.format.css = css2rgb;\n\ninput.autodetect.push({\n    p: 5,\n    test: (h, ...rest) => {\n        if (!rest.length && type(h) === 'string' && css2rgb.test(h)) {\n            return 'css';\n        }\n    }\n});\n\ninput.format.gl = (...args) => {\n    const rgb = unpack(args, 'rgba');\n    rgb[0] *= 255;\n    rgb[1] *= 255;\n    rgb[2] *= 255;\n    return rgb;\n};\n\nconst gl = (...args) => new Color(...args, 'gl');\nchroma.gl = gl;\n\nColor.prototype.gl = function () {\n    const rgb = this._rgb;\n    return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, rgb[3]];\n};\n\nColor.prototype.hex = function (mode) {\n    return rgb2hex(this._rgb, mode);\n};\n\nconst hex = (...args) => new Color(...args, 'hex');\nchroma.hex = hex;\n\ninput.format.hex = hex2rgb;\ninput.autodetect.push({\n    p: 4,\n    test: (h, ...rest) => {\n        if (\n            !rest.length &&\n            type(h) === 'string' &&\n            [3, 4, 5, 6, 7, 8, 9].indexOf(h.length) >= 0\n        ) {\n            return 'hex';\n        }\n    }\n});\n\n/*\n * Based on implementation by Neil Bartlett\n * https://github.com/neilbartlett/color-temperature\n */\n\nconst { log } = Math;\n\nconst temperature2rgb = (kelvin) => {\n    const temp = kelvin / 100;\n    let r, g, b;\n    if (temp < 66) {\n        r = 255;\n        g =\n            temp < 6\n                ? 0\n                : -155.25485562709179 -\n                  0.44596950469579133 * (g = temp - 2) +\n                  104.49216199393888 * log(g);\n        b =\n            temp < 20\n                ? 0\n                : -254.76935184120902 +\n                  0.8274096064007395 * (b = temp - 10) +\n                  115.67994401066147 * log(b);\n    } else {\n        r =\n            351.97690566805693 +\n            0.114206453784165 * (r = temp - 55) -\n            40.25366309332127 * log(r);\n        g =\n            325.4494125711974 +\n            0.07943456536662342 * (g = temp - 50) -\n            28.0852963507957 * log(g);\n        b = 255;\n    }\n    return [r, g, b, 1];\n};\n\n/*\n * Based on implementation by Neil Bartlett\n * https://github.com/neilbartlett/color-temperature\n **/\n\nconst { round } = Math;\n\nconst rgb2temperature = (...args) => {\n    const rgb = unpack(args, 'rgb');\n    const r = rgb[0],\n        b = rgb[2];\n    let minTemp = 1000;\n    let maxTemp = 40000;\n    const eps = 0.4;\n    let temp;\n    while (maxTemp - minTemp > eps) {\n        temp = (maxTemp + minTemp) * 0.5;\n        const rgb = temperature2rgb(temp);\n        if (rgb[2] / rgb[0] >= b / r) {\n            maxTemp = temp;\n        } else {\n            minTemp = temp;\n        }\n    }\n    return round(temp);\n};\n\nColor.prototype.temp =\n    Color.prototype.kelvin =\n    Color.prototype.temperature =\n        function () {\n            return rgb2temperature(this._rgb);\n        };\n\nconst temp = (...args) => new Color(...args, 'temp');\nObject.assign(chroma, { temp, kelvin: temp, temperature: temp });\n\ninput.format.temp =\n    input.format.kelvin =\n    input.format.temperature =\n        temperature2rgb;\n\nColor.prototype.oklch = function () {\n    return rgb2oklch(this._rgb);\n};\n\nconst oklch = (...args) => new Color(...args, 'oklch');\nObject.assign(chroma, { oklch });\n\ninput.format.oklch = oklch2rgb;\n\ninput.autodetect.push({\n    p: 2,\n    test: (...args) => {\n        args = unpack(args, 'oklch');\n        if (type(args) === 'array' && args.length === 3) {\n            return 'oklch';\n        }\n    }\n});\n\n// feel free to comment out anything to rollup\n// a smaller chroma.js bundle\n\nObject.assign(chroma, {\n    analyze,\n    average,\n    bezier: bezier$1,\n    blend,\n    brewer: colorbrewer,\n    Color,\n    colors: w3cx11,\n    contrast,\n    cubehelix,\n    deltaE,\n    distance,\n    input,\n    interpolate: mix,\n    limits,\n    mix,\n    random: random$1,\n    scale,\n    scales,\n    valid\n});\n\nfunction replaceNaN(array) {\n    // fixes a NaN for 0 values in ChromaJS\n    array[0] = 0;\n    return array;\n}\nfunction convertToNamedObject(hsv) {\n    return {\n        hue: hsv[0],\n        saturation: hsv[1],\n        brightness: hsv[2],\n    };\n}\nfunction generateColorsWithLock(props, options, results) {\n    const lockHSV = isNaN(chroma.hex(`${options.lockHex}`).hsv()[0])\n        ? convertToNamedObject(replaceNaN(chroma.hex(`${options.lockHex}`).hsv()))\n        : convertToNamedObject(chroma.hex(`${options.lockHex}`).hsv());\n    let shortestDistance = 999999;\n    let lockedColor = {\n        hue: { step: 0, value: 0 },\n        saturation: { step: 0, value: 0 },\n        brightness: { step: 0, value: 0 },\n        step: 0,\n        isMajor: false,\n        isLocked: false\n    };\n    let lockedIndex;\n    const lastColor = results[results.length - 1];\n    results.forEach(function (color, index) {\n        const { hue, saturation, brightness } = color;\n        const hex = chroma.hsv(hue.value, saturation.value, brightness.value);\n        if (options.lockHex !== undefined) {\n            const distance = chroma.distance(hex, options.lockHex);\n            if (shortestDistance > distance) {\n                shortestDistance = distance;\n                lockedColor = color;\n                lockedIndex = index;\n            }\n        }\n    });\n    const difference = {\n        hue: lockHSV.hue - lockedColor.hue.value,\n        saturation: lockHSV.saturation - lockedColor.saturation.value,\n        brightness: lockHSV.brightness - lockedColor.brightness.value,\n    };\n    const adjustedColorSet = results.map(function (color, index) {\n        var _a, _b, _c;\n        if (index < lockedIndex) {\n            const hueDifference = distribute({\n                value: index,\n                rangeA: [0, lockedIndex],\n                rangeB: [0, difference.hue],\n            });\n            const saturationDifference = distribute({\n                value: index,\n                rangeA: [0, lockedIndex],\n                rangeB: [0, difference.saturation],\n            });\n            const brightnessDifference = distribute({\n                value: index,\n                rangeA: [0, lockedIndex],\n                rangeB: [0, difference.brightness],\n            });\n            return {\n                hue: {\n                    step: color.hue.step,\n                    value: color.hue.value + hueDifference > 0\n                        ? color.hue.value + hueDifference\n                        : 0,\n                },\n                saturation: {\n                    step: color.saturation.step,\n                    value: color.saturation.value + saturationDifference > 0\n                        ? color.saturation.value + saturationDifference\n                        : 0,\n                },\n                brightness: {\n                    step: color.brightness.step,\n                    value: color.brightness.value + brightnessDifference > 0\n                        ? color.brightness.value + brightnessDifference\n                        : 0,\n                },\n                step: color.step,\n                isMajor: color.isMajor,\n                isLocked: false,\n            };\n        }\n        else if (index === lockedIndex) {\n            return {\n                hue: { step: color.hue.step, value: lockHSV.hue },\n                saturation: { step: color.saturation.step, value: lockHSV.saturation },\n                brightness: { step: color.brightness.step, value: lockHSV.brightness },\n                step: color.step,\n                isMajor: color.isMajor,\n                isLocked: true,\n            };\n        }\n        else {\n            const hueDifference = distribute({\n                value: index,\n                rangeA: [lockedIndex, lastColor.step + (((_a = options === null || options === void 0 ? void 0 : options.minorSteps) === null || _a === void 0 ? void 0 : _a.length) || 0)],\n                rangeB: [difference.hue, 0],\n            });\n            const saturationDifference = distribute({\n                value: index,\n                rangeA: [lockedIndex, lastColor.step + (((_b = options === null || options === void 0 ? void 0 : options.minorSteps) === null || _b === void 0 ? void 0 : _b.length) || 0)],\n                rangeB: [difference.saturation, 0],\n            });\n            const brightnessDifference = distribute({\n                value: index,\n                rangeA: [lockedIndex, lastColor.step + (((_c = options === null || options === void 0 ? void 0 : options.minorSteps) === null || _c === void 0 ? void 0 : _c.length) || 0)],\n                rangeB: [difference.brightness, 0],\n            });\n            return {\n                hue: {\n                    step: color.hue.step,\n                    value: color.hue.value + hueDifference > 0 ||\n                        color.hue.value + hueDifference < 360\n                        ? color.hue.value + hueDifference\n                        : 0,\n                },\n                saturation: {\n                    step: color.saturation.step,\n                    value: color.saturation.value + saturationDifference < 1\n                        ? color.saturation.value + saturationDifference\n                        : 1,\n                },\n                brightness: {\n                    step: color.brightness.step,\n                    value: color.brightness.value + brightnessDifference < 1\n                        ? color.brightness.value + brightnessDifference\n                        : 1,\n                },\n                step: color.step,\n                isMajor: color.isMajor,\n                isLocked: false,\n            };\n        }\n    });\n    return adjustedColorSet;\n}\n\nfunction generate(props, options) {\n    if (options === undefined) {\n        options = {};\n    }\n    const { lockHex, lockHexInverted, provideInverted } = options;\n    const algorithmResult = [];\n    const generated = generateColors(props, options);\n    if (lockHex) {\n        algorithmResult.push(generateColorsWithLock(props, options, generated));\n    }\n    else {\n        algorithmResult.push(generated);\n    }\n    if (provideInverted) {\n        const generatedInverted = generateColors(props, options, true);\n        lockHexInverted === undefined\n            ? algorithmResult.push(generatedInverted)\n            : algorithmResult.push(generateColorsWithLock(props, options, generatedInverted));\n    }\n    return convertToColors(props, options, algorithmResult);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aay12eW4vY29sb3JhbGdvcml0aG0vZGlzdC9idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQWU7QUFDeEMsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHFDQUFxQztBQUNqRCxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0RBQXNEO0FBQ3RELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsK0VBQVc7QUFDcEM7QUFDQTtBQUNBLDJDQUEyQyx1REFBdUQ7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLG1DQUFtQzs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxFQUFFLGFBQWEsRUFBRTtBQUNqRCxpQ0FBaUMsRUFBRSxhQUFhLEVBQUU7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLElBQUk7QUFDOUM7O0FBRUEsUUFBUSxpQkFBaUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixJQUFJLEVBQUUsSUFBSTtBQUNqQztBQUNBLHVCQUF1QixJQUFJLEVBQUUsSUFBSTtBQUNqQztBQUNBLHVCQUF1QixJQUFJO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSwwQkFBMEI7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksK0RBQStEO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSw4REFBOEQ7QUFDMUU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixnREFBZ0Q7O0FBRXhFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUyxVQUFVLEtBQUs7QUFDbkUsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGFBQWE7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU07QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHlCQUF5Qjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLCtDQUErQzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixpQkFBaUI7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsVUFBVSxLQUFLO0FBQ25FLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVEsMkJBQTJCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLFlBQVk7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVEsaUJBQWlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVEsYUFBYTs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxpQ0FBaUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxRQUFRLGlCQUFpQjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEseUJBQXlCOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZ0JBQWdCOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVEsNkVBQTZFOztBQUVyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsUUFBUSxhQUFhOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHLG9HQUFvRztBQUNwRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7O0FBRTVDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsaUJBQWlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3QkFBd0IsS0FBSzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQ0FBcUM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSx5QkFBeUI7O0FBRWpDO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLDRDQUE0Qzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLDREQUE0RDs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsTUFBTTs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLE1BQU07O0FBRTlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYyxrQkFBa0IsR0FBRyxlQUFlO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DOztBQUVBLFFBQVEsaUJBQWlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0IsR0FBRyxnREFBZ0Q7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsaUJBQWlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsTUFBTTs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFFBQVE7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHVDQUF1Qzs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLE9BQU87O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hELHdEQUF3RCxnQkFBZ0I7QUFDeEUsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEMsc0JBQXNCLG1CQUFtQjtBQUN6QyxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQTBDO0FBQ2pFLDhCQUE4Qix3REFBd0Q7QUFDdEYsOEJBQThCLHdEQUF3RDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBNEM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9CIiwic291cmNlcyI6WyIvVXNlcnMvZGF2aWRlYmlzY3Vzby9Eb2N1bWVudHMvR2l0SHViL2NvbG9yLXJhbXAvbm9kZV9tb2R1bGVzL0BrLXZ5bi9jb2xvcmFsZ29yaXRobS9kaXN0L2J1bmRsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBPcmlnaW5hbGx5IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2tvZW5ib2svRnJhbWVyL2Jsb2IvbWFzdGVyL2ZyYW1lci9VdGlscy5jb2ZmZWVcbi8vIFRyYW5zbGF0ZWQgdG8gVHlwZXNjcmlwdFxuZnVuY3Rpb24gZGlzdHJpYnV0ZSh7IHZhbHVlLCByYW5nZUEsIHJhbmdlQiwgbGltaXQsIH0pIHtcbiAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW1pdCA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBbZnJvbUxvdywgZnJvbUhpZ2hdID0gQXJyYXkuZnJvbShyYW5nZUEpO1xuICAgIGNvbnN0IFt0b0xvdywgdG9IaWdoXSA9IEFycmF5LmZyb20ocmFuZ2VCKTtcbiAgICBjb25zdCByZXN1bHQgPSB0b0xvdyArICgodmFsdWUgLSBmcm9tTG93KSAvIChmcm9tSGlnaCAtIGZyb21Mb3cpKSAqICh0b0hpZ2ggLSB0b0xvdyk7XG4gICAgaWYgKGxpbWl0ID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0b0xvdyA8IHRvSGlnaCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA8IHRvTG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvTG93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA+IHRvSGlnaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0hpZ2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID4gdG9Mb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9Mb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0IDwgdG9IaWdoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvSGlnaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBiZXppZXIkMiA9IHJlcXVpcmUoXCJiZXppZXItZWFzaW5nXCIpO1xuZnVuY3Rpb24gZ2VuZXJhdGVOdW1iZXJPZlN0ZXBzKHsgY3VydmUsIHN0ZXBzLCB9KSB7XG4gICAgY29uc3QgYXJyYXlPZlN0ZXBzID0gQXJyYXkuZnJvbShBcnJheShzdGVwcykua2V5cygpKTtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHN0ZXAgaW4gYXJyYXlPZlN0ZXBzKSB7XG4gICAgICAgIGNvbnN0IHN0ZXBOdW1iZXIgPSBwYXJzZUludChzdGVwLCAxMCk7XG4gICAgICAgIGNvbnN0IGVhc2luZyA9IGJlemllciQyKC4uLmN1cnZlKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlYXNpbmcoc3RlcE51bWJlciAvIChzdGVwcyAtIDEpKTtcbiAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuY29uc3QgZGVmYXVsdEN1cnZlcyA9IHtcbiAgICBsaW5lYXI6IHtcbiAgICAgICAgbmFtZTogXCJsaW5lYXJcIixcbiAgICAgICAgZm9ybWF0dGVkX25hbWU6IFwiTGluZWFyXCIsXG4gICAgICAgIHZhbHVlOiBbMC41LCAwLjUsIDAuNSwgMC41XSxcbiAgICB9LFxuICAgIGVhc2VJbkN1YmljOiB7XG4gICAgICAgIG5hbWU6IFwiZWFzZUluQ3ViaWNcIixcbiAgICAgICAgZm9ybWF0dGVkX25hbWU6IFwiQ3ViaWMgLSBFYXNlSW5cIixcbiAgICAgICAgdmFsdWU6IFswLjU1LCAwLjA1NSwgMC42NzUsIDAuMTldLFxuICAgIH0sXG4gICAgZWFzZU91dEN1YmljOiB7XG4gICAgICAgIG5hbWU6IFwiZWFzZU91dEN1YmljXCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIkN1YmljIC0gRWFzZU91dFwiLFxuICAgICAgICB2YWx1ZTogWzAuMjE1LCAwLjYxLCAwLjM1NSwgMV0sXG4gICAgfSxcbiAgICBlYXNlSW5PdXRDdWJpYzoge1xuICAgICAgICBuYW1lOiBcImVhc2VJbk91dEN1YmljXCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIkN1YmljIC0gRWFzZUluT3V0XCIsXG4gICAgICAgIHZhbHVlOiBbMC42NDUsIDAuMDQ1LCAwLjM1NSwgMV0sXG4gICAgfSxcbiAgICBlYXNlSW5TaW5lOiB7XG4gICAgICAgIG5hbWU6IFwiZWFzZUluU2luZVwiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJTaW5lIC0gRWFzZUluXCIsXG4gICAgICAgIHZhbHVlOiBbMC40NywgMCwgMC43NDUsIDAuNzE1XSxcbiAgICB9LFxuICAgIGVhc2VPdXRTaW5lOiB7XG4gICAgICAgIG5hbWU6IFwiZWFzZU91dFNpbmVcIixcbiAgICAgICAgZm9ybWF0dGVkX25hbWU6IFwiU2luZSAtIEVhc2VPdXRcIixcbiAgICAgICAgdmFsdWU6IFswLjM5LCAwLjU3NSwgMC41NjUsIDFdLFxuICAgIH0sXG4gICAgZWFzZUluT3V0U2luZToge1xuICAgICAgICBuYW1lOiBcImVhc2VJbk91dFNpbmVcIixcbiAgICAgICAgZm9ybWF0dGVkX25hbWU6IFwiU2luZSAtIEVhc2VJbk91dFwiLFxuICAgICAgICB2YWx1ZTogWzAuNDQ1LCAwLjA1LCAwLjU1LCAwLjk1XSxcbiAgICB9LFxuICAgIGVhc2VJblF1YWQ6IHtcbiAgICAgICAgbmFtZTogXCJlYXNlSW5RdWFkXCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIlF1YWQgLSBFYXNlSW5cIixcbiAgICAgICAgdmFsdWU6IFswLjU1LCAwLjA4NSwgMC42OCwgMC41M10sXG4gICAgfSxcbiAgICBlYXNlT3V0UXVhZDoge1xuICAgICAgICBuYW1lOiBcImVhc2VPdXRRdWFkXCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIlF1YWQgLSBFYXNlT3V0XCIsXG4gICAgICAgIHZhbHVlOiBbMC4yNSwgMC40NiwgMC40NSwgMC45NF0sXG4gICAgfSxcbiAgICBlYXNlSW5PdXRRdWFkOiB7XG4gICAgICAgIG5hbWU6IFwiZWFzZUluT3V0UXVhZFwiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJRdWFkIC0gRWFzZUluT3V0XCIsXG4gICAgICAgIHZhbHVlOiBbMC40NTUsIDAuMDMsIDAuNTE1LCAwLjk1NV0sXG4gICAgfSxcbiAgICBlYXNlSW5RdWFydDoge1xuICAgICAgICBuYW1lOiBcImVhc2VJblF1YXJ0XCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIlF1YXJ0IC0gRWFzZUluXCIsXG4gICAgICAgIHZhbHVlOiBbMC44OTUsIDAuMDMsIDAuNjg1LCAwLjIyXSxcbiAgICB9LFxuICAgIGVhc2VPdXRRdWFydDoge1xuICAgICAgICBuYW1lOiBcImVhc2VPdXRRdWFydFwiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJRdWFydCAtIEVhc2VPdXRcIixcbiAgICAgICAgdmFsdWU6IFswLjE2NSwgMC44NCwgMC40NCwgMV0sXG4gICAgfSxcbiAgICBlYXNlSW5PdXRRdWFydDoge1xuICAgICAgICBuYW1lOiBcImVhc2VJbk91dFF1YXJ0XCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIlF1YXJ0IC0gRWFzZUluT3V0XCIsXG4gICAgICAgIHZhbHVlOiBbMC43NywgMCwgMC4xNzUsIDFdLFxuICAgIH0sXG4gICAgZWFzZUluUXVpbnQ6IHtcbiAgICAgICAgbmFtZTogXCJlYXNlSW5RdWludFwiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJRdWludCAtIEVhc2VJblwiLFxuICAgICAgICB2YWx1ZTogWzAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNl0sXG4gICAgfSxcbiAgICBlYXNlT3V0UXVpbnQ6IHtcbiAgICAgICAgbmFtZTogXCJlYXNlT3V0UXVpbnRcIixcbiAgICAgICAgZm9ybWF0dGVkX25hbWU6IFwiUXVpbnQgLSBFYXNlT3V0XCIsXG4gICAgICAgIHZhbHVlOiBbMC4yMywgMSwgMC4zMiwgMV0sXG4gICAgfSxcbiAgICBlYXNlSW5PdXRRdWludDoge1xuICAgICAgICBuYW1lOiBcImVhc2VJbk91dFF1aW50XCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIlF1aW50IC0gRWFzZUluT3V0XCIsXG4gICAgICAgIHZhbHVlOiBbMC44NiwgMCwgMC4wNywgMV0sXG4gICAgfSxcbiAgICBlYXNlSW5DaXJjOiB7XG4gICAgICAgIG5hbWU6IFwiZWFzZUluQ2lyY1wiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJDaXJjIC0gRWFzZUluXCIsXG4gICAgICAgIHZhbHVlOiBbMC42LCAwLjA0LCAwLjk4LCAwLjMzNV0sXG4gICAgfSxcbiAgICBlYXNlT3V0Q2lyYzoge1xuICAgICAgICBuYW1lOiBcImVhc2VPdXRDaXJjXCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIkNpcmMgLSBFYXNlT3V0XCIsXG4gICAgICAgIHZhbHVlOiBbMC4wNzUsIDAuODIsIDAuMTY1LCAxXSxcbiAgICB9LFxuICAgIGVhc2VJbk91dENpcmM6IHtcbiAgICAgICAgbmFtZTogXCJlYXNlSW5PdXRDaXJjXCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIkNpcmMgLSBFYXNlSW5PdXRcIixcbiAgICAgICAgdmFsdWU6IFswLjc4NSwgMC4xMzUsIDAuMTUsIDAuODZdLFxuICAgIH0sXG4gICAgZWFzZUluRXhwbzoge1xuICAgICAgICBuYW1lOiBcImVhc2VJbkV4cG9cIixcbiAgICAgICAgZm9ybWF0dGVkX25hbWU6IFwiRXhwbyAtIEVhc2VJblwiLFxuICAgICAgICB2YWx1ZTogWzAuOTUsIDAuMDUsIDAuNzk1LCAwLjAzNV0sXG4gICAgfSxcbiAgICBlYXNlT3V0RXhwbzoge1xuICAgICAgICBuYW1lOiBcImVhc2VPdXRFeHBvXCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIkV4cG8gLSBFYXNlT3V0XCIsXG4gICAgICAgIHZhbHVlOiBbMC4xOSwgMSwgMC4yMiwgMV0sXG4gICAgfSxcbiAgICBlYXNlSW5PdXRFeHBvOiB7XG4gICAgICAgIG5hbWU6IFwiZWFzZUluT3V0RXhwb1wiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJFeHBvIC0gRWFzZUluT3V0XCIsXG4gICAgICAgIHZhbHVlOiBbMSwgMCwgMCwgMV0sXG4gICAgfSxcbiAgICBlYXNlSW5CYWNrOiB7XG4gICAgICAgIG5hbWU6IFwiZWFzZUluQmFja1wiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJCYWNrIC0gRWFzZUluXCIsXG4gICAgICAgIHZhbHVlOiBbMC42LCAtMC4yOCwgMC43MzUsIDAuMDQ1XSxcbiAgICB9LFxuICAgIGVhc2VPdXRCYWNrOiB7XG4gICAgICAgIG5hbWU6IFwiZWFzZU91dEJhY2tcIixcbiAgICAgICAgZm9ybWF0dGVkX25hbWU6IFwiQmFjayAtIEVhc2VPdXRcIixcbiAgICAgICAgdmFsdWU6IFswLjE3NSwgMC44ODUsIDAuMzIsIDEuMjc1XSxcbiAgICB9LFxuICAgIGVhc2VJbk91dEJhY2s6IHtcbiAgICAgICAgbmFtZTogXCJlYXNlSW5PdXRCYWNrXCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIkJhY2sgLSBFYXNlSW5PdXRcIixcbiAgICAgICAgdmFsdWU6IFswLjY4LCAtMC41NSwgMC4yNjUsIDEuNTVdLFxuICAgIH0sXG59O1xuXG5mdW5jdGlvbiBnZXRDb29yZGluYXRlcyhjdXJ2ZSwgaW52ZXJ0KSB7XG4gICAgaWYgKHR5cGVvZiBjdXJ2ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBjb29yZGluYXRlcyA9IGRlZmF1bHRDdXJ2ZXNbY3VydmVdO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnZlcnQgPT09IHRydWVcbiAgICAgICAgICAgICAgICA/IGNvb3JkaW5hdGVzLnZhbHVlLnNsaWNlKCkucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgOiBjb29yZGluYXRlcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwicHJvdmlkZWQgaW5jb3JyZWN0IGN1cnZlXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3VydmUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGN1cnZlLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgaWYgKCFjdXJ2ZS5zb21lKGlzTmFOKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJ2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW5jb21wYXRpYmxlIGN1cnZlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJjdXJ2ZSBpcyBuZWl0aGVyIGEgc3RyaW5nIG9yIGEgY29tcGF0aWJsZSBhcnJheVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcImN1cnZlIHdhcyBuZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdFwiKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVDb2xvcnMocHJvcHMsIG9wdGlvbnMsIGludmVydCkge1xuICAgIGNvbnN0IHsgc3RlcHMsIGh1ZSwgc2F0dXJhdGlvbiwgYnJpZ2h0bmVzcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyBtaW5vclN0ZXBzIH0gPSBvcHRpb25zO1xuICAgIC8vIGRlZmF1bHQgcm90YXRpb24gaXMgY2xvY2t3aXNlXG4gICAgY29uc3Qgcm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uID09PSBcImNvdW50ZXJjbG9ja3dpc2VcIiB8fCBvcHRpb25zLnJvdGF0aW9uID09PSBcImNjd1wiXG4gICAgICAgID8gXCJjY3dcIlxuICAgICAgICA6IFwiY3dcIjtcbiAgICAvLyBnZW5lcmF0ZSBzdGVwcyAwIHRvIDEgYmFzZWQgb24gY3VydmVcbiAgICBjb25zdCBodWVTdGVwcyA9IGdlbmVyYXRlTnVtYmVyT2ZTdGVwcyh7XG4gICAgICAgIGN1cnZlOiBnZXRDb29yZGluYXRlcyhodWUuY3VydmUsIGludmVydCksXG4gICAgICAgIHN0ZXBzLFxuICAgIH0pO1xuICAgIGNvbnN0IHNhdHVyYXRpb25TdGVwcyA9IGdlbmVyYXRlTnVtYmVyT2ZTdGVwcyh7XG4gICAgICAgIGN1cnZlOiBnZXRDb29yZGluYXRlcyhzYXR1cmF0aW9uLmN1cnZlLCBpbnZlcnQpLFxuICAgICAgICBzdGVwcyxcbiAgICB9KTtcbiAgICBjb25zdCBicmlnaHRuZXNzU3RlcHMgPSBnZW5lcmF0ZU51bWJlck9mU3RlcHMoe1xuICAgICAgICBjdXJ2ZTogZ2V0Q29vcmRpbmF0ZXMoYnJpZ2h0bmVzcy5jdXJ2ZSwgaW52ZXJ0KSxcbiAgICAgICAgc3RlcHMsXG4gICAgfSk7XG4gICAgLy8gYWRqdXN0IGh1ZSBzdGFydC9lbmQgdG8gZ2V0IHRoZSBpbnRlbmRlZCByb3RhdGlvblxuICAgIGlmIChyb3RhdGlvbiA9PT0gXCJjd1wiKSB7XG4gICAgICAgIGlmIChodWUuc3RhcnQgPiBodWUuZW5kKSB7XG4gICAgICAgICAgICBodWUuc3RhcnQgLT0gMzYwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJvdGF0aW9uID09PSBcImNjd1wiKSB7XG4gICAgICAgIGlmIChodWUuZW5kID4gaHVlLnN0YXJ0KSB7XG4gICAgICAgICAgICBodWUuZW5kIC09IDM2MDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEaXN0cmlidXRlIHRoZSBnZW5lcmF0ZWQgc3RlcHMgYmV0d2VlbiBodWUsIHNhdHVyYXRpb24sIGJyaWdodG5lc3MgcmFuZ2VzXG4gICAgY29uc3QgaHVlVmFsdWVzID0gaHVlU3RlcHMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBkaXN0cmlidXRlKHtcbiAgICAgICAgICAgIHZhbHVlOiBzLFxuICAgICAgICAgICAgcmFuZ2VBOiBbMCwgMV0sXG4gICAgICAgICAgICByYW5nZUI6IFtcbiAgICAgICAgICAgICAgICBpbnZlcnQgPT09IHRydWUgPyBodWUuZW5kIDogaHVlLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGludmVydCA9PT0gdHJ1ZSA/IGh1ZS5zdGFydCA6IGh1ZS5lbmQsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbGltaXQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHNhdHVyYXRpb25WYWx1ZXMgPSBzYXR1cmF0aW9uU3RlcHMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGlzdHJpYnV0ZSh7XG4gICAgICAgICAgICB2YWx1ZTogcyxcbiAgICAgICAgICAgIHJhbmdlQTogWzAsIDFdLFxuICAgICAgICAgICAgcmFuZ2VCOiBbXG4gICAgICAgICAgICAgICAgaW52ZXJ0ID09PSB0cnVlID8gc2F0dXJhdGlvbi5lbmQgOiBzYXR1cmF0aW9uLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGludmVydCA9PT0gdHJ1ZSA/IHNhdHVyYXRpb24uc3RhcnQgOiBzYXR1cmF0aW9uLmVuZCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBsaW1pdDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHZhbHVlV2l0aFJhdGUgPSB2YWx1ZSAqIHNhdHVyYXRpb24ucmF0ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlV2l0aFJhdGUgPCAxID8gdmFsdWVXaXRoUmF0ZSA6IDE7IC8vIHByZXZlbnQgdG9vIG11Y2ggc2F0dWFydGlvbiBzYXR1cmF0aW9uXG4gICAgfSk7XG4gICAgY29uc3QgYnJpZ2h0bmVzc1ZhbHVlcyA9IGJyaWdodG5lc3NTdGVwcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIGRpc3RyaWJ1dGUoe1xuICAgICAgICAgICAgdmFsdWU6IHMsXG4gICAgICAgICAgICByYW5nZUE6IFswLCAxXSxcbiAgICAgICAgICAgIHJhbmdlQjogW1xuICAgICAgICAgICAgICAgIGludmVydCA9PT0gdHJ1ZSA/IGJyaWdodG5lc3MuZW5kIDogYnJpZ2h0bmVzcy5zdGFydCxcbiAgICAgICAgICAgICAgICBpbnZlcnQgPT09IHRydWUgPyBicmlnaHRuZXNzLnN0YXJ0IDogYnJpZ2h0bmVzcy5lbmQsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBNZXJnZSB2YWx1ZXMgaW50byBjb2xvciBzdGVwc1xuICAgIGNvbnN0IGNvbG9yU3RlcHMgPSBodWVWYWx1ZXMubWFwKGZ1bmN0aW9uIChodWUsIGkpIHtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHtcbiAgICAgICAgICAgIGh1ZToge1xuICAgICAgICAgICAgICAgIHN0ZXA6IGh1ZVN0ZXBzW2ldLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBodWVWYWx1ZXNbaV0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2F0dXJhdGlvbjoge1xuICAgICAgICAgICAgICAgIHN0ZXA6IHNhdHVyYXRpb25TdGVwc1tpXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2F0dXJhdGlvblZhbHVlc1tpXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBicmlnaHRuZXNzOiB7XG4gICAgICAgICAgICAgICAgc3RlcDogYnJpZ2h0bmVzc1N0ZXBzW2ldLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBicmlnaHRuZXNzVmFsdWVzW2ldLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0ZXA6IGksXG4gICAgICAgICAgICBpc01ham9yOiB0cnVlLFxuICAgICAgICAgICAgaXNMb2NrZWQ6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICB9KTtcbiAgICAvLyBnZW5lcmF0ZSBtaW5vciBzdGVwc1xuICAgIGlmIChtaW5vclN0ZXBzKSB7XG4gICAgICAgIG1pbm9yU3RlcHMuZm9yRWFjaChmdW5jdGlvbiAobywgaSkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFN0ZXAgPSB7XG4gICAgICAgICAgICAgICAgaHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IDAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2F0dXJhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBzdGVwOiAwLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJyaWdodG5lc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogMCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc01ham9yOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzTG9ja2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdGVwOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBpbnNlcnRQcmV2aW91c1N0ZXAgPSBkZWZhdWx0U3RlcDtcbiAgICAgICAgICAgIGxldCBpbnNlcnROZXh0U3RlcCA9IGRlZmF1bHRTdGVwO1xuICAgICAgICAgICAgbGV0IGluc2VydEF0SW5kZXggPSAwO1xuICAgICAgICAgICAgY29sb3JTdGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG8gPT09IHAuc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRBdEluZGV4ID0gaiArIDE7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFByZXZpb3VzU3RlcCA9IHA7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydE5leHRTdGVwID0gY29sb3JTdGVwc1tqICsgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBodWVTdGVwID0gKGluc2VydFByZXZpb3VzU3RlcC5odWUuc3RlcCArIGluc2VydE5leHRTdGVwLmh1ZS5zdGVwKSAvIDI7XG4gICAgICAgICAgICBjb25zdCBodWVWYWx1ZSA9IGRpc3RyaWJ1dGUoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBodWVTdGVwLFxuICAgICAgICAgICAgICAgIHJhbmdlQTogWzAsIDFdLFxuICAgICAgICAgICAgICAgIHJhbmdlQjogW1xuICAgICAgICAgICAgICAgICAgICBpbnZlcnQgPT09IHRydWUgPyBodWUuZW5kIDogaHVlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBpbnZlcnQgPT09IHRydWUgPyBodWUuc3RhcnQgOiBodWUuZW5kLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNhdHVyYXRpb25TdGVwID0gKGluc2VydFByZXZpb3VzU3RlcC5zYXR1cmF0aW9uLnN0ZXAgKyBpbnNlcnROZXh0U3RlcC5zYXR1cmF0aW9uLnN0ZXApIC9cbiAgICAgICAgICAgICAgICAyO1xuICAgICAgICAgICAgbGV0IHNhdHVyYXRpb25WYWx1ZSA9IGRpc3RyaWJ1dGUoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzYXR1cmF0aW9uU3RlcCxcbiAgICAgICAgICAgICAgICByYW5nZUE6IFswLCAxXSxcbiAgICAgICAgICAgICAgICByYW5nZUI6IFtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJ0ID09PSB0cnVlID8gc2F0dXJhdGlvbi5lbmQgOiBzYXR1cmF0aW9uLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBpbnZlcnQgPT09IHRydWUgPyBzYXR1cmF0aW9uLnN0YXJ0IDogc2F0dXJhdGlvbi5lbmQsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pICogc2F0dXJhdGlvbi5yYXRlO1xuICAgICAgICAgICAgc2F0dXJhdGlvblZhbHVlID0gc2F0dXJhdGlvblZhbHVlIDwgMSA/IHNhdHVyYXRpb25WYWx1ZSA6IDE7XG4gICAgICAgICAgICBjb25zdCBicmlnaHRuZXNzU3RlcCA9IChpbnNlcnRQcmV2aW91c1N0ZXAuYnJpZ2h0bmVzcy5zdGVwICsgaW5zZXJ0TmV4dFN0ZXAuYnJpZ2h0bmVzcy5zdGVwKSAvXG4gICAgICAgICAgICAgICAgMjtcbiAgICAgICAgICAgIGNvbnN0IGJyaWdodG5lc3NWYWx1ZSA9IGRpc3RyaWJ1dGUoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBicmlnaHRuZXNzU3RlcCxcbiAgICAgICAgICAgICAgICByYW5nZUE6IFswLCAxXSxcbiAgICAgICAgICAgICAgICByYW5nZUI6IFtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJ0ID09PSB0cnVlID8gYnJpZ2h0bmVzcy5lbmQgOiBicmlnaHRuZXNzLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBpbnZlcnQgPT09IHRydWUgPyBicmlnaHRuZXNzLnN0YXJ0IDogYnJpZ2h0bmVzcy5lbmQsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGluc2VydEF0SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc2VydEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGh1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogaHVlU3RlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBodWVWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2F0dXJhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogc2F0dXJhdGlvblN0ZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2F0dXJhdGlvblZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBicmlnaHRuZXNzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwOiBicmlnaHRuZXNzU3RlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBicmlnaHRuZXNzVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGlzTG9ja2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaXNNYWpvcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IChpbnNlcnRQcmV2aW91c1N0ZXAuc3RlcCArIGluc2VydE5leHRTdGVwLnN0ZXApIC8gMixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbG9yU3RlcHMuc3BsaWNlKGluc2VydEF0SW5kZXgsIDAsIGluc2VydEl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yU3RlcHM7XG59XG5cbmNvbnN0IGNocm9tYSQxID0gcmVxdWlyZShcImNocm9tYS1qc1wiKTtcbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbG9ycyhwcm9wcywgb3B0aW9ucywgYWxnb3JpdGhtUmVzdWx0KSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IGFsZ29yaXRobVJlc3VsdC5tYXAoZnVuY3Rpb24gKHNldCwgaSkge1xuICAgICAgICBjb25zdCBjb2xvcnMgPSBzZXQubWFwKGZ1bmN0aW9uICh7IGh1ZSwgc2F0dXJhdGlvbiwgYnJpZ2h0bmVzcywgaXNNYWpvciwgaXNMb2NrZWQsIHN0ZXAsIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gY2hyb21hJDEuaHN2KGh1ZS52YWx1ZSwgc2F0dXJhdGlvbi52YWx1ZSwgYnJpZ2h0bmVzcy52YWx1ZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiByZXBsYWNlTmFOKGFycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gZml4ZXMgYSBOYU4gZm9yIDAgdmFsdWVzIGluIENocm9tYUpTXG4gICAgICAgICAgICAgICAgYXJyYXlbMF0gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZENvbG9yID0ge1xuICAgICAgICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgICAgICAgaHVlOiBodWUudmFsdWUsXG4gICAgICAgICAgICAgICAgc2F0dXJhdGlvbjogc2F0dXJhdGlvbi52YWx1ZSxcbiAgICAgICAgICAgICAgICBicmlnaHRuZXNzOiBicmlnaHRuZXNzLnZhbHVlLFxuICAgICAgICAgICAgICAgIGlzTWFqb3IsXG4gICAgICAgICAgICAgICAgaXNMb2NrZWQsXG4gICAgICAgICAgICAgICAgaGV4OiBjb2xvci5oZXgoKSxcbiAgICAgICAgICAgICAgICBoc2w6IGlzTmFOKGNvbG9yLmhzbCgpWzBdKSA/IHJlcGxhY2VOYU4oY29sb3IuaHNsKCkpIDogY29sb3IuaHNsKCksXG4gICAgICAgICAgICAgICAgaHN2OiBpc05hTihjb2xvci5oc3YoKVswXSkgPyByZXBsYWNlTmFOKGNvbG9yLmhzdigpKSA6IGNvbG9yLmhzdigpLFxuICAgICAgICAgICAgICAgIGxhYjogaXNOYU4oY29sb3IubGFiKClbMF0pID8gcmVwbGFjZU5hTihjb2xvci5sYWIoKSkgOiBjb2xvci5sYWIoKSxcbiAgICAgICAgICAgICAgICByZ2JTdHJpbmc6IGNvbG9yLnJnYigpLmpvaW4oKSxcbiAgICAgICAgICAgICAgICByZ2JBcnJheTogY29sb3IucmdiKCksXG4gICAgICAgICAgICAgICAgcmdiYVN0cmluZzogY29sb3IucmdiYSgpLmpvaW4oKSxcbiAgICAgICAgICAgICAgICByZ2JhQXJyYXk6IGNvbG9yLnJnYmEoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gY29udmVydGVkQ29sb3I7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW52ZXJ0ZWQ6IGkgPiAwID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgY29sb3JzOiBjb2xvcnMsXG4gICAgICAgICAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbnZhciBsaW1pdCA9ICh4LCBsb3cgPSAwLCBoaWdoID0gMSkgPT4ge1xuICAgIHJldHVybiBtaW4kMyhtYXgkMyhsb3csIHgpLCBoaWdoKTtcbn07XG5cbnZhciBjbGlwX3JnYiA9IChyZ2IpID0+IHtcbiAgICByZ2IuX2NsaXBwZWQgPSBmYWxzZTtcbiAgICByZ2IuX3VuY2xpcHBlZCA9IHJnYi5zbGljZSgwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAzOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPCAzKSB7XG4gICAgICAgICAgICBpZiAocmdiW2ldIDwgMCB8fCByZ2JbaV0gPiAyNTUpIHJnYi5fY2xpcHBlZCA9IHRydWU7XG4gICAgICAgICAgICByZ2JbaV0gPSBsaW1pdChyZ2JbaV0sIDAsIDI1NSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMykge1xuICAgICAgICAgICAgcmdiW2ldID0gbGltaXQocmdiW2ldLCAwLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmdiO1xufTtcblxuLy8gcG9ydGVkIGZyb20galF1ZXJ5J3MgJC50eXBlXG5jb25zdCBjbGFzc1RvVHlwZSA9IHt9O1xuZm9yIChsZXQgbmFtZSBvZiBbXG4gICAgJ0Jvb2xlYW4nLFxuICAgICdOdW1iZXInLFxuICAgICdTdHJpbmcnLFxuICAgICdGdW5jdGlvbicsXG4gICAgJ0FycmF5JyxcbiAgICAnRGF0ZScsXG4gICAgJ1JlZ0V4cCcsXG4gICAgJ1VuZGVmaW5lZCcsXG4gICAgJ051bGwnXG5dKSB7XG4gICAgY2xhc3NUb1R5cGVbYFtvYmplY3QgJHtuYW1lfV1gXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHR5cGUgKG9iaikge1xuICAgIHJldHVybiBjbGFzc1RvVHlwZVtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKV0gfHwgJ29iamVjdCc7XG59XG5cbnZhciB1bnBhY2sgPSAoYXJncywga2V5T3JkZXIgPSBudWxsKSA9PiB7XG4gICAgLy8gaWYgY2FsbGVkIHdpdGggbW9yZSB0aGFuIDMgYXJndW1lbnRzLCB3ZSByZXR1cm4gdGhlIGFyZ3VtZW50c1xuICAgIGlmIChhcmdzLmxlbmd0aCA+PSAzKSByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgLy8gd2l0aCBsZXNzIHRoYW4gMyBhcmdzIHdlIGNoZWNrIGlmIGZpcnN0IGFyZyBpcyBvYmplY3RcbiAgICAvLyBhbmQgdXNlIHRoZSBrZXlPcmRlciBzdHJpbmcgdG8gZXh0cmFjdCBhbmQgc29ydCBwcm9wZXJ0aWVzXG4gICAgaWYgKHR5cGUoYXJnc1swXSkgPT0gJ29iamVjdCcgJiYga2V5T3JkZXIpIHtcbiAgICAgICAgcmV0dXJuIGtleU9yZGVyXG4gICAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgICAuZmlsdGVyKChrKSA9PiBhcmdzWzBdW2tdICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAubWFwKChrKSA9PiBhcmdzWzBdW2tdKTtcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIHdlIGp1c3QgcmV0dXJuIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgIC8vICh3aGljaCB3ZSBzdXBwb3NlIGlzIGFuIGFycmF5IG9mIGFyZ3MpXG4gICAgcmV0dXJuIGFyZ3NbMF0uc2xpY2UoMCk7XG59O1xuXG52YXIgbGFzdCA9IChhcmdzKSA9PiB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgbCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICBpZiAodHlwZShhcmdzW2xdKSA9PSAnc3RyaW5nJykgcmV0dXJuIGFyZ3NbbF0udG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IHsgUEk6IFBJJDIsIG1pbjogbWluJDMsIG1heDogbWF4JDMgfSA9IE1hdGg7XG5cbmNvbnN0IHJuZDIgPSAoYSkgPT4gTWF0aC5yb3VuZChhICogMTAwKSAvIDEwMDtcbmNvbnN0IHJuZDMgPSAoYSkgPT4gTWF0aC5yb3VuZChhICogMTAwKSAvIDEwMDtcblxuY29uc3QgVFdPUEkgPSBQSSQyICogMjtcbmNvbnN0IFBJVEhJUkQgPSBQSSQyIC8gMztcbmNvbnN0IERFRzJSQUQgPSBQSSQyIC8gMTgwO1xuY29uc3QgUkFEMkRFRyA9IDE4MCAvIFBJJDI7XG5cbnZhciBpbnB1dCA9IHtcbiAgICBmb3JtYXQ6IHt9LFxuICAgIGF1dG9kZXRlY3Q6IFtdXG59O1xuXG5jbGFzcyBDb2xvciB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGUoYXJnc1swXSkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBhcmdzWzBdLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICBhcmdzWzBdLmNvbnN0cnVjdG9yID09PSB0aGlzLmNvbnN0cnVjdG9yXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gdGhlIGFyZ3VtZW50IGlzIGFscmVhZHkgYSBDb2xvciBpbnN0YW5jZVxuICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGFzdCBhcmd1bWVudCBjb3VsZCBiZSB0aGUgbW9kZVxuICAgICAgICBsZXQgbW9kZSA9IGxhc3QoYXJncyk7XG4gICAgICAgIGxldCBhdXRvZGV0ZWN0ID0gZmFsc2U7XG4gICAgICAgIGlmICghbW9kZSkge1xuICAgICAgICAgICAgYXV0b2RldGVjdCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghaW5wdXQuc29ydGVkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuYXV0b2RldGVjdCA9IGlucHV0LmF1dG9kZXRlY3Quc29ydCgoYSwgYikgPT4gYi5wIC0gYS5wKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5zb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhdXRvLWRldGVjdCBmb3JtYXRcbiAgICAgICAgICAgIGZvciAobGV0IGNoayBvZiBpbnB1dC5hdXRvZGV0ZWN0KSB7XG4gICAgICAgICAgICAgICAgbW9kZSA9IGNoay50ZXN0KC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQuZm9ybWF0W21vZGVdKSB7XG4gICAgICAgICAgICBjb25zdCByZ2IgPSBpbnB1dC5mb3JtYXRbbW9kZV0uYXBwbHkoXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBhdXRvZGV0ZWN0ID8gYXJncyA6IGFyZ3Muc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWUuX3JnYiA9IGNsaXBfcmdiKHJnYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gZm9ybWF0OiAnICsgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGFscGhhIGNoYW5uZWxcbiAgICAgICAgaWYgKG1lLl9yZ2IubGVuZ3RoID09PSAzKSBtZS5fcmdiLnB1c2goMSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodHlwZSh0aGlzLmhleCkgPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuaGV4KCk7XG4gICAgICAgIHJldHVybiBgWyR7dGhpcy5fcmdiLmpvaW4oJywnKX1dYDtcbiAgICB9XG59XG5cbi8vIHRoaXMgZ2V0cyB1cGRhdGVkIGF1dG9tYXRpY2FsbHlcbmNvbnN0IHZlcnNpb24gPSAnMy4wLjAnO1xuXG5jb25zdCBjaHJvbWEgPSAoLi4uYXJncykgPT4ge1xuICAgIHJldHVybiBuZXcgQ29sb3IoLi4uYXJncyk7XG59O1xuXG5jaHJvbWEudmVyc2lvbiA9IHZlcnNpb247XG5cbi8qKlxuXHRYMTEgY29sb3IgbmFtZXNcblxuXHRodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3JcbiovXG5cbmNvbnN0IHczY3gxMSA9IHtcbiAgICBhbGljZWJsdWU6ICcjZjBmOGZmJyxcbiAgICBhbnRpcXVld2hpdGU6ICcjZmFlYmQ3JyxcbiAgICBhcXVhOiAnIzAwZmZmZicsXG4gICAgYXF1YW1hcmluZTogJyM3ZmZmZDQnLFxuICAgIGF6dXJlOiAnI2YwZmZmZicsXG4gICAgYmVpZ2U6ICcjZjVmNWRjJyxcbiAgICBiaXNxdWU6ICcjZmZlNGM0JyxcbiAgICBibGFjazogJyMwMDAwMDAnLFxuICAgIGJsYW5jaGVkYWxtb25kOiAnI2ZmZWJjZCcsXG4gICAgYmx1ZTogJyMwMDAwZmYnLFxuICAgIGJsdWV2aW9sZXQ6ICcjOGEyYmUyJyxcbiAgICBicm93bjogJyNhNTJhMmEnLFxuICAgIGJ1cmx5d29vZDogJyNkZWI4ODcnLFxuICAgIGNhZGV0Ymx1ZTogJyM1ZjllYTAnLFxuICAgIGNoYXJ0cmV1c2U6ICcjN2ZmZjAwJyxcbiAgICBjaG9jb2xhdGU6ICcjZDI2OTFlJyxcbiAgICBjb3JhbDogJyNmZjdmNTAnLFxuICAgIGNvcm5mbG93ZXJibHVlOiAnIzY0OTVlZCcsXG4gICAgY29ybnNpbGs6ICcjZmZmOGRjJyxcbiAgICBjcmltc29uOiAnI2RjMTQzYycsXG4gICAgY3lhbjogJyMwMGZmZmYnLFxuICAgIGRhcmtibHVlOiAnIzAwMDA4YicsXG4gICAgZGFya2N5YW46ICcjMDA4YjhiJyxcbiAgICBkYXJrZ29sZGVucm9kOiAnI2I4ODYwYicsXG4gICAgZGFya2dyYXk6ICcjYTlhOWE5JyxcbiAgICBkYXJrZ3JlZW46ICcjMDA2NDAwJyxcbiAgICBkYXJrZ3JleTogJyNhOWE5YTknLFxuICAgIGRhcmtraGFraTogJyNiZGI3NmInLFxuICAgIGRhcmttYWdlbnRhOiAnIzhiMDA4YicsXG4gICAgZGFya29saXZlZ3JlZW46ICcjNTU2YjJmJyxcbiAgICBkYXJrb3JhbmdlOiAnI2ZmOGMwMCcsXG4gICAgZGFya29yY2hpZDogJyM5OTMyY2MnLFxuICAgIGRhcmtyZWQ6ICcjOGIwMDAwJyxcbiAgICBkYXJrc2FsbW9uOiAnI2U5OTY3YScsXG4gICAgZGFya3NlYWdyZWVuOiAnIzhmYmM4ZicsXG4gICAgZGFya3NsYXRlYmx1ZTogJyM0ODNkOGInLFxuICAgIGRhcmtzbGF0ZWdyYXk6ICcjMmY0ZjRmJyxcbiAgICBkYXJrc2xhdGVncmV5OiAnIzJmNGY0ZicsXG4gICAgZGFya3R1cnF1b2lzZTogJyMwMGNlZDEnLFxuICAgIGRhcmt2aW9sZXQ6ICcjOTQwMGQzJyxcbiAgICBkZWVwcGluazogJyNmZjE0OTMnLFxuICAgIGRlZXBza3libHVlOiAnIzAwYmZmZicsXG4gICAgZGltZ3JheTogJyM2OTY5NjknLFxuICAgIGRpbWdyZXk6ICcjNjk2OTY5JyxcbiAgICBkb2RnZXJibHVlOiAnIzFlOTBmZicsXG4gICAgZmlyZWJyaWNrOiAnI2IyMjIyMicsXG4gICAgZmxvcmFsd2hpdGU6ICcjZmZmYWYwJyxcbiAgICBmb3Jlc3RncmVlbjogJyMyMjhiMjInLFxuICAgIGZ1Y2hzaWE6ICcjZmYwMGZmJyxcbiAgICBnYWluc2Jvcm86ICcjZGNkY2RjJyxcbiAgICBnaG9zdHdoaXRlOiAnI2Y4ZjhmZicsXG4gICAgZ29sZDogJyNmZmQ3MDAnLFxuICAgIGdvbGRlbnJvZDogJyNkYWE1MjAnLFxuICAgIGdyYXk6ICcjODA4MDgwJyxcbiAgICBncmVlbjogJyMwMDgwMDAnLFxuICAgIGdyZWVueWVsbG93OiAnI2FkZmYyZicsXG4gICAgZ3JleTogJyM4MDgwODAnLFxuICAgIGhvbmV5ZGV3OiAnI2YwZmZmMCcsXG4gICAgaG90cGluazogJyNmZjY5YjQnLFxuICAgIGluZGlhbnJlZDogJyNjZDVjNWMnLFxuICAgIGluZGlnbzogJyM0YjAwODInLFxuICAgIGl2b3J5OiAnI2ZmZmZmMCcsXG4gICAga2hha2k6ICcjZjBlNjhjJyxcbiAgICBsYXNlcmxlbW9uOiAnI2ZmZmY1NCcsXG4gICAgbGF2ZW5kZXI6ICcjZTZlNmZhJyxcbiAgICBsYXZlbmRlcmJsdXNoOiAnI2ZmZjBmNScsXG4gICAgbGF3bmdyZWVuOiAnIzdjZmMwMCcsXG4gICAgbGVtb25jaGlmZm9uOiAnI2ZmZmFjZCcsXG4gICAgbGlnaHRibHVlOiAnI2FkZDhlNicsXG4gICAgbGlnaHRjb3JhbDogJyNmMDgwODAnLFxuICAgIGxpZ2h0Y3lhbjogJyNlMGZmZmYnLFxuICAgIGxpZ2h0Z29sZGVucm9kOiAnI2ZhZmFkMicsXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjZmFmYWQyJyxcbiAgICBsaWdodGdyYXk6ICcjZDNkM2QzJyxcbiAgICBsaWdodGdyZWVuOiAnIzkwZWU5MCcsXG4gICAgbGlnaHRncmV5OiAnI2QzZDNkMycsXG4gICAgbGlnaHRwaW5rOiAnI2ZmYjZjMScsXG4gICAgbGlnaHRzYWxtb246ICcjZmZhMDdhJyxcbiAgICBsaWdodHNlYWdyZWVuOiAnIzIwYjJhYScsXG4gICAgbGlnaHRza3libHVlOiAnIzg3Y2VmYScsXG4gICAgbGlnaHRzbGF0ZWdyYXk6ICcjNzc4ODk5JyxcbiAgICBsaWdodHNsYXRlZ3JleTogJyM3Nzg4OTknLFxuICAgIGxpZ2h0c3RlZWxibHVlOiAnI2IwYzRkZScsXG4gICAgbGlnaHR5ZWxsb3c6ICcjZmZmZmUwJyxcbiAgICBsaW1lOiAnIzAwZmYwMCcsXG4gICAgbGltZWdyZWVuOiAnIzMyY2QzMicsXG4gICAgbGluZW46ICcjZmFmMGU2JyxcbiAgICBtYWdlbnRhOiAnI2ZmMDBmZicsXG4gICAgbWFyb29uOiAnIzgwMDAwMCcsXG4gICAgbWFyb29uMjogJyM3ZjAwMDAnLFxuICAgIG1hcm9vbjM6ICcjYjAzMDYwJyxcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiAnIzY2Y2RhYScsXG4gICAgbWVkaXVtYmx1ZTogJyMwMDAwY2QnLFxuICAgIG1lZGl1bW9yY2hpZDogJyNiYTU1ZDMnLFxuICAgIG1lZGl1bXB1cnBsZTogJyM5MzcwZGInLFxuICAgIG1lZGl1bXNlYWdyZWVuOiAnIzNjYjM3MScsXG4gICAgbWVkaXVtc2xhdGVibHVlOiAnIzdiNjhlZScsXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46ICcjMDBmYTlhJyxcbiAgICBtZWRpdW10dXJxdW9pc2U6ICcjNDhkMWNjJyxcbiAgICBtZWRpdW12aW9sZXRyZWQ6ICcjYzcxNTg1JyxcbiAgICBtaWRuaWdodGJsdWU6ICcjMTkxOTcwJyxcbiAgICBtaW50Y3JlYW06ICcjZjVmZmZhJyxcbiAgICBtaXN0eXJvc2U6ICcjZmZlNGUxJyxcbiAgICBtb2NjYXNpbjogJyNmZmU0YjUnLFxuICAgIG5hdmFqb3doaXRlOiAnI2ZmZGVhZCcsXG4gICAgbmF2eTogJyMwMDAwODAnLFxuICAgIG9sZGxhY2U6ICcjZmRmNWU2JyxcbiAgICBvbGl2ZTogJyM4MDgwMDAnLFxuICAgIG9saXZlZHJhYjogJyM2YjhlMjMnLFxuICAgIG9yYW5nZTogJyNmZmE1MDAnLFxuICAgIG9yYW5nZXJlZDogJyNmZjQ1MDAnLFxuICAgIG9yY2hpZDogJyNkYTcwZDYnLFxuICAgIHBhbGVnb2xkZW5yb2Q6ICcjZWVlOGFhJyxcbiAgICBwYWxlZ3JlZW46ICcjOThmYjk4JyxcbiAgICBwYWxldHVycXVvaXNlOiAnI2FmZWVlZScsXG4gICAgcGFsZXZpb2xldHJlZDogJyNkYjcwOTMnLFxuICAgIHBhcGF5YXdoaXA6ICcjZmZlZmQ1JyxcbiAgICBwZWFjaHB1ZmY6ICcjZmZkYWI5JyxcbiAgICBwZXJ1OiAnI2NkODUzZicsXG4gICAgcGluazogJyNmZmMwY2InLFxuICAgIHBsdW06ICcjZGRhMGRkJyxcbiAgICBwb3dkZXJibHVlOiAnI2IwZTBlNicsXG4gICAgcHVycGxlOiAnIzgwMDA4MCcsXG4gICAgcHVycGxlMjogJyM3ZjAwN2YnLFxuICAgIHB1cnBsZTM6ICcjYTAyMGYwJyxcbiAgICByZWJlY2NhcHVycGxlOiAnIzY2MzM5OScsXG4gICAgcmVkOiAnI2ZmMDAwMCcsXG4gICAgcm9zeWJyb3duOiAnI2JjOGY4ZicsXG4gICAgcm95YWxibHVlOiAnIzQxNjllMScsXG4gICAgc2FkZGxlYnJvd246ICcjOGI0NTEzJyxcbiAgICBzYWxtb246ICcjZmE4MDcyJyxcbiAgICBzYW5keWJyb3duOiAnI2Y0YTQ2MCcsXG4gICAgc2VhZ3JlZW46ICcjMmU4YjU3JyxcbiAgICBzZWFzaGVsbDogJyNmZmY1ZWUnLFxuICAgIHNpZW5uYTogJyNhMDUyMmQnLFxuICAgIHNpbHZlcjogJyNjMGMwYzAnLFxuICAgIHNreWJsdWU6ICcjODdjZWViJyxcbiAgICBzbGF0ZWJsdWU6ICcjNmE1YWNkJyxcbiAgICBzbGF0ZWdyYXk6ICcjNzA4MDkwJyxcbiAgICBzbGF0ZWdyZXk6ICcjNzA4MDkwJyxcbiAgICBzbm93OiAnI2ZmZmFmYScsXG4gICAgc3ByaW5nZ3JlZW46ICcjMDBmZjdmJyxcbiAgICBzdGVlbGJsdWU6ICcjNDY4MmI0JyxcbiAgICB0YW46ICcjZDJiNDhjJyxcbiAgICB0ZWFsOiAnIzAwODA4MCcsXG4gICAgdGhpc3RsZTogJyNkOGJmZDgnLFxuICAgIHRvbWF0bzogJyNmZjYzNDcnLFxuICAgIHR1cnF1b2lzZTogJyM0MGUwZDAnLFxuICAgIHZpb2xldDogJyNlZTgyZWUnLFxuICAgIHdoZWF0OiAnI2Y1ZGViMycsXG4gICAgd2hpdGU6ICcjZmZmZmZmJyxcbiAgICB3aGl0ZXNtb2tlOiAnI2Y1ZjVmNScsXG4gICAgeWVsbG93OiAnI2ZmZmYwMCcsXG4gICAgeWVsbG93Z3JlZW46ICcjOWFjZDMyJ1xufTtcblxuY29uc3QgUkVfSEVYID0gL14jPyhbQS1GYS1mMC05XXs2fXxbQS1GYS1mMC05XXszfSkkLztcbmNvbnN0IFJFX0hFWEEgPSAvXiM/KFtBLUZhLWYwLTldezh9fFtBLUZhLWYwLTldezR9KSQvO1xuXG5jb25zdCBoZXgycmdiID0gKGhleCkgPT4ge1xuICAgIGlmIChoZXgubWF0Y2goUkVfSEVYKSkge1xuICAgICAgICAvLyByZW1vdmUgb3B0aW9uYWwgbGVhZGluZyAjXG4gICAgICAgIGlmIChoZXgubGVuZ3RoID09PSA0IHx8IGhleC5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgICAgIGhleCA9IGhleC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhwYW5kIHNob3J0LW5vdGF0aW9uIHRvIGZ1bGwgc2l4LWRpZ2l0XG4gICAgICAgIGlmIChoZXgubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICBoZXggPSBoZXguc3BsaXQoJycpO1xuICAgICAgICAgICAgaGV4ID0gaGV4WzBdICsgaGV4WzBdICsgaGV4WzFdICsgaGV4WzFdICsgaGV4WzJdICsgaGV4WzJdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHUgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgICAgY29uc3QgciA9IHUgPj4gMTY7XG4gICAgICAgIGNvbnN0IGcgPSAodSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGNvbnN0IGIgPSB1ICYgMHhmZjtcbiAgICAgICAgcmV0dXJuIFtyLCBnLCBiLCAxXTtcbiAgICB9XG5cbiAgICAvLyBtYXRjaCByZ2JhIGhleCBmb3JtYXQsIGVnICNGRjAwMDA3N1xuICAgIGlmIChoZXgubWF0Y2goUkVfSEVYQSkpIHtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDUgfHwgaGV4Lmxlbmd0aCA9PT0gOSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG9wdGlvbmFsIGxlYWRpbmcgI1xuICAgICAgICAgICAgaGV4ID0gaGV4LnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleHBhbmQgc2hvcnQtbm90YXRpb24gdG8gZnVsbCBlaWdodC1kaWdpdFxuICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgaGV4ID0gaGV4LnNwbGl0KCcnKTtcbiAgICAgICAgICAgIGhleCA9XG4gICAgICAgICAgICAgICAgaGV4WzBdICtcbiAgICAgICAgICAgICAgICBoZXhbMF0gK1xuICAgICAgICAgICAgICAgIGhleFsxXSArXG4gICAgICAgICAgICAgICAgaGV4WzFdICtcbiAgICAgICAgICAgICAgICBoZXhbMl0gK1xuICAgICAgICAgICAgICAgIGhleFsyXSArXG4gICAgICAgICAgICAgICAgaGV4WzNdICtcbiAgICAgICAgICAgICAgICBoZXhbM107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICBjb25zdCByID0gKHUgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgY29uc3QgZyA9ICh1ID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGNvbnN0IGIgPSAodSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGNvbnN0IGEgPSBNYXRoLnJvdW5kKCgodSAmIDB4ZmYpIC8gMHhmZikgKiAxMDApIC8gMTAwO1xuICAgICAgICByZXR1cm4gW3IsIGcsIGIsIGFdO1xuICAgIH1cblxuICAgIC8vIHdlIHVzZWQgdG8gY2hlY2sgZm9yIGNzcyBjb2xvcnMgaGVyZVxuICAgIC8vIGlmIF9pbnB1dC5jc3M/IGFuZCByZ2IgPSBfaW5wdXQuY3NzIGhleFxuICAgIC8vICAgICByZXR1cm4gcmdiXG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gaGV4IGNvbG9yOiAke2hleH1gKTtcbn07XG5cbmNvbnN0IHsgcm91bmQ6IHJvdW5kJDUgfSA9IE1hdGg7XG5cbmNvbnN0IHJnYjJoZXggPSAoLi4uYXJncykgPT4ge1xuICAgIGxldCBbciwgZywgYiwgYV0gPSB1bnBhY2soYXJncywgJ3JnYmEnKTtcbiAgICBsZXQgbW9kZSA9IGxhc3QoYXJncykgfHwgJ2F1dG8nO1xuICAgIGlmIChhID09PSB1bmRlZmluZWQpIGEgPSAxO1xuICAgIGlmIChtb2RlID09PSAnYXV0bycpIHtcbiAgICAgICAgbW9kZSA9IGEgPCAxID8gJ3JnYmEnIDogJ3JnYic7XG4gICAgfVxuICAgIHIgPSByb3VuZCQ1KHIpO1xuICAgIGcgPSByb3VuZCQ1KGcpO1xuICAgIGIgPSByb3VuZCQ1KGIpO1xuICAgIGNvbnN0IHUgPSAociA8PCAxNikgfCAoZyA8PCA4KSB8IGI7XG4gICAgbGV0IHN0ciA9ICcwMDAwMDAnICsgdS50b1N0cmluZygxNik7IC8vIy50b1VwcGVyQ2FzZSgpO1xuICAgIHN0ciA9IHN0ci5zdWJzdHIoc3RyLmxlbmd0aCAtIDYpO1xuICAgIGxldCBoeGEgPSAnMCcgKyByb3VuZCQ1KGEgKiAyNTUpLnRvU3RyaW5nKDE2KTtcbiAgICBoeGEgPSBoeGEuc3Vic3RyKGh4YS5sZW5ndGggLSAyKTtcbiAgICBzd2l0Y2ggKG1vZGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgICAgIHJldHVybiBgIyR7c3RyfSR7aHhhfWA7XG4gICAgICAgIGNhc2UgJ2FyZ2InOlxuICAgICAgICAgICAgcmV0dXJuIGAjJHtoeGF9JHtzdHJ9YDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBgIyR7c3RyfWA7XG4gICAgfVxufTtcblxuQ29sb3IucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgaGV4ID0gcmdiMmhleCh0aGlzLl9yZ2IsICdyZ2InKTtcbiAgICBmb3IgKGxldCBuIG9mIE9iamVjdC5rZXlzKHczY3gxMSkpIHtcbiAgICAgICAgaWYgKHczY3gxMVtuXSA9PT0gaGV4KSByZXR1cm4gbi50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufTtcblxuaW5wdXQuZm9ybWF0Lm5hbWVkID0gKG5hbWUpID0+IHtcbiAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh3M2N4MTFbbmFtZV0pIHJldHVybiBoZXgycmdiKHczY3gxMVtuYW1lXSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbG9yIG5hbWU6ICcgKyBuYW1lKTtcbn07XG5cbmlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogNSxcbiAgICB0ZXN0OiAoaCwgLi4ucmVzdCkgPT4ge1xuICAgICAgICBpZiAoIXJlc3QubGVuZ3RoICYmIHR5cGUoaCkgPT09ICdzdHJpbmcnICYmIHczY3gxMVtoLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgICAgICByZXR1cm4gJ25hbWVkJztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5Db2xvci5wcm90b3R5cGUuYWxwaGEgPSBmdW5jdGlvbiAoYSwgbXV0YXRlID0gZmFsc2UpIHtcbiAgICBpZiAoYSAhPT0gdW5kZWZpbmVkICYmIHR5cGUoYSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChtdXRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JnYlszXSA9IGE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKFt0aGlzLl9yZ2JbMF0sIHRoaXMuX3JnYlsxXSwgdGhpcy5fcmdiWzJdLCBhXSwgJ3JnYicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmdiWzNdO1xufTtcblxuQ29sb3IucHJvdG90eXBlLmNsaXBwZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JnYi5fY2xpcHBlZCB8fCBmYWxzZTtcbn07XG5cbmNvbnN0IGxhYkNvbnN0YW50cyA9IHtcbiAgICAvLyBDb3JyZXNwb25kcyByb3VnaGx5IHRvIFJHQiBicmlnaHRlci9kYXJrZXJcbiAgICBLbjogMTgsXG5cbiAgICAvLyBENjUgc3RhbmRhcmQgcmVmZXJlbnRcbiAgICBsYWJXaGl0ZVBvaW50OiAnZDY1JyxcbiAgICBYbjogMC45NTA0NyxcbiAgICBZbjogMSxcbiAgICBabjogMS4wODg4MyxcblxuICAgIHQwOiAwLjEzNzkzMTAzNCwgLy8gNCAvIDI5XG4gICAgdDE6IDAuMjA2ODk2NTUyLCAvLyA2IC8gMjlcbiAgICB0MjogMC4xMjg0MTg1NSwgLy8gMyAqIHQxICogdDFcbiAgICB0MzogMC4wMDg4NTY0NTIsIC8vIHQxICogdDEgKiB0MSxcblxuICAgIGtFOiAyMTYuMCAvIDI0Mzg5LjAsXG4gICAga0tFOiA4LjAsXG4gICAga0s6IDI0Mzg5LjAgLyAyNy4wLFxuXG4gICAgUmVmV2hpdGVSR0I6IHtcbiAgICAgICAgLy8gc1JHQlxuICAgICAgICBYOiAwLjk1MDQ3LFxuICAgICAgICBZOiAxLFxuICAgICAgICBaOiAxLjA4ODgzXG4gICAgfSxcblxuICAgIE10eFJHQjJYWVo6IHtcbiAgICAgICAgbTAwOiAwLjQxMjQ1NjQzOTA4OTY5MjIsXG4gICAgICAgIG0wMTogMC4yMTI2NzI4NTE0MDU2MjI1MyxcbiAgICAgICAgbTAyOiAwLjAxOTMzMzg5NTU4MjMyOTMsXG4gICAgICAgIG0xMDogMC4zNTc1NzYwNzc2NDM5MDksXG4gICAgICAgIG0xMTogMC43MTUxNTIxNTUyODc4MTgsXG4gICAgICAgIG0xMjogMC4xMTkxOTIwMjU4ODEzMDI5NyxcbiAgICAgICAgbTIwOiAwLjE4MDQzNzQ4MzI2NjM5ODk0LFxuICAgICAgICBtMjE6IDAuMDcyMTc0OTkzMzA2NTU5NTgsXG4gICAgICAgIG0yMjogMC45NTAzMDQwNzg1MzYzNjc5XG4gICAgfSxcblxuICAgIE10eFhZWjJSR0I6IHtcbiAgICAgICAgbTAwOiAzLjI0MDQ1NDE2MjExNDEwNDUsXG4gICAgICAgIG0wMTogLTAuOTY5MjY2MDMwNTA1MTg2OCxcbiAgICAgICAgbTAyOiAwLjA1NTY0MzQzMDk1OTExNDcyNixcbiAgICAgICAgbTEwOiAtMS41MzcxMzg1MTI3OTc3MTY2LFxuICAgICAgICBtMTE6IDEuODc2MDEwODQ1NDQ2Njk0MixcbiAgICAgICAgbTEyOiAtMC4yMDQwMjU5MTM1MTY3NTM4LFxuICAgICAgICBtMjA6IC0wLjQ5ODUzMTQwOTU1NjAxNixcbiAgICAgICAgbTIxOiAwLjA0MTU1NjAxNzUzMDM0OTgzNCxcbiAgICAgICAgbTIyOiAxLjA1NzIyNTE4ODIyMzE3OTFcbiAgICB9LFxuXG4gICAgLy8gdXNlZCBpbiByZ2IyeHl6XG4gICAgQXM6IDAuOTQxNDI4NTM1MDAwMDAwMSxcbiAgICBCczogMS4wNDA0MTc0NjcsXG4gICAgQ3M6IDEuMDg5NTMyNjUxLFxuXG4gICAgTXR4QWRhcHRNYToge1xuICAgICAgICBtMDA6IDAuODk1MSxcbiAgICAgICAgbTAxOiAtMC43NTAyLFxuICAgICAgICBtMDI6IDAuMDM4OSxcbiAgICAgICAgbTEwOiAwLjI2NjQsXG4gICAgICAgIG0xMTogMS43MTM1LFxuICAgICAgICBtMTI6IC0wLjA2ODUsXG4gICAgICAgIG0yMDogLTAuMTYxNCxcbiAgICAgICAgbTIxOiAwLjAzNjcsXG4gICAgICAgIG0yMjogMS4wMjk2XG4gICAgfSxcblxuICAgIE10eEFkYXB0TWFJOiB7XG4gICAgICAgIG0wMDogMC45ODY5OTI5MDU0NjY3MTIzLFxuICAgICAgICBtMDE6IDAuNDMyMzA1MjY5NzIzMzk0NTYsXG4gICAgICAgIG0wMjogLTAuMDA4NTI4NjY0NTc1MTc3MzI4LFxuICAgICAgICBtMTA6IC0wLjE0NzA1NDI1NjQyMDk5MDEzLFxuICAgICAgICBtMTE6IDAuNTE4MzYwMjcxNTM2Nzc3NixcbiAgICAgICAgbTEyOiAwLjA0MDA0MjgyMTY1NDA4NDg3LFxuICAgICAgICBtMjA6IDAuMTU5OTYyNjUxNjYzNzMxMjUsXG4gICAgICAgIG0yMTogMC4wNDkyOTEyMjgyMTI4NTU2LFxuICAgICAgICBtMjI6IDAuOTY4NDg2Njk1Nzg3NTUwMlxuICAgIH1cbn07XG5cbi8vIHRha2VuIGZyb20gaHR0cHM6Ly9kZS5tYXRod29ya3MuY29tL2hlbHAvaW1hZ2VzL3JlZi93aGl0ZXBvaW50Lmh0bWxcbmNvbnN0IElMTFVNSU5BTlRTID0gbmV3IE1hcChbXG4gICAgLy8gQVNUTSBFMzA4LTAxXG4gICAgWydhJywgWzEuMDk4NSwgMC4zNTU4NV1dLFxuICAgIC8vIFd5c3plY2tpICYgU3RpbGVzLCBwLiA3NjlcbiAgICBbJ2InLCBbMS4wOTg1LCAwLjM1NTg1XV0sXG4gICAgLy8gQyBBU1RNIEUzMDgtMDFcbiAgICBbJ2MnLCBbMC45ODA3NCwgMS4xODIzMl1dLFxuICAgIC8vIEQ1MCAoQVNUTSBFMzA4LTAxKVxuICAgIFsnZDUwJywgWzAuOTY0MjIsIDAuODI1MjFdXSxcbiAgICAvLyBENTUgKEFTVE0gRTMwOC0wMSlcbiAgICBbJ2Q1NScsIFswLjk1NjgyLCAwLjkyMTQ5XV0sXG4gICAgLy8gRDY1IChBU1RNIEUzMDgtMDEpXG4gICAgWydkNjUnLCBbMC45NTA0NywgMS4wODg4M11dLFxuICAgIC8vIEUgKEFTVE0gRTMwOC0wMSlcbiAgICBbJ2UnLCBbMSwgMSwgMV1dLFxuICAgIC8vIEYyIChBU1RNIEUzMDgtMDEpXG4gICAgWydmMicsIFswLjk5MTg2LCAwLjY3MzkzXV0sXG4gICAgLy8gRjcgKEFTVE0gRTMwOC0wMSlcbiAgICBbJ2Y3JywgWzAuOTUwNDEsIDEuMDg3NDddXSxcbiAgICAvLyBGMTEgKEFTVE0gRTMwOC0wMSlcbiAgICBbJ2YxMScsIFsxLjAwOTYyLCAwLjY0MzVdXSxcbiAgICBbJ2ljYycsIFswLjk2NDIyLCAwLjgyNTIxXV1cbl0pO1xuXG5mdW5jdGlvbiBzZXRMYWJXaGl0ZVBvaW50KG5hbWUpIHtcbiAgICBjb25zdCBpbGwgPSBJTExVTUlOQU5UUy5nZXQoU3RyaW5nKG5hbWUpLnRvTG93ZXJDYXNlKCkpO1xuICAgIGlmICghaWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBMYWIgaWxsdW1pbmFudCAnICsgbmFtZSk7XG4gICAgfVxuICAgIGxhYkNvbnN0YW50cy5sYWJXaGl0ZVBvaW50ID0gbmFtZTtcbiAgICBsYWJDb25zdGFudHMuWG4gPSBpbGxbMF07XG4gICAgbGFiQ29uc3RhbnRzLlpuID0gaWxsWzFdO1xufVxuXG5mdW5jdGlvbiBnZXRMYWJXaGl0ZVBvaW50KCkge1xuICAgIHJldHVybiBsYWJDb25zdGFudHMubGFiV2hpdGVQb2ludDtcbn1cblxuLypcbiAqIEwqIFswLi4xMDBdXG4gKiBhIFstMTAwLi4xMDBdXG4gKiBiIFstMTAwLi4xMDBdXG4gKi9cbmNvbnN0IGxhYjJyZ2IgPSAoLi4uYXJncykgPT4ge1xuICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2xhYicpO1xuICAgIGNvbnN0IFtMLCBhLCBiXSA9IGFyZ3M7XG4gICAgY29uc3QgW3gsIHksIHpdID0gbGFiMnh5eihMLCBhLCBiKTtcbiAgICBjb25zdCBbciwgZywgYl9dID0geHl6MnJnYih4LCB5LCB6KTtcbiAgICByZXR1cm4gW3IsIGcsIGJfLCBhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMV07XG59O1xuXG5jb25zdCBsYWIyeHl6ID0gKEwsIGEsIGIpID0+IHtcbiAgICBjb25zdCB7IGtFLCBrSywga0tFLCBYbiwgWW4sIFpuIH0gPSBsYWJDb25zdGFudHM7XG5cbiAgICBjb25zdCBmeSA9IChMICsgMTYuMCkgLyAxMTYuMDtcbiAgICBjb25zdCBmeCA9IDAuMDAyICogYSArIGZ5O1xuICAgIGNvbnN0IGZ6ID0gZnkgLSAwLjAwNSAqIGI7XG5cbiAgICBjb25zdCBmeDMgPSBmeCAqIGZ4ICogZng7XG4gICAgY29uc3QgZnozID0gZnogKiBmeiAqIGZ6O1xuXG4gICAgY29uc3QgeHIgPSBmeDMgPiBrRSA/IGZ4MyA6ICgxMTYuMCAqIGZ4IC0gMTYuMCkgLyBrSztcbiAgICBjb25zdCB5ciA9IEwgPiBrS0UgPyBNYXRoLnBvdygoTCArIDE2LjApIC8gMTE2LjAsIDMuMCkgOiBMIC8ga0s7XG4gICAgY29uc3QgenIgPSBmejMgPiBrRSA/IGZ6MyA6ICgxMTYuMCAqIGZ6IC0gMTYuMCkgLyBrSztcblxuICAgIGNvbnN0IHggPSB4ciAqIFhuO1xuICAgIGNvbnN0IHkgPSB5ciAqIFluO1xuICAgIGNvbnN0IHogPSB6ciAqIFpuO1xuXG4gICAgcmV0dXJuIFt4LCB5LCB6XTtcbn07XG5cbmNvbnN0IGNvbXBhbmQgPSAobGluZWFyKSA9PiB7XG4gICAgLyogc1JHQiAqL1xuICAgIGNvbnN0IHNpZ24gPSBNYXRoLnNpZ24obGluZWFyKTtcbiAgICBsaW5lYXIgPSBNYXRoLmFicyhsaW5lYXIpO1xuICAgIHJldHVybiAoXG4gICAgICAgIChsaW5lYXIgPD0gMC4wMDMxMzA4XG4gICAgICAgICAgICA/IGxpbmVhciAqIDEyLjkyXG4gICAgICAgICAgICA6IDEuMDU1ICogTWF0aC5wb3cobGluZWFyLCAxLjAgLyAyLjQpIC0gMC4wNTUpICogc2lnblxuICAgICk7XG59O1xuXG5jb25zdCB4eXoycmdiID0gKHgsIHksIHopID0+IHtcbiAgICBjb25zdCB7IE10eEFkYXB0TWEsIE10eEFkYXB0TWFJLCBNdHhYWVoyUkdCLCBSZWZXaGl0ZVJHQiwgWG4sIFluLCBabiB9ID1cbiAgICAgICAgbGFiQ29uc3RhbnRzO1xuXG4gICAgY29uc3QgQXMgPSBYbiAqIE10eEFkYXB0TWEubTAwICsgWW4gKiBNdHhBZGFwdE1hLm0xMCArIFpuICogTXR4QWRhcHRNYS5tMjA7XG4gICAgY29uc3QgQnMgPSBYbiAqIE10eEFkYXB0TWEubTAxICsgWW4gKiBNdHhBZGFwdE1hLm0xMSArIFpuICogTXR4QWRhcHRNYS5tMjE7XG4gICAgY29uc3QgQ3MgPSBYbiAqIE10eEFkYXB0TWEubTAyICsgWW4gKiBNdHhBZGFwdE1hLm0xMiArIFpuICogTXR4QWRhcHRNYS5tMjI7XG5cbiAgICBjb25zdCBBZCA9XG4gICAgICAgIFJlZldoaXRlUkdCLlggKiBNdHhBZGFwdE1hLm0wMCArXG4gICAgICAgIFJlZldoaXRlUkdCLlkgKiBNdHhBZGFwdE1hLm0xMCArXG4gICAgICAgIFJlZldoaXRlUkdCLlogKiBNdHhBZGFwdE1hLm0yMDtcbiAgICBjb25zdCBCZCA9XG4gICAgICAgIFJlZldoaXRlUkdCLlggKiBNdHhBZGFwdE1hLm0wMSArXG4gICAgICAgIFJlZldoaXRlUkdCLlkgKiBNdHhBZGFwdE1hLm0xMSArXG4gICAgICAgIFJlZldoaXRlUkdCLlogKiBNdHhBZGFwdE1hLm0yMTtcbiAgICBjb25zdCBDZCA9XG4gICAgICAgIFJlZldoaXRlUkdCLlggKiBNdHhBZGFwdE1hLm0wMiArXG4gICAgICAgIFJlZldoaXRlUkdCLlkgKiBNdHhBZGFwdE1hLm0xMiArXG4gICAgICAgIFJlZldoaXRlUkdCLlogKiBNdHhBZGFwdE1hLm0yMjtcblxuICAgIGNvbnN0IFgxID1cbiAgICAgICAgKHggKiBNdHhBZGFwdE1hLm0wMCArIHkgKiBNdHhBZGFwdE1hLm0xMCArIHogKiBNdHhBZGFwdE1hLm0yMCkgKlxuICAgICAgICAoQWQgLyBBcyk7XG4gICAgY29uc3QgWTEgPVxuICAgICAgICAoeCAqIE10eEFkYXB0TWEubTAxICsgeSAqIE10eEFkYXB0TWEubTExICsgeiAqIE10eEFkYXB0TWEubTIxKSAqXG4gICAgICAgIChCZCAvIEJzKTtcbiAgICBjb25zdCBaMSA9XG4gICAgICAgICh4ICogTXR4QWRhcHRNYS5tMDIgKyB5ICogTXR4QWRhcHRNYS5tMTIgKyB6ICogTXR4QWRhcHRNYS5tMjIpICpcbiAgICAgICAgKENkIC8gQ3MpO1xuXG4gICAgY29uc3QgWDIgPVxuICAgICAgICBYMSAqIE10eEFkYXB0TWFJLm0wMCArIFkxICogTXR4QWRhcHRNYUkubTEwICsgWjEgKiBNdHhBZGFwdE1hSS5tMjA7XG4gICAgY29uc3QgWTIgPVxuICAgICAgICBYMSAqIE10eEFkYXB0TWFJLm0wMSArIFkxICogTXR4QWRhcHRNYUkubTExICsgWjEgKiBNdHhBZGFwdE1hSS5tMjE7XG4gICAgY29uc3QgWjIgPVxuICAgICAgICBYMSAqIE10eEFkYXB0TWFJLm0wMiArIFkxICogTXR4QWRhcHRNYUkubTEyICsgWjEgKiBNdHhBZGFwdE1hSS5tMjI7XG5cbiAgICBjb25zdCByID0gY29tcGFuZChcbiAgICAgICAgWDIgKiBNdHhYWVoyUkdCLm0wMCArIFkyICogTXR4WFlaMlJHQi5tMTAgKyBaMiAqIE10eFhZWjJSR0IubTIwXG4gICAgKTtcbiAgICBjb25zdCBnID0gY29tcGFuZChcbiAgICAgICAgWDIgKiBNdHhYWVoyUkdCLm0wMSArIFkyICogTXR4WFlaMlJHQi5tMTEgKyBaMiAqIE10eFhZWjJSR0IubTIxXG4gICAgKTtcbiAgICBjb25zdCBiID0gY29tcGFuZChcbiAgICAgICAgWDIgKiBNdHhYWVoyUkdCLm0wMiArIFkyICogTXR4WFlaMlJHQi5tMTIgKyBaMiAqIE10eFhZWjJSR0IubTIyXG4gICAgKTtcblxuICAgIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuXG5jb25zdCByZ2IybGFiID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBbciwgZywgYiwgLi4ucmVzdF0gPSB1bnBhY2soYXJncywgJ3JnYicpO1xuICAgIGNvbnN0IFt4LCB5LCB6XSA9IHJnYjJ4eXoociwgZywgYik7XG4gICAgY29uc3QgW0wsIGEsIGJfXSA9IHh5ejJsYWIoeCwgeSwgeik7XG4gICAgcmV0dXJuIFtMLCBhLCBiXywgLi4uKHJlc3QubGVuZ3RoID4gMCAmJiByZXN0WzBdIDwgMSA/IFtyZXN0WzBdXSA6IFtdKV07XG59O1xuXG5mdW5jdGlvbiB4eXoybGFiKHgsIHksIHopIHtcbiAgICBjb25zdCB7IFhuLCBZbiwgWm4sIGtFLCBrSyB9ID0gbGFiQ29uc3RhbnRzO1xuICAgIGNvbnN0IHhyID0geCAvIFhuO1xuICAgIGNvbnN0IHlyID0geSAvIFluO1xuICAgIGNvbnN0IHpyID0geiAvIFpuO1xuXG4gICAgY29uc3QgZnggPSB4ciA+IGtFID8gTWF0aC5wb3coeHIsIDEuMCAvIDMuMCkgOiAoa0sgKiB4ciArIDE2LjApIC8gMTE2LjA7XG4gICAgY29uc3QgZnkgPSB5ciA+IGtFID8gTWF0aC5wb3coeXIsIDEuMCAvIDMuMCkgOiAoa0sgKiB5ciArIDE2LjApIC8gMTE2LjA7XG4gICAgY29uc3QgZnogPSB6ciA+IGtFID8gTWF0aC5wb3coenIsIDEuMCAvIDMuMCkgOiAoa0sgKiB6ciArIDE2LjApIC8gMTE2LjA7XG5cbiAgICByZXR1cm4gWzExNi4wICogZnkgLSAxNi4wLCA1MDAuMCAqIChmeCAtIGZ5KSwgMjAwLjAgKiAoZnkgLSBmeildO1xufVxuXG5mdW5jdGlvbiBnYW1tYUFkanVzdFNSR0IoY29tcGFuZGVkKSB7XG4gICAgY29uc3Qgc2lnbiA9IE1hdGguc2lnbihjb21wYW5kZWQpO1xuICAgIGNvbXBhbmRlZCA9IE1hdGguYWJzKGNvbXBhbmRlZCk7XG4gICAgY29uc3QgbGluZWFyID1cbiAgICAgICAgY29tcGFuZGVkIDw9IDAuMDQwNDVcbiAgICAgICAgICAgID8gY29tcGFuZGVkIC8gMTIuOTJcbiAgICAgICAgICAgIDogTWF0aC5wb3coKGNvbXBhbmRlZCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICAgIHJldHVybiBsaW5lYXIgKiBzaWduO1xufVxuXG5jb25zdCByZ2IyeHl6ID0gKHIsIGcsIGIpID0+IHtcbiAgICAvLyBub3JtYWxpemUgYW5kIGdhbW1hIGFkanVzdFxuICAgIHIgPSBnYW1tYUFkanVzdFNSR0IociAvIDI1NSk7XG4gICAgZyA9IGdhbW1hQWRqdXN0U1JHQihnIC8gMjU1KTtcbiAgICBiID0gZ2FtbWFBZGp1c3RTUkdCKGIgLyAyNTUpO1xuXG4gICAgY29uc3QgeyBNdHhSR0IyWFlaLCBNdHhBZGFwdE1hLCBNdHhBZGFwdE1hSSwgWG4sIFluLCBabiwgQXMsIEJzLCBDcyB9ID1cbiAgICAgICAgbGFiQ29uc3RhbnRzO1xuXG4gICAgbGV0IHggPSByICogTXR4UkdCMlhZWi5tMDAgKyBnICogTXR4UkdCMlhZWi5tMTAgKyBiICogTXR4UkdCMlhZWi5tMjA7XG4gICAgbGV0IHkgPSByICogTXR4UkdCMlhZWi5tMDEgKyBnICogTXR4UkdCMlhZWi5tMTEgKyBiICogTXR4UkdCMlhZWi5tMjE7XG4gICAgbGV0IHogPSByICogTXR4UkdCMlhZWi5tMDIgKyBnICogTXR4UkdCMlhZWi5tMTIgKyBiICogTXR4UkdCMlhZWi5tMjI7XG5cbiAgICBjb25zdCBBZCA9IFhuICogTXR4QWRhcHRNYS5tMDAgKyBZbiAqIE10eEFkYXB0TWEubTEwICsgWm4gKiBNdHhBZGFwdE1hLm0yMDtcbiAgICBjb25zdCBCZCA9IFhuICogTXR4QWRhcHRNYS5tMDEgKyBZbiAqIE10eEFkYXB0TWEubTExICsgWm4gKiBNdHhBZGFwdE1hLm0yMTtcbiAgICBjb25zdCBDZCA9IFhuICogTXR4QWRhcHRNYS5tMDIgKyBZbiAqIE10eEFkYXB0TWEubTEyICsgWm4gKiBNdHhBZGFwdE1hLm0yMjtcblxuICAgIGxldCBYID0geCAqIE10eEFkYXB0TWEubTAwICsgeSAqIE10eEFkYXB0TWEubTEwICsgeiAqIE10eEFkYXB0TWEubTIwO1xuICAgIGxldCBZID0geCAqIE10eEFkYXB0TWEubTAxICsgeSAqIE10eEFkYXB0TWEubTExICsgeiAqIE10eEFkYXB0TWEubTIxO1xuICAgIGxldCBaID0geCAqIE10eEFkYXB0TWEubTAyICsgeSAqIE10eEFkYXB0TWEubTEyICsgeiAqIE10eEFkYXB0TWEubTIyO1xuXG4gICAgWCAqPSBBZCAvIEFzO1xuICAgIFkgKj0gQmQgLyBCcztcbiAgICBaICo9IENkIC8gQ3M7XG5cbiAgICB4ID0gWCAqIE10eEFkYXB0TWFJLm0wMCArIFkgKiBNdHhBZGFwdE1hSS5tMTAgKyBaICogTXR4QWRhcHRNYUkubTIwO1xuICAgIHkgPSBYICogTXR4QWRhcHRNYUkubTAxICsgWSAqIE10eEFkYXB0TWFJLm0xMSArIFogKiBNdHhBZGFwdE1hSS5tMjE7XG4gICAgeiA9IFggKiBNdHhBZGFwdE1hSS5tMDIgKyBZICogTXR4QWRhcHRNYUkubTEyICsgWiAqIE10eEFkYXB0TWFJLm0yMjtcblxuICAgIHJldHVybiBbeCwgeSwgel07XG59O1xuXG5Db2xvci5wcm90b3R5cGUubGFiID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IybGFiKHRoaXMuX3JnYik7XG59O1xuXG5jb25zdCBsYWIkMSA9ICguLi5hcmdzKSA9PiBuZXcgQ29sb3IoLi4uYXJncywgJ2xhYicpO1xuT2JqZWN0LmFzc2lnbihjaHJvbWEsIHsgbGFiOiBsYWIkMSwgZ2V0TGFiV2hpdGVQb2ludCwgc2V0TGFiV2hpdGVQb2ludCB9KTtcblxuaW5wdXQuZm9ybWF0LmxhYiA9IGxhYjJyZ2I7XG5cbmlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMixcbiAgICB0ZXN0OiAoLi4uYXJncykgPT4ge1xuICAgICAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdsYWInKTtcbiAgICAgICAgaWYgKHR5cGUoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiAnbGFiJztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5Db2xvci5wcm90b3R5cGUuZGFya2VuID0gZnVuY3Rpb24gKGFtb3VudCA9IDEpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbGFiID0gbWUubGFiKCk7XG4gICAgbGFiWzBdIC09IGxhYkNvbnN0YW50cy5LbiAqIGFtb3VudDtcbiAgICByZXR1cm4gbmV3IENvbG9yKGxhYiwgJ2xhYicpLmFscGhhKG1lLmFscGhhKCksIHRydWUpO1xufTtcblxuQ29sb3IucHJvdG90eXBlLmJyaWdodGVuID0gZnVuY3Rpb24gKGFtb3VudCA9IDEpIHtcbiAgICByZXR1cm4gdGhpcy5kYXJrZW4oLWFtb3VudCk7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuZGFya2VyID0gQ29sb3IucHJvdG90eXBlLmRhcmtlbjtcbkNvbG9yLnByb3RvdHlwZS5icmlnaHRlciA9IENvbG9yLnByb3RvdHlwZS5icmlnaHRlbjtcblxuQ29sb3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChtYykge1xuICAgIGNvbnN0IFttb2RlLCBjaGFubmVsXSA9IG1jLnNwbGl0KCcuJyk7XG4gICAgY29uc3Qgc3JjID0gdGhpc1ttb2RlXSgpO1xuICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgIGNvbnN0IGkgPSBtb2RlLmluZGV4T2YoY2hhbm5lbCkgLSAobW9kZS5zdWJzdHIoMCwgMikgPT09ICdvaycgPyAyIDogMCk7XG4gICAgICAgIGlmIChpID4gLTEpIHJldHVybiBzcmNbaV07XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBjaGFubmVsICR7Y2hhbm5lbH0gaW4gbW9kZSAke21vZGV9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG59O1xuXG5jb25zdCB7IHBvdzogcG93JDYgfSA9IE1hdGg7XG5cbmNvbnN0IEVQUyA9IDFlLTc7XG5jb25zdCBNQVhfSVRFUiA9IDIwO1xuXG5Db2xvci5wcm90b3R5cGUubHVtaW5hbmNlID0gZnVuY3Rpb24gKGx1bSwgbW9kZSA9ICdyZ2InKSB7XG4gICAgaWYgKGx1bSAhPT0gdW5kZWZpbmVkICYmIHR5cGUobHVtKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGx1bSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIHB1cmUgYmxhY2tcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IoWzAsIDAsIDAsIHRoaXMuX3JnYlszXV0sICdyZ2InKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobHVtID09PSAxKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gcHVyZSB3aGl0ZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihbMjU1LCAyNTUsIDI1NSwgdGhpcy5fcmdiWzNdXSwgJ3JnYicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXB1dGUgbmV3IGNvbG9yIHVzaW5nLi4uXG4gICAgICAgIGxldCBjdXJfbHVtID0gdGhpcy5sdW1pbmFuY2UoKTtcbiAgICAgICAgbGV0IG1heF9pdGVyID0gTUFYX0lURVI7XG5cbiAgICAgICAgY29uc3QgdGVzdCA9IChsb3csIGhpZ2gpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IGxvdy5pbnRlcnBvbGF0ZShoaWdoLCAwLjUsIG1vZGUpO1xuICAgICAgICAgICAgY29uc3QgbG0gPSBtaWQubHVtaW5hbmNlKCk7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobHVtIC0gbG0pIDwgRVBTIHx8ICFtYXhfaXRlci0tKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xvc2UgZW5vdWdoXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsbSA+IGx1bSA/IHRlc3QobG93LCBtaWQpIDogdGVzdChtaWQsIGhpZ2gpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJnYiA9IChcbiAgICAgICAgICAgIGN1cl9sdW0gPiBsdW1cbiAgICAgICAgICAgICAgICA/IHRlc3QobmV3IENvbG9yKFswLCAwLCAwXSksIHRoaXMpXG4gICAgICAgICAgICAgICAgOiB0ZXN0KHRoaXMsIG5ldyBDb2xvcihbMjU1LCAyNTUsIDI1NV0pKVxuICAgICAgICApLnJnYigpO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yKFsuLi5yZ2IsIHRoaXMuX3JnYlszXV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmdiMmx1bWluYW5jZSguLi50aGlzLl9yZ2Iuc2xpY2UoMCwgMykpO1xufTtcblxuY29uc3QgcmdiMmx1bWluYW5jZSA9IChyLCBnLCBiKSA9PiB7XG4gICAgLy8gcmVsYXRpdmUgbHVtaW5hbmNlXG4gICAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICByID0gbHVtaW5hbmNlX3gocik7XG4gICAgZyA9IGx1bWluYW5jZV94KGcpO1xuICAgIGIgPSBsdW1pbmFuY2VfeChiKTtcbiAgICByZXR1cm4gMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiO1xufTtcblxuY29uc3QgbHVtaW5hbmNlX3ggPSAoeCkgPT4ge1xuICAgIHggLz0gMjU1O1xuICAgIHJldHVybiB4IDw9IDAuMDM5MjggPyB4IC8gMTIuOTIgOiBwb3ckNigoeCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xufTtcblxudmFyIGluZGV4ID0ge307XG5cbnZhciBtaXggPSAoY29sMSwgY29sMiwgZiA9IDAuNSwgLi4ucmVzdCkgPT4ge1xuICAgIGxldCBtb2RlID0gcmVzdFswXSB8fCAnbHJnYic7XG4gICAgaWYgKCFpbmRleFttb2RlXSAmJiAhcmVzdC5sZW5ndGgpIHtcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBmaXJzdCBzdXBwb3J0ZWQgbW9kZVxuICAgICAgICBtb2RlID0gT2JqZWN0LmtleXMoaW5kZXgpWzBdO1xuICAgIH1cbiAgICBpZiAoIWluZGV4W21vZGVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW50ZXJwb2xhdGlvbiBtb2RlICR7bW9kZX0gaXMgbm90IGRlZmluZWRgKTtcbiAgICB9XG4gICAgaWYgKHR5cGUoY29sMSkgIT09ICdvYmplY3QnKSBjb2wxID0gbmV3IENvbG9yKGNvbDEpO1xuICAgIGlmICh0eXBlKGNvbDIpICE9PSAnb2JqZWN0JykgY29sMiA9IG5ldyBDb2xvcihjb2wyKTtcbiAgICByZXR1cm4gaW5kZXhbbW9kZV0oY29sMSwgY29sMiwgZikuYWxwaGEoXG4gICAgICAgIGNvbDEuYWxwaGEoKSArIGYgKiAoY29sMi5hbHBoYSgpIC0gY29sMS5hbHBoYSgpKVxuICAgICk7XG59O1xuXG5Db2xvci5wcm90b3R5cGUubWl4ID0gQ29sb3IucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24gKFxuICAgIGNvbDIsXG4gICAgZiA9IDAuNSxcbiAgICAuLi5yZXN0XG4pIHtcbiAgICByZXR1cm4gbWl4KHRoaXMsIGNvbDIsIGYsIC4uLnJlc3QpO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnByZW11bHRpcGx5ID0gZnVuY3Rpb24gKG11dGF0ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIGNvbnN0IGEgPSByZ2JbM107XG4gICAgaWYgKG11dGF0ZSkge1xuICAgICAgICB0aGlzLl9yZ2IgPSBbcmdiWzBdICogYSwgcmdiWzFdICogYSwgcmdiWzJdICogYSwgYV07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IoW3JnYlswXSAqIGEsIHJnYlsxXSAqIGEsIHJnYlsyXSAqIGEsIGFdLCAncmdiJyk7XG4gICAgfVxufTtcblxuY29uc3QgeyBzaW46IHNpbiQzLCBjb3M6IGNvcyQ0IH0gPSBNYXRoO1xuXG5jb25zdCBsY2gybGFiID0gKC4uLmFyZ3MpID0+IHtcbiAgICAvKlxuICAgIENvbnZlcnQgZnJvbSBhIHF1YWxpdGF0aXZlIHBhcmFtZXRlciBoIGFuZCBhIHF1YW50aXRhdGl2ZSBwYXJhbWV0ZXIgbCB0byBhIDI0LWJpdCBwaXhlbC5cbiAgICBUaGVzZSBmb3JtdWxhcyB3ZXJlIGludmVudGVkIGJ5IERhdmlkIERhbHJ5bXBsZSB0byBvYnRhaW4gbWF4aW11bSBjb250cmFzdCB3aXRob3V0IGdvaW5nXG4gICAgb3V0IG9mIGdhbXV0IGlmIHRoZSBwYXJhbWV0ZXJzIGFyZSBpbiB0aGUgcmFuZ2UgMC0xLlxuXG4gICAgQSBzYXR1cmF0aW9uIG11bHRpcGxpZXIgd2FzIGFkZGVkIGJ5IEdyZWdvciBBaXNjaFxuICAgICovXG4gICAgbGV0IFtsLCBjLCBoXSA9IHVucGFjayhhcmdzLCAnbGNoJyk7XG4gICAgaWYgKGlzTmFOKGgpKSBoID0gMDtcbiAgICBoID0gaCAqIERFRzJSQUQ7XG4gICAgcmV0dXJuIFtsLCBjb3MkNChoKSAqIGMsIHNpbiQzKGgpICogY107XG59O1xuXG5jb25zdCBsY2gycmdiID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdsY2gnKTtcbiAgICBjb25zdCBbbCwgYywgaF0gPSBhcmdzO1xuICAgIGNvbnN0IFtMLCBhLCBiX10gPSBsY2gybGFiKGwsIGMsIGgpO1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IGxhYjJyZ2IoTCwgYSwgYl8pO1xuICAgIHJldHVybiBbciwgZywgYiwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xufTtcblxuY29uc3QgaGNsMnJnYiA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgaGNsID0gdW5wYWNrKGFyZ3MsICdoY2wnKS5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIGxjaDJyZ2IoLi4uaGNsKTtcbn07XG5cbmNvbnN0IHsgc3FydDogc3FydCQ0LCBhdGFuMjogYXRhbjIkMiwgcm91bmQ6IHJvdW5kJDQgfSA9IE1hdGg7XG5cbmNvbnN0IGxhYjJsY2ggPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IFtsLCBhLCBiXSA9IHVucGFjayhhcmdzLCAnbGFiJyk7XG4gICAgY29uc3QgYyA9IHNxcnQkNChhICogYSArIGIgKiBiKTtcbiAgICBsZXQgaCA9IChhdGFuMiQyKGIsIGEpICogUkFEMkRFRyArIDM2MCkgJSAzNjA7XG4gICAgaWYgKHJvdW5kJDQoYyAqIDEwMDAwKSA9PT0gMCkgaCA9IE51bWJlci5OYU47XG4gICAgcmV0dXJuIFtsLCBjLCBoXTtcbn07XG5cbmNvbnN0IHJnYjJsY2ggPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IFtyLCBnLCBiLCAuLi5yZXN0XSA9IHVucGFjayhhcmdzLCAncmdiJyk7XG4gICAgY29uc3QgW2wsIGEsIGJfXSA9IHJnYjJsYWIociwgZywgYik7XG4gICAgY29uc3QgW0wsIGMsIGhdID0gbGFiMmxjaChsLCBhLCBiXyk7XG4gICAgcmV0dXJuIFtMLCBjLCBoLCAuLi4ocmVzdC5sZW5ndGggPiAwICYmIHJlc3RbMF0gPCAxID8gW3Jlc3RbMF1dIDogW10pXTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5sY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJnYjJsY2godGhpcy5fcmdiKTtcbn07XG5Db2xvci5wcm90b3R5cGUuaGNsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IybGNoKHRoaXMuX3JnYikucmV2ZXJzZSgpO1xufTtcblxuY29uc3QgbGNoJDEgPSAoLi4uYXJncykgPT4gbmV3IENvbG9yKC4uLmFyZ3MsICdsY2gnKTtcbmNvbnN0IGhjbCA9ICguLi5hcmdzKSA9PiBuZXcgQ29sb3IoLi4uYXJncywgJ2hjbCcpO1xuXG5PYmplY3QuYXNzaWduKGNocm9tYSwgeyBsY2g6IGxjaCQxLCBoY2wgfSk7XG5cbmlucHV0LmZvcm1hdC5sY2ggPSBsY2gycmdiO1xuaW5wdXQuZm9ybWF0LmhjbCA9IGhjbDJyZ2I7XG5bJ2xjaCcsICdoY2wnXS5mb3JFYWNoKChtKSA9PlxuICAgIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDIsXG4gICAgICAgIHRlc3Q6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrKGFyZ3MsIG0pO1xuICAgICAgICAgICAgaWYgKHR5cGUoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG4pO1xuXG5Db2xvci5wcm90b3R5cGUuc2F0dXJhdGUgPSBmdW5jdGlvbiAoYW1vdW50ID0gMSkge1xuICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICBjb25zdCBsY2ggPSBtZS5sY2goKTtcbiAgICBsY2hbMV0gKz0gbGFiQ29uc3RhbnRzLktuICogYW1vdW50O1xuICAgIGlmIChsY2hbMV0gPCAwKSBsY2hbMV0gPSAwO1xuICAgIHJldHVybiBuZXcgQ29sb3IobGNoLCAnbGNoJykuYWxwaGEobWUuYWxwaGEoKSwgdHJ1ZSk7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuZGVzYXR1cmF0ZSA9IGZ1bmN0aW9uIChhbW91bnQgPSAxKSB7XG4gICAgcmV0dXJuIHRoaXMuc2F0dXJhdGUoLWFtb3VudCk7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG1jLCB2YWx1ZSwgbXV0YXRlID0gZmFsc2UpIHtcbiAgICBjb25zdCBbbW9kZSwgY2hhbm5lbF0gPSBtYy5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHNyYyA9IHRoaXNbbW9kZV0oKTtcbiAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICBjb25zdCBpID0gbW9kZS5pbmRleE9mKGNoYW5uZWwpIC0gKG1vZGUuc3Vic3RyKDAsIDIpID09PSAnb2snID8gMiA6IDApO1xuICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAodHlwZSh2YWx1ZSkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tpXSArPSArdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNbaV0gKz0gK3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjW2ldICo9ICt2YWx1ZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNbaV0gLz0gK3ZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjW2ldID0gK3ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSh2YWx1ZSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgc3JjW2ldID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdmFsdWUgZm9yIENvbG9yLnNldGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3V0ID0gbmV3IENvbG9yKHNyYywgbW9kZSk7XG4gICAgICAgICAgICBpZiAobXV0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmdiID0gb3V0Ll9yZ2I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBjaGFubmVsICR7Y2hhbm5lbH0gaW4gbW9kZSAke21vZGV9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG59O1xuXG5Db2xvci5wcm90b3R5cGUudGludCA9IGZ1bmN0aW9uIChmID0gMC41LCAuLi5yZXN0KSB7XG4gICAgcmV0dXJuIG1peCh0aGlzLCAnd2hpdGUnLCBmLCAuLi5yZXN0KTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zaGFkZSA9IGZ1bmN0aW9uIChmID0gMC41LCAuLi5yZXN0KSB7XG4gICAgcmV0dXJuIG1peCh0aGlzLCAnYmxhY2snLCBmLCAuLi5yZXN0KTtcbn07XG5cbmNvbnN0IHJnYiQxID0gKGNvbDEsIGNvbDIsIGYpID0+IHtcbiAgICBjb25zdCB4eXowID0gY29sMS5fcmdiO1xuICAgIGNvbnN0IHh5ejEgPSBjb2wyLl9yZ2I7XG4gICAgcmV0dXJuIG5ldyBDb2xvcihcbiAgICAgICAgeHl6MFswXSArIGYgKiAoeHl6MVswXSAtIHh5ejBbMF0pLFxuICAgICAgICB4eXowWzFdICsgZiAqICh4eXoxWzFdIC0geHl6MFsxXSksXG4gICAgICAgIHh5ejBbMl0gKyBmICogKHh5ejFbMl0gLSB4eXowWzJdKSxcbiAgICAgICAgJ3JnYidcbiAgICApO1xufTtcblxuLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5pbmRleC5yZ2IgPSByZ2IkMTtcblxuY29uc3QgeyBzcXJ0OiBzcXJ0JDMsIHBvdzogcG93JDUgfSA9IE1hdGg7XG5cbmNvbnN0IGxyZ2IgPSAoY29sMSwgY29sMiwgZikgPT4ge1xuICAgIGNvbnN0IFt4MSwgeTEsIHoxXSA9IGNvbDEuX3JnYjtcbiAgICBjb25zdCBbeDIsIHkyLCB6Ml0gPSBjb2wyLl9yZ2I7XG4gICAgcmV0dXJuIG5ldyBDb2xvcihcbiAgICAgICAgc3FydCQzKHBvdyQ1KHgxLCAyKSAqICgxIC0gZikgKyBwb3ckNSh4MiwgMikgKiBmKSxcbiAgICAgICAgc3FydCQzKHBvdyQ1KHkxLCAyKSAqICgxIC0gZikgKyBwb3ckNSh5MiwgMikgKiBmKSxcbiAgICAgICAgc3FydCQzKHBvdyQ1KHoxLCAyKSAqICgxIC0gZikgKyBwb3ckNSh6MiwgMikgKiBmKSxcbiAgICAgICAgJ3JnYidcbiAgICApO1xufTtcblxuLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5pbmRleC5scmdiID0gbHJnYjtcblxuY29uc3QgbGFiID0gKGNvbDEsIGNvbDIsIGYpID0+IHtcbiAgICBjb25zdCB4eXowID0gY29sMS5sYWIoKTtcbiAgICBjb25zdCB4eXoxID0gY29sMi5sYWIoKTtcbiAgICByZXR1cm4gbmV3IENvbG9yKFxuICAgICAgICB4eXowWzBdICsgZiAqICh4eXoxWzBdIC0geHl6MFswXSksXG4gICAgICAgIHh5ejBbMV0gKyBmICogKHh5ejFbMV0gLSB4eXowWzFdKSxcbiAgICAgICAgeHl6MFsyXSArIGYgKiAoeHl6MVsyXSAtIHh5ejBbMl0pLFxuICAgICAgICAnbGFiJ1xuICAgICk7XG59O1xuXG4vLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbmluZGV4LmxhYiA9IGxhYjtcblxudmFyIGludGVycG9sYXRlX2hzeCA9IChjb2wxLCBjb2wyLCBmLCBtKSA9PiB7XG4gICAgbGV0IHh5ejAsIHh5ejE7XG4gICAgaWYgKG0gPT09ICdoc2wnKSB7XG4gICAgICAgIHh5ejAgPSBjb2wxLmhzbCgpO1xuICAgICAgICB4eXoxID0gY29sMi5oc2woKTtcbiAgICB9IGVsc2UgaWYgKG0gPT09ICdoc3YnKSB7XG4gICAgICAgIHh5ejAgPSBjb2wxLmhzdigpO1xuICAgICAgICB4eXoxID0gY29sMi5oc3YoKTtcbiAgICB9IGVsc2UgaWYgKG0gPT09ICdoY2cnKSB7XG4gICAgICAgIHh5ejAgPSBjb2wxLmhjZygpO1xuICAgICAgICB4eXoxID0gY29sMi5oY2coKTtcbiAgICB9IGVsc2UgaWYgKG0gPT09ICdoc2knKSB7XG4gICAgICAgIHh5ejAgPSBjb2wxLmhzaSgpO1xuICAgICAgICB4eXoxID0gY29sMi5oc2koKTtcbiAgICB9IGVsc2UgaWYgKG0gPT09ICdsY2gnIHx8IG0gPT09ICdoY2wnKSB7XG4gICAgICAgIG0gPSAnaGNsJztcbiAgICAgICAgeHl6MCA9IGNvbDEuaGNsKCk7XG4gICAgICAgIHh5ejEgPSBjb2wyLmhjbCgpO1xuICAgIH0gZWxzZSBpZiAobSA9PT0gJ29rbGNoJykge1xuICAgICAgICB4eXowID0gY29sMS5va2xjaCgpLnJldmVyc2UoKTtcbiAgICAgICAgeHl6MSA9IGNvbDIub2tsY2goKS5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgbGV0IGh1ZTAsIGh1ZTEsIHNhdDAsIHNhdDEsIGxidjAsIGxidjE7XG4gICAgaWYgKG0uc3Vic3RyKDAsIDEpID09PSAnaCcgfHwgbSA9PT0gJ29rbGNoJykge1xuICAgICAgICBbaHVlMCwgc2F0MCwgbGJ2MF0gPSB4eXowO1xuICAgICAgICBbaHVlMSwgc2F0MSwgbGJ2MV0gPSB4eXoxO1xuICAgIH1cblxuICAgIGxldCBzYXQsIGh1ZSwgbGJ2LCBkaDtcblxuICAgIGlmICghaXNOYU4oaHVlMCkgJiYgIWlzTmFOKGh1ZTEpKSB7XG4gICAgICAgIC8vIGJvdGggY29sb3JzIGhhdmUgaHVlXG4gICAgICAgIGlmIChodWUxID4gaHVlMCAmJiBodWUxIC0gaHVlMCA+IDE4MCkge1xuICAgICAgICAgICAgZGggPSBodWUxIC0gKGh1ZTAgKyAzNjApO1xuICAgICAgICB9IGVsc2UgaWYgKGh1ZTEgPCBodWUwICYmIGh1ZTAgLSBodWUxID4gMTgwKSB7XG4gICAgICAgICAgICBkaCA9IGh1ZTEgKyAzNjAgLSBodWUwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGggPSBodWUxIC0gaHVlMDtcbiAgICAgICAgfVxuICAgICAgICBodWUgPSBodWUwICsgZiAqIGRoO1xuICAgIH0gZWxzZSBpZiAoIWlzTmFOKGh1ZTApKSB7XG4gICAgICAgIGh1ZSA9IGh1ZTA7XG4gICAgICAgIGlmICgobGJ2MSA9PSAxIHx8IGxidjEgPT0gMCkgJiYgbSAhPSAnaHN2Jykgc2F0ID0gc2F0MDtcbiAgICB9IGVsc2UgaWYgKCFpc05hTihodWUxKSkge1xuICAgICAgICBodWUgPSBodWUxO1xuICAgICAgICBpZiAoKGxidjAgPT0gMSB8fCBsYnYwID09IDApICYmIG0gIT0gJ2hzdicpIHNhdCA9IHNhdDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaHVlID0gTnVtYmVyLk5hTjtcbiAgICB9XG5cbiAgICBpZiAoc2F0ID09PSB1bmRlZmluZWQpIHNhdCA9IHNhdDAgKyBmICogKHNhdDEgLSBzYXQwKTtcbiAgICBsYnYgPSBsYnYwICsgZiAqIChsYnYxIC0gbGJ2MCk7XG4gICAgcmV0dXJuIG0gPT09ICdva2xjaCdcbiAgICAgICAgPyBuZXcgQ29sb3IoW2xidiwgc2F0LCBodWVdLCBtKVxuICAgICAgICA6IG5ldyBDb2xvcihbaHVlLCBzYXQsIGxidl0sIG0pO1xufTtcblxuY29uc3QgbGNoID0gKGNvbDEsIGNvbDIsIGYpID0+IHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGVfaHN4KGNvbDEsIGNvbDIsIGYsICdsY2gnKTtcbn07XG5cbi8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuaW5kZXgubGNoID0gbGNoO1xuaW5kZXguaGNsID0gbGNoO1xuXG5jb25zdCBudW0ycmdiID0gKG51bSkgPT4ge1xuICAgIGlmICh0eXBlKG51bSkgPT0gJ251bWJlcicgJiYgbnVtID49IDAgJiYgbnVtIDw9IDB4ZmZmZmZmKSB7XG4gICAgICAgIGNvbnN0IHIgPSBudW0gPj4gMTY7XG4gICAgICAgIGNvbnN0IGcgPSAobnVtID4+IDgpICYgMHhmZjtcbiAgICAgICAgY29uc3QgYiA9IG51bSAmIDB4ZmY7XG4gICAgICAgIHJldHVybiBbciwgZywgYiwgMV07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBudW0gY29sb3I6ICcgKyBudW0pO1xufTtcblxuY29uc3QgcmdiMm51bSA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gdW5wYWNrKGFyZ3MsICdyZ2InKTtcbiAgICByZXR1cm4gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiO1xufTtcblxuQ29sb3IucHJvdG90eXBlLm51bSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMm51bSh0aGlzLl9yZ2IpO1xufTtcblxuY29uc3QgbnVtJDEgPSAoLi4uYXJncykgPT4gbmV3IENvbG9yKC4uLmFyZ3MsICdudW0nKTtcblxuT2JqZWN0LmFzc2lnbihjaHJvbWEsIHsgbnVtOiBudW0kMSB9KTtcblxuaW5wdXQuZm9ybWF0Lm51bSA9IG51bTJyZ2I7XG5cbmlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogNSxcbiAgICB0ZXN0OiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBhcmdzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgdHlwZShhcmdzWzBdKSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIGFyZ3NbMF0gPj0gMCAmJlxuICAgICAgICAgICAgYXJnc1swXSA8PSAweGZmZmZmZlxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAnbnVtJztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb25zdCBudW0gPSAoY29sMSwgY29sMiwgZikgPT4ge1xuICAgIGNvbnN0IGMxID0gY29sMS5udW0oKTtcbiAgICBjb25zdCBjMiA9IGNvbDIubnVtKCk7XG4gICAgcmV0dXJuIG5ldyBDb2xvcihjMSArIGYgKiAoYzIgLSBjMSksICdudW0nKTtcbn07XG5cbi8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuaW5kZXgubnVtID0gbnVtO1xuXG5jb25zdCB7IGZsb29yOiBmbG9vciQzIH0gPSBNYXRoO1xuXG4vKlxuICogdGhpcyBpcyBiYXNpY2FsbHkganVzdCBIU1Ygd2l0aCBzb21lIG1pbm9yIHR3ZWFrc1xuICpcbiAqIGh1ZS4uIFswLi4zNjBdXG4gKiBjaHJvbWEgLi4gWzAuLjFdXG4gKiBncmF5bmVzcyAuLiBbMC4uMV1cbiAqL1xuXG5jb25zdCBoY2cycmdiID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdoY2cnKTtcbiAgICBsZXQgW2gsIGMsIF9nXSA9IGFyZ3M7XG4gICAgbGV0IHIsIGcsIGI7XG4gICAgX2cgPSBfZyAqIDI1NTtcbiAgICBjb25zdCBfYyA9IGMgKiAyNTU7XG4gICAgaWYgKGMgPT09IDApIHtcbiAgICAgICAgciA9IGcgPSBiID0gX2c7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGggPT09IDM2MCkgaCA9IDA7XG4gICAgICAgIGlmIChoID4gMzYwKSBoIC09IDM2MDtcbiAgICAgICAgaWYgKGggPCAwKSBoICs9IDM2MDtcbiAgICAgICAgaCAvPSA2MDtcbiAgICAgICAgY29uc3QgaSA9IGZsb29yJDMoaCk7XG4gICAgICAgIGNvbnN0IGYgPSBoIC0gaTtcbiAgICAgICAgY29uc3QgcCA9IF9nICogKDEgLSBjKTtcbiAgICAgICAgY29uc3QgcSA9IHAgKyBfYyAqICgxIC0gZik7XG4gICAgICAgIGNvbnN0IHQgPSBwICsgX2MgKiBmO1xuICAgICAgICBjb25zdCB2ID0gcCArIF9jO1xuICAgICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBbciwgZywgYl0gPSBbdiwgdCwgcF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgW3IsIGcsIGJdID0gW3EsIHYsIHBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIFtyLCBnLCBiXSA9IFtwLCB2LCB0XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBbciwgZywgYl0gPSBbcCwgcSwgdl07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgW3IsIGcsIGJdID0gW3QsIHAsIHZdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIFtyLCBnLCBiXSA9IFt2LCBwLCBxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3IsIGcsIGIsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbn07XG5cbmNvbnN0IHJnYjJoY2cgPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHVucGFjayhhcmdzLCAncmdiJyk7XG4gICAgY29uc3QgbWluUmdiID0gbWluJDMociwgZywgYik7XG4gICAgY29uc3QgbWF4UmdiID0gbWF4JDMociwgZywgYik7XG4gICAgY29uc3QgZGVsdGEgPSBtYXhSZ2IgLSBtaW5SZ2I7XG4gICAgY29uc3QgYyA9IChkZWx0YSAqIDEwMCkgLyAyNTU7XG4gICAgY29uc3QgX2cgPSAobWluUmdiIC8gKDI1NSAtIGRlbHRhKSkgKiAxMDA7XG4gICAgbGV0IGg7XG4gICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgIGggPSBOdW1iZXIuTmFOO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyID09PSBtYXhSZ2IpIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgICAgIGlmIChnID09PSBtYXhSZ2IpIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgICAgICBpZiAoYiA9PT0gbWF4UmdiKSBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICAgICAgaCAqPSA2MDtcbiAgICAgICAgaWYgKGggPCAwKSBoICs9IDM2MDtcbiAgICB9XG4gICAgcmV0dXJuIFtoLCBjLCBfZ107XG59O1xuXG5Db2xvci5wcm90b3R5cGUuaGNnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IyaGNnKHRoaXMuX3JnYik7XG59O1xuXG5jb25zdCBoY2ckMSA9ICguLi5hcmdzKSA9PiBuZXcgQ29sb3IoLi4uYXJncywgJ2hjZycpO1xuY2hyb21hLmhjZyA9IGhjZyQxO1xuXG5pbnB1dC5mb3JtYXQuaGNnID0gaGNnMnJnYjtcblxuaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICBwOiAxLFxuICAgIHRlc3Q6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2hjZycpO1xuICAgICAgICBpZiAodHlwZShhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuICdoY2cnO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmNvbnN0IGhjZyA9IChjb2wxLCBjb2wyLCBmKSA9PiB7XG4gICAgcmV0dXJuIGludGVycG9sYXRlX2hzeChjb2wxLCBjb2wyLCBmLCAnaGNnJyk7XG59O1xuXG4vLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbmluZGV4LmhjZyA9IGhjZztcblxuY29uc3QgeyBjb3M6IGNvcyQzIH0gPSBNYXRoO1xuXG4vKlxuICogaHVlIFswLi4zNjBdXG4gKiBzYXR1cmF0aW9uIFswLi4xXVxuICogaW50ZW5zaXR5IFswLi4xXVxuICovXG5jb25zdCBoc2kycmdiID0gKC4uLmFyZ3MpID0+IHtcbiAgICAvKlxuICAgIGJvcnJvd2VkIGZyb20gaGVyZTpcbiAgICBodHRwOi8vaHVtbWVyLnN0YW5mb3JkLmVkdS9tdXNlaW5mby9kb2MvZXhhbXBsZXMvaHVtZHJ1bS9rZXlzY2FwZTIvaHNpMnJnYi5jcHBcbiAgICAqL1xuICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2hzaScpO1xuICAgIGxldCBbaCwgcywgaV0gPSBhcmdzO1xuICAgIGxldCByLCBnLCBiO1xuXG4gICAgaWYgKGlzTmFOKGgpKSBoID0gMDtcbiAgICBpZiAoaXNOYU4ocykpIHMgPSAwO1xuICAgIC8vIG5vcm1hbGl6ZSBodWVcbiAgICBpZiAoaCA+IDM2MCkgaCAtPSAzNjA7XG4gICAgaWYgKGggPCAwKSBoICs9IDM2MDtcbiAgICBoIC89IDM2MDtcbiAgICBpZiAoaCA8IDEgLyAzKSB7XG4gICAgICAgIGIgPSAoMSAtIHMpIC8gMztcbiAgICAgICAgciA9ICgxICsgKHMgKiBjb3MkMyhUV09QSSAqIGgpKSAvIGNvcyQzKFBJVEhJUkQgLSBUV09QSSAqIGgpKSAvIDM7XG4gICAgICAgIGcgPSAxIC0gKGIgKyByKTtcbiAgICB9IGVsc2UgaWYgKGggPCAyIC8gMykge1xuICAgICAgICBoIC09IDEgLyAzO1xuICAgICAgICByID0gKDEgLSBzKSAvIDM7XG4gICAgICAgIGcgPSAoMSArIChzICogY29zJDMoVFdPUEkgKiBoKSkgLyBjb3MkMyhQSVRISVJEIC0gVFdPUEkgKiBoKSkgLyAzO1xuICAgICAgICBiID0gMSAtIChyICsgZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaCAtPSAyIC8gMztcbiAgICAgICAgZyA9ICgxIC0gcykgLyAzO1xuICAgICAgICBiID0gKDEgKyAocyAqIGNvcyQzKFRXT1BJICogaCkpIC8gY29zJDMoUElUSElSRCAtIFRXT1BJICogaCkpIC8gMztcbiAgICAgICAgciA9IDEgLSAoZyArIGIpO1xuICAgIH1cbiAgICByID0gbGltaXQoaSAqIHIgKiAzKTtcbiAgICBnID0gbGltaXQoaSAqIGcgKiAzKTtcbiAgICBiID0gbGltaXQoaSAqIGIgKiAzKTtcbiAgICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTUsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbn07XG5cbmNvbnN0IHsgbWluOiBtaW4kMiwgc3FydDogc3FydCQyLCBhY29zIH0gPSBNYXRoO1xuXG5jb25zdCByZ2IyaHNpID0gKC4uLmFyZ3MpID0+IHtcbiAgICAvKlxuICAgIGJvcnJvd2VkIGZyb20gaGVyZTpcbiAgICBodHRwOi8vaHVtbWVyLnN0YW5mb3JkLmVkdS9tdXNlaW5mby9kb2MvZXhhbXBsZXMvaHVtZHJ1bS9rZXlzY2FwZTIvcmdiMmhzaS5jcHBcbiAgICAqL1xuICAgIGxldCBbciwgZywgYl0gPSB1bnBhY2soYXJncywgJ3JnYicpO1xuICAgIHIgLz0gMjU1O1xuICAgIGcgLz0gMjU1O1xuICAgIGIgLz0gMjU1O1xuICAgIGxldCBoO1xuICAgIGNvbnN0IG1pbl8gPSBtaW4kMihyLCBnLCBiKTtcbiAgICBjb25zdCBpID0gKHIgKyBnICsgYikgLyAzO1xuICAgIGNvbnN0IHMgPSBpID4gMCA/IDEgLSBtaW5fIC8gaSA6IDA7XG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgaCA9IE5hTjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBoID0gKHIgLSBnICsgKHIgLSBiKSkgLyAyO1xuICAgICAgICBoIC89IHNxcnQkMigociAtIGcpICogKHIgLSBnKSArIChyIC0gYikgKiAoZyAtIGIpKTtcbiAgICAgICAgaCA9IGFjb3MoaCk7XG4gICAgICAgIGlmIChiID4gZykge1xuICAgICAgICAgICAgaCA9IFRXT1BJIC0gaDtcbiAgICAgICAgfVxuICAgICAgICBoIC89IFRXT1BJO1xuICAgIH1cbiAgICByZXR1cm4gW2ggKiAzNjAsIHMsIGldO1xufTtcblxuQ29sb3IucHJvdG90eXBlLmhzaSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmhzaSh0aGlzLl9yZ2IpO1xufTtcblxuY29uc3QgaHNpJDEgPSAoLi4uYXJncykgPT4gbmV3IENvbG9yKC4uLmFyZ3MsICdoc2knKTtcbmNocm9tYS5oc2kgPSBoc2kkMTtcblxuaW5wdXQuZm9ybWF0LmhzaSA9IGhzaTJyZ2I7XG5cbmlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMixcbiAgICB0ZXN0OiAoLi4uYXJncykgPT4ge1xuICAgICAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdoc2knKTtcbiAgICAgICAgaWYgKHR5cGUoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiAnaHNpJztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb25zdCBoc2kgPSAoY29sMSwgY29sMiwgZikgPT4ge1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZV9oc3goY29sMSwgY29sMiwgZiwgJ2hzaScpO1xufTtcblxuLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5pbmRleC5oc2kgPSBoc2k7XG5cbmNvbnN0IGhzbDJyZ2IgPSAoLi4uYXJncykgPT4ge1xuICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2hzbCcpO1xuICAgIGNvbnN0IFtoLCBzLCBsXSA9IGFyZ3M7XG4gICAgbGV0IHIsIGcsIGI7XG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgciA9IGcgPSBiID0gbCAqIDI1NTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0MyA9IFswLCAwLCAwXTtcbiAgICAgICAgY29uc3QgYyA9IFswLCAwLCAwXTtcbiAgICAgICAgY29uc3QgdDIgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICBjb25zdCB0MSA9IDIgKiBsIC0gdDI7XG4gICAgICAgIGNvbnN0IGhfID0gaCAvIDM2MDtcbiAgICAgICAgdDNbMF0gPSBoXyArIDEgLyAzO1xuICAgICAgICB0M1sxXSA9IGhfO1xuICAgICAgICB0M1syXSA9IGhfIC0gMSAvIDM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodDNbaV0gPCAwKSB0M1tpXSArPSAxO1xuICAgICAgICAgICAgaWYgKHQzW2ldID4gMSkgdDNbaV0gLT0gMTtcbiAgICAgICAgICAgIGlmICg2ICogdDNbaV0gPCAxKSBjW2ldID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDNbaV07XG4gICAgICAgICAgICBlbHNlIGlmICgyICogdDNbaV0gPCAxKSBjW2ldID0gdDI7XG4gICAgICAgICAgICBlbHNlIGlmICgzICogdDNbaV0gPCAyKSBjW2ldID0gdDEgKyAodDIgLSB0MSkgKiAoMiAvIDMgLSB0M1tpXSkgKiA2O1xuICAgICAgICAgICAgZWxzZSBjW2ldID0gdDE7XG4gICAgICAgIH1cbiAgICAgICAgW3IsIGcsIGJdID0gW2NbMF0gKiAyNTUsIGNbMV0gKiAyNTUsIGNbMl0gKiAyNTVdO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPiAzKSB7XG4gICAgICAgIC8vIGtlZXAgYWxwaGEgY2hhbm5lbFxuICAgICAgICByZXR1cm4gW3IsIGcsIGIsIGFyZ3NbM11dO1xuICAgIH1cbiAgICByZXR1cm4gW3IsIGcsIGIsIDFdO1xufTtcblxuLypcbiAqIHN1cHBvcnRlZCBhcmd1bWVudHM6XG4gKiAtIHJnYjJoc2wocixnLGIpXG4gKiAtIHJnYjJoc2wocixnLGIsYSlcbiAqIC0gcmdiMmhzbChbcixnLGJdKVxuICogLSByZ2IyaHNsKFtyLGcsYixhXSlcbiAqIC0gcmdiMmhzbCh7cixnLGIsYX0pXG4gKi9cbmNvbnN0IHJnYjJoc2wkMSA9ICguLi5hcmdzKSA9PiB7XG4gICAgYXJncyA9IHVucGFjayhhcmdzLCAncmdiYScpO1xuICAgIGxldCBbciwgZywgYl0gPSBhcmdzO1xuXG4gICAgciAvPSAyNTU7XG4gICAgZyAvPSAyNTU7XG4gICAgYiAvPSAyNTU7XG5cbiAgICBjb25zdCBtaW5SZ2IgPSBtaW4kMyhyLCBnLCBiKTtcbiAgICBjb25zdCBtYXhSZ2IgPSBtYXgkMyhyLCBnLCBiKTtcblxuICAgIGNvbnN0IGwgPSAobWF4UmdiICsgbWluUmdiKSAvIDI7XG4gICAgbGV0IHMsIGg7XG5cbiAgICBpZiAobWF4UmdiID09PSBtaW5SZ2IpIHtcbiAgICAgICAgcyA9IDA7XG4gICAgICAgIGggPSBOdW1iZXIuTmFOO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPVxuICAgICAgICAgICAgbCA8IDAuNVxuICAgICAgICAgICAgICAgID8gKG1heFJnYiAtIG1pblJnYikgLyAobWF4UmdiICsgbWluUmdiKVxuICAgICAgICAgICAgICAgIDogKG1heFJnYiAtIG1pblJnYikgLyAoMiAtIG1heFJnYiAtIG1pblJnYik7XG4gICAgfVxuXG4gICAgaWYgKHIgPT0gbWF4UmdiKSBoID0gKGcgLSBiKSAvIChtYXhSZ2IgLSBtaW5SZ2IpO1xuICAgIGVsc2UgaWYgKGcgPT0gbWF4UmdiKSBoID0gMiArIChiIC0gcikgLyAobWF4UmdiIC0gbWluUmdiKTtcbiAgICBlbHNlIGlmIChiID09IG1heFJnYikgaCA9IDQgKyAociAtIGcpIC8gKG1heFJnYiAtIG1pblJnYik7XG5cbiAgICBoICo9IDYwO1xuICAgIGlmIChoIDwgMCkgaCArPSAzNjA7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMyAmJiBhcmdzWzNdICE9PSB1bmRlZmluZWQpIHJldHVybiBbaCwgcywgbCwgYXJnc1szXV07XG4gICAgcmV0dXJuIFtoLCBzLCBsXTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5oc2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJnYjJoc2wkMSh0aGlzLl9yZ2IpO1xufTtcblxuY29uc3QgaHNsJDEgPSAoLi4uYXJncykgPT4gbmV3IENvbG9yKC4uLmFyZ3MsICdoc2wnKTtcbmNocm9tYS5oc2wgPSBoc2wkMTtcblxuaW5wdXQuZm9ybWF0LmhzbCA9IGhzbDJyZ2I7XG5cbmlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMixcbiAgICB0ZXN0OiAoLi4uYXJncykgPT4ge1xuICAgICAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdoc2wnKTtcbiAgICAgICAgaWYgKHR5cGUoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiAnaHNsJztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb25zdCBoc2wgPSAoY29sMSwgY29sMiwgZikgPT4ge1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZV9oc3goY29sMSwgY29sMiwgZiwgJ2hzbCcpO1xufTtcblxuLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5pbmRleC5oc2wgPSBoc2w7XG5cbmNvbnN0IHsgZmxvb3I6IGZsb29yJDIgfSA9IE1hdGg7XG5cbmNvbnN0IGhzdjJyZ2IgPSAoLi4uYXJncykgPT4ge1xuICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2hzdicpO1xuICAgIGxldCBbaCwgcywgdl0gPSBhcmdzO1xuICAgIGxldCByLCBnLCBiO1xuICAgIHYgKj0gMjU1O1xuICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgIHIgPSBnID0gYiA9IHY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGggPT09IDM2MCkgaCA9IDA7XG4gICAgICAgIGlmIChoID4gMzYwKSBoIC09IDM2MDtcbiAgICAgICAgaWYgKGggPCAwKSBoICs9IDM2MDtcbiAgICAgICAgaCAvPSA2MDtcblxuICAgICAgICBjb25zdCBpID0gZmxvb3IkMihoKTtcbiAgICAgICAgY29uc3QgZiA9IGggLSBpO1xuICAgICAgICBjb25zdCBwID0gdiAqICgxIC0gcyk7XG4gICAgICAgIGNvbnN0IHEgPSB2ICogKDEgLSBzICogZik7XG4gICAgICAgIGNvbnN0IHQgPSB2ICogKDEgLSBzICogKDEgLSBmKSk7XG5cbiAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgW3IsIGcsIGJdID0gW3YsIHQsIHBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIFtyLCBnLCBiXSA9IFtxLCB2LCBwXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBbciwgZywgYl0gPSBbcCwgdiwgdF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgW3IsIGcsIGJdID0gW3AsIHEsIHZdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIFtyLCBnLCBiXSA9IFt0LCBwLCB2XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBbciwgZywgYl0gPSBbdiwgcCwgcV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtyLCBnLCBiLCBhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMV07XG59O1xuXG5jb25zdCB7IG1pbjogbWluJDEsIG1heDogbWF4JDIgfSA9IE1hdGg7XG5cbi8qXG4gKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICogLSByZ2IyaHN2KHIsZyxiKVxuICogLSByZ2IyaHN2KFtyLGcsYl0pXG4gKiAtIHJnYjJoc3Yoe3IsZyxifSlcbiAqL1xuY29uc3QgcmdiMmhzbCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYXJncyA9IHVucGFjayhhcmdzLCAncmdiJyk7XG4gICAgbGV0IFtyLCBnLCBiXSA9IGFyZ3M7XG4gICAgY29uc3QgbWluXyA9IG1pbiQxKHIsIGcsIGIpO1xuICAgIGNvbnN0IG1heF8gPSBtYXgkMihyLCBnLCBiKTtcbiAgICBjb25zdCBkZWx0YSA9IG1heF8gLSBtaW5fO1xuICAgIGxldCBoLCBzLCB2O1xuICAgIHYgPSBtYXhfIC8gMjU1LjA7XG4gICAgaWYgKG1heF8gPT09IDApIHtcbiAgICAgICAgaCA9IE51bWJlci5OYU47XG4gICAgICAgIHMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSBkZWx0YSAvIG1heF87XG4gICAgICAgIGlmIChyID09PSBtYXhfKSBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgICBpZiAoZyA9PT0gbWF4XykgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgICAgIGlmIChiID09PSBtYXhfKSBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICAgICAgaCAqPSA2MDtcbiAgICAgICAgaWYgKGggPCAwKSBoICs9IDM2MDtcbiAgICB9XG4gICAgcmV0dXJuIFtoLCBzLCB2XTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5oc3YgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJnYjJoc2wodGhpcy5fcmdiKTtcbn07XG5cbmNvbnN0IGhzdiQxID0gKC4uLmFyZ3MpID0+IG5ldyBDb2xvciguLi5hcmdzLCAnaHN2Jyk7XG5jaHJvbWEuaHN2ID0gaHN2JDE7XG5cbmlucHV0LmZvcm1hdC5oc3YgPSBoc3YycmdiO1xuXG5pbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDIsXG4gICAgdGVzdDogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgYXJncyA9IHVucGFjayhhcmdzLCAnaHN2Jyk7XG4gICAgICAgIGlmICh0eXBlKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2hzdic7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3QgaHN2ID0gKGNvbDEsIGNvbDIsIGYpID0+IHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGVfaHN4KGNvbDEsIGNvbDIsIGYsICdoc3YnKTtcbn07XG5cbi8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuaW5kZXguaHN2ID0gaHN2O1xuXG4vLyBmcm9tIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItNC9tdWx0aXBseS1tYXRyaWNlcy5qc1xuZnVuY3Rpb24gbXVsdGlwbHlNYXRyaWNlcyhBLCBCKSB7XG4gICAgbGV0IG0gPSBBLmxlbmd0aDtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShBWzBdKSkge1xuICAgICAgICAvLyBBIGlzIHZlY3RvciwgY29udmVydCB0byBbW2EsIGIsIGMsIC4uLl1dXG4gICAgICAgIEEgPSBbQV07XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KEJbMF0pKSB7XG4gICAgICAgIC8vIEIgaXMgdmVjdG9yLCBjb252ZXJ0IHRvIFtbYV0sIFtiXSwgW2NdLCAuLi5dXVxuICAgICAgICBCID0gQi5tYXAoKHgpID0+IFt4XSk7XG4gICAgfVxuXG4gICAgbGV0IHAgPSBCWzBdLmxlbmd0aDtcbiAgICBsZXQgQl9jb2xzID0gQlswXS5tYXAoKF8sIGkpID0+IEIubWFwKCh4KSA9PiB4W2ldKSk7IC8vIHRyYW5zcG9zZSBCXG4gICAgbGV0IHByb2R1Y3QgPSBBLm1hcCgocm93KSA9PlxuICAgICAgICBCX2NvbHMubWFwKChjb2wpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyb3cpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbC5yZWR1Y2UoKGEsIGMpID0+IGEgKyBjICogcm93LCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJvdy5yZWR1Y2UoKGEsIGMsIGkpID0+IGEgKyBjICogKGNvbFtpXSB8fCAwKSwgMCk7XG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIGlmIChtID09PSAxKSB7XG4gICAgICAgIHByb2R1Y3QgPSBwcm9kdWN0WzBdOyAvLyBBdm9pZCBbW2EsIGIsIGMsIC4uLl1dXG4gICAgfVxuXG4gICAgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHByb2R1Y3QubWFwKCh4KSA9PiB4WzBdKTsgLy8gQXZvaWQgW1thXSwgW2JdLCBbY10sIC4uLl1dXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2R1Y3Q7XG59XG5cbmNvbnN0IG9rbGFiMnJnYiA9ICguLi5hcmdzKSA9PiB7XG4gICAgYXJncyA9IHVucGFjayhhcmdzLCAnbGFiJyk7XG4gICAgY29uc3QgW0wsIGEsIGIsIC4uLnJlc3RdID0gYXJncztcbiAgICBjb25zdCBbWCwgWSwgWl0gPSBPS0xhYl90b19YWVooW0wsIGEsIGJdKTtcbiAgICBjb25zdCBbciwgZywgYl9dID0geHl6MnJnYihYLCBZLCBaKTtcbiAgICByZXR1cm4gW3IsIGcsIGJfLCAuLi4ocmVzdC5sZW5ndGggPiAwICYmIHJlc3RbMF0gPCAxID8gW3Jlc3RbMF1dIDogW10pXTtcbn07XG5cbi8vIGZyb20gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci00LyNjb2xvci1jb252ZXJzaW9uLWNvZGVcbmZ1bmN0aW9uIE9LTGFiX3RvX1hZWihPS0xhYikge1xuICAgIC8vIEdpdmVuIE9LTGFiLCBjb252ZXJ0IHRvIFhZWiByZWxhdGl2ZSB0byBENjVcbiAgICB2YXIgTE1TdG9YWVogPSBbXG4gICAgICAgIFsxLjIyNjg3OTg3NTg0NTkyNDMsIC0wLjU1NzgxNDk5NDQ2MDIxNzEsIDAuMjgxMzkxMDQ1NjY1OTY0N10sXG4gICAgICAgIFstMC4wNDA1NzU3NDUyMTQ4MDA4LCAxLjExMjI4NjgwMzI4MDMxNywgLTAuMDcxNzExMDU4MDY1NTE2NF0sXG4gICAgICAgIFstMC4wNzYzNzI5MzY2NzQ2NjAxLCAtMC40MjE0OTMzMzI0MDIyNDMyLCAxLjU4NjkyNDAxOTgzNjc4MTZdXG4gICAgXTtcbiAgICB2YXIgT0tMYWJ0b0xNUyA9IFtcbiAgICAgICAgWzEuMCwgMC4zOTYzMzc3NzczNzYxNzQ5LCAwLjIxNTgwMzc1NzMwOTkxMzZdLFxuICAgICAgICBbMS4wLCAtMC4xMDU1NjEzNDU4MTU2NTg2LCAtMC4wNjM4NTQxNzI4MjU4MTMzXSxcbiAgICAgICAgWzEuMCwgLTAuMDg5NDg0MTc3NTI5ODExOSwgLTEuMjkxNDg1NTQ4MDE5NDA5Ml1cbiAgICBdO1xuXG4gICAgdmFyIExNU25sID0gbXVsdGlwbHlNYXRyaWNlcyhPS0xhYnRvTE1TLCBPS0xhYik7XG4gICAgcmV0dXJuIG11bHRpcGx5TWF0cmljZXMoXG4gICAgICAgIExNU3RvWFlaLFxuICAgICAgICBMTVNubC5tYXAoKGMpID0+IGMgKiogMylcbiAgICApO1xufVxuXG5jb25zdCByZ2Iyb2tsYWIgPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IFtyLCBnLCBiLCAuLi5yZXN0XSA9IHVucGFjayhhcmdzLCAncmdiJyk7XG4gICAgY29uc3QgeHl6ID0gcmdiMnh5eihyLCBnLCBiKTtcbiAgICBjb25zdCBva2xhYiA9IFhZWl90b19PS0xhYih4eXopO1xuICAgIHJldHVybiBbLi4ub2tsYWIsIC4uLihyZXN0Lmxlbmd0aCA+IDAgJiYgcmVzdFswXSA8IDEgPyBbcmVzdFswXV0gOiBbXSldO1xufTtcblxuLy8gZnJvbSBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTQvI2NvbG9yLWNvbnZlcnNpb24tY29kZVxuZnVuY3Rpb24gWFlaX3RvX09LTGFiKFhZWikge1xuICAgIC8vIEdpdmVuIFhZWiByZWxhdGl2ZSB0byBENjUsIGNvbnZlcnQgdG8gT0tMYWJcbiAgICBjb25zdCBYWVp0b0xNUyA9IFtcbiAgICAgICAgWzAuODE5MDIyNDM3OTk2NzAzLCAwLjM2MTkwNjI2MDA1Mjg5MDQsIC0wLjEyODg3Mzc4MTUyMDk4NzldLFxuICAgICAgICBbMC4wMzI5ODM2NTM5MzIzODg1LCAwLjkyOTI4Njg2MTU4NjM0MzQsIDAuMDM2MTQ0NjY2MzUwNjQyNF0sXG4gICAgICAgIFswLjA0ODE3NzE4OTM1OTYyNDIsIDAuMjY0MjM5NTMxNzUyNzMwOCwgMC42MzM1NDc4Mjg0Njk0MzA5XVxuICAgIF07XG4gICAgY29uc3QgTE1TdG9PS0xhYiA9IFtcbiAgICAgICAgWzAuMjEwNDU0MjY4MzA5MzE0LCAwLjc5MzYxNzc3NDcwMjMwNTQsIC0wLjAwNDA3MjA0MzAxMTYxOTNdLFxuICAgICAgICBbMS45Nzc5OTg1MzI0MzExNjg0LCAtMi40Mjg1OTIyNDIwNDg1Nzk5LCAwLjQ1MDU5MzcwOTYxNzQxMV0sXG4gICAgICAgIFswLjAyNTkwNDA0MjQ2NTU0NzgsIDAuNzgyNzcxNzEyNDU3NTI5NiwgLTAuODA4Njc1NzU0OTIzMDc3NF1cbiAgICBdO1xuXG4gICAgY29uc3QgTE1TID0gbXVsdGlwbHlNYXRyaWNlcyhYWVp0b0xNUywgWFlaKTtcbiAgICAvLyBKYXZhU2NyaXB0IE1hdGguY2JydCByZXR1cm5zIGEgc2lnbi1tYXRjaGVkIGN1YmUgcm9vdFxuICAgIC8vIGJld2FyZSBpZiBwb3J0aW5nIHRvIG90aGVyIGxhbmd1YWdlc1xuICAgIC8vIGVzcGVjaWFsbHkgaWYgdGVtcHRlZCB0byB1c2UgYSBnZW5lcmFsIHBvd2VyIGZ1bmN0aW9uXG4gICAgcmV0dXJuIG11bHRpcGx5TWF0cmljZXMoXG4gICAgICAgIExNU3RvT0tMYWIsXG4gICAgICAgIExNUy5tYXAoKGMpID0+IE1hdGguY2JydChjKSlcbiAgICApO1xuICAgIC8vIEwgaW4gcmFuZ2UgWzAsMV0uIEZvciB1c2UgaW4gQ1NTLCBtdWx0aXBseSBieSAxMDAgYW5kIGFkZCBhIHBlcmNlbnRcbn1cblxuQ29sb3IucHJvdG90eXBlLm9rbGFiID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2Iyb2tsYWIodGhpcy5fcmdiKTtcbn07XG5cbmNvbnN0IG9rbGFiJDEgPSAoLi4uYXJncykgPT4gbmV3IENvbG9yKC4uLmFyZ3MsICdva2xhYicpO1xuT2JqZWN0LmFzc2lnbihjaHJvbWEsIHsgb2tsYWI6IG9rbGFiJDEgfSk7XG5cbmlucHV0LmZvcm1hdC5va2xhYiA9IG9rbGFiMnJnYjtcblxuaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICBwOiAyLFxuICAgIHRlc3Q6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ29rbGFiJyk7XG4gICAgICAgIGlmICh0eXBlKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ29rbGFiJztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb25zdCBva2xhYiA9IChjb2wxLCBjb2wyLCBmKSA9PiB7XG4gICAgY29uc3QgeHl6MCA9IGNvbDEub2tsYWIoKTtcbiAgICBjb25zdCB4eXoxID0gY29sMi5va2xhYigpO1xuICAgIHJldHVybiBuZXcgQ29sb3IoXG4gICAgICAgIHh5ejBbMF0gKyBmICogKHh5ejFbMF0gLSB4eXowWzBdKSxcbiAgICAgICAgeHl6MFsxXSArIGYgKiAoeHl6MVsxXSAtIHh5ejBbMV0pLFxuICAgICAgICB4eXowWzJdICsgZiAqICh4eXoxWzJdIC0geHl6MFsyXSksXG4gICAgICAgICdva2xhYidcbiAgICApO1xufTtcblxuLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5pbmRleC5va2xhYiA9IG9rbGFiO1xuXG5jb25zdCBva2xjaCQxID0gKGNvbDEsIGNvbDIsIGYpID0+IHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGVfaHN4KGNvbDEsIGNvbDIsIGYsICdva2xjaCcpO1xufTtcblxuLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5pbmRleC5va2xjaCA9IG9rbGNoJDE7XG5cbmNvbnN0IHsgcG93OiBwb3ckNCwgc3FydDogc3FydCQxLCBQSTogUEkkMSwgY29zOiBjb3MkMiwgc2luOiBzaW4kMiwgYXRhbjI6IGF0YW4yJDEgfSA9IE1hdGg7XG5cbnZhciBhdmVyYWdlID0gKGNvbG9ycywgbW9kZSA9ICdscmdiJywgd2VpZ2h0cyA9IG51bGwpID0+IHtcbiAgICBjb25zdCBsID0gY29sb3JzLmxlbmd0aDtcbiAgICBpZiAoIXdlaWdodHMpIHdlaWdodHMgPSBBcnJheS5mcm9tKG5ldyBBcnJheShsKSkubWFwKCgpID0+IDEpO1xuICAgIC8vIG5vcm1hbGl6ZSB3ZWlnaHRzXG4gICAgY29uc3QgayA9XG4gICAgICAgIGwgL1xuICAgICAgICB3ZWlnaHRzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAgICB9KTtcbiAgICB3ZWlnaHRzLmZvckVhY2goKHcsIGkpID0+IHtcbiAgICAgICAgd2VpZ2h0c1tpXSAqPSBrO1xuICAgIH0pO1xuICAgIC8vIGNvbnZlcnQgY29sb3JzIHRvIENvbG9yIG9iamVjdHNcbiAgICBjb2xvcnMgPSBjb2xvcnMubWFwKChjKSA9PiBuZXcgQ29sb3IoYykpO1xuICAgIGlmIChtb2RlID09PSAnbHJnYicpIHtcbiAgICAgICAgcmV0dXJuIF9hdmVyYWdlX2xyZ2IoY29sb3JzLCB3ZWlnaHRzKTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3QgPSBjb2xvcnMuc2hpZnQoKTtcbiAgICBjb25zdCB4eXogPSBmaXJzdC5nZXQobW9kZSk7XG4gICAgY29uc3QgY250ID0gW107XG4gICAgbGV0IGR4ID0gMDtcbiAgICBsZXQgZHkgPSAwO1xuICAgIC8vIGluaXRpYWwgY29sb3JcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHh5ei5sZW5ndGg7IGkrKykge1xuICAgICAgICB4eXpbaV0gPSAoeHl6W2ldIHx8IDApICogd2VpZ2h0c1swXTtcbiAgICAgICAgY250LnB1c2goaXNOYU4oeHl6W2ldKSA/IDAgOiB3ZWlnaHRzWzBdKTtcbiAgICAgICAgaWYgKG1vZGUuY2hhckF0KGkpID09PSAnaCcgJiYgIWlzTmFOKHh5eltpXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IEEgPSAoeHl6W2ldIC8gMTgwKSAqIFBJJDE7XG4gICAgICAgICAgICBkeCArPSBjb3MkMihBKSAqIHdlaWdodHNbMF07XG4gICAgICAgICAgICBkeSArPSBzaW4kMihBKSAqIHdlaWdodHNbMF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgYWxwaGEgPSBmaXJzdC5hbHBoYSgpICogd2VpZ2h0c1swXTtcbiAgICBjb2xvcnMuZm9yRWFjaCgoYywgY2kpID0+IHtcbiAgICAgICAgY29uc3QgeHl6MiA9IGMuZ2V0KG1vZGUpO1xuICAgICAgICBhbHBoYSArPSBjLmFscGhhKCkgKiB3ZWlnaHRzW2NpICsgMV07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeHl6Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHh5ejJbaV0pKSB7XG4gICAgICAgICAgICAgICAgY250W2ldICs9IHdlaWdodHNbY2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAobW9kZS5jaGFyQXQoaSkgPT09ICdoJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBBID0gKHh5ejJbaV0gLyAxODApICogUEkkMTtcbiAgICAgICAgICAgICAgICAgICAgZHggKz0gY29zJDIoQSkgKiB3ZWlnaHRzW2NpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGR5ICs9IHNpbiQyKEEpICogd2VpZ2h0c1tjaSArIDFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHh5eltpXSArPSB4eXoyW2ldICogd2VpZ2h0c1tjaSArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4eXoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG1vZGUuY2hhckF0KGkpID09PSAnaCcpIHtcbiAgICAgICAgICAgIGxldCBBID0gKGF0YW4yJDEoZHkgLyBjbnRbaV0sIGR4IC8gY250W2ldKSAvIFBJJDEpICogMTgwO1xuICAgICAgICAgICAgd2hpbGUgKEEgPCAwKSBBICs9IDM2MDtcbiAgICAgICAgICAgIHdoaWxlIChBID49IDM2MCkgQSAtPSAzNjA7XG4gICAgICAgICAgICB4eXpbaV0gPSBBO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeHl6W2ldID0geHl6W2ldIC8gY250W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFscGhhIC89IGw7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih4eXosIG1vZGUpLmFscGhhKGFscGhhID4gMC45OTk5OSA/IDEgOiBhbHBoYSwgdHJ1ZSk7XG59O1xuXG5jb25zdCBfYXZlcmFnZV9scmdiID0gKGNvbG9ycywgd2VpZ2h0cykgPT4ge1xuICAgIGNvbnN0IGwgPSBjb2xvcnMubGVuZ3RoO1xuICAgIGNvbnN0IHh5eiA9IFswLCAwLCAwLCAwXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb2wgPSBjb2xvcnNbaV07XG4gICAgICAgIGNvbnN0IGYgPSB3ZWlnaHRzW2ldIC8gbDtcbiAgICAgICAgY29uc3QgcmdiID0gY29sLl9yZ2I7XG4gICAgICAgIHh5elswXSArPSBwb3ckNChyZ2JbMF0sIDIpICogZjtcbiAgICAgICAgeHl6WzFdICs9IHBvdyQ0KHJnYlsxXSwgMikgKiBmO1xuICAgICAgICB4eXpbMl0gKz0gcG93JDQocmdiWzJdLCAyKSAqIGY7XG4gICAgICAgIHh5elszXSArPSByZ2JbM10gKiBmO1xuICAgIH1cbiAgICB4eXpbMF0gPSBzcXJ0JDEoeHl6WzBdKTtcbiAgICB4eXpbMV0gPSBzcXJ0JDEoeHl6WzFdKTtcbiAgICB4eXpbMl0gPSBzcXJ0JDEoeHl6WzJdKTtcbiAgICBpZiAoeHl6WzNdID4gMC45OTk5OTk5KSB4eXpbM10gPSAxO1xuICAgIHJldHVybiBuZXcgQ29sb3IoY2xpcF9yZ2IoeHl6KSk7XG59O1xuXG4vLyBtaW5pbWFsIG11bHRpLXB1cnBvc2UgaW50ZXJmYWNlXG5cblxuY29uc3QgeyBwb3c6IHBvdyQzIH0gPSBNYXRoO1xuXG5mdW5jdGlvbiBzY2FsZSAoY29sb3JzKSB7XG4gICAgLy8gY29uc3RydWN0b3JcbiAgICBsZXQgX21vZGUgPSAncmdiJztcbiAgICBsZXQgX25hY29sID0gY2hyb21hKCcjY2NjJyk7XG4gICAgbGV0IF9zcHJlYWQgPSAwO1xuICAgIC8vIGNvbnN0IF9maXhlZCA9IGZhbHNlO1xuICAgIGxldCBfZG9tYWluID0gWzAsIDFdO1xuICAgIGxldCBfcG9zID0gW107XG4gICAgbGV0IF9wYWRkaW5nID0gWzAsIDBdO1xuICAgIGxldCBfY2xhc3NlcyA9IGZhbHNlO1xuICAgIGxldCBfY29sb3JzID0gW107XG4gICAgbGV0IF9vdXQgPSBmYWxzZTtcbiAgICBsZXQgX21pbiA9IDA7XG4gICAgbGV0IF9tYXggPSAxO1xuICAgIGxldCBfY29ycmVjdExpZ2h0bmVzcyA9IGZhbHNlO1xuICAgIGxldCBfY29sb3JDYWNoZSA9IHt9O1xuICAgIGxldCBfdXNlQ2FjaGUgPSB0cnVlO1xuICAgIGxldCBfZ2FtbWEgPSAxO1xuXG4gICAgLy8gcHJpdmF0ZSBtZXRob2RzXG5cbiAgICBjb25zdCBzZXRDb2xvcnMgPSBmdW5jdGlvbiAoY29sb3JzKSB7XG4gICAgICAgIGNvbG9ycyA9IGNvbG9ycyB8fCBbJyNmZmYnLCAnIzAwMCddO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb2xvcnMgJiZcbiAgICAgICAgICAgIHR5cGUoY29sb3JzKSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIGNocm9tYS5icmV3ZXIgJiZcbiAgICAgICAgICAgIGNocm9tYS5icmV3ZXJbY29sb3JzLnRvTG93ZXJDYXNlKCldXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29sb3JzID0gY2hyb21hLmJyZXdlcltjb2xvcnMudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUoY29sb3JzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgLy8gaGFuZGxlIHNpbmdsZSBjb2xvclxuICAgICAgICAgICAgaWYgKGNvbG9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb2xvcnMgPSBbY29sb3JzWzBdLCBjb2xvcnNbMF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFrZSBhIGNvcHkgb2YgdGhlIGNvbG9yc1xuICAgICAgICAgICAgY29sb3JzID0gY29sb3JzLnNsaWNlKDApO1xuICAgICAgICAgICAgLy8gY29udmVydCB0byBjaHJvbWEgY2xhc3Nlc1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb2xvcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgICBjb2xvcnNbY10gPSBjaHJvbWEoY29sb3JzW2NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGF1dG8tZmlsbCBjb2xvciBwb3NpdGlvblxuICAgICAgICAgICAgX3Bvcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb2xvcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgICBfcG9zLnB1c2goYyAvIChjb2xvcnMubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc2V0Q2FjaGUoKTtcbiAgICAgICAgcmV0dXJuIChfY29sb3JzID0gY29sb3JzKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0Q2xhc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKF9jbGFzc2VzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBfY2xhc3Nlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBuICYmIHZhbHVlID49IF9jbGFzc2VzW2ldKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGkgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG5cbiAgICBsZXQgdE1hcExpZ2h0bmVzcyA9ICh0KSA9PiB0O1xuICAgIGxldCB0TWFwRG9tYWluID0gKHQpID0+IHQ7XG5cbiAgICAvLyBjb25zdCBjbGFzc2lmeVZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyAgICAgbGV0IHZhbCA9IHZhbHVlO1xuICAgIC8vICAgICBpZiAoX2NsYXNzZXMubGVuZ3RoID4gMikge1xuICAgIC8vICAgICAgICAgY29uc3QgbiA9IF9jbGFzc2VzLmxlbmd0aC0xO1xuICAgIC8vICAgICAgICAgY29uc3QgaSA9IGdldENsYXNzKHZhbHVlKTtcbiAgICAvLyAgICAgICAgIGNvbnN0IG1pbmMgPSBfY2xhc3Nlc1swXSArICgoX2NsYXNzZXNbMV0tX2NsYXNzZXNbMF0pICogKDAgKyAoX3NwcmVhZCAqIDAuNSkpKTsgIC8vIGNlbnRlciBvZiAxc3QgY2xhc3NcbiAgICAvLyAgICAgICAgIGNvbnN0IG1heGMgPSBfY2xhc3Nlc1tuLTFdICsgKChfY2xhc3Nlc1tuXS1fY2xhc3Nlc1tuLTFdKSAqICgxIC0gKF9zcHJlYWQgKiAwLjUpKSk7ICAvLyBjZW50ZXIgb2YgbGFzdCBjbGFzc1xuICAgIC8vICAgICAgICAgdmFsID0gX21pbiArICgoKChfY2xhc3Nlc1tpXSArICgoX2NsYXNzZXNbaSsxXSAtIF9jbGFzc2VzW2ldKSAqIDAuNSkpIC0gbWluYykgLyAobWF4Yy1taW5jKSkgKiAoX21heCAtIF9taW4pKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICByZXR1cm4gdmFsO1xuICAgIC8vIH07XG5cbiAgICBjb25zdCBnZXRDb2xvciA9IGZ1bmN0aW9uICh2YWwsIGJ5cGFzc01hcCkge1xuICAgICAgICBsZXQgY29sLCB0O1xuICAgICAgICBpZiAoYnlwYXNzTWFwID09IG51bGwpIHtcbiAgICAgICAgICAgIGJ5cGFzc01hcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTih2YWwpIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9uYWNvbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJ5cGFzc01hcCkge1xuICAgICAgICAgICAgaWYgKF9jbGFzc2VzICYmIF9jbGFzc2VzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBjbGFzc1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBnZXRDbGFzcyh2YWwpO1xuICAgICAgICAgICAgICAgIHQgPSBjIC8gKF9jbGFzc2VzLmxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfbWF4ICE9PSBfbWluKSB7XG4gICAgICAgICAgICAgICAgLy8ganVzdCBpbnRlcnBvbGF0ZSBiZXR3ZWVuIG1pbi9tYXhcbiAgICAgICAgICAgICAgICB0ID0gKHZhbCAtIF9taW4pIC8gKF9tYXggLSBfbWluKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ID0gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9tYWluIG1hcFxuICAgICAgICB0ID0gdE1hcERvbWFpbih0KTtcblxuICAgICAgICBpZiAoIWJ5cGFzc01hcCkge1xuICAgICAgICAgICAgdCA9IHRNYXBMaWdodG5lc3ModCk7IC8vIGxpZ2h0bmVzcyBjb3JyZWN0aW9uXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2dhbW1hICE9PSAxKSB7XG4gICAgICAgICAgICB0ID0gcG93JDModCwgX2dhbW1hKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHQgPSBfcGFkZGluZ1swXSArIHQgKiAoMSAtIF9wYWRkaW5nWzBdIC0gX3BhZGRpbmdbMV0pO1xuXG4gICAgICAgIHQgPSBsaW1pdCh0LCAwLCAxKTtcblxuICAgICAgICBjb25zdCBrID0gTWF0aC5mbG9vcih0ICogMTAwMDApO1xuXG4gICAgICAgIGlmIChfdXNlQ2FjaGUgJiYgX2NvbG9yQ2FjaGVba10pIHtcbiAgICAgICAgICAgIGNvbCA9IF9jb2xvckNhY2hlW2tdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGUoX2NvbG9ycykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAvL2ZvciBpIGluIFswLi5fcG9zLmxlbmd0aC0xXVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX3Bvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gX3Bvc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPD0gcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gX2NvbG9yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID49IHAgJiYgaSA9PT0gX3Bvcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBfY29sb3JzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPiBwICYmIHQgPCBfcG9zW2kgKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9ICh0IC0gcCkgLyAoX3Bvc1tpICsgMV0gLSBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IGNocm9tYS5pbnRlcnBvbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29sb3JzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb2xvcnNbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX21vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZShfY29sb3JzKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbCA9IF9jb2xvcnModCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3VzZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgX2NvbG9yQ2FjaGVba10gPSBjb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbDtcbiAgICB9O1xuXG4gICAgdmFyIHJlc2V0Q2FjaGUgPSAoKSA9PiAoX2NvbG9yQ2FjaGUgPSB7fSk7XG5cbiAgICBzZXRDb2xvcnMoY29sb3JzKTtcblxuICAgIC8vIHB1YmxpYyBpbnRlcmZhY2VcblxuICAgIGNvbnN0IGYgPSBmdW5jdGlvbiAodikge1xuICAgICAgICBjb25zdCBjID0gY2hyb21hKGdldENvbG9yKHYpKTtcbiAgICAgICAgaWYgKF9vdXQgJiYgY1tfb3V0XSkge1xuICAgICAgICAgICAgcmV0dXJuIGNbX291dF0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGYuY2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc2VzKSB7XG4gICAgICAgIGlmIChjbGFzc2VzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlKGNsYXNzZXMpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgX2NsYXNzZXMgPSBjbGFzc2VzO1xuICAgICAgICAgICAgICAgIF9kb21haW4gPSBbY2xhc3Nlc1swXSwgY2xhc3Nlc1tjbGFzc2VzLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IGNocm9tYS5hbmFseXplKF9kb21haW4pO1xuICAgICAgICAgICAgICAgIGlmIChjbGFzc2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc2VzID0gW2QubWluLCBkLm1heF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzZXMgPSBjaHJvbWEubGltaXRzKGQsICdlJywgY2xhc3Nlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9jbGFzc2VzO1xuICAgIH07XG5cbiAgICBmLmRvbWFpbiA9IGZ1bmN0aW9uIChkb21haW4pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2RvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICBfbWluID0gZG9tYWluWzBdO1xuICAgICAgICBfbWF4ID0gZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXTtcbiAgICAgICAgX3BvcyA9IFtdO1xuICAgICAgICBjb25zdCBrID0gX2NvbG9ycy5sZW5ndGg7XG4gICAgICAgIGlmIChkb21haW4ubGVuZ3RoID09PSBrICYmIF9taW4gIT09IF9tYXgpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbnNcbiAgICAgICAgICAgIGZvciAobGV0IGQgb2YgQXJyYXkuZnJvbShkb21haW4pKSB7XG4gICAgICAgICAgICAgICAgX3Bvcy5wdXNoKChkIC0gX21pbikgLyAoX21heCAtIF9taW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgazsgYysrKSB7XG4gICAgICAgICAgICAgICAgX3Bvcy5wdXNoKGMgLyAoayAtIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkb21haW4ubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIC8vIHNldCBkb21haW4gbWFwXG4gICAgICAgICAgICAgICAgY29uc3QgdE91dCA9IGRvbWFpbi5tYXAoKGQsIGkpID0+IGkgLyAoZG9tYWluLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0QnJlYWtzID0gZG9tYWluLm1hcCgoZCkgPT4gKGQgLSBfbWluKSAvIChfbWF4IC0gX21pbikpO1xuICAgICAgICAgICAgICAgIGlmICghdEJyZWFrcy5ldmVyeSgodmFsLCBpKSA9PiB0T3V0W2ldID09PSB2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRNYXBEb21haW4gPSAodCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPD0gMCB8fCB0ID49IDEpIHJldHVybiB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHQgPj0gdEJyZWFrc1tpICsgMV0pIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGYgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0IC0gdEJyZWFrc1tpXSkgLyAodEJyZWFrc1tpICsgMV0gLSB0QnJlYWtzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dCA9IHRPdXRbaV0gKyBmICogKHRPdXRbaSArIDFdIC0gdE91dFtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfZG9tYWluID0gW19taW4sIF9tYXhdO1xuICAgICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZi5tb2RlID0gZnVuY3Rpb24gKF9tKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIF9tb2RlO1xuICAgICAgICB9XG4gICAgICAgIF9tb2RlID0gX207XG4gICAgICAgIHJlc2V0Q2FjaGUoKTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGYucmFuZ2UgPSBmdW5jdGlvbiAoY29sb3JzLCBfcG9zKSB7XG4gICAgICAgIHNldENvbG9ycyhjb2xvcnMpO1xuICAgICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZi5vdXQgPSBmdW5jdGlvbiAoX28pIHtcbiAgICAgICAgX291dCA9IF9vO1xuICAgICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgZi5zcHJlYWQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zcHJlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgX3NwcmVhZCA9IHZhbDtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGYuY29ycmVjdExpZ2h0bmVzcyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIF9jb3JyZWN0TGlnaHRuZXNzID0gdjtcbiAgICAgICAgcmVzZXRDYWNoZSgpO1xuICAgICAgICBpZiAoX2NvcnJlY3RMaWdodG5lc3MpIHtcbiAgICAgICAgICAgIHRNYXBMaWdodG5lc3MgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IEwwID0gZ2V0Q29sb3IoMCwgdHJ1ZSkubGFiKClbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgTDEgPSBnZXRDb2xvcigxLCB0cnVlKS5sYWIoKVswXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2wgPSBMMCA+IEwxO1xuICAgICAgICAgICAgICAgIGxldCBMX2FjdHVhbCA9IGdldENvbG9yKHQsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IExfaWRlYWwgPSBMMCArIChMMSAtIEwwKSAqIHQ7XG4gICAgICAgICAgICAgICAgbGV0IExfZGlmZiA9IExfYWN0dWFsIC0gTF9pZGVhbDtcbiAgICAgICAgICAgICAgICBsZXQgdDAgPSAwO1xuICAgICAgICAgICAgICAgIGxldCB0MSA9IDE7XG4gICAgICAgICAgICAgICAgbGV0IG1heF9pdGVyID0gMjA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKE1hdGguYWJzKExfZGlmZikgPiAxZS0yICYmIG1heF9pdGVyLS0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTF9kaWZmICo9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKExfZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MCA9IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCArPSAodDEgLSB0KSAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdDEgPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgKz0gKHQwIC0gdCkgKiAwLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBMX2FjdHVhbCA9IGdldENvbG9yKHQsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChMX2RpZmYgPSBMX2FjdHVhbCAtIExfaWRlYWwpO1xuICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0TWFwTGlnaHRuZXNzID0gKHQpID0+IHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGYucGFkZGluZyA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIGlmIChwICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlKHApID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHAgPSBbcCwgcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfcGFkZGluZyA9IHA7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfcGFkZGluZztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmLmNvbG9ycyA9IGZ1bmN0aW9uIChudW1Db2xvcnMsIG91dCkge1xuICAgICAgICAvLyBJZiBubyBhcmd1bWVudHMgYXJlIGdpdmVuLCByZXR1cm4gdGhlIG9yaWdpbmFsIGNvbG9ycyB0aGF0IHdlcmUgcHJvdmlkZWRcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBvdXQgPSAnaGV4JztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb2xvcnMuc2xpY2UoMCk7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtQ29sb3JzID09PSAxKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbZigwLjUpXTtcbiAgICAgICAgfSBlbHNlIGlmIChudW1Db2xvcnMgPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBkbSA9IF9kb21haW5bMF07XG4gICAgICAgICAgICBjb25zdCBkZCA9IF9kb21haW5bMV0gLSBkbTtcbiAgICAgICAgICAgIHJlc3VsdCA9IF9fcmFuZ2VfXygwLCBudW1Db2xvcnMpLm1hcCgoaSkgPT5cbiAgICAgICAgICAgICAgICBmKGRtICsgKGkgLyAobnVtQ29sb3JzIC0gMSkpICogZGQpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcmV0dXJucyBhbGwgY29sb3JzIGJhc2VkIG9uIHRoZSBkZWZpbmVkIGNsYXNzZXNcbiAgICAgICAgICAgIGNvbG9ycyA9IFtdO1xuICAgICAgICAgICAgbGV0IHNhbXBsZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChfY2xhc3NlcyAmJiBfY2xhc3Nlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAxLCBlbmQgPSBfY2xhc3Nlcy5sZW5ndGgsIGFzYyA9IDEgPD0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBhc2MgPyBpIDwgZW5kIDogaSA+IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgYXNjID8gaSsrIDogaS0tXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXMucHVzaCgoX2NsYXNzZXNbaSAtIDFdICsgX2NsYXNzZXNbaV0pICogMC41KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNhbXBsZXMgPSBfZG9tYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gc2FtcGxlcy5tYXAoKHYpID0+IGYodikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNocm9tYVtvdXRdKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKChjKSA9PiBjW291dF0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgZi5jYWNoZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjICE9IG51bGwpIHtcbiAgICAgICAgICAgIF91c2VDYWNoZSA9IGM7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfdXNlQ2FjaGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZi5nYW1tYSA9IGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIGlmIChnICE9IG51bGwpIHtcbiAgICAgICAgICAgIF9nYW1tYSA9IGc7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2FtbWE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZi5ub2RhdGEgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICBpZiAoZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBfbmFjb2wgPSBjaHJvbWEoZCk7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfbmFjb2w7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGY7XG59XG5cbmZ1bmN0aW9uIF9fcmFuZ2VfXyhsZWZ0LCByaWdodCwgaW5jbHVzaXZlKSB7XG4gICAgbGV0IHJhbmdlID0gW107XG4gICAgbGV0IGFzY2VuZGluZyA9IGxlZnQgPCByaWdodDtcbiAgICBsZXQgZW5kID0gcmlnaHQgO1xuICAgIGZvciAobGV0IGkgPSBsZWZ0OyBhc2NlbmRpbmcgPyBpIDwgZW5kIDogaSA+IGVuZDsgYXNjZW5kaW5nID8gaSsrIDogaS0tKSB7XG4gICAgICAgIHJhbmdlLnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZTtcbn1cblxuLy9cbi8vIGludGVycG9sYXRlcyBiZXR3ZWVuIGEgc2V0IG9mIGNvbG9ycyB1emluZyBhIGJlemllciBzcGxpbmVcbi8vXG5cblxuLy8gbnRoIHJvdyBvZiB0aGUgcGFzY2FsIHRyaWFuZ2xlXG5jb25zdCBiaW5vbV9yb3cgPSBmdW5jdGlvbiAobikge1xuICAgIGxldCByb3cgPSBbMSwgMV07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGV0IG5ld3JvdyA9IFsxXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPD0gcm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBuZXdyb3dbal0gPSAocm93W2pdIHx8IDApICsgcm93W2ogLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByb3cgPSBuZXdyb3c7XG4gICAgfVxuICAgIHJldHVybiByb3c7XG59O1xuXG5jb25zdCBiZXppZXIgPSBmdW5jdGlvbiAoY29sb3JzKSB7XG4gICAgbGV0IEksIGxhYjAsIGxhYjEsIGxhYjI7XG4gICAgY29sb3JzID0gY29sb3JzLm1hcCgoYykgPT4gbmV3IENvbG9yKGMpKTtcbiAgICBpZiAoY29sb3JzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICBbbGFiMCwgbGFiMV0gPSBjb2xvcnMubWFwKChjKSA9PiBjLmxhYigpKTtcbiAgICAgICAgSSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBjb25zdCBsYWIgPSBbMCwgMSwgMl0ubWFwKChpKSA9PiBsYWIwW2ldICsgdCAqIChsYWIxW2ldIC0gbGFiMFtpXSkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihsYWIsICdsYWInKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGNvbG9ycy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgLy8gcXVhZHJhdGljIGJlemllciBpbnRlcnBvbGF0aW9uXG4gICAgICAgIFtsYWIwLCBsYWIxLCBsYWIyXSA9IGNvbG9ycy5tYXAoKGMpID0+IGMubGFiKCkpO1xuICAgICAgICBJID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhYiA9IFswLCAxLCAyXS5tYXAoXG4gICAgICAgICAgICAgICAgKGkpID0+XG4gICAgICAgICAgICAgICAgICAgICgxIC0gdCkgKiAoMSAtIHQpICogbGFiMFtpXSArXG4gICAgICAgICAgICAgICAgICAgIDIgKiAoMSAtIHQpICogdCAqIGxhYjFbaV0gK1xuICAgICAgICAgICAgICAgICAgICB0ICogdCAqIGxhYjJbaV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKGxhYiwgJ2xhYicpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAvLyBjdWJpYyBiZXppZXIgaW50ZXJwb2xhdGlvblxuICAgICAgICBsZXQgbGFiMztcbiAgICAgICAgW2xhYjAsIGxhYjEsIGxhYjIsIGxhYjNdID0gY29sb3JzLm1hcCgoYykgPT4gYy5sYWIoKSk7XG4gICAgICAgIEkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgY29uc3QgbGFiID0gWzAsIDEsIDJdLm1hcChcbiAgICAgICAgICAgICAgICAoaSkgPT5cbiAgICAgICAgICAgICAgICAgICAgKDEgLSB0KSAqICgxIC0gdCkgKiAoMSAtIHQpICogbGFiMFtpXSArXG4gICAgICAgICAgICAgICAgICAgIDMgKiAoMSAtIHQpICogKDEgLSB0KSAqIHQgKiBsYWIxW2ldICtcbiAgICAgICAgICAgICAgICAgICAgMyAqICgxIC0gdCkgKiB0ICogdCAqIGxhYjJbaV0gK1xuICAgICAgICAgICAgICAgICAgICB0ICogdCAqIHQgKiBsYWIzW2ldXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihsYWIsICdsYWInKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGNvbG9ycy5sZW5ndGggPj0gNSkge1xuICAgICAgICAvLyBnZW5lcmFsIGNhc2UgKGRlZ3JlZSBuIGJlemllcilcbiAgICAgICAgbGV0IGxhYnMsIHJvdywgbjtcbiAgICAgICAgbGFicyA9IGNvbG9ycy5tYXAoKGMpID0+IGMubGFiKCkpO1xuICAgICAgICBuID0gY29sb3JzLmxlbmd0aCAtIDE7XG4gICAgICAgIHJvdyA9IGJpbm9tX3JvdyhuKTtcbiAgICAgICAgSSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gMSAtIHQ7XG4gICAgICAgICAgICBjb25zdCBsYWIgPSBbMCwgMSwgMl0ubWFwKChpKSA9PlxuICAgICAgICAgICAgICAgIGxhYnMucmVkdWNlKFxuICAgICAgICAgICAgICAgICAgICAoc3VtLCBlbCwgaikgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArIHJvd1tqXSAqIHUgKiogKG4gLSBqKSAqIHQgKiogaiAqIGVsW2ldLFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobGFiLCAnbGFiJyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ05vIHBvaW50IGluIHJ1bm5pbmcgYmV6aWVyIHdpdGggb25seSBvbmUgY29sb3IuJyk7XG4gICAgfVxuICAgIHJldHVybiBJO1xufTtcblxudmFyIGJlemllciQxID0gKGNvbG9ycykgPT4ge1xuICAgIGNvbnN0IGYgPSBiZXppZXIoY29sb3JzKTtcbiAgICBmLnNjYWxlID0gKCkgPT4gc2NhbGUoZik7XG4gICAgcmV0dXJuIGY7XG59O1xuXG5jb25zdCB7IHJvdW5kOiByb3VuZCQzIH0gPSBNYXRoO1xuXG5Db2xvci5wcm90b3R5cGUucmdiID0gZnVuY3Rpb24gKHJuZCA9IHRydWUpIHtcbiAgICBpZiAocm5kID09PSBmYWxzZSkgcmV0dXJuIHRoaXMuX3JnYi5zbGljZSgwLCAzKTtcbiAgICByZXR1cm4gdGhpcy5fcmdiLnNsaWNlKDAsIDMpLm1hcChyb3VuZCQzKTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5yZ2JhID0gZnVuY3Rpb24gKHJuZCA9IHRydWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmdiLnNsaWNlKDAsIDQpLm1hcCgodiwgaSkgPT4ge1xuICAgICAgICByZXR1cm4gaSA8IDMgPyAocm5kID09PSBmYWxzZSA/IHYgOiByb3VuZCQzKHYpKSA6IHY7XG4gICAgfSk7XG59O1xuXG5jb25zdCByZ2IgPSAoLi4uYXJncykgPT4gbmV3IENvbG9yKC4uLmFyZ3MsICdyZ2InKTtcbk9iamVjdC5hc3NpZ24oY2hyb21hLCB7IHJnYiB9KTtcblxuaW5wdXQuZm9ybWF0LnJnYiA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgcmdiYSA9IHVucGFjayhhcmdzLCAncmdiYScpO1xuICAgIGlmIChyZ2JhWzNdID09PSB1bmRlZmluZWQpIHJnYmFbM10gPSAxO1xuICAgIHJldHVybiByZ2JhO1xufTtcblxuaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICBwOiAzLFxuICAgIHRlc3Q6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ3JnYmEnKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZShhcmdzKSA9PT0gJ2FycmF5JyAmJlxuICAgICAgICAgICAgKGFyZ3MubGVuZ3RoID09PSAzIHx8XG4gICAgICAgICAgICAgICAgKGFyZ3MubGVuZ3RoID09PSA0ICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGUoYXJnc1szXSkgPT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICAgICAgYXJnc1szXSA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbM10gPD0gMSkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuICdyZ2InO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qXG4gKiBpbnRlcnBvbGF0ZXMgYmV0d2VlbiBhIHNldCBvZiBjb2xvcnMgdXppbmcgYSBiZXppZXIgc3BsaW5lXG4gKiBibGVuZCBtb2RlIGZvcm11bGFzIHRha2VuIGZyb20gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTgwMTEwMDE0OTQ2L2h0dHA6Ly93d3cudmVudHVyZS13YXJlLmNvbS9rZXZpbi9jb2RpbmcvbGV0cy1sZWFybi1tYXRoLXBob3Rvc2hvcC1ibGVuZC1tb2Rlcy9cbiAqL1xuXG5cbmNvbnN0IGJsZW5kID0gKGJvdHRvbSwgdG9wLCBtb2RlKSA9PiB7XG4gICAgaWYgKCFibGVuZFttb2RlXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gYmxlbmQgbW9kZSAnICsgbW9kZSk7XG4gICAgfVxuICAgIHJldHVybiBibGVuZFttb2RlXShib3R0b20sIHRvcCk7XG59O1xuXG5jb25zdCBibGVuZF9mID0gKGYpID0+IChib3R0b20sIHRvcCkgPT4ge1xuICAgIGNvbnN0IGMwID0gY2hyb21hKHRvcCkucmdiKCk7XG4gICAgY29uc3QgYzEgPSBjaHJvbWEoYm90dG9tKS5yZ2IoKTtcbiAgICByZXR1cm4gY2hyb21hLnJnYihmKGMwLCBjMSkpO1xufTtcblxuY29uc3QgZWFjaCA9IChmKSA9PiAoYzAsIGMxKSA9PiB7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgb3V0WzBdID0gZihjMFswXSwgYzFbMF0pO1xuICAgIG91dFsxXSA9IGYoYzBbMV0sIGMxWzFdKTtcbiAgICBvdXRbMl0gPSBmKGMwWzJdLCBjMVsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbmNvbnN0IG5vcm1hbCA9IChhKSA9PiBhO1xuY29uc3QgbXVsdGlwbHkgPSAoYSwgYikgPT4gKGEgKiBiKSAvIDI1NTtcbmNvbnN0IGRhcmtlbiA9IChhLCBiKSA9PiAoYSA+IGIgPyBiIDogYSk7XG5jb25zdCBsaWdodGVuID0gKGEsIGIpID0+IChhID4gYiA/IGEgOiBiKTtcbmNvbnN0IHNjcmVlbiA9IChhLCBiKSA9PiAyNTUgKiAoMSAtICgxIC0gYSAvIDI1NSkgKiAoMSAtIGIgLyAyNTUpKTtcbmNvbnN0IG92ZXJsYXkgPSAoYSwgYikgPT5cbiAgICBiIDwgMTI4ID8gKDIgKiBhICogYikgLyAyNTUgOiAyNTUgKiAoMSAtIDIgKiAoMSAtIGEgLyAyNTUpICogKDEgLSBiIC8gMjU1KSk7XG5jb25zdCBidXJuID0gKGEsIGIpID0+IDI1NSAqICgxIC0gKDEgLSBiIC8gMjU1KSAvIChhIC8gMjU1KSk7XG5jb25zdCBkb2RnZSA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEgPT09IDI1NSkgcmV0dXJuIDI1NTtcbiAgICBhID0gKDI1NSAqIChiIC8gMjU1KSkgLyAoMSAtIGEgLyAyNTUpO1xuICAgIHJldHVybiBhID4gMjU1ID8gMjU1IDogYTtcbn07XG5cbi8vICMgYWRkID0gKGEsYikgLT5cbi8vICMgICAgIGlmIChhICsgYiA+IDI1NSkgdGhlbiAyNTUgZWxzZSBhICsgYlxuXG5ibGVuZC5ub3JtYWwgPSBibGVuZF9mKGVhY2gobm9ybWFsKSk7XG5ibGVuZC5tdWx0aXBseSA9IGJsZW5kX2YoZWFjaChtdWx0aXBseSkpO1xuYmxlbmQuc2NyZWVuID0gYmxlbmRfZihlYWNoKHNjcmVlbikpO1xuYmxlbmQub3ZlcmxheSA9IGJsZW5kX2YoZWFjaChvdmVybGF5KSk7XG5ibGVuZC5kYXJrZW4gPSBibGVuZF9mKGVhY2goZGFya2VuKSk7XG5ibGVuZC5saWdodGVuID0gYmxlbmRfZihlYWNoKGxpZ2h0ZW4pKTtcbmJsZW5kLmRvZGdlID0gYmxlbmRfZihlYWNoKGRvZGdlKSk7XG5ibGVuZC5idXJuID0gYmxlbmRfZihlYWNoKGJ1cm4pKTtcblxuLy8gY3ViZWhlbGl4IGludGVycG9sYXRpb25cbi8vIGJhc2VkIG9uIEQuQS4gR3JlZW4gXCJBIGNvbG91ciBzY2hlbWUgZm9yIHRoZSBkaXNwbGF5IG9mIGFzdHJvbm9taWNhbCBpbnRlbnNpdHkgaW1hZ2VzXCJcbi8vIGh0dHA6Ly9hc3Ryb24tc29jLmluL2J1bGxldGluLzExSnVuZS8yODkzOTIwMTEucGRmXG5jb25zdCB7IHBvdzogcG93JDIsIHNpbjogc2luJDEsIGNvczogY29zJDEgfSA9IE1hdGg7XG5cbmZ1bmN0aW9uIGN1YmVoZWxpeCAoXG4gICAgc3RhcnQgPSAzMDAsXG4gICAgcm90YXRpb25zID0gLTEuNSxcbiAgICBodWUgPSAxLFxuICAgIGdhbW1hID0gMSxcbiAgICBsaWdodG5lc3MgPSBbMCwgMV1cbikge1xuICAgIGxldCBkaCA9IDAsXG4gICAgICAgIGRsO1xuICAgIGlmICh0eXBlKGxpZ2h0bmVzcykgPT09ICdhcnJheScpIHtcbiAgICAgICAgZGwgPSBsaWdodG5lc3NbMV0gLSBsaWdodG5lc3NbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGwgPSAwO1xuICAgICAgICBsaWdodG5lc3MgPSBbbGlnaHRuZXNzLCBsaWdodG5lc3NdO1xuICAgIH1cbiAgICBjb25zdCBmID0gZnVuY3Rpb24gKGZyYWN0KSB7XG4gICAgICAgIGNvbnN0IGEgPSBUV09QSSAqICgoc3RhcnQgKyAxMjApIC8gMzYwICsgcm90YXRpb25zICogZnJhY3QpO1xuICAgICAgICBjb25zdCBsID0gcG93JDIobGlnaHRuZXNzWzBdICsgZGwgKiBmcmFjdCwgZ2FtbWEpO1xuICAgICAgICBjb25zdCBoID0gZGggIT09IDAgPyBodWVbMF0gKyBmcmFjdCAqIGRoIDogaHVlO1xuICAgICAgICBjb25zdCBhbXAgPSAoaCAqIGwgKiAoMSAtIGwpKSAvIDI7XG4gICAgICAgIGNvbnN0IGNvc19hID0gY29zJDEoYSk7XG4gICAgICAgIGNvbnN0IHNpbl9hID0gc2luJDEoYSk7XG4gICAgICAgIGNvbnN0IHIgPSBsICsgYW1wICogKC0wLjE0ODYxICogY29zX2EgKyAxLjc4Mjc3ICogc2luX2EpO1xuICAgICAgICBjb25zdCBnID0gbCArIGFtcCAqICgtMC4yOTIyNyAqIGNvc19hIC0gMC45MDY0OSAqIHNpbl9hKTtcbiAgICAgICAgY29uc3QgYiA9IGwgKyBhbXAgKiAoKzEuOTcyOTQgKiBjb3NfYSk7XG4gICAgICAgIHJldHVybiBjaHJvbWEoY2xpcF9yZ2IoW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTUsIDFdKSk7XG4gICAgfTtcbiAgICBmLnN0YXJ0ID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgaWYgKHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gcztcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcbiAgICBmLnJvdGF0aW9ucyA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIGlmIChyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByb3RhdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgcm90YXRpb25zID0gcjtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcbiAgICBmLmdhbW1hID0gZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgaWYgKGcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdhbW1hO1xuICAgICAgICB9XG4gICAgICAgIGdhbW1hID0gZztcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcbiAgICBmLmh1ZSA9IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIGlmIChoID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBodWU7XG4gICAgICAgIH1cbiAgICAgICAgaHVlID0gaDtcbiAgICAgICAgaWYgKHR5cGUoaHVlKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgZGggPSBodWVbMV0gLSBodWVbMF07XG4gICAgICAgICAgICBpZiAoZGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBodWUgPSBodWVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcbiAgICBmLmxpZ2h0bmVzcyA9IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIGlmIChoID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsaWdodG5lc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUoaCkgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIGxpZ2h0bmVzcyA9IGg7XG4gICAgICAgICAgICBkbCA9IGhbMV0gLSBoWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlnaHRuZXNzID0gW2gsIGhdO1xuICAgICAgICAgICAgZGwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmO1xuICAgIH07XG4gICAgZi5zY2FsZSA9ICgpID0+IGNocm9tYS5zY2FsZShmKTtcbiAgICBmLmh1ZShodWUpO1xuICAgIHJldHVybiBmO1xufVxuXG5jb25zdCBkaWdpdHMgPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG5cbmNvbnN0IHsgZmxvb3I6IGZsb29yJDEsIHJhbmRvbSB9ID0gTWF0aDtcblxudmFyIHJhbmRvbSQxID0gKCkgPT4ge1xuICAgIGxldCBjb2RlID0gJyMnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgIGNvZGUgKz0gZGlnaXRzLmNoYXJBdChmbG9vciQxKHJhbmRvbSgpICogMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb2xvcihjb2RlLCAnaGV4Jyk7XG59O1xuXG5jb25zdCB7IGxvZzogbG9nJDEsIHBvdzogcG93JDEsIGZsb29yLCBhYnM6IGFicyQxIH0gPSBNYXRoO1xuXG5mdW5jdGlvbiBhbmFseXplKGRhdGEsIGtleSA9IG51bGwpIHtcbiAgICBjb25zdCByID0ge1xuICAgICAgICBtaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIG1heDogTnVtYmVyLk1BWF9WQUxVRSAqIC0xLFxuICAgICAgICBzdW06IDAsXG4gICAgICAgIHZhbHVlczogW10sXG4gICAgICAgIGNvdW50OiAwXG4gICAgfTtcbiAgICBpZiAodHlwZShkYXRhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZGF0YSA9IE9iamVjdC52YWx1ZXMoZGF0YSk7XG4gICAgfVxuICAgIGRhdGEuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICAgIGlmIChrZXkgJiYgdHlwZSh2YWwpID09PSAnb2JqZWN0JykgdmFsID0gdmFsW2tleV07XG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09IG51bGwgJiYgIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgIHIudmFsdWVzLnB1c2godmFsKTtcbiAgICAgICAgICAgIHIuc3VtICs9IHZhbDtcbiAgICAgICAgICAgIGlmICh2YWwgPCByLm1pbikgci5taW4gPSB2YWw7XG4gICAgICAgICAgICBpZiAodmFsID4gci5tYXgpIHIubWF4ID0gdmFsO1xuICAgICAgICAgICAgci5jb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByLmRvbWFpbiA9IFtyLm1pbiwgci5tYXhdO1xuXG4gICAgci5saW1pdHMgPSAobW9kZSwgbnVtKSA9PiBsaW1pdHMociwgbW9kZSwgbnVtKTtcblxuICAgIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBsaW1pdHMoZGF0YSwgbW9kZSA9ICdlcXVhbCcsIG51bSA9IDcpIHtcbiAgICBpZiAodHlwZShkYXRhKSA9PSAnYXJyYXknKSB7XG4gICAgICAgIGRhdGEgPSBhbmFseXplKGRhdGEpO1xuICAgIH1cbiAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSBkYXRhO1xuICAgIGNvbnN0IHZhbHVlcyA9IGRhdGEudmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcblxuICAgIGlmIChudW0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgfVxuXG4gICAgY29uc3QgbGltaXRzID0gW107XG5cbiAgICBpZiAobW9kZS5zdWJzdHIoMCwgMSkgPT09ICdjJykge1xuICAgICAgICAvLyBjb250aW51b3VzXG4gICAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgfVxuXG4gICAgaWYgKG1vZGUuc3Vic3RyKDAsIDEpID09PSAnZScpIHtcbiAgICAgICAgLy8gZXF1YWwgaW50ZXJ2YWxcbiAgICAgICAgbGltaXRzLnB1c2gobWluKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW07IGkrKykge1xuICAgICAgICAgICAgbGltaXRzLnB1c2gobWluICsgKGkgLyBudW0pICogKG1heCAtIG1pbikpO1xuICAgICAgICB9XG4gICAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgfSBlbHNlIGlmIChtb2RlLnN1YnN0cigwLCAxKSA9PT0gJ2wnKSB7XG4gICAgICAgIC8vIGxvZyBzY2FsZVxuICAgICAgICBpZiAobWluIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnTG9nYXJpdGhtaWMgc2NhbGVzIGFyZSBvbmx5IHBvc3NpYmxlIGZvciB2YWx1ZXMgPiAwJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW5fbG9nID0gTWF0aC5MT0cxMEUgKiBsb2ckMShtaW4pO1xuICAgICAgICBjb25zdCBtYXhfbG9nID0gTWF0aC5MT0cxMEUgKiBsb2ckMShtYXgpO1xuICAgICAgICBsaW1pdHMucHVzaChtaW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bTsgaSsrKSB7XG4gICAgICAgICAgICBsaW1pdHMucHVzaChwb3ckMSgxMCwgbWluX2xvZyArIChpIC8gbnVtKSAqIChtYXhfbG9nIC0gbWluX2xvZykpKTtcbiAgICAgICAgfVxuICAgICAgICBsaW1pdHMucHVzaChtYXgpO1xuICAgIH0gZWxzZSBpZiAobW9kZS5zdWJzdHIoMCwgMSkgPT09ICdxJykge1xuICAgICAgICAvLyBxdWFudGlsZSBzY2FsZVxuICAgICAgICBsaW1pdHMucHVzaChtaW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gKCh2YWx1ZXMubGVuZ3RoIC0gMSkgKiBpKSAvIG51bTtcbiAgICAgICAgICAgIGNvbnN0IHBiID0gZmxvb3IocCk7XG4gICAgICAgICAgICBpZiAocGIgPT09IHApIHtcbiAgICAgICAgICAgICAgICBsaW1pdHMucHVzaCh2YWx1ZXNbcGJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcCA+IHBiXG4gICAgICAgICAgICAgICAgY29uc3QgcHIgPSBwIC0gcGI7XG4gICAgICAgICAgICAgICAgbGltaXRzLnB1c2godmFsdWVzW3BiXSAqICgxIC0gcHIpICsgdmFsdWVzW3BiICsgMV0gKiBwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGltaXRzLnB1c2gobWF4KTtcbiAgICB9IGVsc2UgaWYgKG1vZGUuc3Vic3RyKDAsIDEpID09PSAnaycpIHtcbiAgICAgICAgLy8gay1tZWFucyBjbHVzdGVyaW5nXG4gICAgICAgIC8qXG4gICAgICAgIGltcGxlbWVudGF0aW9uIGJhc2VkIG9uXG4gICAgICAgIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9maWd1ZS9zb3VyY2UvYnJvd3NlL3RydW5rL2ZpZ3VlLmpzIzMzNlxuICAgICAgICBzaW1wbGlmaWVkIGZvciAxLWQgaW5wdXQgdmFsdWVzXG4gICAgICAgICovXG4gICAgICAgIGxldCBjbHVzdGVyO1xuICAgICAgICBjb25zdCBuID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYXNzaWdubWVudHMgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJTaXplcyA9IG5ldyBBcnJheShudW0pO1xuICAgICAgICBsZXQgcmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgbGV0IG5iX2l0ZXJzID0gMDtcbiAgICAgICAgbGV0IGNlbnRyb2lkcyA9IG51bGw7XG5cbiAgICAgICAgLy8gZ2V0IHNlZWQgdmFsdWVzXG4gICAgICAgIGNlbnRyb2lkcyA9IFtdO1xuICAgICAgICBjZW50cm9pZHMucHVzaChtaW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bTsgaSsrKSB7XG4gICAgICAgICAgICBjZW50cm9pZHMucHVzaChtaW4gKyAoaSAvIG51bSkgKiAobWF4IC0gbWluKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2VudHJvaWRzLnB1c2gobWF4KTtcblxuICAgICAgICB3aGlsZSAocmVwZWF0KSB7XG4gICAgICAgICAgICAvLyBhc3NpZ25tZW50IHN0ZXBcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVyU2l6ZXNbal0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgbWluZGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICAgICAgbGV0IGJlc3Q7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW07IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXN0ID0gYWJzJDEoY2VudHJvaWRzW2pdIC0gdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IG1pbmRpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdCA9IGo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2x1c3RlclNpemVzW2Jlc3RdKys7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRzW2ldID0gYmVzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBjZW50cm9pZHMgc3RlcFxuICAgICAgICAgICAgY29uc3QgbmV3Q2VudHJvaWRzID0gbmV3IEFycmF5KG51bSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bTsgaisrKSB7XG4gICAgICAgICAgICAgICAgbmV3Q2VudHJvaWRzW2pdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2x1c3RlciA9IGFzc2lnbm1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChuZXdDZW50cm9pZHNbY2x1c3Rlcl0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2VudHJvaWRzW2NsdXN0ZXJdID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NlbnRyb2lkc1tjbHVzdGVyXSArPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW07IGorKykge1xuICAgICAgICAgICAgICAgIG5ld0NlbnRyb2lkc1tqXSAqPSAxIC8gY2x1c3RlclNpemVzW2pdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBjb252ZXJnZW5jZVxuICAgICAgICAgICAgcmVwZWF0ID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0NlbnRyb2lkc1tqXSAhPT0gY2VudHJvaWRzW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2VudHJvaWRzID0gbmV3Q2VudHJvaWRzO1xuICAgICAgICAgICAgbmJfaXRlcnMrKztcblxuICAgICAgICAgICAgaWYgKG5iX2l0ZXJzID4gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmVwZWF0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5pc2hlZCBrLW1lYW5zIGNsdXN0ZXJpbmdcbiAgICAgICAgLy8gdGhlIG5leHQgcGFydCBpcyBib3Jyb3dlZCBmcm9tIGdhYnJpZWxmbG9yLml0XG4gICAgICAgIGNvbnN0IGtDbHVzdGVycyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bTsgaisrKSB7XG4gICAgICAgICAgICBrQ2x1c3RlcnNbal0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY2x1c3RlciA9IGFzc2lnbm1lbnRzW2ldO1xuICAgICAgICAgICAga0NsdXN0ZXJzW2NsdXN0ZXJdLnB1c2godmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG1wS01lYW5zQnJlYWtzID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtOyBqKyspIHtcbiAgICAgICAgICAgIHRtcEtNZWFuc0JyZWFrcy5wdXNoKGtDbHVzdGVyc1tqXVswXSk7XG4gICAgICAgICAgICB0bXBLTWVhbnNCcmVha3MucHVzaChrQ2x1c3RlcnNbal1ba0NsdXN0ZXJzW2pdLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfVxuICAgICAgICB0bXBLTWVhbnNCcmVha3MgPSB0bXBLTWVhbnNCcmVha3Muc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICBsaW1pdHMucHVzaCh0bXBLTWVhbnNCcmVha3NbMF0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRtcEtNZWFuc0JyZWFrcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRtcEtNZWFuc0JyZWFrc1tpXTtcbiAgICAgICAgICAgIGlmICghaXNOYU4odikgJiYgbGltaXRzLmluZGV4T2YodikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGltaXRzLnB1c2godik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbWl0cztcbn1cblxudmFyIGNvbnRyYXN0ID0gKGEsIGIpID0+IHtcbiAgICAvLyBXQ0FHIGNvbnRyYXN0IHJhdGlvXG4gICAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jY29udHJhc3QtcmF0aW9kZWZcbiAgICBhID0gbmV3IENvbG9yKGEpO1xuICAgIGIgPSBuZXcgQ29sb3IoYik7XG4gICAgY29uc3QgbDEgPSBhLmx1bWluYW5jZSgpO1xuICAgIGNvbnN0IGwyID0gYi5sdW1pbmFuY2UoKTtcbiAgICByZXR1cm4gbDEgPiBsMiA/IChsMSArIDAuMDUpIC8gKGwyICsgMC4wNSkgOiAobDIgKyAwLjA1KSAvIChsMSArIDAuMDUpO1xufTtcblxuY29uc3QgeyBzcXJ0LCBwb3csIG1pbiwgbWF4OiBtYXgkMSwgYXRhbjIsIGFicywgY29zLCBzaW4sIGV4cCwgUEkgfSA9IE1hdGg7XG5cbmZ1bmN0aW9uIGRlbHRhRSAoYSwgYiwgS2wgPSAxLCBLYyA9IDEsIEtoID0gMSkge1xuICAgIC8vIERlbHRhIEUgKENJRSAyMDAwKVxuICAgIC8vIHNlZSBodHRwOi8vd3d3LmJydWNlbGluZGJsb29tLmNvbS9pbmRleC5odG1sP0Vxbl9EZWx0YUVfQ0lFMjAwMC5odG1sXG4gICAgdmFyIHJhZDJkZWcgPSBmdW5jdGlvbiAocmFkKSB7XG4gICAgICAgIHJldHVybiAoMzYwICogcmFkKSAvICgyICogUEkpO1xuICAgIH07XG4gICAgdmFyIGRlZzJyYWQgPSBmdW5jdGlvbiAoZGVnKSB7XG4gICAgICAgIHJldHVybiAoMiAqIFBJICogZGVnKSAvIDM2MDtcbiAgICB9O1xuICAgIGEgPSBuZXcgQ29sb3IoYSk7XG4gICAgYiA9IG5ldyBDb2xvcihiKTtcbiAgICBjb25zdCBbTDEsIGExLCBiMV0gPSBBcnJheS5mcm9tKGEubGFiKCkpO1xuICAgIGNvbnN0IFtMMiwgYTIsIGIyXSA9IEFycmF5LmZyb20oYi5sYWIoKSk7XG4gICAgY29uc3QgYXZnTCA9IChMMSArIEwyKSAvIDI7XG4gICAgY29uc3QgQzEgPSBzcXJ0KHBvdyhhMSwgMikgKyBwb3coYjEsIDIpKTtcbiAgICBjb25zdCBDMiA9IHNxcnQocG93KGEyLCAyKSArIHBvdyhiMiwgMikpO1xuICAgIGNvbnN0IGF2Z0MgPSAoQzEgKyBDMikgLyAyO1xuICAgIGNvbnN0IEcgPSAwLjUgKiAoMSAtIHNxcnQocG93KGF2Z0MsIDcpIC8gKHBvdyhhdmdDLCA3KSArIHBvdygyNSwgNykpKSk7XG4gICAgY29uc3QgYTFwID0gYTEgKiAoMSArIEcpO1xuICAgIGNvbnN0IGEycCA9IGEyICogKDEgKyBHKTtcbiAgICBjb25zdCBDMXAgPSBzcXJ0KHBvdyhhMXAsIDIpICsgcG93KGIxLCAyKSk7XG4gICAgY29uc3QgQzJwID0gc3FydChwb3coYTJwLCAyKSArIHBvdyhiMiwgMikpO1xuICAgIGNvbnN0IGF2Z0NwID0gKEMxcCArIEMycCkgLyAyO1xuICAgIGNvbnN0IGFyY3RhbjEgPSByYWQyZGVnKGF0YW4yKGIxLCBhMXApKTtcbiAgICBjb25zdCBhcmN0YW4yID0gcmFkMmRlZyhhdGFuMihiMiwgYTJwKSk7XG4gICAgY29uc3QgaDFwID0gYXJjdGFuMSA+PSAwID8gYXJjdGFuMSA6IGFyY3RhbjEgKyAzNjA7XG4gICAgY29uc3QgaDJwID0gYXJjdGFuMiA+PSAwID8gYXJjdGFuMiA6IGFyY3RhbjIgKyAzNjA7XG4gICAgY29uc3QgYXZnSHAgPVxuICAgICAgICBhYnMoaDFwIC0gaDJwKSA+IDE4MCA/IChoMXAgKyBoMnAgKyAzNjApIC8gMiA6IChoMXAgKyBoMnApIC8gMjtcbiAgICBjb25zdCBUID1cbiAgICAgICAgMSAtXG4gICAgICAgIDAuMTcgKiBjb3MoZGVnMnJhZChhdmdIcCAtIDMwKSkgK1xuICAgICAgICAwLjI0ICogY29zKGRlZzJyYWQoMiAqIGF2Z0hwKSkgK1xuICAgICAgICAwLjMyICogY29zKGRlZzJyYWQoMyAqIGF2Z0hwICsgNikpIC1cbiAgICAgICAgMC4yICogY29zKGRlZzJyYWQoNCAqIGF2Z0hwIC0gNjMpKTtcbiAgICBsZXQgZGVsdGFIcCA9IGgycCAtIGgxcDtcbiAgICBkZWx0YUhwID1cbiAgICAgICAgYWJzKGRlbHRhSHApIDw9IDE4MFxuICAgICAgICAgICAgPyBkZWx0YUhwXG4gICAgICAgICAgICA6IGgycCA8PSBoMXBcbiAgICAgICAgICAgICAgPyBkZWx0YUhwICsgMzYwXG4gICAgICAgICAgICAgIDogZGVsdGFIcCAtIDM2MDtcbiAgICBkZWx0YUhwID0gMiAqIHNxcnQoQzFwICogQzJwKSAqIHNpbihkZWcycmFkKGRlbHRhSHApIC8gMik7XG4gICAgY29uc3QgZGVsdGFMID0gTDIgLSBMMTtcbiAgICBjb25zdCBkZWx0YUNwID0gQzJwIC0gQzFwO1xuICAgIGNvbnN0IHNsID0gMSArICgwLjAxNSAqIHBvdyhhdmdMIC0gNTAsIDIpKSAvIHNxcnQoMjAgKyBwb3coYXZnTCAtIDUwLCAyKSk7XG4gICAgY29uc3Qgc2MgPSAxICsgMC4wNDUgKiBhdmdDcDtcbiAgICBjb25zdCBzaCA9IDEgKyAwLjAxNSAqIGF2Z0NwICogVDtcbiAgICBjb25zdCBkZWx0YVRoZXRhID0gMzAgKiBleHAoLXBvdygoYXZnSHAgLSAyNzUpIC8gMjUsIDIpKTtcbiAgICBjb25zdCBSYyA9IDIgKiBzcXJ0KHBvdyhhdmdDcCwgNykgLyAocG93KGF2Z0NwLCA3KSArIHBvdygyNSwgNykpKTtcbiAgICBjb25zdCBSdCA9IC1SYyAqIHNpbigyICogZGVnMnJhZChkZWx0YVRoZXRhKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gc3FydChcbiAgICAgICAgcG93KGRlbHRhTCAvIChLbCAqIHNsKSwgMikgK1xuICAgICAgICAgICAgcG93KGRlbHRhQ3AgLyAoS2MgKiBzYyksIDIpICtcbiAgICAgICAgICAgIHBvdyhkZWx0YUhwIC8gKEtoICogc2gpLCAyKSArXG4gICAgICAgICAgICBSdCAqIChkZWx0YUNwIC8gKEtjICogc2MpKSAqIChkZWx0YUhwIC8gKEtoICogc2gpKVxuICAgICk7XG4gICAgcmV0dXJuIG1heCQxKDAsIG1pbigxMDAsIHJlc3VsdCkpO1xufVxuXG4vLyBzaW1wbGUgRXVjbGlkZWFuIGRpc3RhbmNlXG5mdW5jdGlvbiBkaXN0YW5jZSAoYSwgYiwgbW9kZSA9ICdsYWInKSB7XG4gICAgLy8gRGVsdGEgRSAoQ0lFIDE5NzYpXG4gICAgLy8gc2VlIGh0dHA6Ly93d3cuYnJ1Y2VsaW5kYmxvb20uY29tL2luZGV4Lmh0bWw/RXF1YXRpb25zLmh0bWxcbiAgICBhID0gbmV3IENvbG9yKGEpO1xuICAgIGIgPSBuZXcgQ29sb3IoYik7XG4gICAgY29uc3QgbDEgPSBhLmdldChtb2RlKTtcbiAgICBjb25zdCBsMiA9IGIuZ2V0KG1vZGUpO1xuICAgIGxldCBzdW1fc3EgPSAwO1xuICAgIGZvciAobGV0IGkgaW4gbDEpIHtcbiAgICAgICAgY29uc3QgZCA9IChsMVtpXSB8fCAwKSAtIChsMltpXSB8fCAwKTtcbiAgICAgICAgc3VtX3NxICs9IGQgKiBkO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHN1bV9zcSk7XG59XG5cbnZhciB2YWxpZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IENvbG9yKC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuLy8gc29tZSBwcmUtZGVmaW5lZCBjb2xvciBzY2FsZXM6XG5cbnZhciBzY2FsZXMgPSB7XG4gICAgY29vbCgpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlKFtjaHJvbWEuaHNsKDE4MCwgMSwgMC45KSwgY2hyb21hLmhzbCgyNTAsIDAuNywgMC40KV0pO1xuICAgIH0sXG4gICAgaG90KCkge1xuICAgICAgICByZXR1cm4gc2NhbGUoWycjMDAwJywgJyNmMDAnLCAnI2ZmMCcsICcjZmZmJ10pLm1vZGUoXG4gICAgICAgICAgICAncmdiJ1xuICAgICAgICApO1xuICAgIH1cbn07XG5cbi8qKlxuICAgIENvbG9yQnJld2VyIGNvbG9ycyBmb3IgY2hyb21hLmpzXG5cbiAgICBDb3B5cmlnaHQgKGMpIDIwMDIgQ3ludGhpYSBCcmV3ZXIsIE1hcmsgSGFycm93ZXIsIGFuZCBUaGVcbiAgICBQZW5uc3lsdmFuaWEgU3RhdGUgVW5pdmVyc2l0eS5cblxuICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZFxuICAgIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SXG4gICAgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAgICBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuY29uc3QgY29sb3JicmV3ZXIgPSB7XG4gICAgLy8gc2VxdWVudGlhbFxuICAgIE9yUmQ6IFsnI2ZmZjdlYycsICcjZmVlOGM4JywgJyNmZGQ0OWUnLCAnI2ZkYmI4NCcsICcjZmM4ZDU5JywgJyNlZjY1NDgnLCAnI2Q3MzAxZicsICcjYjMwMDAwJywgJyM3ZjAwMDAnXSxcbiAgICBQdUJ1OiBbJyNmZmY3ZmInLCAnI2VjZTdmMicsICcjZDBkMWU2JywgJyNhNmJkZGInLCAnIzc0YTljZicsICcjMzY5MGMwJywgJyMwNTcwYjAnLCAnIzA0NWE4ZCcsICcjMDIzODU4J10sXG4gICAgQnVQdTogWycjZjdmY2ZkJywgJyNlMGVjZjQnLCAnI2JmZDNlNicsICcjOWViY2RhJywgJyM4Yzk2YzYnLCAnIzhjNmJiMScsICcjODg0MTlkJywgJyM4MTBmN2MnLCAnIzRkMDA0YiddLFxuICAgIE9yYW5nZXM6IFsnI2ZmZjVlYicsICcjZmVlNmNlJywgJyNmZGQwYTInLCAnI2ZkYWU2YicsICcjZmQ4ZDNjJywgJyNmMTY5MTMnLCAnI2Q5NDgwMScsICcjYTYzNjAzJywgJyM3ZjI3MDQnXSxcbiAgICBCdUduOiBbJyNmN2ZjZmQnLCAnI2U1ZjVmOScsICcjY2NlY2U2JywgJyM5OWQ4YzknLCAnIzY2YzJhNCcsICcjNDFhZTc2JywgJyMyMzhiNDUnLCAnIzAwNmQyYycsICcjMDA0NDFiJ10sXG4gICAgWWxPckJyOiBbJyNmZmZmZTUnLCAnI2ZmZjdiYycsICcjZmVlMzkxJywgJyNmZWM0NGYnLCAnI2ZlOTkyOScsICcjZWM3MDE0JywgJyNjYzRjMDInLCAnIzk5MzQwNCcsICcjNjYyNTA2J10sXG4gICAgWWxHbjogWycjZmZmZmU1JywgJyNmN2ZjYjknLCAnI2Q5ZjBhMycsICcjYWRkZDhlJywgJyM3OGM2NzknLCAnIzQxYWI1ZCcsICcjMjM4NDQzJywgJyMwMDY4MzcnLCAnIzAwNDUyOSddLFxuICAgIFJlZHM6IFsnI2ZmZjVmMCcsICcjZmVlMGQyJywgJyNmY2JiYTEnLCAnI2ZjOTI3MicsICcjZmI2YTRhJywgJyNlZjNiMmMnLCAnI2NiMTgxZCcsICcjYTUwZjE1JywgJyM2NzAwMGQnXSxcbiAgICBSZFB1OiBbJyNmZmY3ZjMnLCAnI2ZkZTBkZCcsICcjZmNjNWMwJywgJyNmYTlmYjUnLCAnI2Y3NjhhMScsICcjZGQzNDk3JywgJyNhZTAxN2UnLCAnIzdhMDE3NycsICcjNDkwMDZhJ10sXG4gICAgR3JlZW5zOiBbJyNmN2ZjZjUnLCAnI2U1ZjVlMCcsICcjYzdlOWMwJywgJyNhMWQ5OWInLCAnIzc0YzQ3NicsICcjNDFhYjVkJywgJyMyMzhiNDUnLCAnIzAwNmQyYycsICcjMDA0NDFiJ10sXG4gICAgWWxHbkJ1OiBbJyNmZmZmZDknLCAnI2VkZjhiMScsICcjYzdlOWI0JywgJyM3ZmNkYmInLCAnIzQxYjZjNCcsICcjMWQ5MWMwJywgJyMyMjVlYTgnLCAnIzI1MzQ5NCcsICcjMDgxZDU4J10sXG4gICAgUHVycGxlczogWycjZmNmYmZkJywgJyNlZmVkZjUnLCAnI2RhZGFlYicsICcjYmNiZGRjJywgJyM5ZTlhYzgnLCAnIzgwN2RiYScsICcjNmE1MWEzJywgJyM1NDI3OGYnLCAnIzNmMDA3ZCddLFxuICAgIEduQnU6IFsnI2Y3ZmNmMCcsICcjZTBmM2RiJywgJyNjY2ViYzUnLCAnI2E4ZGRiNScsICcjN2JjY2M0JywgJyM0ZWIzZDMnLCAnIzJiOGNiZScsICcjMDg2OGFjJywgJyMwODQwODEnXSxcbiAgICBHcmV5czogWycjZmZmZmZmJywgJyNmMGYwZjAnLCAnI2Q5ZDlkOScsICcjYmRiZGJkJywgJyM5Njk2OTYnLCAnIzczNzM3MycsICcjNTI1MjUyJywgJyMyNTI1MjUnLCAnIzAwMDAwMCddLFxuICAgIFlsT3JSZDogWycjZmZmZmNjJywgJyNmZmVkYTAnLCAnI2ZlZDk3NicsICcjZmViMjRjJywgJyNmZDhkM2MnLCAnI2ZjNGUyYScsICcjZTMxYTFjJywgJyNiZDAwMjYnLCAnIzgwMDAyNiddLFxuICAgIFB1UmQ6IFsnI2Y3ZjRmOScsICcjZTdlMWVmJywgJyNkNGI5ZGEnLCAnI2M5OTRjNycsICcjZGY2NWIwJywgJyNlNzI5OGEnLCAnI2NlMTI1NicsICcjOTgwMDQzJywgJyM2NzAwMWYnXSxcbiAgICBCbHVlczogWycjZjdmYmZmJywgJyNkZWViZjcnLCAnI2M2ZGJlZicsICcjOWVjYWUxJywgJyM2YmFlZDYnLCAnIzQyOTJjNicsICcjMjE3MWI1JywgJyMwODUxOWMnLCAnIzA4MzA2YiddLFxuICAgIFB1QnVHbjogWycjZmZmN2ZiJywgJyNlY2UyZjAnLCAnI2QwZDFlNicsICcjYTZiZGRiJywgJyM2N2E5Y2YnLCAnIzM2OTBjMCcsICcjMDI4MThhJywgJyMwMTZjNTknLCAnIzAxNDYzNiddLFxuICAgIFZpcmlkaXM6IFsnIzQ0MDE1NCcsICcjNDgyNzc3JywgJyMzZjRhOGEnLCAnIzMxNjc4ZScsICcjMjY4MzhmJywgJyMxZjlkOGEnLCAnIzZjY2U1YScsICcjYjZkZTJiJywgJyNmZWU4MjUnXSxcblxuICAgIC8vIGRpdmVyZ2luZ1xuICAgIFNwZWN0cmFsOiBbJyM5ZTAxNDInLCAnI2Q1M2U0ZicsICcjZjQ2ZDQzJywgJyNmZGFlNjEnLCAnI2ZlZTA4YicsICcjZmZmZmJmJywgJyNlNmY1OTgnLCAnI2FiZGRhNCcsICcjNjZjMmE1JywgJyMzMjg4YmQnLCAnIzVlNGZhMiddLFxuICAgIFJkWWxHbjogWycjYTUwMDI2JywgJyNkNzMwMjcnLCAnI2Y0NmQ0MycsICcjZmRhZTYxJywgJyNmZWUwOGInLCAnI2ZmZmZiZicsICcjZDllZjhiJywgJyNhNmQ5NmEnLCAnIzY2YmQ2MycsICcjMWE5ODUwJywgJyMwMDY4MzcnXSxcbiAgICBSZEJ1OiBbJyM2NzAwMWYnLCAnI2IyMTgyYicsICcjZDY2MDRkJywgJyNmNGE1ODInLCAnI2ZkZGJjNycsICcjZjdmN2Y3JywgJyNkMWU1ZjAnLCAnIzkyYzVkZScsICcjNDM5M2MzJywgJyMyMTY2YWMnLCAnIzA1MzA2MSddLFxuICAgIFBpWUc6IFsnIzhlMDE1MicsICcjYzUxYjdkJywgJyNkZTc3YWUnLCAnI2YxYjZkYScsICcjZmRlMGVmJywgJyNmN2Y3ZjcnLCAnI2U2ZjVkMCcsICcjYjhlMTg2JywgJyM3ZmJjNDEnLCAnIzRkOTIyMScsICcjMjc2NDE5J10sXG4gICAgUFJHbjogWycjNDAwMDRiJywgJyM3NjJhODMnLCAnIzk5NzBhYicsICcjYzJhNWNmJywgJyNlN2Q0ZTgnLCAnI2Y3ZjdmNycsICcjZDlmMGQzJywgJyNhNmRiYTAnLCAnIzVhYWU2MScsICcjMWI3ODM3JywgJyMwMDQ0MWInXSxcbiAgICBSZFlsQnU6IFsnI2E1MDAyNicsICcjZDczMDI3JywgJyNmNDZkNDMnLCAnI2ZkYWU2MScsICcjZmVlMDkwJywgJyNmZmZmYmYnLCAnI2UwZjNmOCcsICcjYWJkOWU5JywgJyM3NGFkZDEnLCAnIzQ1NzViNCcsICcjMzEzNjk1J10sXG4gICAgQnJCRzogWycjNTQzMDA1JywgJyM4YzUxMGEnLCAnI2JmODEyZCcsICcjZGZjMjdkJywgJyNmNmU4YzMnLCAnI2Y1ZjVmNScsICcjYzdlYWU1JywgJyM4MGNkYzEnLCAnIzM1OTc4ZicsICcjMDE2NjVlJywgJyMwMDNjMzAnXSxcbiAgICBSZEd5OiBbJyM2NzAwMWYnLCAnI2IyMTgyYicsICcjZDY2MDRkJywgJyNmNGE1ODInLCAnI2ZkZGJjNycsICcjZmZmZmZmJywgJyNlMGUwZTAnLCAnI2JhYmFiYScsICcjODc4Nzg3JywgJyM0ZDRkNGQnLCAnIzFhMWExYSddLFxuICAgIFB1T3I6IFsnIzdmM2IwOCcsICcjYjM1ODA2JywgJyNlMDgyMTQnLCAnI2ZkYjg2MycsICcjZmVlMGI2JywgJyNmN2Y3ZjcnLCAnI2Q4ZGFlYicsICcjYjJhYmQyJywgJyM4MDczYWMnLCAnIzU0Mjc4OCcsICcjMmQwMDRiJ10sXG5cbiAgICAvLyBxdWFsaXRhdGl2ZVxuICAgIFNldDI6IFsnIzY2YzJhNScsICcjZmM4ZDYyJywgJyM4ZGEwY2InLCAnI2U3OGFjMycsICcjYTZkODU0JywgJyNmZmQ5MmYnLCAnI2U1YzQ5NCcsICcjYjNiM2IzJ10sXG4gICAgQWNjZW50OiBbJyM3ZmM5N2YnLCAnI2JlYWVkNCcsICcjZmRjMDg2JywgJyNmZmZmOTknLCAnIzM4NmNiMCcsICcjZjAwMjdmJywgJyNiZjViMTcnLCAnIzY2NjY2NiddLFxuICAgIFNldDE6IFsnI2U0MWExYycsICcjMzc3ZWI4JywgJyM0ZGFmNGEnLCAnIzk4NGVhMycsICcjZmY3ZjAwJywgJyNmZmZmMzMnLCAnI2E2NTYyOCcsICcjZjc4MWJmJywgJyM5OTk5OTknXSxcbiAgICBTZXQzOiBbJyM4ZGQzYzcnLCAnI2ZmZmZiMycsICcjYmViYWRhJywgJyNmYjgwNzInLCAnIzgwYjFkMycsICcjZmRiNDYyJywgJyNiM2RlNjknLCAnI2ZjY2RlNScsICcjZDlkOWQ5JywgJyNiYzgwYmQnLCAnI2NjZWJjNScsICcjZmZlZDZmJ10sXG4gICAgRGFyazI6IFsnIzFiOWU3NycsICcjZDk1ZjAyJywgJyM3NTcwYjMnLCAnI2U3Mjk4YScsICcjNjZhNjFlJywgJyNlNmFiMDInLCAnI2E2NzYxZCcsICcjNjY2NjY2J10sXG4gICAgUGFpcmVkOiBbJyNhNmNlZTMnLCAnIzFmNzhiNCcsICcjYjJkZjhhJywgJyMzM2EwMmMnLCAnI2ZiOWE5OScsICcjZTMxYTFjJywgJyNmZGJmNmYnLCAnI2ZmN2YwMCcsICcjY2FiMmQ2JywgJyM2YTNkOWEnLCAnI2ZmZmY5OScsICcjYjE1OTI4J10sXG4gICAgUGFzdGVsMjogWycjYjNlMmNkJywgJyNmZGNkYWMnLCAnI2NiZDVlOCcsICcjZjRjYWU0JywgJyNlNmY1YzknLCAnI2ZmZjJhZScsICcjZjFlMmNjJywgJyNjY2NjY2MnXSxcbiAgICBQYXN0ZWwxOiBbJyNmYmI0YWUnLCAnI2IzY2RlMycsICcjY2NlYmM1JywgJyNkZWNiZTQnLCAnI2ZlZDlhNicsICcjZmZmZmNjJywgJyNlNWQ4YmQnLCAnI2ZkZGFlYycsICcjZjJmMmYyJ11cbn07XG5cbi8vIGFkZCBsb3dlcmNhc2UgYWxpYXNlcyBmb3IgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGVzXG5mb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoY29sb3JicmV3ZXIpKSB7XG4gICAgY29sb3JicmV3ZXJba2V5LnRvTG93ZXJDYXNlKCldID0gY29sb3JicmV3ZXJba2V5XTtcbn1cblxuY29uc3QgY215azJyZ2IgPSAoLi4uYXJncykgPT4ge1xuICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2NteWsnKTtcbiAgICBjb25zdCBbYywgbSwgeSwga10gPSBhcmdzO1xuICAgIGNvbnN0IGFscGhhID0gYXJncy5sZW5ndGggPiA0ID8gYXJnc1s0XSA6IDE7XG4gICAgaWYgKGsgPT09IDEpIHJldHVybiBbMCwgMCwgMCwgYWxwaGFdO1xuICAgIHJldHVybiBbXG4gICAgICAgIGMgPj0gMSA/IDAgOiAyNTUgKiAoMSAtIGMpICogKDEgLSBrKSwgLy8gclxuICAgICAgICBtID49IDEgPyAwIDogMjU1ICogKDEgLSBtKSAqICgxIC0gayksIC8vIGdcbiAgICAgICAgeSA+PSAxID8gMCA6IDI1NSAqICgxIC0geSkgKiAoMSAtIGspLCAvLyBiXG4gICAgICAgIGFscGhhXG4gICAgXTtcbn07XG5cbmNvbnN0IHsgbWF4IH0gPSBNYXRoO1xuXG5jb25zdCByZ2IyY215ayA9ICguLi5hcmdzKSA9PiB7XG4gICAgbGV0IFtyLCBnLCBiXSA9IHVucGFjayhhcmdzLCAncmdiJyk7XG4gICAgciA9IHIgLyAyNTU7XG4gICAgZyA9IGcgLyAyNTU7XG4gICAgYiA9IGIgLyAyNTU7XG4gICAgY29uc3QgayA9IDEgLSBtYXgociwgbWF4KGcsIGIpKTtcbiAgICBjb25zdCBmID0gayA8IDEgPyAxIC8gKDEgLSBrKSA6IDA7XG4gICAgY29uc3QgYyA9ICgxIC0gciAtIGspICogZjtcbiAgICBjb25zdCBtID0gKDEgLSBnIC0gaykgKiBmO1xuICAgIGNvbnN0IHkgPSAoMSAtIGIgLSBrKSAqIGY7XG4gICAgcmV0dXJuIFtjLCBtLCB5LCBrXTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5jbXlrID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IyY215ayh0aGlzLl9yZ2IpO1xufTtcblxuY29uc3QgY215ayA9ICguLi5hcmdzKSA9PiBuZXcgQ29sb3IoLi4uYXJncywgJ2NteWsnKTtcbk9iamVjdC5hc3NpZ24oY2hyb21hLCB7IGNteWsgfSk7XG5cbmlucHV0LmZvcm1hdC5jbXlrID0gY215azJyZ2I7XG5cbmlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMixcbiAgICB0ZXN0OiAoLi4uYXJncykgPT4ge1xuICAgICAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdjbXlrJyk7XG4gICAgICAgIGlmICh0eXBlKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NteWsnO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qXG4gKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICogLSBoc2wyY3NzKGgscyxsKVxuICogLSBoc2wyY3NzKGgscyxsLGEpXG4gKiAtIGhzbDJjc3MoW2gscyxsXSwgbW9kZSlcbiAqIC0gaHNsMmNzcyhbaCxzLGwsYV0sIG1vZGUpXG4gKiAtIGhzbDJjc3Moe2gscyxsLGF9LCBtb2RlKVxuICovXG5jb25zdCBoc2wyY3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBoc2xhID0gdW5wYWNrKGFyZ3MsICdoc2xhJyk7XG4gICAgbGV0IG1vZGUgPSBsYXN0KGFyZ3MpIHx8ICdsc2EnO1xuICAgIGhzbGFbMF0gPSBybmQyKGhzbGFbMF0gfHwgMCkgKyAnZGVnJztcbiAgICBoc2xhWzFdID0gcm5kMihoc2xhWzFdICogMTAwKSArICclJztcbiAgICBoc2xhWzJdID0gcm5kMihoc2xhWzJdICogMTAwKSArICclJztcbiAgICBpZiAobW9kZSA9PT0gJ2hzbGEnIHx8IChoc2xhLmxlbmd0aCA+IDMgJiYgaHNsYVszXSA8IDEpKSB7XG4gICAgICAgIGhzbGFbM10gPSAnLyAnICsgKGhzbGEubGVuZ3RoID4gMyA/IGhzbGFbM10gOiAxKTtcbiAgICAgICAgbW9kZSA9ICdoc2xhJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBoc2xhLmxlbmd0aCA9IDM7XG4gICAgfVxuICAgIHJldHVybiBgJHttb2RlLnN1YnN0cigwLCAzKX0oJHtoc2xhLmpvaW4oJyAnKX0pYDtcbn07XG5cbi8qXG4gKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICogLSBsYWIyY3NzKGwsYSxiKVxuICogLSBsYWIyY3NzKGwsYSxiLGFscGhhKVxuICogLSBsYWIyY3NzKFtsLGEsYl0sIG1vZGUpXG4gKiAtIGxhYjJjc3MoW2wsYSxiLGFscGhhXSwgbW9kZSlcbiAqL1xuY29uc3QgbGFiMmNzcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgbGFiYSA9IHVucGFjayhhcmdzLCAnbGFiJyk7XG4gICAgbGV0IG1vZGUgPSBsYXN0KGFyZ3MpIHx8ICdsYWInO1xuICAgIGxhYmFbMF0gPSBybmQyKGxhYmFbMF0pICsgJyUnO1xuICAgIGxhYmFbMV0gPSBybmQyKGxhYmFbMV0pO1xuICAgIGxhYmFbMl0gPSBybmQyKGxhYmFbMl0pO1xuICAgIGlmIChtb2RlID09PSAnbGFiYScgfHwgKGxhYmEubGVuZ3RoID4gMyAmJiBsYWJhWzNdIDwgMSkpIHtcbiAgICAgICAgbGFiYVszXSA9ICcvICcgKyAobGFiYS5sZW5ndGggPiAzID8gbGFiYVszXSA6IDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmEubGVuZ3RoID0gMztcbiAgICB9XG4gICAgcmV0dXJuIGBsYWIoJHtsYWJhLmpvaW4oJyAnKX0pYDtcbn07XG5cbi8qXG4gKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICogLSBsYWIyY3NzKGwsYSxiKVxuICogLSBsYWIyY3NzKGwsYSxiLGFscGhhKVxuICogLSBsYWIyY3NzKFtsLGEsYl0sIG1vZGUpXG4gKiAtIGxhYjJjc3MoW2wsYSxiLGFscGhhXSwgbW9kZSlcbiAqL1xuY29uc3QgbGNoMmNzcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgbGNoYSA9IHVucGFjayhhcmdzLCAnbGNoJyk7XG4gICAgbGV0IG1vZGUgPSBsYXN0KGFyZ3MpIHx8ICdsYWInO1xuICAgIGxjaGFbMF0gPSBybmQyKGxjaGFbMF0pICsgJyUnO1xuICAgIGxjaGFbMV0gPSBybmQyKGxjaGFbMV0pO1xuICAgIGxjaGFbMl0gPSBybmQyKGxjaGFbMl0pICsgJ2RlZyc7IC8vIGFkZCBkZWcgdW5pdCB0byBodWVcbiAgICBpZiAobW9kZSA9PT0gJ2xjaGEnIHx8IChsY2hhLmxlbmd0aCA+IDMgJiYgbGNoYVszXSA8IDEpKSB7XG4gICAgICAgIGxjaGFbM10gPSAnLyAnICsgKGxjaGEubGVuZ3RoID4gMyA/IGxjaGFbM10gOiAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsY2hhLmxlbmd0aCA9IDM7XG4gICAgfVxuICAgIHJldHVybiBgbGNoKCR7bGNoYS5qb2luKCcgJyl9KWA7XG59O1xuXG5jb25zdCBva2xhYjJjc3MkMSA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgbGFiYSA9IHVucGFjayhhcmdzLCAnbGFiJyk7XG4gICAgbGFiYVswXSA9IHJuZDIobGFiYVswXSAqIDEwMCkgKyAnJSc7XG4gICAgbGFiYVsxXSA9IHJuZDMobGFiYVsxXSk7XG4gICAgbGFiYVsyXSA9IHJuZDMobGFiYVsyXSk7XG4gICAgaWYgKGxhYmEubGVuZ3RoID4gMyAmJiBsYWJhWzNdIDwgMSkge1xuICAgICAgICBsYWJhWzNdID0gJy8gJyArIChsYWJhLmxlbmd0aCA+IDMgPyBsYWJhWzNdIDogMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGFiYS5sZW5ndGggPSAzO1xuICAgIH1cbiAgICByZXR1cm4gYG9rbGFiKCR7bGFiYS5qb2luKCcgJyl9KWA7XG59O1xuXG5jb25zdCByZ2Iyb2tsY2ggPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IFtyLCBnLCBiLCAuLi5yZXN0XSA9IHVucGFjayhhcmdzLCAncmdiJyk7XG4gICAgY29uc3QgW2wsIGEsIGJfXSA9IHJnYjJva2xhYihyLCBnLCBiKTtcbiAgICBjb25zdCBbTCwgYywgaF0gPSBsYWIybGNoKGwsIGEsIGJfKTtcbiAgICByZXR1cm4gW0wsIGMsIGgsIC4uLihyZXN0Lmxlbmd0aCA+IDAgJiYgcmVzdFswXSA8IDEgPyBbcmVzdFswXV0gOiBbXSldO1xufTtcblxuY29uc3Qgb2tsYWIyY3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBsYWJhID0gdW5wYWNrKGFyZ3MsICdsYWInKTtcbiAgICBsYWJhWzBdID0gcm5kMihsYWJhWzBdICogMTAwKSArICclJztcbiAgICBsYWJhWzFdID0gcm5kMyhsYWJhWzFdKTtcbiAgICBsYWJhWzJdID0gcm5kMihsYWJhWzJdKSArICdkZWcnO1xuICAgIGlmIChsYWJhLmxlbmd0aCA+IDMgJiYgbGFiYVszXSA8IDEpIHtcbiAgICAgICAgbGFiYVszXSA9ICcvICcgKyAobGFiYS5sZW5ndGggPiAzID8gbGFiYVszXSA6IDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmEubGVuZ3RoID0gMztcbiAgICB9XG4gICAgcmV0dXJuIGBva2xjaCgke2xhYmEuam9pbignICcpfSlgO1xufTtcblxuY29uc3QgeyByb3VuZDogcm91bmQkMiB9ID0gTWF0aDtcblxuLypcbiAqIHN1cHBvcnRlZCBhcmd1bWVudHM6XG4gKiAtIHJnYjJjc3MocixnLGIpXG4gKiAtIHJnYjJjc3MocixnLGIsYSlcbiAqIC0gcmdiMmNzcyhbcixnLGJdLCBtb2RlKVxuICogLSByZ2IyY3NzKFtyLGcsYixhXSwgbW9kZSlcbiAqIC0gcmdiMmNzcyh7cixnLGIsYX0sIG1vZGUpXG4gKi9cbmNvbnN0IHJnYjJjc3MgPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHJnYmEgPSB1bnBhY2soYXJncywgJ3JnYmEnKTtcbiAgICBsZXQgbW9kZSA9IGxhc3QoYXJncykgfHwgJ3JnYic7XG4gICAgaWYgKG1vZGUuc3Vic3RyKDAsIDMpID09PSAnaHNsJykge1xuICAgICAgICByZXR1cm4gaHNsMmNzcyhyZ2IyaHNsJDEocmdiYSksIG1vZGUpO1xuICAgIH1cbiAgICBpZiAobW9kZS5zdWJzdHIoMCwgMykgPT09ICdsYWInKSB7XG4gICAgICAgIC8vIGNoYW5nZSB0byBENTAgbGFiIHdoaXRlcG9pbnQgc2luY2UgdGhpcyBpcyB3aGF0IFczQyBpcyB1c2luZyBmb3IgQ1NTIExhYiBjb2xvcnNcbiAgICAgICAgY29uc3QgcHJldldoaXRlUG9pbnQgPSBnZXRMYWJXaGl0ZVBvaW50KCk7XG4gICAgICAgIHNldExhYldoaXRlUG9pbnQoJ2Q1MCcpO1xuICAgICAgICBjb25zdCBjc3NDb2xvciA9IGxhYjJjc3MocmdiMmxhYihyZ2JhKSwgbW9kZSk7XG4gICAgICAgIHNldExhYldoaXRlUG9pbnQocHJldldoaXRlUG9pbnQpO1xuICAgICAgICByZXR1cm4gY3NzQ29sb3I7XG4gICAgfVxuICAgIGlmIChtb2RlLnN1YnN0cigwLCAzKSA9PT0gJ2xjaCcpIHtcbiAgICAgICAgLy8gY2hhbmdlIHRvIEQ1MCBsYWIgd2hpdGVwb2ludCBzaW5jZSB0aGlzIGlzIHdoYXQgVzNDIGlzIHVzaW5nIGZvciBDU1MgTGFiIGNvbG9yc1xuICAgICAgICBjb25zdCBwcmV2V2hpdGVQb2ludCA9IGdldExhYldoaXRlUG9pbnQoKTtcbiAgICAgICAgc2V0TGFiV2hpdGVQb2ludCgnZDUwJyk7XG4gICAgICAgIGNvbnN0IGNzc0NvbG9yID0gbGNoMmNzcyhyZ2IybGNoKHJnYmEpLCBtb2RlKTtcbiAgICAgICAgc2V0TGFiV2hpdGVQb2ludChwcmV2V2hpdGVQb2ludCk7XG4gICAgICAgIHJldHVybiBjc3NDb2xvcjtcbiAgICB9XG4gICAgaWYgKG1vZGUuc3Vic3RyKDAsIDUpID09PSAnb2tsYWInKSB7XG4gICAgICAgIHJldHVybiBva2xhYjJjc3MkMShyZ2Iyb2tsYWIocmdiYSkpO1xuICAgIH1cbiAgICBpZiAobW9kZS5zdWJzdHIoMCwgNSkgPT09ICdva2xjaCcpIHtcbiAgICAgICAgcmV0dXJuIG9rbGFiMmNzcyhyZ2Iyb2tsY2gocmdiYSkpO1xuICAgIH1cbiAgICByZ2JhWzBdID0gcm91bmQkMihyZ2JhWzBdKTtcbiAgICByZ2JhWzFdID0gcm91bmQkMihyZ2JhWzFdKTtcbiAgICByZ2JhWzJdID0gcm91bmQkMihyZ2JhWzJdKTtcbiAgICBpZiAobW9kZSA9PT0gJ3JnYmEnIHx8IChyZ2JhLmxlbmd0aCA+IDMgJiYgcmdiYVszXSA8IDEpKSB7XG4gICAgICAgIHJnYmFbM10gPSAnLyAnICsgKHJnYmEubGVuZ3RoID4gMyA/IHJnYmFbM10gOiAxKTtcbiAgICAgICAgbW9kZSA9ICdyZ2JhJztcbiAgICB9XG4gICAgcmV0dXJuIGAke21vZGUuc3Vic3RyKDAsIDMpfSgke3JnYmEuc2xpY2UoMCwgbW9kZSA9PT0gJ3JnYicgPyAzIDogNCkuam9pbignICcpfSlgO1xufTtcblxuY29uc3Qgb2tsY2gycmdiID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdsY2gnKTtcbiAgICBjb25zdCBbbCwgYywgaCwgLi4ucmVzdF0gPSBhcmdzO1xuICAgIGNvbnN0IFtMLCBhLCBiX10gPSBsY2gybGFiKGwsIGMsIGgpO1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IG9rbGFiMnJnYihMLCBhLCBiXyk7XG4gICAgcmV0dXJuIFtyLCBnLCBiLCAuLi4ocmVzdC5sZW5ndGggPiAwICYmIHJlc3RbMF0gPCAxID8gW3Jlc3RbMF1dIDogW10pXTtcbn07XG5cbmNvbnN0IFJFX1JHQiA9IC9ecmdiXFwoXFxzKigtP1xcZCspIFxccyooLT9cXGQrKVxccyogXFxzKigtP1xcZCspXFxzKlxcKSQvO1xuY29uc3QgUkVfUkdCX0xFR0FDWSA9IC9ecmdiXFwoXFxzKigtP1xcZCspLFxccyooLT9cXGQrKVxccyosXFxzKigtP1xcZCspXFxzKlxcKSQvO1xuXG5jb25zdCBSRV9SR0JBID1cbiAgICAvXnJnYmE/XFwoXFxzKigtP1xcZCspIFxccyooLT9cXGQrKVxccyogXFxzKigtP1xcZCspXFxzKlxcL1xccyooWzAxXXxbMDFdP1xcLlxcZCspXFwpJC87XG5jb25zdCBSRV9SR0JBX0xFR0FDWSA9XG4gICAgL15yZ2JhXFwoXFxzKigtP1xcZCspLFxccyooLT9cXGQrKVxccyosXFxzKigtP1xcZCspXFxzKixcXHMqKFswMV18WzAxXT9cXC5cXGQrKVxcKSQvO1xuXG5jb25zdCBSRV9SR0JfUENUID1cbiAgICAvXnJnYlxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSUgXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyogXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkkLztcbmNvbnN0IFJFX1JHQl9QQ1RfTEVHQUNZID1cbiAgICAvXnJnYlxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSUsXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkkLztcblxuY29uc3QgUkVfUkdCQV9QQ1QgPVxuICAgIC9ecmdiYT9cXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklIFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqIFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqXFwvXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcbmNvbnN0IFJFX1JHQkFfUENUX0xFR0FDWSA9XG4gICAgL15yZ2JhXFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJSxcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFswMV18WzAxXT9cXC5cXGQrKVxcKSQvO1xuXG5jb25zdCBSRV9IU0wgPVxuICAgIC9eaHNsXFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pZGVnIFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqIFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqXFwpJC87XG5jb25zdCBSRV9IU0xfTEVHQUNZID1cbiAgICAvXmhzbFxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSxcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKlxcKSQvO1xuXG5jb25zdCBSRV9IU0xBID1cbiAgICAvXmhzbGE/XFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pZGVnIFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqIFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqXFwvXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcbmNvbnN0IFJFX0hTTEFfTEVHQUNZID1cbiAgICAvXmhzbGFcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyksXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcblxuY29uc3QgUkVfTEFCID1cbiAgICAvXmxhYlxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/JT8pIFxccyooLT9cXGQrKD86XFwuXFxkKyk/JT8pIFxccyooLT9cXGQrKD86XFwuXFxkKyk/JT8pXFxzKig/OlxcL1xccyooXFxkKyg/OlxcLlxcZCspPykpP1xcKT8kLztcbmNvbnN0IFJFX0xDSCA9XG4gICAgL15sY2hcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyU/KSBcXHMqKCg/Oi0/XFxkKyg/OlxcLlxcZCspPyU/KXxub25lKSBcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyg/OmRlZyk/fG5vbmUpXFxzKig/OlxcL1xccyooXFxkKyg/OlxcLlxcZCspPykpP1xcKT8kLztcbmNvbnN0IFJFX09LTEFCID1cbiAgICAvXm9rbGFiXFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8lPykgXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8lPykgXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8lPylcXHMqKD86XFwvXFxzKihcXGQrKD86XFwuXFxkKyk/KSk/XFwpPyQvO1xuY29uc3QgUkVfT0tMQ0ggPVxuICAgIC9eb2tsY2hcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyU/KSBcXHMqKD86KC0/XFxkKyg/OlxcLlxcZCspPyU/KXxub25lKSBcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyg/OmRlZyk/fG5vbmUpXFxzKig/OlxcL1xccyooXFxkKyg/OlxcLlxcZCspPykpP1xcKT8kLztcblxuY29uc3QgeyByb3VuZDogcm91bmQkMSB9ID0gTWF0aDtcblxuY29uc3Qgcm91bmRSR0IgPSAocmdiKSA9PiB7XG4gICAgcmV0dXJuIHJnYi5tYXAoKHYsIGkpID0+IChpIDw9IDIgPyBsaW1pdChyb3VuZCQxKHYpLCAwLCAyNTUpIDogdikpO1xufTtcblxuY29uc3QgcGVyY2VudFRvQWJzb2x1dGUgPSAocGN0LCBtaW4gPSAwLCBtYXggPSAxMDAsIHNpZ25lZCA9IGZhbHNlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwY3QgPT09ICdzdHJpbmcnICYmIHBjdC5lbmRzV2l0aCgnJScpKSB7XG4gICAgICAgIHBjdCA9IHBhcnNlRmxvYXQocGN0LnN1YnN0cmluZygwLCBwY3QubGVuZ3RoIC0gMSkpIC8gMTAwO1xuICAgICAgICBpZiAoc2lnbmVkKSB7XG4gICAgICAgICAgICAvLyBzaWduZWQgcGVyY2VudGFnZXMgYXJlIGluIHRoZSByYW5nZSAtMTAwJSB0byAxMDAlXG4gICAgICAgICAgICBwY3QgPSBtaW4gKyAocGN0ICsgMSkgKiAwLjUgKiAobWF4IC0gbWluKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBjdCA9IG1pbiArIHBjdCAqIChtYXggLSBtaW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiArcGN0O1xufTtcblxuY29uc3Qgbm9uZVRvVmFsdWUgPSAodiwgbm9uZVZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHYgPT09ICdub25lJyA/IG5vbmVWYWx1ZSA6IHY7XG59O1xuXG5jb25zdCBjc3MycmdiID0gKGNzcykgPT4ge1xuICAgIGNzcyA9IGNzcy50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICBsZXQgbTtcblxuICAgIGlmIChpbnB1dC5mb3JtYXQubmFtZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5mb3JtYXQubmFtZWQoY3NzKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIC8vIHJnYigyNTAgMjAgMCkgb3IgcmdiKDI1MCwyMCwwKVxuICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9SR0IpKSB8fCAobSA9IGNzcy5tYXRjaChSRV9SR0JfTEVHQUNZKSkpIHtcbiAgICAgICAgY29uc3QgcmdiID0gbS5zbGljZSgxLCA0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIHJnYltpXSA9ICtyZ2JbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmdiWzNdID0gMTsgLy8gZGVmYXVsdCBhbHBoYVxuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH1cblxuICAgIC8vIHJnYmEoMjUwLDIwLDAsMC40KVxuICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9SR0JBKSkgfHwgKG0gPSBjc3MubWF0Y2goUkVfUkdCQV9MRUdBQ1kpKSkge1xuICAgICAgICBjb25zdCByZ2IgPSBtLnNsaWNlKDEsIDUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgcmdiW2ldID0gK3JnYltpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH1cblxuICAgIC8vIHJnYigxMDAlLDAlLDAlKVxuICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9SR0JfUENUKSkgfHwgKG0gPSBjc3MubWF0Y2goUkVfUkdCX1BDVF9MRUdBQ1kpKSkge1xuICAgICAgICBjb25zdCByZ2IgPSBtLnNsaWNlKDEsIDQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgcmdiW2ldID0gcm91bmQkMShyZ2JbaV0gKiAyLjU1KTtcbiAgICAgICAgfVxuICAgICAgICByZ2JbM10gPSAxOyAvLyBkZWZhdWx0IGFscGhhXG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuXG4gICAgLy8gcmdiYSgxMDAlLDAlLDAlLDAuNClcbiAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfUkdCQV9QQ1QpKSB8fCAobSA9IGNzcy5tYXRjaChSRV9SR0JBX1BDVF9MRUdBQ1kpKSkge1xuICAgICAgICBjb25zdCByZ2IgPSBtLnNsaWNlKDEsIDUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgcmdiW2ldID0gcm91bmQkMShyZ2JbaV0gKiAyLjU1KTtcbiAgICAgICAgfVxuICAgICAgICByZ2JbM10gPSArcmdiWzNdO1xuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH1cblxuICAgIC8vIGhzbCgwLDEwMCUsNTAlKVxuICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9IU0wpKSB8fCAobSA9IGNzcy5tYXRjaChSRV9IU0xfTEVHQUNZKSkpIHtcbiAgICAgICAgY29uc3QgaHNsID0gbS5zbGljZSgxLCA0KTtcbiAgICAgICAgaHNsWzFdICo9IDAuMDE7XG4gICAgICAgIGhzbFsyXSAqPSAwLjAxO1xuICAgICAgICBjb25zdCByZ2IgPSBoc2wycmdiKGhzbCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICByZ2JbaV0gPSByb3VuZCQxKHJnYltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmdiWzNdID0gMTtcbiAgICAgICAgcmV0dXJuIHJnYjtcbiAgICB9XG5cbiAgICAvLyBoc2xhKDAsMTAwJSw1MCUsMC41KVxuICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9IU0xBKSkgfHwgKG0gPSBjc3MubWF0Y2goUkVfSFNMQV9MRUdBQ1kpKSkge1xuICAgICAgICBjb25zdCBoc2wgPSBtLnNsaWNlKDEsIDQpO1xuICAgICAgICBoc2xbMV0gKj0gMC4wMTtcbiAgICAgICAgaHNsWzJdICo9IDAuMDE7XG4gICAgICAgIGNvbnN0IHJnYiA9IGhzbDJyZ2IoaHNsKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIHJnYltpXSA9IHJvdW5kJDEocmdiW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZ2JbM10gPSArbVs0XTsgLy8gZGVmYXVsdCBhbHBoYSA9IDFcbiAgICAgICAgcmV0dXJuIHJnYjtcbiAgICB9XG5cbiAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfTEFCKSkpIHtcbiAgICAgICAgY29uc3QgbGFiID0gbS5zbGljZSgxLCA0KTtcbiAgICAgICAgbGFiWzBdID0gcGVyY2VudFRvQWJzb2x1dGUobGFiWzBdLCAwLCAxMDApO1xuICAgICAgICBsYWJbMV0gPSBwZXJjZW50VG9BYnNvbHV0ZShsYWJbMV0sIC0xMjUsIDEyNSwgdHJ1ZSk7XG4gICAgICAgIGxhYlsyXSA9IHBlcmNlbnRUb0Fic29sdXRlKGxhYlsyXSwgLTEyNSwgMTI1LCB0cnVlKTtcbiAgICAgICAgLy8gY29udmVydCB0byBENTAgTGFiIHdoaXRlcG9pbnRcbiAgICAgICAgY29uc3Qgd3AgPSBnZXRMYWJXaGl0ZVBvaW50KCk7XG4gICAgICAgIHNldExhYldoaXRlUG9pbnQoJ2Q1MCcpO1xuICAgICAgICBjb25zdCByZ2IgPSByb3VuZFJHQihsYWIycmdiKGxhYikpO1xuICAgICAgICAvLyBjb252ZXJ0IGJhY2sgdG8gb3JpZ2luYWwgTGFiIHdoaXRlcG9pbnRcbiAgICAgICAgc2V0TGFiV2hpdGVQb2ludCh3cCk7XG4gICAgICAgIHJnYlszXSA9IG1bNF0gIT09IHVuZGVmaW5lZCA/ICttWzRdIDogMTtcbiAgICAgICAgcmV0dXJuIHJnYjtcbiAgICB9XG5cbiAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfTENIKSkpIHtcbiAgICAgICAgY29uc3QgbGNoID0gbS5zbGljZSgxLCA0KTtcbiAgICAgICAgbGNoWzBdID0gcGVyY2VudFRvQWJzb2x1dGUobGNoWzBdLCAwLCAxMDApO1xuICAgICAgICBsY2hbMV0gPSBwZXJjZW50VG9BYnNvbHV0ZShub25lVG9WYWx1ZShsY2hbMV0sIDApLCAwLCAxNTAsIGZhbHNlKTtcbiAgICAgICAgbGNoWzJdID0gK25vbmVUb1ZhbHVlKGxjaFsyXS5yZXBsYWNlKCdkZWcnLCAnJyksIDApO1xuICAgICAgICAvLyBjb252ZXJ0IHRvIEQ1MCBMYWIgd2hpdGVwb2ludFxuICAgICAgICBjb25zdCB3cCA9IGdldExhYldoaXRlUG9pbnQoKTtcbiAgICAgICAgc2V0TGFiV2hpdGVQb2ludCgnZDUwJyk7XG4gICAgICAgIGNvbnN0IHJnYiA9IHJvdW5kUkdCKGxjaDJyZ2IobGNoKSk7XG4gICAgICAgIC8vIGNvbnZlcnQgYmFjayB0byBvcmlnaW5hbCBMYWIgd2hpdGVwb2ludFxuICAgICAgICBzZXRMYWJXaGl0ZVBvaW50KHdwKTtcbiAgICAgICAgcmdiWzNdID0gbVs0XSAhPT0gdW5kZWZpbmVkID8gK21bNF0gOiAxO1xuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH1cblxuICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9PS0xBQikpKSB7XG4gICAgICAgIGNvbnN0IG9rbGFiID0gbS5zbGljZSgxLCA0KTtcbiAgICAgICAgb2tsYWJbMF0gPSBwZXJjZW50VG9BYnNvbHV0ZShva2xhYlswXSwgMCwgMSk7XG4gICAgICAgIG9rbGFiWzFdID0gcGVyY2VudFRvQWJzb2x1dGUob2tsYWJbMV0sIC0wLjQsIDAuNCwgdHJ1ZSk7XG4gICAgICAgIG9rbGFiWzJdID0gcGVyY2VudFRvQWJzb2x1dGUob2tsYWJbMl0sIC0wLjQsIDAuNCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHJnYiA9IHJvdW5kUkdCKG9rbGFiMnJnYihva2xhYikpO1xuICAgICAgICByZ2JbM10gPSBtWzRdICE9PSB1bmRlZmluZWQgPyArbVs0XSA6IDE7XG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuXG4gICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX09LTENIKSkpIHtcbiAgICAgICAgY29uc3Qgb2tsY2ggPSBtLnNsaWNlKDEsIDQpO1xuICAgICAgICBva2xjaFswXSA9IHBlcmNlbnRUb0Fic29sdXRlKG9rbGNoWzBdLCAwLCAxKTtcbiAgICAgICAgb2tsY2hbMV0gPSBwZXJjZW50VG9BYnNvbHV0ZShub25lVG9WYWx1ZShva2xjaFsxXSwgMCksIDAsIDAuNCwgZmFsc2UpO1xuICAgICAgICBva2xjaFsyXSA9ICtub25lVG9WYWx1ZShva2xjaFsyXS5yZXBsYWNlKCdkZWcnLCAnJyksIDApO1xuICAgICAgICBjb25zdCByZ2IgPSByb3VuZFJHQihva2xjaDJyZ2Iob2tsY2gpKTtcbiAgICAgICAgcmdiWzNdID0gbVs0XSAhPT0gdW5kZWZpbmVkID8gK21bNF0gOiAxO1xuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH1cbn07XG5cbmNzczJyZ2IudGVzdCA9IChzKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgLy8gbW9kZXJuXG4gICAgICAgIFJFX1JHQi50ZXN0KHMpIHx8XG4gICAgICAgIFJFX1JHQkEudGVzdChzKSB8fFxuICAgICAgICBSRV9SR0JfUENULnRlc3QocykgfHxcbiAgICAgICAgUkVfUkdCQV9QQ1QudGVzdChzKSB8fFxuICAgICAgICBSRV9IU0wudGVzdChzKSB8fFxuICAgICAgICBSRV9IU0xBLnRlc3QocykgfHxcbiAgICAgICAgUkVfTEFCLnRlc3QocykgfHxcbiAgICAgICAgUkVfTENILnRlc3QocykgfHxcbiAgICAgICAgUkVfT0tMQUIudGVzdChzKSB8fFxuICAgICAgICBSRV9PS0xDSC50ZXN0KHMpIHx8XG4gICAgICAgIC8vIGxlZ2FjeVxuICAgICAgICBSRV9SR0JfTEVHQUNZLnRlc3QocykgfHxcbiAgICAgICAgUkVfUkdCQV9MRUdBQ1kudGVzdChzKSB8fFxuICAgICAgICBSRV9SR0JfUENUX0xFR0FDWS50ZXN0KHMpIHx8XG4gICAgICAgIFJFX1JHQkFfUENUX0xFR0FDWS50ZXN0KHMpIHx8XG4gICAgICAgIFJFX0hTTF9MRUdBQ1kudGVzdChzKSB8fFxuICAgICAgICBSRV9IU0xBX0xFR0FDWS50ZXN0KHMpXG4gICAgKTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5jc3MgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgIHJldHVybiByZ2IyY3NzKHRoaXMuX3JnYiwgbW9kZSk7XG59O1xuXG5jb25zdCBjc3MgPSAoLi4uYXJncykgPT4gbmV3IENvbG9yKC4uLmFyZ3MsICdjc3MnKTtcbmNocm9tYS5jc3MgPSBjc3M7XG5cbmlucHV0LmZvcm1hdC5jc3MgPSBjc3MycmdiO1xuXG5pbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDUsXG4gICAgdGVzdDogKGgsIC4uLnJlc3QpID0+IHtcbiAgICAgICAgaWYgKCFyZXN0Lmxlbmd0aCAmJiB0eXBlKGgpID09PSAnc3RyaW5nJyAmJiBjc3MycmdiLnRlc3QoaCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnY3NzJztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5pbnB1dC5mb3JtYXQuZ2wgPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHJnYiA9IHVucGFjayhhcmdzLCAncmdiYScpO1xuICAgIHJnYlswXSAqPSAyNTU7XG4gICAgcmdiWzFdICo9IDI1NTtcbiAgICByZ2JbMl0gKj0gMjU1O1xuICAgIHJldHVybiByZ2I7XG59O1xuXG5jb25zdCBnbCA9ICguLi5hcmdzKSA9PiBuZXcgQ29sb3IoLi4uYXJncywgJ2dsJyk7XG5jaHJvbWEuZ2wgPSBnbDtcblxuQ29sb3IucHJvdG90eXBlLmdsID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICByZXR1cm4gW3JnYlswXSAvIDI1NSwgcmdiWzFdIC8gMjU1LCByZ2JbMl0gLyAyNTUsIHJnYlszXV07XG59O1xuXG5Db2xvci5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICByZXR1cm4gcmdiMmhleCh0aGlzLl9yZ2IsIG1vZGUpO1xufTtcblxuY29uc3QgaGV4ID0gKC4uLmFyZ3MpID0+IG5ldyBDb2xvciguLi5hcmdzLCAnaGV4Jyk7XG5jaHJvbWEuaGV4ID0gaGV4O1xuXG5pbnB1dC5mb3JtYXQuaGV4ID0gaGV4MnJnYjtcbmlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogNCxcbiAgICB0ZXN0OiAoaCwgLi4ucmVzdCkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhcmVzdC5sZW5ndGggJiZcbiAgICAgICAgICAgIHR5cGUoaCkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBbMywgNCwgNSwgNiwgNywgOCwgOV0uaW5kZXhPZihoLmxlbmd0aCkgPj0gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAnaGV4JztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKlxuICogQmFzZWQgb24gaW1wbGVtZW50YXRpb24gYnkgTmVpbCBCYXJ0bGV0dFxuICogaHR0cHM6Ly9naXRodWIuY29tL25laWxiYXJ0bGV0dC9jb2xvci10ZW1wZXJhdHVyZVxuICovXG5cbmNvbnN0IHsgbG9nIH0gPSBNYXRoO1xuXG5jb25zdCB0ZW1wZXJhdHVyZTJyZ2IgPSAoa2VsdmluKSA9PiB7XG4gICAgY29uc3QgdGVtcCA9IGtlbHZpbiAvIDEwMDtcbiAgICBsZXQgciwgZywgYjtcbiAgICBpZiAodGVtcCA8IDY2KSB7XG4gICAgICAgIHIgPSAyNTU7XG4gICAgICAgIGcgPVxuICAgICAgICAgICAgdGVtcCA8IDZcbiAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICA6IC0xNTUuMjU0ODU1NjI3MDkxNzkgLVxuICAgICAgICAgICAgICAgICAgMC40NDU5Njk1MDQ2OTU3OTEzMyAqIChnID0gdGVtcCAtIDIpICtcbiAgICAgICAgICAgICAgICAgIDEwNC40OTIxNjE5OTM5Mzg4OCAqIGxvZyhnKTtcbiAgICAgICAgYiA9XG4gICAgICAgICAgICB0ZW1wIDwgMjBcbiAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICA6IC0yNTQuNzY5MzUxODQxMjA5MDIgK1xuICAgICAgICAgICAgICAgICAgMC44Mjc0MDk2MDY0MDA3Mzk1ICogKGIgPSB0ZW1wIC0gMTApICtcbiAgICAgICAgICAgICAgICAgIDExNS42Nzk5NDQwMTA2NjE0NyAqIGxvZyhiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByID1cbiAgICAgICAgICAgIDM1MS45NzY5MDU2NjgwNTY5MyArXG4gICAgICAgICAgICAwLjExNDIwNjQ1Mzc4NDE2NSAqIChyID0gdGVtcCAtIDU1KSAtXG4gICAgICAgICAgICA0MC4yNTM2NjMwOTMzMjEyNyAqIGxvZyhyKTtcbiAgICAgICAgZyA9XG4gICAgICAgICAgICAzMjUuNDQ5NDEyNTcxMTk3NCArXG4gICAgICAgICAgICAwLjA3OTQzNDU2NTM2NjYyMzQyICogKGcgPSB0ZW1wIC0gNTApIC1cbiAgICAgICAgICAgIDI4LjA4NTI5NjM1MDc5NTcgKiBsb2coZyk7XG4gICAgICAgIGIgPSAyNTU7XG4gICAgfVxuICAgIHJldHVybiBbciwgZywgYiwgMV07XG59O1xuXG4vKlxuICogQmFzZWQgb24gaW1wbGVtZW50YXRpb24gYnkgTmVpbCBCYXJ0bGV0dFxuICogaHR0cHM6Ly9naXRodWIuY29tL25laWxiYXJ0bGV0dC9jb2xvci10ZW1wZXJhdHVyZVxuICoqL1xuXG5jb25zdCB7IHJvdW5kIH0gPSBNYXRoO1xuXG5jb25zdCByZ2IydGVtcGVyYXR1cmUgPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHJnYiA9IHVucGFjayhhcmdzLCAncmdiJyk7XG4gICAgY29uc3QgciA9IHJnYlswXSxcbiAgICAgICAgYiA9IHJnYlsyXTtcbiAgICBsZXQgbWluVGVtcCA9IDEwMDA7XG4gICAgbGV0IG1heFRlbXAgPSA0MDAwMDtcbiAgICBjb25zdCBlcHMgPSAwLjQ7XG4gICAgbGV0IHRlbXA7XG4gICAgd2hpbGUgKG1heFRlbXAgLSBtaW5UZW1wID4gZXBzKSB7XG4gICAgICAgIHRlbXAgPSAobWF4VGVtcCArIG1pblRlbXApICogMC41O1xuICAgICAgICBjb25zdCByZ2IgPSB0ZW1wZXJhdHVyZTJyZ2IodGVtcCk7XG4gICAgICAgIGlmIChyZ2JbMl0gLyByZ2JbMF0gPj0gYiAvIHIpIHtcbiAgICAgICAgICAgIG1heFRlbXAgPSB0ZW1wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluVGVtcCA9IHRlbXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvdW5kKHRlbXApO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnRlbXAgPVxuICAgIENvbG9yLnByb3RvdHlwZS5rZWx2aW4gPVxuICAgIENvbG9yLnByb3RvdHlwZS50ZW1wZXJhdHVyZSA9XG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiByZ2IydGVtcGVyYXR1cmUodGhpcy5fcmdiKTtcbiAgICAgICAgfTtcblxuY29uc3QgdGVtcCA9ICguLi5hcmdzKSA9PiBuZXcgQ29sb3IoLi4uYXJncywgJ3RlbXAnKTtcbk9iamVjdC5hc3NpZ24oY2hyb21hLCB7IHRlbXAsIGtlbHZpbjogdGVtcCwgdGVtcGVyYXR1cmU6IHRlbXAgfSk7XG5cbmlucHV0LmZvcm1hdC50ZW1wID1cbiAgICBpbnB1dC5mb3JtYXQua2VsdmluID1cbiAgICBpbnB1dC5mb3JtYXQudGVtcGVyYXR1cmUgPVxuICAgICAgICB0ZW1wZXJhdHVyZTJyZ2I7XG5cbkNvbG9yLnByb3RvdHlwZS5va2xjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMm9rbGNoKHRoaXMuX3JnYik7XG59O1xuXG5jb25zdCBva2xjaCA9ICguLi5hcmdzKSA9PiBuZXcgQ29sb3IoLi4uYXJncywgJ29rbGNoJyk7XG5PYmplY3QuYXNzaWduKGNocm9tYSwgeyBva2xjaCB9KTtcblxuaW5wdXQuZm9ybWF0Lm9rbGNoID0gb2tsY2gycmdiO1xuXG5pbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDIsXG4gICAgdGVzdDogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgYXJncyA9IHVucGFjayhhcmdzLCAnb2tsY2gnKTtcbiAgICAgICAgaWYgKHR5cGUoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiAnb2tsY2gnO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8vIGZlZWwgZnJlZSB0byBjb21tZW50IG91dCBhbnl0aGluZyB0byByb2xsdXBcbi8vIGEgc21hbGxlciBjaHJvbWEuanMgYnVuZGxlXG5cbk9iamVjdC5hc3NpZ24oY2hyb21hLCB7XG4gICAgYW5hbHl6ZSxcbiAgICBhdmVyYWdlLFxuICAgIGJlemllcjogYmV6aWVyJDEsXG4gICAgYmxlbmQsXG4gICAgYnJld2VyOiBjb2xvcmJyZXdlcixcbiAgICBDb2xvcixcbiAgICBjb2xvcnM6IHczY3gxMSxcbiAgICBjb250cmFzdCxcbiAgICBjdWJlaGVsaXgsXG4gICAgZGVsdGFFLFxuICAgIGRpc3RhbmNlLFxuICAgIGlucHV0LFxuICAgIGludGVycG9sYXRlOiBtaXgsXG4gICAgbGltaXRzLFxuICAgIG1peCxcbiAgICByYW5kb206IHJhbmRvbSQxLFxuICAgIHNjYWxlLFxuICAgIHNjYWxlcyxcbiAgICB2YWxpZFxufSk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VOYU4oYXJyYXkpIHtcbiAgICAvLyBmaXhlcyBhIE5hTiBmb3IgMCB2YWx1ZXMgaW4gQ2hyb21hSlNcbiAgICBhcnJheVswXSA9IDA7XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gY29udmVydFRvTmFtZWRPYmplY3QoaHN2KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaHVlOiBoc3ZbMF0sXG4gICAgICAgIHNhdHVyYXRpb246IGhzdlsxXSxcbiAgICAgICAgYnJpZ2h0bmVzczogaHN2WzJdLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbG9yc1dpdGhMb2NrKHByb3BzLCBvcHRpb25zLCByZXN1bHRzKSB7XG4gICAgY29uc3QgbG9ja0hTViA9IGlzTmFOKGNocm9tYS5oZXgoYCR7b3B0aW9ucy5sb2NrSGV4fWApLmhzdigpWzBdKVxuICAgICAgICA/IGNvbnZlcnRUb05hbWVkT2JqZWN0KHJlcGxhY2VOYU4oY2hyb21hLmhleChgJHtvcHRpb25zLmxvY2tIZXh9YCkuaHN2KCkpKVxuICAgICAgICA6IGNvbnZlcnRUb05hbWVkT2JqZWN0KGNocm9tYS5oZXgoYCR7b3B0aW9ucy5sb2NrSGV4fWApLmhzdigpKTtcbiAgICBsZXQgc2hvcnRlc3REaXN0YW5jZSA9IDk5OTk5OTtcbiAgICBsZXQgbG9ja2VkQ29sb3IgPSB7XG4gICAgICAgIGh1ZTogeyBzdGVwOiAwLCB2YWx1ZTogMCB9LFxuICAgICAgICBzYXR1cmF0aW9uOiB7IHN0ZXA6IDAsIHZhbHVlOiAwIH0sXG4gICAgICAgIGJyaWdodG5lc3M6IHsgc3RlcDogMCwgdmFsdWU6IDAgfSxcbiAgICAgICAgc3RlcDogMCxcbiAgICAgICAgaXNNYWpvcjogZmFsc2UsXG4gICAgICAgIGlzTG9ja2VkOiBmYWxzZVxuICAgIH07XG4gICAgbGV0IGxvY2tlZEluZGV4O1xuICAgIGNvbnN0IGxhc3RDb2xvciA9IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXTtcbiAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24gKGNvbG9yLCBpbmRleCkge1xuICAgICAgICBjb25zdCB7IGh1ZSwgc2F0dXJhdGlvbiwgYnJpZ2h0bmVzcyB9ID0gY29sb3I7XG4gICAgICAgIGNvbnN0IGhleCA9IGNocm9tYS5oc3YoaHVlLnZhbHVlLCBzYXR1cmF0aW9uLnZhbHVlLCBicmlnaHRuZXNzLnZhbHVlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubG9ja0hleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGNocm9tYS5kaXN0YW5jZShoZXgsIG9wdGlvbnMubG9ja0hleCk7XG4gICAgICAgICAgICBpZiAoc2hvcnRlc3REaXN0YW5jZSA+IGRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgc2hvcnRlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGxvY2tlZENvbG9yID0gY29sb3I7XG4gICAgICAgICAgICAgICAgbG9ja2VkSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB7XG4gICAgICAgIGh1ZTogbG9ja0hTVi5odWUgLSBsb2NrZWRDb2xvci5odWUudmFsdWUsXG4gICAgICAgIHNhdHVyYXRpb246IGxvY2tIU1Yuc2F0dXJhdGlvbiAtIGxvY2tlZENvbG9yLnNhdHVyYXRpb24udmFsdWUsXG4gICAgICAgIGJyaWdodG5lc3M6IGxvY2tIU1YuYnJpZ2h0bmVzcyAtIGxvY2tlZENvbG9yLmJyaWdodG5lc3MudmFsdWUsXG4gICAgfTtcbiAgICBjb25zdCBhZGp1c3RlZENvbG9yU2V0ID0gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKGNvbG9yLCBpbmRleCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKGluZGV4IDwgbG9ja2VkSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGh1ZURpZmZlcmVuY2UgPSBkaXN0cmlidXRlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaW5kZXgsXG4gICAgICAgICAgICAgICAgcmFuZ2VBOiBbMCwgbG9ja2VkSW5kZXhdLFxuICAgICAgICAgICAgICAgIHJhbmdlQjogWzAsIGRpZmZlcmVuY2UuaHVlXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2F0dXJhdGlvbkRpZmZlcmVuY2UgPSBkaXN0cmlidXRlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaW5kZXgsXG4gICAgICAgICAgICAgICAgcmFuZ2VBOiBbMCwgbG9ja2VkSW5kZXhdLFxuICAgICAgICAgICAgICAgIHJhbmdlQjogWzAsIGRpZmZlcmVuY2Uuc2F0dXJhdGlvbl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGJyaWdodG5lc3NEaWZmZXJlbmNlID0gZGlzdHJpYnV0ZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGluZGV4LFxuICAgICAgICAgICAgICAgIHJhbmdlQTogWzAsIGxvY2tlZEluZGV4XSxcbiAgICAgICAgICAgICAgICByYW5nZUI6IFswLCBkaWZmZXJlbmNlLmJyaWdodG5lc3NdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGh1ZToge1xuICAgICAgICAgICAgICAgICAgICBzdGVwOiBjb2xvci5odWUuc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbG9yLmh1ZS52YWx1ZSArIGh1ZURpZmZlcmVuY2UgPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbG9yLmh1ZS52YWx1ZSArIGh1ZURpZmZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNhdHVyYXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogY29sb3Iuc2F0dXJhdGlvbi5zdGVwLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29sb3Iuc2F0dXJhdGlvbi52YWx1ZSArIHNhdHVyYXRpb25EaWZmZXJlbmNlID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb2xvci5zYXR1cmF0aW9uLnZhbHVlICsgc2F0dXJhdGlvbkRpZmZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJyaWdodG5lc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogY29sb3IuYnJpZ2h0bmVzcy5zdGVwLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29sb3IuYnJpZ2h0bmVzcy52YWx1ZSArIGJyaWdodG5lc3NEaWZmZXJlbmNlID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb2xvci5icmlnaHRuZXNzLnZhbHVlICsgYnJpZ2h0bmVzc0RpZmZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0ZXA6IGNvbG9yLnN0ZXAsXG4gICAgICAgICAgICAgICAgaXNNYWpvcjogY29sb3IuaXNNYWpvcixcbiAgICAgICAgICAgICAgICBpc0xvY2tlZDogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSBsb2NrZWRJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBodWU6IHsgc3RlcDogY29sb3IuaHVlLnN0ZXAsIHZhbHVlOiBsb2NrSFNWLmh1ZSB9LFxuICAgICAgICAgICAgICAgIHNhdHVyYXRpb246IHsgc3RlcDogY29sb3Iuc2F0dXJhdGlvbi5zdGVwLCB2YWx1ZTogbG9ja0hTVi5zYXR1cmF0aW9uIH0sXG4gICAgICAgICAgICAgICAgYnJpZ2h0bmVzczogeyBzdGVwOiBjb2xvci5icmlnaHRuZXNzLnN0ZXAsIHZhbHVlOiBsb2NrSFNWLmJyaWdodG5lc3MgfSxcbiAgICAgICAgICAgICAgICBzdGVwOiBjb2xvci5zdGVwLFxuICAgICAgICAgICAgICAgIGlzTWFqb3I6IGNvbG9yLmlzTWFqb3IsXG4gICAgICAgICAgICAgICAgaXNMb2NrZWQ6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaHVlRGlmZmVyZW5jZSA9IGRpc3RyaWJ1dGUoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpbmRleCxcbiAgICAgICAgICAgICAgICByYW5nZUE6IFtsb2NrZWRJbmRleCwgbGFzdENvbG9yLnN0ZXAgKyAoKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW5vclN0ZXBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSB8fCAwKV0sXG4gICAgICAgICAgICAgICAgcmFuZ2VCOiBbZGlmZmVyZW5jZS5odWUsIDBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzYXR1cmF0aW9uRGlmZmVyZW5jZSA9IGRpc3RyaWJ1dGUoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpbmRleCxcbiAgICAgICAgICAgICAgICByYW5nZUE6IFtsb2NrZWRJbmRleCwgbGFzdENvbG9yLnN0ZXAgKyAoKChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW5vclN0ZXBzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSB8fCAwKV0sXG4gICAgICAgICAgICAgICAgcmFuZ2VCOiBbZGlmZmVyZW5jZS5zYXR1cmF0aW9uLCAwXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYnJpZ2h0bmVzc0RpZmZlcmVuY2UgPSBkaXN0cmlidXRlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaW5kZXgsXG4gICAgICAgICAgICAgICAgcmFuZ2VBOiBbbG9ja2VkSW5kZXgsIGxhc3RDb2xvci5zdGVwICsgKCgoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWlub3JTdGVwcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkgfHwgMCldLFxuICAgICAgICAgICAgICAgIHJhbmdlQjogW2RpZmZlcmVuY2UuYnJpZ2h0bmVzcywgMF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IGNvbG9yLmh1ZS5zdGVwLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29sb3IuaHVlLnZhbHVlICsgaHVlRGlmZmVyZW5jZSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yLmh1ZS52YWx1ZSArIGh1ZURpZmZlcmVuY2UgPCAzNjBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29sb3IuaHVlLnZhbHVlICsgaHVlRGlmZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2F0dXJhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBzdGVwOiBjb2xvci5zYXR1cmF0aW9uLnN0ZXAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2xvci5zYXR1cmF0aW9uLnZhbHVlICsgc2F0dXJhdGlvbkRpZmZlcmVuY2UgPCAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbG9yLnNhdHVyYXRpb24udmFsdWUgKyBzYXR1cmF0aW9uRGlmZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYnJpZ2h0bmVzczoge1xuICAgICAgICAgICAgICAgICAgICBzdGVwOiBjb2xvci5icmlnaHRuZXNzLnN0ZXAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2xvci5icmlnaHRuZXNzLnZhbHVlICsgYnJpZ2h0bmVzc0RpZmZlcmVuY2UgPCAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbG9yLmJyaWdodG5lc3MudmFsdWUgKyBicmlnaHRuZXNzRGlmZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAxLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RlcDogY29sb3Iuc3RlcCxcbiAgICAgICAgICAgICAgICBpc01ham9yOiBjb2xvci5pc01ham9yLFxuICAgICAgICAgICAgICAgIGlzTG9ja2VkOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWRqdXN0ZWRDb2xvclNldDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGUocHJvcHMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgeyBsb2NrSGV4LCBsb2NrSGV4SW52ZXJ0ZWQsIHByb3ZpZGVJbnZlcnRlZCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBhbGdvcml0aG1SZXN1bHQgPSBbXTtcbiAgICBjb25zdCBnZW5lcmF0ZWQgPSBnZW5lcmF0ZUNvbG9ycyhwcm9wcywgb3B0aW9ucyk7XG4gICAgaWYgKGxvY2tIZXgpIHtcbiAgICAgICAgYWxnb3JpdGhtUmVzdWx0LnB1c2goZ2VuZXJhdGVDb2xvcnNXaXRoTG9jayhwcm9wcywgb3B0aW9ucywgZ2VuZXJhdGVkKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhbGdvcml0aG1SZXN1bHQucHVzaChnZW5lcmF0ZWQpO1xuICAgIH1cbiAgICBpZiAocHJvdmlkZUludmVydGVkKSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZEludmVydGVkID0gZ2VuZXJhdGVDb2xvcnMocHJvcHMsIG9wdGlvbnMsIHRydWUpO1xuICAgICAgICBsb2NrSGV4SW52ZXJ0ZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBhbGdvcml0aG1SZXN1bHQucHVzaChnZW5lcmF0ZWRJbnZlcnRlZClcbiAgICAgICAgICAgIDogYWxnb3JpdGhtUmVzdWx0LnB1c2goZ2VuZXJhdGVDb2xvcnNXaXRoTG9jayhwcm9wcywgb3B0aW9ucywgZ2VuZXJhdGVkSW52ZXJ0ZWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbG9ycyhwcm9wcywgb3B0aW9ucywgYWxnb3JpdGhtUmVzdWx0KTtcbn1cblxuZXhwb3J0IHsgZ2VuZXJhdGUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@k-vyn/coloralgorithm/dist/bundle.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/bezier-easing/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/bezier-easing/src/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gatan Renaudeau 2014 - 2015  MIT License\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\n\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\nfunction B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\nfunction C (aA1)      { return 3.0 * aA1; }\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }\n\nfunction binarySubdivide (aX, aA, aB, mX1, mX2) {\n  var currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\n\nfunction newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {\n for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n   var currentSlope = getSlope(aGuessT, mX1, mX2);\n   if (currentSlope === 0.0) {\n     return aGuessT;\n   }\n   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n   aGuessT -= currentX / currentSlope;\n }\n return aGuessT;\n}\n\nfunction LinearEasing (x) {\n  return x;\n}\n\nmodule.exports = function bezier (mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  }\n\n  // Precompute samples table\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX (aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing (x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iZXppZXItZWFzaW5nL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3Qjs7QUFFeEI7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtRUFBbUU7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXZpZGViaXNjdXNvL0RvY3VtZW50cy9HaXRIdWIvY29sb3ItcmFtcC9ub2RlX21vZHVsZXMvYmV6aWVyLWVhc2luZy9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNpbmdcbiAqIEJlemllckVhc2luZyAtIHVzZSBiZXppZXIgY3VydmUgZm9yIHRyYW5zaXRpb24gZWFzaW5nIGZ1bmN0aW9uXG4gKiBieSBHYcOrdGFuIFJlbmF1ZGVhdSAyMDE0IC0gMjAxNSDigJMgTUlUIExpY2Vuc2VcbiAqL1xuXG4vLyBUaGVzZSB2YWx1ZXMgYXJlIGVzdGFibGlzaGVkIGJ5IGVtcGlyaWNpc20gd2l0aCB0ZXN0cyAodHJhZGVvZmY6IHBlcmZvcm1hbmNlIFZTIHByZWNpc2lvbilcbnZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQ7XG52YXIgTkVXVE9OX01JTl9TTE9QRSA9IDAuMDAxO1xudmFyIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMTtcbnZhciBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xuXG52YXIga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xudmFyIGtTYW1wbGVTdGVwU2l6ZSA9IDEuMCAvIChrU3BsaW5lVGFibGVTaXplIC0gMS4wKTtcblxudmFyIGZsb2F0MzJBcnJheVN1cHBvcnRlZCA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICdmdW5jdGlvbic7XG5cbmZ1bmN0aW9uIEEgKGFBMSwgYUEyKSB7IHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTE7IH1cbmZ1bmN0aW9uIEIgKGFBMSwgYUEyKSB7IHJldHVybiAzLjAgKiBhQTIgLSA2LjAgKiBhQTE7IH1cbmZ1bmN0aW9uIEMgKGFBMSkgICAgICB7IHJldHVybiAzLjAgKiBhQTE7IH1cblxuLy8gUmV0dXJucyB4KHQpIGdpdmVuIHQsIHgxLCBhbmQgeDIsIG9yIHkodCkgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cbmZ1bmN0aW9uIGNhbGNCZXppZXIgKGFULCBhQTEsIGFBMikgeyByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQ7IH1cblxuLy8gUmV0dXJucyBkeC9kdCBnaXZlbiB0LCB4MSwgYW5kIHgyLCBvciBkeS9kdCBnaXZlbiB0LCB5MSwgYW5kIHkyLlxuZnVuY3Rpb24gZ2V0U2xvcGUgKGFULCBhQTEsIGFBMikgeyByZXR1cm4gMy4wICogQShhQTEsIGFBMikgKiBhVCAqIGFUICsgMi4wICogQihhQTEsIGFBMikgKiBhVCArIEMoYUExKTsgfVxuXG5mdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUgKGFYLCBhQSwgYUIsIG1YMSwgbVgyKSB7XG4gIHZhciBjdXJyZW50WCwgY3VycmVudFQsIGkgPSAwO1xuICBkbyB7XG4gICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xuICAgICAgYUIgPSBjdXJyZW50VDtcbiAgICB9IGVsc2Uge1xuICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICB9XG4gIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG4gIHJldHVybiBjdXJyZW50VDtcbn1cblxuZnVuY3Rpb24gbmV3dG9uUmFwaHNvbkl0ZXJhdGUgKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xuIGZvciAodmFyIGkgPSAwOyBpIDwgTkVXVE9OX0lURVJBVElPTlM7ICsraSkge1xuICAgdmFyIGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcbiAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkge1xuICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgIH1cbiAgIHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuIH1cbiByZXR1cm4gYUd1ZXNzVDtcbn1cblxuZnVuY3Rpb24gTGluZWFyRWFzaW5nICh4KSB7XG4gIHJldHVybiB4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJlemllciAobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gIGlmICghKDAgPD0gbVgxICYmIG1YMSA8PSAxICYmIDAgPD0gbVgyICYmIG1YMiA8PSAxKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmV6aWVyIHggdmFsdWVzIG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlJyk7XG4gIH1cblxuICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICByZXR1cm4gTGluZWFyRWFzaW5nO1xuICB9XG5cbiAgLy8gUHJlY29tcHV0ZSBzYW1wbGVzIHRhYmxlXG4gIHZhciBzYW1wbGVWYWx1ZXMgPSBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPyBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpIDogbmV3IEFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VEZvclggKGFYKSB7XG4gICAgdmFyIGludGVydmFsU3RhcnQgPSAwLjA7XG4gICAgdmFyIGN1cnJlbnRTYW1wbGUgPSAxO1xuICAgIHZhciBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG5cbiAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgfVxuICAgIC0tY3VycmVudFNhbXBsZTtcblxuICAgIC8vIEludGVycG9sYXRlIHRvIHByb3ZpZGUgYW4gaW5pdGlhbCBndWVzcyBmb3IgdFxuICAgIHZhciBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcbiAgICB2YXIgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG5cbiAgICB2YXIgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG4gICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgIH0gZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwLjApIHtcbiAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gQmV6aWVyRWFzaW5nICh4KSB7XG4gICAgLy8gQmVjYXVzZSBKYXZhU2NyaXB0IG51bWJlciBhcmUgaW1wcmVjaXNlLCB3ZSBzaG91bGQgZ3VhcmFudGVlIHRoZSBleHRyZW1lcyBhcmUgcmlnaHQuXG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoeCA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKHgpLCBtWTEsIG1ZMik7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/bezier-easing/src/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/color-contrast/dist/index.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/color-contrast/dist/index.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar installedColorSpaces = [],\n    undef = function (obj) {\n  return typeof obj === 'undefined';\n},\n    channelRegExp = /\\s*(\\.\\d+|\\d+(?:\\.\\d+)?)(%)?\\s*/,\n    percentageChannelRegExp = /\\s*(\\.\\d+|100|\\d?\\d(?:\\.\\d+)?)%\\s*/,\n    alphaChannelRegExp = /\\s*(\\.\\d+|\\d+(?:\\.\\d+)?)\\s*/,\n    cssColorRegExp = new RegExp('^(rgb|hsl|hsv)a?' + '\\\\(' + channelRegExp.source + ',' + channelRegExp.source + ',' + channelRegExp.source + '(?:,' + alphaChannelRegExp.source + ')?' + '\\\\)$', 'i');\n\nfunction color(obj) {\n  if (Array.isArray(obj)) {\n    if (typeof obj[0] === 'string' && typeof color[obj[0]] === 'function') {\n      // Assumed array from .toJSON()\n      return new color[obj[0]](obj.slice(1, obj.length));\n    } else if (obj.length === 4) {\n      // Assumed 4 element int RGB array from canvas with all channels [0;255]\n      return new color.RGB(obj[0] / 255, obj[1] / 255, obj[2] / 255, obj[3] / 255);\n    }\n  } else if (typeof obj === 'string') {\n    var lowerCased = obj.toLowerCase();\n\n    if (color.namedColors[lowerCased]) {\n      obj = '#' + color.namedColors[lowerCased];\n    }\n\n    if (lowerCased === 'transparent') {\n      obj = 'rgba(0,0,0,0)';\n    } // Test for CSS rgb(....) string\n\n\n    var matchCssSyntax = obj.match(cssColorRegExp);\n\n    if (matchCssSyntax) {\n      var colorSpaceName = matchCssSyntax[1].toUpperCase(),\n          alpha = undef(matchCssSyntax[8]) ? matchCssSyntax[8] : parseFloat(matchCssSyntax[8]),\n          hasHue = colorSpaceName[0] === 'H',\n          firstChannelDivisor = matchCssSyntax[3] ? 100 : hasHue ? 360 : 255,\n          secondChannelDivisor = matchCssSyntax[5] || hasHue ? 100 : 255,\n          thirdChannelDivisor = matchCssSyntax[7] || hasHue ? 100 : 255;\n\n      if (undef(color[colorSpaceName])) {\n        throw new Error('color.' + colorSpaceName + ' is not installed.');\n      }\n\n      return new color[colorSpaceName](parseFloat(matchCssSyntax[2]) / firstChannelDivisor, parseFloat(matchCssSyntax[4]) / secondChannelDivisor, parseFloat(matchCssSyntax[6]) / thirdChannelDivisor, alpha);\n    } // Assume hex syntax\n\n\n    if (obj.length < 6) {\n      // Allow CSS shorthand\n      obj = obj.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, '$1$1$2$2$3$3');\n    } // Split obj into red, green, and blue components\n\n\n    var hexMatch = obj.match(/^#?([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])$/i);\n\n    if (hexMatch) {\n      return new color.RGB(parseInt(hexMatch[1], 16) / 255, parseInt(hexMatch[2], 16) / 255, parseInt(hexMatch[3], 16) / 255);\n    } // No match so far. Lets try the less likely ones\n\n\n    if (color.CMYK) {\n      var cmykMatch = obj.match(new RegExp('^cmyk' + '\\\\(' + percentageChannelRegExp.source + ',' + percentageChannelRegExp.source + ',' + percentageChannelRegExp.source + ',' + percentageChannelRegExp.source + '\\\\)$', 'i'));\n\n      if (cmykMatch) {\n        return new color.CMYK(parseFloat(cmykMatch[1]) / 100, parseFloat(cmykMatch[2]) / 100, parseFloat(cmykMatch[3]) / 100, parseFloat(cmykMatch[4]) / 100);\n      }\n    }\n  } else if (typeof obj === 'object' && obj.isColor) {\n    return obj;\n  }\n\n  return false;\n}\n\ncolor.namedColors = {};\n\ncolor.installColorSpace = function (colorSpaceName, propertyNames, config) {\n  color[colorSpaceName] = function (a1) {\n    // ...\n    var args = Array.isArray(a1) ? a1 : arguments;\n    propertyNames.forEach(function (propertyName, i) {\n      var propertyValue = args[i];\n\n      if (propertyName === 'alpha') {\n        this._alpha = isNaN(propertyValue) || propertyValue > 1 ? 1 : propertyValue < 0 ? 0 : propertyValue;\n      } else {\n        if (isNaN(propertyValue)) {\n          throw new Error('[' + colorSpaceName + ']: Invalid color: (' + propertyNames.join(',') + ')');\n        }\n\n        if (propertyName === 'hue') {\n          this._hue = propertyValue < 0 ? propertyValue - Math.floor(propertyValue) : propertyValue % 1;\n        } else {\n          this['_' + propertyName] = propertyValue < 0 ? 0 : propertyValue > 1 ? 1 : propertyValue;\n        }\n      }\n    }, this);\n  };\n\n  color[colorSpaceName].propertyNames = propertyNames;\n  var prototype = color[colorSpaceName].prototype;\n  ['valueOf', 'hex', 'hexa', 'css', 'cssa'].forEach(function (methodName) {\n    prototype[methodName] = prototype[methodName] || (colorSpaceName === 'RGB' ? prototype.hex : function () {\n      return this.rgb()[methodName]();\n    });\n  });\n  prototype.isColor = true;\n\n  prototype.equals = function (otherColor, epsilon) {\n    if (undef(epsilon)) {\n      epsilon = 1e-10;\n    }\n\n    otherColor = otherColor[colorSpaceName.toLowerCase()]();\n\n    for (var i = 0; i < propertyNames.length; i = i + 1) {\n      if (Math.abs(this['_' + propertyNames[i]] - otherColor['_' + propertyNames[i]]) > epsilon) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  prototype.toJSON = function () {\n    return [colorSpaceName].concat(propertyNames.map(function (propertyName) {\n      return this['_' + propertyName];\n    }, this));\n  };\n\n  for (var propertyName in config) {\n    if (config.hasOwnProperty(propertyName)) {\n      var matchFromColorSpace = propertyName.match(/^from(.*)$/);\n\n      if (matchFromColorSpace) {\n        color[matchFromColorSpace[1].toUpperCase()].prototype[colorSpaceName.toLowerCase()] = config[propertyName];\n      } else {\n        prototype[propertyName] = config[propertyName];\n      }\n    }\n  } // It is pretty easy to implement the conversion to the same color space:\n\n\n  prototype[colorSpaceName.toLowerCase()] = function () {\n    return this;\n  };\n\n  prototype.toString = function () {\n    return '[' + colorSpaceName + ' ' + propertyNames.map(function (propertyName) {\n      return this['_' + propertyName];\n    }, this).join(', ') + ']';\n  }; // Generate getters and setters\n\n\n  propertyNames.forEach(function (propertyName) {\n    var shortName = propertyName === 'black' ? 'k' : propertyName.charAt(0);\n\n    prototype[propertyName] = prototype[shortName] = function (value, isDelta) {\n      // Simple getter mode: color.red()\n      if (typeof value === 'undefined') {\n        return this['_' + propertyName];\n      } else if (isDelta) {\n        // Adjuster: color.red(+.2, true)\n        return new this.constructor(propertyNames.map(function (otherPropertyName) {\n          return this['_' + otherPropertyName] + (propertyName === otherPropertyName ? value : 0);\n        }, this));\n      } else {\n        // Setter: color.red(.2);\n        return new this.constructor(propertyNames.map(function (otherPropertyName) {\n          return propertyName === otherPropertyName ? value : this['_' + otherPropertyName];\n        }, this));\n      }\n    };\n  });\n\n  function installForeignMethods(targetColorSpaceName, sourceColorSpaceName) {\n    var obj = {};\n\n    obj[sourceColorSpaceName.toLowerCase()] = function () {\n      return this.rgb()[sourceColorSpaceName.toLowerCase()]();\n    };\n\n    color[sourceColorSpaceName].propertyNames.forEach(function (propertyName) {\n      var shortName = propertyName === 'black' ? 'k' : propertyName.charAt(0);\n\n      obj[propertyName] = obj[shortName] = function (value, isDelta) {\n        return this[sourceColorSpaceName.toLowerCase()]()[propertyName](value, isDelta);\n      };\n    });\n\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop) && color[targetColorSpaceName].prototype[prop] === undefined) {\n        color[targetColorSpaceName].prototype[prop] = obj[prop];\n      }\n    }\n  }\n\n  installedColorSpaces.forEach(function (otherColorSpaceName) {\n    installForeignMethods(colorSpaceName, otherColorSpaceName);\n    installForeignMethods(otherColorSpaceName, colorSpaceName);\n  });\n  installedColorSpaces.push(colorSpaceName);\n  return color;\n};\n\ncolor.pluginList = [];\n\ncolor.use = function (plugin) {\n  if (color.pluginList.indexOf(plugin) === -1) {\n    this.pluginList.push(plugin);\n    plugin(color);\n  }\n\n  return color;\n};\n\ncolor.installMethod = function (name, fn) {\n  installedColorSpaces.forEach(function (colorSpace) {\n    color[colorSpace].prototype[name] = fn;\n  });\n  return this;\n};\n\ncolor.installColorSpace('RGB', ['red', 'green', 'blue', 'alpha'], {\n  hex: function () {\n    var hexString = (Math.round(255 * this._red) * 0x10000 + Math.round(255 * this._green) * 0x100 + Math.round(255 * this._blue)).toString(16);\n    return '#' + '00000'.substr(0, 6 - hexString.length) + hexString;\n  },\n  hexa: function () {\n    var alphaString = Math.round(this._alpha * 255).toString(16);\n    return '#' + '00'.substr(0, 2 - alphaString.length) + alphaString + this.hex().substr(1, 6);\n  },\n  css: function () {\n    return 'rgb(' + Math.round(255 * this._red) + ',' + Math.round(255 * this._green) + ',' + Math.round(255 * this._blue) + ')';\n  },\n  cssa: function () {\n    return 'rgba(' + Math.round(255 * this._red) + ',' + Math.round(255 * this._green) + ',' + Math.round(255 * this._blue) + ',' + this._alpha + ')';\n  }\n});\nvar color_1 = color;\n\nvar XYZ = function XYZ(color) {\n  color.installColorSpace('XYZ', ['x', 'y', 'z', 'alpha'], {\n    fromRgb: function () {\n      // http://www.easyrgb.com/index.php?X=MATH&H=02#text2\n      var convert = function (channel) {\n        return channel > 0.04045 ? Math.pow((channel + 0.055) / 1.055, 2.4) : channel / 12.92;\n      },\n          r = convert(this._red),\n          g = convert(this._green),\n          b = convert(this._blue); // Reference white point sRGB D65:\n      // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\n\n      return new color.XYZ(r * 0.4124564 + g * 0.3575761 + b * 0.1804375, r * 0.2126729 + g * 0.7151522 + b * 0.0721750, r * 0.0193339 + g * 0.1191920 + b * 0.9503041, this._alpha);\n    },\n    rgb: function () {\n      // http://www.easyrgb.com/index.php?X=MATH&H=01#text1\n      var x = this._x,\n          y = this._y,\n          z = this._z,\n          convert = function (channel) {\n        return channel > 0.0031308 ? 1.055 * Math.pow(channel, 1 / 2.4) - 0.055 : 12.92 * channel;\n      }; // Reference white point sRGB D65:\n      // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\n\n      return new color.RGB(convert(x * 3.2404542 + y * -1.5371385 + z * -0.4985314), convert(x * -0.9692660 + y * 1.8760108 + z * 0.0415560), convert(x * 0.0556434 + y * -0.2040259 + z * 1.0572252), this._alpha);\n    },\n    lab: function () {\n      // http://www.easyrgb.com/index.php?X=MATH&H=07#text7\n      var convert = function (channel) {\n        return channel > 0.008856 ? Math.pow(channel, 1 / 3) : 7.787037 * channel + 4 / 29;\n      },\n          x = convert(this._x / 95.047),\n          y = convert(this._y / 100.000),\n          z = convert(this._z / 108.883);\n\n      return new color.LAB(116 * y - 16, 500 * (x - y), 200 * (y - z), this._alpha);\n    }\n  });\n};\n\nvar LAB = function LAB(color) {\n  color.use(XYZ);\n  color.installColorSpace('LAB', ['l', 'a', 'b', 'alpha'], {\n    fromRgb: function () {\n      return this.xyz().lab();\n    },\n    rgb: function () {\n      return this.xyz().rgb();\n    },\n    xyz: function () {\n      // http://www.easyrgb.com/index.php?X=MATH&H=08#text8\n      var convert = function (channel) {\n        var pow = Math.pow(channel, 3);\n        return pow > 0.008856 ? pow : (channel - 16 / 116) / 7.87;\n      },\n          y = (this._l + 16) / 116,\n          x = this._a / 500 + y,\n          z = y - this._b / 200;\n\n      return new color.XYZ(convert(x) * 95.047, convert(y) * 100.000, convert(z) * 108.883, this._alpha);\n    }\n  });\n};\n\nvar HSV = function HSV(color) {\n  color.installColorSpace('HSV', ['hue', 'saturation', 'value', 'alpha'], {\n    rgb: function () {\n      var hue = this._hue,\n          saturation = this._saturation,\n          value = this._value,\n          i = Math.min(5, Math.floor(hue * 6)),\n          f = hue * 6 - i,\n          p = value * (1 - saturation),\n          q = value * (1 - f * saturation),\n          t = value * (1 - (1 - f) * saturation),\n          red,\n          green,\n          blue;\n\n      switch (i) {\n        case 0:\n          red = value;\n          green = t;\n          blue = p;\n          break;\n\n        case 1:\n          red = q;\n          green = value;\n          blue = p;\n          break;\n\n        case 2:\n          red = p;\n          green = value;\n          blue = t;\n          break;\n\n        case 3:\n          red = p;\n          green = q;\n          blue = value;\n          break;\n\n        case 4:\n          red = t;\n          green = p;\n          blue = value;\n          break;\n\n        case 5:\n          red = value;\n          green = p;\n          blue = q;\n          break;\n      }\n\n      return new color.RGB(red, green, blue, this._alpha);\n    },\n    hsl: function () {\n      var l = (2 - this._saturation) * this._value,\n          sv = this._saturation * this._value,\n          svDivisor = l <= 1 ? l : 2 - l,\n          saturation; // Avoid division by zero when lightness approaches zero:\n\n      if (svDivisor < 1e-9) {\n        saturation = 0;\n      } else {\n        saturation = sv / svDivisor;\n      }\n\n      return new color.HSL(this._hue, saturation, l / 2, this._alpha);\n    },\n    fromRgb: function () {\n      // Becomes one.color.RGB.prototype.hsv\n      var red = this._red,\n          green = this._green,\n          blue = this._blue,\n          max = Math.max(red, green, blue),\n          min = Math.min(red, green, blue),\n          delta = max - min,\n          hue,\n          saturation = max === 0 ? 0 : delta / max,\n          value = max;\n\n      if (delta === 0) {\n        hue = 0;\n      } else {\n        switch (max) {\n          case red:\n            hue = (green - blue) / delta / 6 + (green < blue ? 1 : 0);\n            break;\n\n          case green:\n            hue = (blue - red) / delta / 6 + 1 / 3;\n            break;\n\n          case blue:\n            hue = (red - green) / delta / 6 + 2 / 3;\n            break;\n        }\n      }\n\n      return new color.HSV(hue, saturation, value, this._alpha);\n    }\n  });\n};\n\nvar HSL = function HSL(color) {\n  color.use(HSV);\n  color.installColorSpace('HSL', ['hue', 'saturation', 'lightness', 'alpha'], {\n    hsv: function () {\n      // Algorithm adapted from http://wiki.secondlife.com/wiki/Color_conversion_scripts\n      var l = this._lightness * 2,\n          s = this._saturation * (l <= 1 ? l : 2 - l),\n          saturation; // Avoid division by zero when l + s is very small (approaching black):\n\n      if (l + s < 1e-9) {\n        saturation = 0;\n      } else {\n        saturation = 2 * s / (l + s);\n      }\n\n      return new color.HSV(this._hue, saturation, (l + s) / 2, this._alpha);\n    },\n    rgb: function () {\n      return this.hsv().rgb();\n    },\n    fromRgb: function () {\n      // Becomes one.color.RGB.prototype.hsv\n      return this.hsv().hsl();\n    }\n  });\n};\n\nvar CMYK = function CMYK(color) {\n  color.installColorSpace('CMYK', ['cyan', 'magenta', 'yellow', 'black', 'alpha'], {\n    rgb: function () {\n      return new color.RGB(1 - this._cyan * (1 - this._black) - this._black, 1 - this._magenta * (1 - this._black) - this._black, 1 - this._yellow * (1 - this._black) - this._black, this._alpha);\n    },\n    fromRgb: function () {\n      // Becomes one.color.RGB.prototype.cmyk\n      // Adapted from http://www.javascripter.net/faq/rgb2cmyk.htm\n      var red = this._red,\n          green = this._green,\n          blue = this._blue,\n          cyan = 1 - red,\n          magenta = 1 - green,\n          yellow = 1 - blue,\n          black = 1;\n\n      if (red || green || blue) {\n        black = Math.min(cyan, Math.min(magenta, yellow));\n        cyan = (cyan - black) / (1 - black);\n        magenta = (magenta - black) / (1 - black);\n        yellow = (yellow - black) / (1 - black);\n      } else {\n        black = 1;\n      }\n\n      return new color.CMYK(cyan, magenta, yellow, black, this._alpha);\n    }\n  });\n};\n\nvar namedColors = function namedColors(color) {\n  color.namedColors = {\n    aliceblue: 'f0f8ff',\n    antiquewhite: 'faebd7',\n    aqua: '0ff',\n    aquamarine: '7fffd4',\n    azure: 'f0ffff',\n    beige: 'f5f5dc',\n    bisque: 'ffe4c4',\n    black: '000',\n    blanchedalmond: 'ffebcd',\n    blue: '00f',\n    blueviolet: '8a2be2',\n    brown: 'a52a2a',\n    burlywood: 'deb887',\n    cadetblue: '5f9ea0',\n    chartreuse: '7fff00',\n    chocolate: 'd2691e',\n    coral: 'ff7f50',\n    cornflowerblue: '6495ed',\n    cornsilk: 'fff8dc',\n    crimson: 'dc143c',\n    cyan: '0ff',\n    darkblue: '00008b',\n    darkcyan: '008b8b',\n    darkgoldenrod: 'b8860b',\n    darkgray: 'a9a9a9',\n    darkgrey: 'a9a9a9',\n    darkgreen: '006400',\n    darkkhaki: 'bdb76b',\n    darkmagenta: '8b008b',\n    darkolivegreen: '556b2f',\n    darkorange: 'ff8c00',\n    darkorchid: '9932cc',\n    darkred: '8b0000',\n    darksalmon: 'e9967a',\n    darkseagreen: '8fbc8f',\n    darkslateblue: '483d8b',\n    darkslategray: '2f4f4f',\n    darkslategrey: '2f4f4f',\n    darkturquoise: '00ced1',\n    darkviolet: '9400d3',\n    deeppink: 'ff1493',\n    deepskyblue: '00bfff',\n    dimgray: '696969',\n    dimgrey: '696969',\n    dodgerblue: '1e90ff',\n    firebrick: 'b22222',\n    floralwhite: 'fffaf0',\n    forestgreen: '228b22',\n    fuchsia: 'f0f',\n    gainsboro: 'dcdcdc',\n    ghostwhite: 'f8f8ff',\n    gold: 'ffd700',\n    goldenrod: 'daa520',\n    gray: '808080',\n    grey: '808080',\n    green: '008000',\n    greenyellow: 'adff2f',\n    honeydew: 'f0fff0',\n    hotpink: 'ff69b4',\n    indianred: 'cd5c5c',\n    indigo: '4b0082',\n    ivory: 'fffff0',\n    khaki: 'f0e68c',\n    lavender: 'e6e6fa',\n    lavenderblush: 'fff0f5',\n    lawngreen: '7cfc00',\n    lemonchiffon: 'fffacd',\n    lightblue: 'add8e6',\n    lightcoral: 'f08080',\n    lightcyan: 'e0ffff',\n    lightgoldenrodyellow: 'fafad2',\n    lightgray: 'd3d3d3',\n    lightgrey: 'd3d3d3',\n    lightgreen: '90ee90',\n    lightpink: 'ffb6c1',\n    lightsalmon: 'ffa07a',\n    lightseagreen: '20b2aa',\n    lightskyblue: '87cefa',\n    lightslategray: '789',\n    lightslategrey: '789',\n    lightsteelblue: 'b0c4de',\n    lightyellow: 'ffffe0',\n    lime: '0f0',\n    limegreen: '32cd32',\n    linen: 'faf0e6',\n    magenta: 'f0f',\n    maroon: '800000',\n    mediumaquamarine: '66cdaa',\n    mediumblue: '0000cd',\n    mediumorchid: 'ba55d3',\n    mediumpurple: '9370d8',\n    mediumseagreen: '3cb371',\n    mediumslateblue: '7b68ee',\n    mediumspringgreen: '00fa9a',\n    mediumturquoise: '48d1cc',\n    mediumvioletred: 'c71585',\n    midnightblue: '191970',\n    mintcream: 'f5fffa',\n    mistyrose: 'ffe4e1',\n    moccasin: 'ffe4b5',\n    navajowhite: 'ffdead',\n    navy: '000080',\n    oldlace: 'fdf5e6',\n    olive: '808000',\n    olivedrab: '6b8e23',\n    orange: 'ffa500',\n    orangered: 'ff4500',\n    orchid: 'da70d6',\n    palegoldenrod: 'eee8aa',\n    palegreen: '98fb98',\n    paleturquoise: 'afeeee',\n    palevioletred: 'd87093',\n    papayawhip: 'ffefd5',\n    peachpuff: 'ffdab9',\n    peru: 'cd853f',\n    pink: 'ffc0cb',\n    plum: 'dda0dd',\n    powderblue: 'b0e0e6',\n    purple: '800080',\n    rebeccapurple: '639',\n    red: 'f00',\n    rosybrown: 'bc8f8f',\n    royalblue: '4169e1',\n    saddlebrown: '8b4513',\n    salmon: 'fa8072',\n    sandybrown: 'f4a460',\n    seagreen: '2e8b57',\n    seashell: 'fff5ee',\n    sienna: 'a0522d',\n    silver: 'c0c0c0',\n    skyblue: '87ceeb',\n    slateblue: '6a5acd',\n    slategray: '708090',\n    slategrey: '708090',\n    snow: 'fffafa',\n    springgreen: '00ff7f',\n    steelblue: '4682b4',\n    tan: 'd2b48c',\n    teal: '008080',\n    thistle: 'd8bfd8',\n    tomato: 'ff6347',\n    turquoise: '40e0d0',\n    violet: 'ee82ee',\n    wheat: 'f5deb3',\n    white: 'fff',\n    whitesmoke: 'f5f5f5',\n    yellow: 'ff0',\n    yellowgreen: '9acd32'\n  };\n};\n\nvar clearer = function clearer(color) {\n  color.installMethod('clearer', function (amount) {\n    return this.alpha(isNaN(amount) ? -0.1 : -amount, true);\n  });\n};\n\nvar luminance = function luminance(color) {\n  // http://www.w3.org/TR/WCAG20/#relativeluminancedef\n  function channelLuminance(value) {\n    return value <= 0.03928 ? value / 12.92 : Math.pow((value + 0.055) / 1.055, 2.4);\n  }\n\n  color.installMethod('luminance', function () {\n    var rgb = this.rgb();\n    return 0.2126 * channelLuminance(rgb._red) + 0.7152 * channelLuminance(rgb._green) + 0.0722 * channelLuminance(rgb._blue);\n  });\n};\n\nvar contrast = function contrast(color) {\n  // http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n  color.use(luminance);\n  color.installMethod('contrast', function (color2) {\n    var lum1 = this.luminance();\n    var lum2 = color2.luminance();\n\n    if (lum1 > lum2) {\n      return (lum1 + 0.05) / (lum2 + 0.05);\n    }\n\n    return (lum2 + 0.05) / (lum1 + 0.05);\n  });\n};\n\nvar darken = function darken(color) {\n  color.use(HSL);\n  color.installMethod('darken', function (amount) {\n    return this.lightness(isNaN(amount) ? -0.1 : -amount, true);\n  });\n};\n\nvar desaturate = function desaturate(color) {\n  color.use(HSL);\n  color.installMethod('desaturate', function (amount) {\n    return this.saturation(isNaN(amount) ? -0.1 : -amount, true);\n  });\n};\n\nvar grayscale = function grayscale(color) {\n  function gs() {\n    /*jslint strict:false*/\n    var rgb = this.rgb(),\n        val = rgb._red * 0.3 + rgb._green * 0.59 + rgb._blue * 0.11;\n    return new color.RGB(val, val, val, rgb._alpha);\n  }\n\n  color.installMethod('greyscale', gs).installMethod('grayscale', gs);\n};\n\nvar isDark = function isDark(color) {\n  color.installMethod('isDark', function () {\n    var rgb = this.rgb(); // YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\n    var yiq = (rgb._red * 255 * 299 + rgb._green * 255 * 587 + rgb._blue * 255 * 114) / 1000;\n    return yiq < 128;\n  });\n};\n\nvar isLight = function isLight(color) {\n  color.use(isDark);\n  color.installMethod('isLight', function () {\n    return !this.isDark();\n  });\n};\n\nvar lighten = function lighten(color) {\n  color.use(HSL);\n  color.installMethod('lighten', function (amount) {\n    return this.lightness(isNaN(amount) ? 0.1 : amount, true);\n  });\n};\n\nvar mix = function mix(color) {\n  color.installMethod('mix', function (otherColor, weight) {\n    otherColor = color(otherColor).rgb();\n    weight = 1 - (isNaN(weight) ? 0.5 : weight);\n    var w = weight * 2 - 1,\n        a = this._alpha - otherColor._alpha,\n        weight1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2,\n        weight2 = 1 - weight1,\n        rgb = this.rgb();\n    return new color.RGB(rgb._red * weight1 + otherColor._red * weight2, rgb._green * weight1 + otherColor._green * weight2, rgb._blue * weight1 + otherColor._blue * weight2, rgb._alpha * weight + otherColor._alpha * (1 - weight));\n  });\n};\n\nvar negate = function negate(color) {\n  color.installMethod('negate', function () {\n    var rgb = this.rgb();\n    return new color.RGB(1 - rgb._red, 1 - rgb._green, 1 - rgb._blue, this._alpha);\n  });\n};\n\nvar opaquer = function opaquer(color) {\n  color.installMethod('opaquer', function (amount) {\n    return this.alpha(isNaN(amount) ? 0.1 : amount, true);\n  });\n};\n\nvar rotate = function rotate(color) {\n  color.use(HSL);\n  color.installMethod('rotate', function (degrees) {\n    return this.hue((degrees || 0) / 360, true);\n  });\n};\n\nvar saturate = function saturate(color) {\n  color.use(HSL);\n  color.installMethod('saturate', function (amount) {\n    return this.saturation(isNaN(amount) ? 0.1 : amount, true);\n  });\n};\n\n// Adapted from http://gimp.sourcearchive.com/documentation/2.6.6-1ubuntu1/color-to-alpha_8c-source.html\n// toAlpha returns a color where the values of the argument have been converted to alpha\nvar toAlpha = function toAlpha(color) {\n  color.installMethod('toAlpha', function (color) {\n    var me = this.rgb(),\n        other = color(color).rgb(),\n        epsilon = 1e-10,\n        a = new color.RGB(0, 0, 0, me._alpha),\n        channels = ['_red', '_green', '_blue'];\n    channels.forEach(function (channel) {\n      if (me[channel] < epsilon) {\n        a[channel] = me[channel];\n      } else if (me[channel] > other[channel]) {\n        a[channel] = (me[channel] - other[channel]) / (1 - other[channel]);\n      } else if (me[channel] > other[channel]) {\n        a[channel] = (other[channel] - me[channel]) / other[channel];\n      } else {\n        a[channel] = 0;\n      }\n    });\n\n    if (a._red > a._green) {\n      if (a._red > a._blue) {\n        me._alpha = a._red;\n      } else {\n        me._alpha = a._blue;\n      }\n    } else if (a._green > a._blue) {\n      me._alpha = a._green;\n    } else {\n      me._alpha = a._blue;\n    }\n\n    if (me._alpha < epsilon) {\n      return me;\n    }\n\n    channels.forEach(function (channel) {\n      me[channel] = (me[channel] - other[channel]) / me._alpha + other[channel];\n    });\n    me._alpha *= a._alpha;\n    return me;\n  });\n};\n\nvar onecolor = color_1.use(XYZ).use(LAB).use(HSV).use(HSL).use(CMYK) // Convenience functions\n.use(namedColors).use(clearer).use(contrast).use(darken).use(desaturate).use(grayscale).use(isDark).use(isLight).use(lighten).use(luminance).use(mix).use(negate).use(opaquer).use(rotate).use(saturate).use(toAlpha);\n\nfunction getContrastRatio(foreground, background) {\n  var backgroundOnWhite = alphaBlend(background, '#fff');\n  var backgroundOnBlack = alphaBlend(background, '#000');\n  var LWhite = getRelativeLuminance(backgroundOnWhite);\n  var LBlack = getRelativeLuminance(backgroundOnBlack);\n  var LForeground = getRelativeLuminance(foreground);\n\n  if (LWhite < LForeground) {\n    return getContrastRatioOpaque(foreground, backgroundOnWhite);\n  } else if (LBlack > LForeground) {\n    return getContrastRatioOpaque(foreground, backgroundOnBlack);\n  } else {\n    return 1;\n  }\n}\n\nfunction alphaBlend(cssForeground, cssBackground) {\n  var foreground = onecolor(cssForeground);\n  var background = onecolor(cssBackground);\n  var result = onecolor('#fff');\n  var a = foreground.alpha();\n  result._red = foreground._red * a + background._red * (1 - a);\n  result._green = foreground._green * a + background._green * (1 - a);\n  result._blue = foreground._blue * a + background._blue * (1 - a);\n  return result;\n}\n\nfunction getContrastRatioOpaque(foreground, background) {\n  var L1 = getRelativeLuminance(background);\n  var L2 = getRelativeLuminance(alphaBlend(foreground, background)); // https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n\n  return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);\n}\n\nfunction getRelativeLuminance(cssColor) {\n  // https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n  var color = onecolor(cssColor);\n  var R = color._red <= 0.03928 ? color._red / 12.92 : Math.pow((color._red + 0.055) / 1.055, 2.4);\n  var G = color._green <= 0.03928 ? color._green / 12.92 : Math.pow((color._green + 0.055) / 1.055, 2.4);\n  var B = color._blue <= 0.03928 ? color._blue / 12.92 : Math.pow((color._blue + 0.055) / 1.055, 2.4);\n  var L = 0.2126 * R + 0.7152 * G + 0.0722 * B;\n  return L;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getContrastRatio);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb2xvci1jb250cmFzdC9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOzs7QUFHQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFFQUFxRTs7QUFFckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsZ0JBQWdCLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXZpZGViaXNjdXNvL0RvY3VtZW50cy9HaXRIdWIvY29sb3ItcmFtcC9ub2RlX21vZHVsZXMvY29sb3ItY29udHJhc3QvZGlzdC9pbmRleC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGluc3RhbGxlZENvbG9yU3BhY2VzID0gW10sXG4gICAgdW5kZWYgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJztcbn0sXG4gICAgY2hhbm5lbFJlZ0V4cCA9IC9cXHMqKFxcLlxcZCt8XFxkKyg/OlxcLlxcZCspPykoJSk/XFxzKi8sXG4gICAgcGVyY2VudGFnZUNoYW5uZWxSZWdFeHAgPSAvXFxzKihcXC5cXGQrfDEwMHxcXGQ/XFxkKD86XFwuXFxkKyk/KSVcXHMqLyxcbiAgICBhbHBoYUNoYW5uZWxSZWdFeHAgPSAvXFxzKihcXC5cXGQrfFxcZCsoPzpcXC5cXGQrKT8pXFxzKi8sXG4gICAgY3NzQ29sb3JSZWdFeHAgPSBuZXcgUmVnRXhwKCdeKHJnYnxoc2x8aHN2KWE/JyArICdcXFxcKCcgKyBjaGFubmVsUmVnRXhwLnNvdXJjZSArICcsJyArIGNoYW5uZWxSZWdFeHAuc291cmNlICsgJywnICsgY2hhbm5lbFJlZ0V4cC5zb3VyY2UgKyAnKD86LCcgKyBhbHBoYUNoYW5uZWxSZWdFeHAuc291cmNlICsgJyk/JyArICdcXFxcKSQnLCAnaScpO1xuXG5mdW5jdGlvbiBjb2xvcihvYmopIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIGlmICh0eXBlb2Ygb2JqWzBdID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgY29sb3Jbb2JqWzBdXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQXNzdW1lZCBhcnJheSBmcm9tIC50b0pTT04oKVxuICAgICAgcmV0dXJuIG5ldyBjb2xvcltvYmpbMF1dKG9iai5zbGljZSgxLCBvYmoubGVuZ3RoKSk7XG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSA0KSB7XG4gICAgICAvLyBBc3N1bWVkIDQgZWxlbWVudCBpbnQgUkdCIGFycmF5IGZyb20gY2FudmFzIHdpdGggYWxsIGNoYW5uZWxzIFswOzI1NV1cbiAgICAgIHJldHVybiBuZXcgY29sb3IuUkdCKG9ialswXSAvIDI1NSwgb2JqWzFdIC8gMjU1LCBvYmpbMl0gLyAyNTUsIG9ialszXSAvIDI1NSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWQgPSBvYmoudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChjb2xvci5uYW1lZENvbG9yc1tsb3dlckNhc2VkXSkge1xuICAgICAgb2JqID0gJyMnICsgY29sb3IubmFtZWRDb2xvcnNbbG93ZXJDYXNlZF07XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWQgPT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgIG9iaiA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICB9IC8vIFRlc3QgZm9yIENTUyByZ2IoLi4uLikgc3RyaW5nXG5cblxuICAgIHZhciBtYXRjaENzc1N5bnRheCA9IG9iai5tYXRjaChjc3NDb2xvclJlZ0V4cCk7XG5cbiAgICBpZiAobWF0Y2hDc3NTeW50YXgpIHtcbiAgICAgIHZhciBjb2xvclNwYWNlTmFtZSA9IG1hdGNoQ3NzU3ludGF4WzFdLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgYWxwaGEgPSB1bmRlZihtYXRjaENzc1N5bnRheFs4XSkgPyBtYXRjaENzc1N5bnRheFs4XSA6IHBhcnNlRmxvYXQobWF0Y2hDc3NTeW50YXhbOF0pLFxuICAgICAgICAgIGhhc0h1ZSA9IGNvbG9yU3BhY2VOYW1lWzBdID09PSAnSCcsXG4gICAgICAgICAgZmlyc3RDaGFubmVsRGl2aXNvciA9IG1hdGNoQ3NzU3ludGF4WzNdID8gMTAwIDogaGFzSHVlID8gMzYwIDogMjU1LFxuICAgICAgICAgIHNlY29uZENoYW5uZWxEaXZpc29yID0gbWF0Y2hDc3NTeW50YXhbNV0gfHwgaGFzSHVlID8gMTAwIDogMjU1LFxuICAgICAgICAgIHRoaXJkQ2hhbm5lbERpdmlzb3IgPSBtYXRjaENzc1N5bnRheFs3XSB8fCBoYXNIdWUgPyAxMDAgOiAyNTU7XG5cbiAgICAgIGlmICh1bmRlZihjb2xvcltjb2xvclNwYWNlTmFtZV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29sb3IuJyArIGNvbG9yU3BhY2VOYW1lICsgJyBpcyBub3QgaW5zdGFsbGVkLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IGNvbG9yW2NvbG9yU3BhY2VOYW1lXShwYXJzZUZsb2F0KG1hdGNoQ3NzU3ludGF4WzJdKSAvIGZpcnN0Q2hhbm5lbERpdmlzb3IsIHBhcnNlRmxvYXQobWF0Y2hDc3NTeW50YXhbNF0pIC8gc2Vjb25kQ2hhbm5lbERpdmlzb3IsIHBhcnNlRmxvYXQobWF0Y2hDc3NTeW50YXhbNl0pIC8gdGhpcmRDaGFubmVsRGl2aXNvciwgYWxwaGEpO1xuICAgIH0gLy8gQXNzdW1lIGhleCBzeW50YXhcblxuXG4gICAgaWYgKG9iai5sZW5ndGggPCA2KSB7XG4gICAgICAvLyBBbGxvdyBDU1Mgc2hvcnRoYW5kXG4gICAgICBvYmogPSBvYmoucmVwbGFjZSgvXiM/KFswLTlhLWZdKShbMC05YS1mXSkoWzAtOWEtZl0pJC9pLCAnJDEkMSQyJDIkMyQzJyk7XG4gICAgfSAvLyBTcGxpdCBvYmogaW50byByZWQsIGdyZWVuLCBhbmQgYmx1ZSBjb21wb25lbnRzXG5cblxuICAgIHZhciBoZXhNYXRjaCA9IG9iai5tYXRjaCgvXiM/KFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdWzAtOWEtZl0pJC9pKTtcblxuICAgIGlmIChoZXhNYXRjaCkge1xuICAgICAgcmV0dXJuIG5ldyBjb2xvci5SR0IocGFyc2VJbnQoaGV4TWF0Y2hbMV0sIDE2KSAvIDI1NSwgcGFyc2VJbnQoaGV4TWF0Y2hbMl0sIDE2KSAvIDI1NSwgcGFyc2VJbnQoaGV4TWF0Y2hbM10sIDE2KSAvIDI1NSk7XG4gICAgfSAvLyBObyBtYXRjaCBzbyBmYXIuIExldHMgdHJ5IHRoZSBsZXNzIGxpa2VseSBvbmVzXG5cblxuICAgIGlmIChjb2xvci5DTVlLKSB7XG4gICAgICB2YXIgY215a01hdGNoID0gb2JqLm1hdGNoKG5ldyBSZWdFeHAoJ15jbXlrJyArICdcXFxcKCcgKyBwZXJjZW50YWdlQ2hhbm5lbFJlZ0V4cC5zb3VyY2UgKyAnLCcgKyBwZXJjZW50YWdlQ2hhbm5lbFJlZ0V4cC5zb3VyY2UgKyAnLCcgKyBwZXJjZW50YWdlQ2hhbm5lbFJlZ0V4cC5zb3VyY2UgKyAnLCcgKyBwZXJjZW50YWdlQ2hhbm5lbFJlZ0V4cC5zb3VyY2UgKyAnXFxcXCkkJywgJ2knKSk7XG5cbiAgICAgIGlmIChjbXlrTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb2xvci5DTVlLKHBhcnNlRmxvYXQoY215a01hdGNoWzFdKSAvIDEwMCwgcGFyc2VGbG9hdChjbXlrTWF0Y2hbMl0pIC8gMTAwLCBwYXJzZUZsb2F0KGNteWtNYXRjaFszXSkgLyAxMDAsIHBhcnNlRmxvYXQoY215a01hdGNoWzRdKSAvIDEwMCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iai5pc0NvbG9yKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuY29sb3IubmFtZWRDb2xvcnMgPSB7fTtcblxuY29sb3IuaW5zdGFsbENvbG9yU3BhY2UgPSBmdW5jdGlvbiAoY29sb3JTcGFjZU5hbWUsIHByb3BlcnR5TmFtZXMsIGNvbmZpZykge1xuICBjb2xvcltjb2xvclNwYWNlTmFtZV0gPSBmdW5jdGlvbiAoYTEpIHtcbiAgICAvLyAuLi5cbiAgICB2YXIgYXJncyA9IEFycmF5LmlzQXJyYXkoYTEpID8gYTEgOiBhcmd1bWVudHM7XG4gICAgcHJvcGVydHlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUsIGkpIHtcbiAgICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gYXJnc1tpXTtcblxuICAgICAgaWYgKHByb3BlcnR5TmFtZSA9PT0gJ2FscGhhJykge1xuICAgICAgICB0aGlzLl9hbHBoYSA9IGlzTmFOKHByb3BlcnR5VmFsdWUpIHx8IHByb3BlcnR5VmFsdWUgPiAxID8gMSA6IHByb3BlcnR5VmFsdWUgPCAwID8gMCA6IHByb3BlcnR5VmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNOYU4ocHJvcGVydHlWYWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1snICsgY29sb3JTcGFjZU5hbWUgKyAnXTogSW52YWxpZCBjb2xvcjogKCcgKyBwcm9wZXJ0eU5hbWVzLmpvaW4oJywnKSArICcpJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydHlOYW1lID09PSAnaHVlJykge1xuICAgICAgICAgIHRoaXMuX2h1ZSA9IHByb3BlcnR5VmFsdWUgPCAwID8gcHJvcGVydHlWYWx1ZSAtIE1hdGguZmxvb3IocHJvcGVydHlWYWx1ZSkgOiBwcm9wZXJ0eVZhbHVlICUgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzWydfJyArIHByb3BlcnR5TmFtZV0gPSBwcm9wZXJ0eVZhbHVlIDwgMCA/IDAgOiBwcm9wZXJ0eVZhbHVlID4gMSA/IDEgOiBwcm9wZXJ0eVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbiAgY29sb3JbY29sb3JTcGFjZU5hbWVdLnByb3BlcnR5TmFtZXMgPSBwcm9wZXJ0eU5hbWVzO1xuICB2YXIgcHJvdG90eXBlID0gY29sb3JbY29sb3JTcGFjZU5hbWVdLnByb3RvdHlwZTtcbiAgWyd2YWx1ZU9mJywgJ2hleCcsICdoZXhhJywgJ2NzcycsICdjc3NhJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHByb3RvdHlwZVttZXRob2ROYW1lXSA9IHByb3RvdHlwZVttZXRob2ROYW1lXSB8fCAoY29sb3JTcGFjZU5hbWUgPT09ICdSR0InID8gcHJvdG90eXBlLmhleCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJnYigpW21ldGhvZE5hbWVdKCk7XG4gICAgfSk7XG4gIH0pO1xuICBwcm90b3R5cGUuaXNDb2xvciA9IHRydWU7XG5cbiAgcHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlckNvbG9yLCBlcHNpbG9uKSB7XG4gICAgaWYgKHVuZGVmKGVwc2lsb24pKSB7XG4gICAgICBlcHNpbG9uID0gMWUtMTA7XG4gICAgfVxuXG4gICAgb3RoZXJDb2xvciA9IG90aGVyQ29sb3JbY29sb3JTcGFjZU5hbWUudG9Mb3dlckNhc2UoKV0oKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydHlOYW1lcy5sZW5ndGg7IGkgPSBpICsgMSkge1xuICAgICAgaWYgKE1hdGguYWJzKHRoaXNbJ18nICsgcHJvcGVydHlOYW1lc1tpXV0gLSBvdGhlckNvbG9yWydfJyArIHByb3BlcnR5TmFtZXNbaV1dKSA+IGVwc2lsb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtjb2xvclNwYWNlTmFtZV0uY29uY2F0KHByb3BlcnR5TmFtZXMubWFwKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzWydfJyArIHByb3BlcnR5TmFtZV07XG4gICAgfSwgdGhpcykpO1xuICB9O1xuXG4gIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcbiAgICAgIHZhciBtYXRjaEZyb21Db2xvclNwYWNlID0gcHJvcGVydHlOYW1lLm1hdGNoKC9eZnJvbSguKikkLyk7XG5cbiAgICAgIGlmIChtYXRjaEZyb21Db2xvclNwYWNlKSB7XG4gICAgICAgIGNvbG9yW21hdGNoRnJvbUNvbG9yU3BhY2VbMV0udG9VcHBlckNhc2UoKV0ucHJvdG90eXBlW2NvbG9yU3BhY2VOYW1lLnRvTG93ZXJDYXNlKCldID0gY29uZmlnW3Byb3BlcnR5TmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm90b3R5cGVbcHJvcGVydHlOYW1lXSA9IGNvbmZpZ1twcm9wZXJ0eU5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBJdCBpcyBwcmV0dHkgZWFzeSB0byBpbXBsZW1lbnQgdGhlIGNvbnZlcnNpb24gdG8gdGhlIHNhbWUgY29sb3Igc3BhY2U6XG5cblxuICBwcm90b3R5cGVbY29sb3JTcGFjZU5hbWUudG9Mb3dlckNhc2UoKV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnWycgKyBjb2xvclNwYWNlTmFtZSArICcgJyArIHByb3BlcnR5TmFtZXMubWFwKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzWydfJyArIHByb3BlcnR5TmFtZV07XG4gICAgfSwgdGhpcykuam9pbignLCAnKSArICddJztcbiAgfTsgLy8gR2VuZXJhdGUgZ2V0dGVycyBhbmQgc2V0dGVyc1xuXG5cbiAgcHJvcGVydHlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICB2YXIgc2hvcnROYW1lID0gcHJvcGVydHlOYW1lID09PSAnYmxhY2snID8gJ2snIDogcHJvcGVydHlOYW1lLmNoYXJBdCgwKTtcblxuICAgIHByb3RvdHlwZVtwcm9wZXJ0eU5hbWVdID0gcHJvdG90eXBlW3Nob3J0TmFtZV0gPSBmdW5jdGlvbiAodmFsdWUsIGlzRGVsdGEpIHtcbiAgICAgIC8vIFNpbXBsZSBnZXR0ZXIgbW9kZTogY29sb3IucmVkKClcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzWydfJyArIHByb3BlcnR5TmFtZV07XG4gICAgICB9IGVsc2UgaWYgKGlzRGVsdGEpIHtcbiAgICAgICAgLy8gQWRqdXN0ZXI6IGNvbG9yLnJlZCgrLjIsIHRydWUpXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihwcm9wZXJ0eU5hbWVzLm1hcChmdW5jdGlvbiAob3RoZXJQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc1snXycgKyBvdGhlclByb3BlcnR5TmFtZV0gKyAocHJvcGVydHlOYW1lID09PSBvdGhlclByb3BlcnR5TmFtZSA/IHZhbHVlIDogMCk7XG4gICAgICAgIH0sIHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNldHRlcjogY29sb3IucmVkKC4yKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHByb3BlcnR5TmFtZXMubWFwKGZ1bmN0aW9uIChvdGhlclByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIHJldHVybiBwcm9wZXJ0eU5hbWUgPT09IG90aGVyUHJvcGVydHlOYW1lID8gdmFsdWUgOiB0aGlzWydfJyArIG90aGVyUHJvcGVydHlOYW1lXTtcbiAgICAgICAgfSwgdGhpcykpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGluc3RhbGxGb3JlaWduTWV0aG9kcyh0YXJnZXRDb2xvclNwYWNlTmFtZSwgc291cmNlQ29sb3JTcGFjZU5hbWUpIHtcbiAgICB2YXIgb2JqID0ge307XG5cbiAgICBvYmpbc291cmNlQ29sb3JTcGFjZU5hbWUudG9Mb3dlckNhc2UoKV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZ2IoKVtzb3VyY2VDb2xvclNwYWNlTmFtZS50b0xvd2VyQ2FzZSgpXSgpO1xuICAgIH07XG5cbiAgICBjb2xvcltzb3VyY2VDb2xvclNwYWNlTmFtZV0ucHJvcGVydHlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIHZhciBzaG9ydE5hbWUgPSBwcm9wZXJ0eU5hbWUgPT09ICdibGFjaycgPyAnaycgOiBwcm9wZXJ0eU5hbWUuY2hhckF0KDApO1xuXG4gICAgICBvYmpbcHJvcGVydHlOYW1lXSA9IG9ialtzaG9ydE5hbWVdID0gZnVuY3Rpb24gKHZhbHVlLCBpc0RlbHRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3NvdXJjZUNvbG9yU3BhY2VOYW1lLnRvTG93ZXJDYXNlKCldKClbcHJvcGVydHlOYW1lXSh2YWx1ZSwgaXNEZWx0YSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkgJiYgY29sb3JbdGFyZ2V0Q29sb3JTcGFjZU5hbWVdLnByb3RvdHlwZVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbG9yW3RhcmdldENvbG9yU3BhY2VOYW1lXS5wcm90b3R5cGVbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5zdGFsbGVkQ29sb3JTcGFjZXMuZm9yRWFjaChmdW5jdGlvbiAob3RoZXJDb2xvclNwYWNlTmFtZSkge1xuICAgIGluc3RhbGxGb3JlaWduTWV0aG9kcyhjb2xvclNwYWNlTmFtZSwgb3RoZXJDb2xvclNwYWNlTmFtZSk7XG4gICAgaW5zdGFsbEZvcmVpZ25NZXRob2RzKG90aGVyQ29sb3JTcGFjZU5hbWUsIGNvbG9yU3BhY2VOYW1lKTtcbiAgfSk7XG4gIGluc3RhbGxlZENvbG9yU3BhY2VzLnB1c2goY29sb3JTcGFjZU5hbWUpO1xuICByZXR1cm4gY29sb3I7XG59O1xuXG5jb2xvci5wbHVnaW5MaXN0ID0gW107XG5cbmNvbG9yLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgaWYgKGNvbG9yLnBsdWdpbkxpc3QuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuICAgIHRoaXMucGx1Z2luTGlzdC5wdXNoKHBsdWdpbik7XG4gICAgcGx1Z2luKGNvbG9yKTtcbiAgfVxuXG4gIHJldHVybiBjb2xvcjtcbn07XG5cbmNvbG9yLmluc3RhbGxNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgaW5zdGFsbGVkQ29sb3JTcGFjZXMuZm9yRWFjaChmdW5jdGlvbiAoY29sb3JTcGFjZSkge1xuICAgIGNvbG9yW2NvbG9yU3BhY2VdLnByb3RvdHlwZVtuYW1lXSA9IGZuO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5jb2xvci5pbnN0YWxsQ29sb3JTcGFjZSgnUkdCJywgWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZScsICdhbHBoYSddLCB7XG4gIGhleDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBoZXhTdHJpbmcgPSAoTWF0aC5yb3VuZCgyNTUgKiB0aGlzLl9yZWQpICogMHgxMDAwMCArIE1hdGgucm91bmQoMjU1ICogdGhpcy5fZ3JlZW4pICogMHgxMDAgKyBNYXRoLnJvdW5kKDI1NSAqIHRoaXMuX2JsdWUpKS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuICcjJyArICcwMDAwMCcuc3Vic3RyKDAsIDYgLSBoZXhTdHJpbmcubGVuZ3RoKSArIGhleFN0cmluZztcbiAgfSxcbiAgaGV4YTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBhbHBoYVN0cmluZyA9IE1hdGgucm91bmQodGhpcy5fYWxwaGEgKiAyNTUpLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gJyMnICsgJzAwJy5zdWJzdHIoMCwgMiAtIGFscGhhU3RyaW5nLmxlbmd0aCkgKyBhbHBoYVN0cmluZyArIHRoaXMuaGV4KCkuc3Vic3RyKDEsIDYpO1xuICB9LFxuICBjc3M6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ3JnYignICsgTWF0aC5yb3VuZCgyNTUgKiB0aGlzLl9yZWQpICsgJywnICsgTWF0aC5yb3VuZCgyNTUgKiB0aGlzLl9ncmVlbikgKyAnLCcgKyBNYXRoLnJvdW5kKDI1NSAqIHRoaXMuX2JsdWUpICsgJyknO1xuICB9LFxuICBjc3NhOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdyZ2JhKCcgKyBNYXRoLnJvdW5kKDI1NSAqIHRoaXMuX3JlZCkgKyAnLCcgKyBNYXRoLnJvdW5kKDI1NSAqIHRoaXMuX2dyZWVuKSArICcsJyArIE1hdGgucm91bmQoMjU1ICogdGhpcy5fYmx1ZSkgKyAnLCcgKyB0aGlzLl9hbHBoYSArICcpJztcbiAgfVxufSk7XG52YXIgY29sb3JfMSA9IGNvbG9yO1xuXG52YXIgWFlaID0gZnVuY3Rpb24gWFlaKGNvbG9yKSB7XG4gIGNvbG9yLmluc3RhbGxDb2xvclNwYWNlKCdYWVonLCBbJ3gnLCAneScsICd6JywgJ2FscGhhJ10sIHtcbiAgICBmcm9tUmdiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBodHRwOi8vd3d3LmVhc3lyZ2IuY29tL2luZGV4LnBocD9YPU1BVEgmSD0wMiN0ZXh0MlxuICAgICAgdmFyIGNvbnZlcnQgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gY2hhbm5lbCA+IDAuMDQwNDUgPyBNYXRoLnBvdygoY2hhbm5lbCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpIDogY2hhbm5lbCAvIDEyLjkyO1xuICAgICAgfSxcbiAgICAgICAgICByID0gY29udmVydCh0aGlzLl9yZWQpLFxuICAgICAgICAgIGcgPSBjb252ZXJ0KHRoaXMuX2dyZWVuKSxcbiAgICAgICAgICBiID0gY29udmVydCh0aGlzLl9ibHVlKTsgLy8gUmVmZXJlbmNlIHdoaXRlIHBvaW50IHNSR0IgRDY1OlxuICAgICAgLy8gaHR0cDovL3d3dy5icnVjZWxpbmRibG9vbS5jb20vaW5kZXguaHRtbD9FcW5fUkdCX1hZWl9NYXRyaXguaHRtbFxuXG5cbiAgICAgIHJldHVybiBuZXcgY29sb3IuWFlaKHIgKiAwLjQxMjQ1NjQgKyBnICogMC4zNTc1NzYxICsgYiAqIDAuMTgwNDM3NSwgciAqIDAuMjEyNjcyOSArIGcgKiAwLjcxNTE1MjIgKyBiICogMC4wNzIxNzUwLCByICogMC4wMTkzMzM5ICsgZyAqIDAuMTE5MTkyMCArIGIgKiAwLjk1MDMwNDEsIHRoaXMuX2FscGhhKTtcbiAgICB9LFxuICAgIHJnYjogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gaHR0cDovL3d3dy5lYXN5cmdiLmNvbS9pbmRleC5waHA/WD1NQVRIJkg9MDEjdGV4dDFcbiAgICAgIHZhciB4ID0gdGhpcy5feCxcbiAgICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgICB6ID0gdGhpcy5feixcbiAgICAgICAgICBjb252ZXJ0ID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWwgPiAwLjAwMzEzMDggPyAxLjA1NSAqIE1hdGgucG93KGNoYW5uZWwsIDEgLyAyLjQpIC0gMC4wNTUgOiAxMi45MiAqIGNoYW5uZWw7XG4gICAgICB9OyAvLyBSZWZlcmVuY2Ugd2hpdGUgcG9pbnQgc1JHQiBENjU6XG4gICAgICAvLyBodHRwOi8vd3d3LmJydWNlbGluZGJsb29tLmNvbS9pbmRleC5odG1sP0Vxbl9SR0JfWFlaX01hdHJpeC5odG1sXG5cblxuICAgICAgcmV0dXJuIG5ldyBjb2xvci5SR0IoY29udmVydCh4ICogMy4yNDA0NTQyICsgeSAqIC0xLjUzNzEzODUgKyB6ICogLTAuNDk4NTMxNCksIGNvbnZlcnQoeCAqIC0wLjk2OTI2NjAgKyB5ICogMS44NzYwMTA4ICsgeiAqIDAuMDQxNTU2MCksIGNvbnZlcnQoeCAqIDAuMDU1NjQzNCArIHkgKiAtMC4yMDQwMjU5ICsgeiAqIDEuMDU3MjI1MiksIHRoaXMuX2FscGhhKTtcbiAgICB9LFxuICAgIGxhYjogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gaHR0cDovL3d3dy5lYXN5cmdiLmNvbS9pbmRleC5waHA/WD1NQVRIJkg9MDcjdGV4dDdcbiAgICAgIHZhciBjb252ZXJ0ID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWwgPiAwLjAwODg1NiA/IE1hdGgucG93KGNoYW5uZWwsIDEgLyAzKSA6IDcuNzg3MDM3ICogY2hhbm5lbCArIDQgLyAyOTtcbiAgICAgIH0sXG4gICAgICAgICAgeCA9IGNvbnZlcnQodGhpcy5feCAvIDk1LjA0NyksXG4gICAgICAgICAgeSA9IGNvbnZlcnQodGhpcy5feSAvIDEwMC4wMDApLFxuICAgICAgICAgIHogPSBjb252ZXJ0KHRoaXMuX3ogLyAxMDguODgzKTtcblxuICAgICAgcmV0dXJuIG5ldyBjb2xvci5MQUIoMTE2ICogeSAtIDE2LCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopLCB0aGlzLl9hbHBoYSk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBMQUIgPSBmdW5jdGlvbiBMQUIoY29sb3IpIHtcbiAgY29sb3IudXNlKFhZWik7XG4gIGNvbG9yLmluc3RhbGxDb2xvclNwYWNlKCdMQUInLCBbJ2wnLCAnYScsICdiJywgJ2FscGhhJ10sIHtcbiAgICBmcm9tUmdiOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy54eXooKS5sYWIoKTtcbiAgICB9LFxuICAgIHJnYjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMueHl6KCkucmdiKCk7XG4gICAgfSxcbiAgICB4eXo6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGh0dHA6Ly93d3cuZWFzeXJnYi5jb20vaW5kZXgucGhwP1g9TUFUSCZIPTA4I3RleHQ4XG4gICAgICB2YXIgY29udmVydCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHZhciBwb3cgPSBNYXRoLnBvdyhjaGFubmVsLCAzKTtcbiAgICAgICAgcmV0dXJuIHBvdyA+IDAuMDA4ODU2ID8gcG93IDogKGNoYW5uZWwgLSAxNiAvIDExNikgLyA3Ljg3O1xuICAgICAgfSxcbiAgICAgICAgICB5ID0gKHRoaXMuX2wgKyAxNikgLyAxMTYsXG4gICAgICAgICAgeCA9IHRoaXMuX2EgLyA1MDAgKyB5LFxuICAgICAgICAgIHogPSB5IC0gdGhpcy5fYiAvIDIwMDtcblxuICAgICAgcmV0dXJuIG5ldyBjb2xvci5YWVooY29udmVydCh4KSAqIDk1LjA0NywgY29udmVydCh5KSAqIDEwMC4wMDAsIGNvbnZlcnQoeikgKiAxMDguODgzLCB0aGlzLl9hbHBoYSk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBIU1YgPSBmdW5jdGlvbiBIU1YoY29sb3IpIHtcbiAgY29sb3IuaW5zdGFsbENvbG9yU3BhY2UoJ0hTVicsIFsnaHVlJywgJ3NhdHVyYXRpb24nLCAndmFsdWUnLCAnYWxwaGEnXSwge1xuICAgIHJnYjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGh1ZSA9IHRoaXMuX2h1ZSxcbiAgICAgICAgICBzYXR1cmF0aW9uID0gdGhpcy5fc2F0dXJhdGlvbixcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3ZhbHVlLFxuICAgICAgICAgIGkgPSBNYXRoLm1pbig1LCBNYXRoLmZsb29yKGh1ZSAqIDYpKSxcbiAgICAgICAgICBmID0gaHVlICogNiAtIGksXG4gICAgICAgICAgcCA9IHZhbHVlICogKDEgLSBzYXR1cmF0aW9uKSxcbiAgICAgICAgICBxID0gdmFsdWUgKiAoMSAtIGYgKiBzYXR1cmF0aW9uKSxcbiAgICAgICAgICB0ID0gdmFsdWUgKiAoMSAtICgxIC0gZikgKiBzYXR1cmF0aW9uKSxcbiAgICAgICAgICByZWQsXG4gICAgICAgICAgZ3JlZW4sXG4gICAgICAgICAgYmx1ZTtcblxuICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZWQgPSB2YWx1ZTtcbiAgICAgICAgICBncmVlbiA9IHQ7XG4gICAgICAgICAgYmx1ZSA9IHA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJlZCA9IHE7XG4gICAgICAgICAgZ3JlZW4gPSB2YWx1ZTtcbiAgICAgICAgICBibHVlID0gcDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmVkID0gcDtcbiAgICAgICAgICBncmVlbiA9IHZhbHVlO1xuICAgICAgICAgIGJsdWUgPSB0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZWQgPSBwO1xuICAgICAgICAgIGdyZWVuID0gcTtcbiAgICAgICAgICBibHVlID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJlZCA9IHQ7XG4gICAgICAgICAgZ3JlZW4gPSBwO1xuICAgICAgICAgIGJsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmVkID0gdmFsdWU7XG4gICAgICAgICAgZ3JlZW4gPSBwO1xuICAgICAgICAgIGJsdWUgPSBxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IGNvbG9yLlJHQihyZWQsIGdyZWVuLCBibHVlLCB0aGlzLl9hbHBoYSk7XG4gICAgfSxcbiAgICBoc2w6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsID0gKDIgLSB0aGlzLl9zYXR1cmF0aW9uKSAqIHRoaXMuX3ZhbHVlLFxuICAgICAgICAgIHN2ID0gdGhpcy5fc2F0dXJhdGlvbiAqIHRoaXMuX3ZhbHVlLFxuICAgICAgICAgIHN2RGl2aXNvciA9IGwgPD0gMSA/IGwgOiAyIC0gbCxcbiAgICAgICAgICBzYXR1cmF0aW9uOyAvLyBBdm9pZCBkaXZpc2lvbiBieSB6ZXJvIHdoZW4gbGlnaHRuZXNzIGFwcHJvYWNoZXMgemVybzpcblxuICAgICAgaWYgKHN2RGl2aXNvciA8IDFlLTkpIHtcbiAgICAgICAgc2F0dXJhdGlvbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzYXR1cmF0aW9uID0gc3YgLyBzdkRpdmlzb3I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgY29sb3IuSFNMKHRoaXMuX2h1ZSwgc2F0dXJhdGlvbiwgbCAvIDIsIHRoaXMuX2FscGhhKTtcbiAgICB9LFxuICAgIGZyb21SZ2I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEJlY29tZXMgb25lLmNvbG9yLlJHQi5wcm90b3R5cGUuaHN2XG4gICAgICB2YXIgcmVkID0gdGhpcy5fcmVkLFxuICAgICAgICAgIGdyZWVuID0gdGhpcy5fZ3JlZW4sXG4gICAgICAgICAgYmx1ZSA9IHRoaXMuX2JsdWUsXG4gICAgICAgICAgbWF4ID0gTWF0aC5tYXgocmVkLCBncmVlbiwgYmx1ZSksXG4gICAgICAgICAgbWluID0gTWF0aC5taW4ocmVkLCBncmVlbiwgYmx1ZSksXG4gICAgICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICAgICAgaHVlLFxuICAgICAgICAgIHNhdHVyYXRpb24gPSBtYXggPT09IDAgPyAwIDogZGVsdGEgLyBtYXgsXG4gICAgICAgICAgdmFsdWUgPSBtYXg7XG5cbiAgICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgICBodWUgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICBjYXNlIHJlZDpcbiAgICAgICAgICAgIGh1ZSA9IChncmVlbiAtIGJsdWUpIC8gZGVsdGEgLyA2ICsgKGdyZWVuIDwgYmx1ZSA/IDEgOiAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBncmVlbjpcbiAgICAgICAgICAgIGh1ZSA9IChibHVlIC0gcmVkKSAvIGRlbHRhIC8gNiArIDEgLyAzO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIGJsdWU6XG4gICAgICAgICAgICBodWUgPSAocmVkIC0gZ3JlZW4pIC8gZGVsdGEgLyA2ICsgMiAvIDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IGNvbG9yLkhTVihodWUsIHNhdHVyYXRpb24sIHZhbHVlLCB0aGlzLl9hbHBoYSk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBIU0wgPSBmdW5jdGlvbiBIU0woY29sb3IpIHtcbiAgY29sb3IudXNlKEhTVik7XG4gIGNvbG9yLmluc3RhbGxDb2xvclNwYWNlKCdIU0wnLCBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcycsICdhbHBoYSddLCB7XG4gICAgaHN2OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBBbGdvcml0aG0gYWRhcHRlZCBmcm9tIGh0dHA6Ly93aWtpLnNlY29uZGxpZmUuY29tL3dpa2kvQ29sb3JfY29udmVyc2lvbl9zY3JpcHRzXG4gICAgICB2YXIgbCA9IHRoaXMuX2xpZ2h0bmVzcyAqIDIsXG4gICAgICAgICAgcyA9IHRoaXMuX3NhdHVyYXRpb24gKiAobCA8PSAxID8gbCA6IDIgLSBsKSxcbiAgICAgICAgICBzYXR1cmF0aW9uOyAvLyBBdm9pZCBkaXZpc2lvbiBieSB6ZXJvIHdoZW4gbCArIHMgaXMgdmVyeSBzbWFsbCAoYXBwcm9hY2hpbmcgYmxhY2spOlxuXG4gICAgICBpZiAobCArIHMgPCAxZS05KSB7XG4gICAgICAgIHNhdHVyYXRpb24gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2F0dXJhdGlvbiA9IDIgKiBzIC8gKGwgKyBzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBjb2xvci5IU1YodGhpcy5faHVlLCBzYXR1cmF0aW9uLCAobCArIHMpIC8gMiwgdGhpcy5fYWxwaGEpO1xuICAgIH0sXG4gICAgcmdiOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oc3YoKS5yZ2IoKTtcbiAgICB9LFxuICAgIGZyb21SZ2I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEJlY29tZXMgb25lLmNvbG9yLlJHQi5wcm90b3R5cGUuaHN2XG4gICAgICByZXR1cm4gdGhpcy5oc3YoKS5oc2woKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIENNWUsgPSBmdW5jdGlvbiBDTVlLKGNvbG9yKSB7XG4gIGNvbG9yLmluc3RhbGxDb2xvclNwYWNlKCdDTVlLJywgWydjeWFuJywgJ21hZ2VudGEnLCAneWVsbG93JywgJ2JsYWNrJywgJ2FscGhhJ10sIHtcbiAgICByZ2I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgY29sb3IuUkdCKDEgLSB0aGlzLl9jeWFuICogKDEgLSB0aGlzLl9ibGFjaykgLSB0aGlzLl9ibGFjaywgMSAtIHRoaXMuX21hZ2VudGEgKiAoMSAtIHRoaXMuX2JsYWNrKSAtIHRoaXMuX2JsYWNrLCAxIC0gdGhpcy5feWVsbG93ICogKDEgLSB0aGlzLl9ibGFjaykgLSB0aGlzLl9ibGFjaywgdGhpcy5fYWxwaGEpO1xuICAgIH0sXG4gICAgZnJvbVJnYjogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQmVjb21lcyBvbmUuY29sb3IuUkdCLnByb3RvdHlwZS5jbXlrXG4gICAgICAvLyBBZGFwdGVkIGZyb20gaHR0cDovL3d3dy5qYXZhc2NyaXB0ZXIubmV0L2ZhcS9yZ2IyY215ay5odG1cbiAgICAgIHZhciByZWQgPSB0aGlzLl9yZWQsXG4gICAgICAgICAgZ3JlZW4gPSB0aGlzLl9ncmVlbixcbiAgICAgICAgICBibHVlID0gdGhpcy5fYmx1ZSxcbiAgICAgICAgICBjeWFuID0gMSAtIHJlZCxcbiAgICAgICAgICBtYWdlbnRhID0gMSAtIGdyZWVuLFxuICAgICAgICAgIHllbGxvdyA9IDEgLSBibHVlLFxuICAgICAgICAgIGJsYWNrID0gMTtcblxuICAgICAgaWYgKHJlZCB8fCBncmVlbiB8fCBibHVlKSB7XG4gICAgICAgIGJsYWNrID0gTWF0aC5taW4oY3lhbiwgTWF0aC5taW4obWFnZW50YSwgeWVsbG93KSk7XG4gICAgICAgIGN5YW4gPSAoY3lhbiAtIGJsYWNrKSAvICgxIC0gYmxhY2spO1xuICAgICAgICBtYWdlbnRhID0gKG1hZ2VudGEgLSBibGFjaykgLyAoMSAtIGJsYWNrKTtcbiAgICAgICAgeWVsbG93ID0gKHllbGxvdyAtIGJsYWNrKSAvICgxIC0gYmxhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxhY2sgPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IGNvbG9yLkNNWUsoY3lhbiwgbWFnZW50YSwgeWVsbG93LCBibGFjaywgdGhpcy5fYWxwaGEpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgbmFtZWRDb2xvcnMgPSBmdW5jdGlvbiBuYW1lZENvbG9ycyhjb2xvcikge1xuICBjb2xvci5uYW1lZENvbG9ycyA9IHtcbiAgICBhbGljZWJsdWU6ICdmMGY4ZmYnLFxuICAgIGFudGlxdWV3aGl0ZTogJ2ZhZWJkNycsXG4gICAgYXF1YTogJzBmZicsXG4gICAgYXF1YW1hcmluZTogJzdmZmZkNCcsXG4gICAgYXp1cmU6ICdmMGZmZmYnLFxuICAgIGJlaWdlOiAnZjVmNWRjJyxcbiAgICBiaXNxdWU6ICdmZmU0YzQnLFxuICAgIGJsYWNrOiAnMDAwJyxcbiAgICBibGFuY2hlZGFsbW9uZDogJ2ZmZWJjZCcsXG4gICAgYmx1ZTogJzAwZicsXG4gICAgYmx1ZXZpb2xldDogJzhhMmJlMicsXG4gICAgYnJvd246ICdhNTJhMmEnLFxuICAgIGJ1cmx5d29vZDogJ2RlYjg4NycsXG4gICAgY2FkZXRibHVlOiAnNWY5ZWEwJyxcbiAgICBjaGFydHJldXNlOiAnN2ZmZjAwJyxcbiAgICBjaG9jb2xhdGU6ICdkMjY5MWUnLFxuICAgIGNvcmFsOiAnZmY3ZjUwJyxcbiAgICBjb3JuZmxvd2VyYmx1ZTogJzY0OTVlZCcsXG4gICAgY29ybnNpbGs6ICdmZmY4ZGMnLFxuICAgIGNyaW1zb246ICdkYzE0M2MnLFxuICAgIGN5YW46ICcwZmYnLFxuICAgIGRhcmtibHVlOiAnMDAwMDhiJyxcbiAgICBkYXJrY3lhbjogJzAwOGI4YicsXG4gICAgZGFya2dvbGRlbnJvZDogJ2I4ODYwYicsXG4gICAgZGFya2dyYXk6ICdhOWE5YTknLFxuICAgIGRhcmtncmV5OiAnYTlhOWE5JyxcbiAgICBkYXJrZ3JlZW46ICcwMDY0MDAnLFxuICAgIGRhcmtraGFraTogJ2JkYjc2YicsXG4gICAgZGFya21hZ2VudGE6ICc4YjAwOGInLFxuICAgIGRhcmtvbGl2ZWdyZWVuOiAnNTU2YjJmJyxcbiAgICBkYXJrb3JhbmdlOiAnZmY4YzAwJyxcbiAgICBkYXJrb3JjaGlkOiAnOTkzMmNjJyxcbiAgICBkYXJrcmVkOiAnOGIwMDAwJyxcbiAgICBkYXJrc2FsbW9uOiAnZTk5NjdhJyxcbiAgICBkYXJrc2VhZ3JlZW46ICc4ZmJjOGYnLFxuICAgIGRhcmtzbGF0ZWJsdWU6ICc0ODNkOGInLFxuICAgIGRhcmtzbGF0ZWdyYXk6ICcyZjRmNGYnLFxuICAgIGRhcmtzbGF0ZWdyZXk6ICcyZjRmNGYnLFxuICAgIGRhcmt0dXJxdW9pc2U6ICcwMGNlZDEnLFxuICAgIGRhcmt2aW9sZXQ6ICc5NDAwZDMnLFxuICAgIGRlZXBwaW5rOiAnZmYxNDkzJyxcbiAgICBkZWVwc2t5Ymx1ZTogJzAwYmZmZicsXG4gICAgZGltZ3JheTogJzY5Njk2OScsXG4gICAgZGltZ3JleTogJzY5Njk2OScsXG4gICAgZG9kZ2VyYmx1ZTogJzFlOTBmZicsXG4gICAgZmlyZWJyaWNrOiAnYjIyMjIyJyxcbiAgICBmbG9yYWx3aGl0ZTogJ2ZmZmFmMCcsXG4gICAgZm9yZXN0Z3JlZW46ICcyMjhiMjInLFxuICAgIGZ1Y2hzaWE6ICdmMGYnLFxuICAgIGdhaW5zYm9ybzogJ2RjZGNkYycsXG4gICAgZ2hvc3R3aGl0ZTogJ2Y4ZjhmZicsXG4gICAgZ29sZDogJ2ZmZDcwMCcsXG4gICAgZ29sZGVucm9kOiAnZGFhNTIwJyxcbiAgICBncmF5OiAnODA4MDgwJyxcbiAgICBncmV5OiAnODA4MDgwJyxcbiAgICBncmVlbjogJzAwODAwMCcsXG4gICAgZ3JlZW55ZWxsb3c6ICdhZGZmMmYnLFxuICAgIGhvbmV5ZGV3OiAnZjBmZmYwJyxcbiAgICBob3RwaW5rOiAnZmY2OWI0JyxcbiAgICBpbmRpYW5yZWQ6ICdjZDVjNWMnLFxuICAgIGluZGlnbzogJzRiMDA4MicsXG4gICAgaXZvcnk6ICdmZmZmZjAnLFxuICAgIGtoYWtpOiAnZjBlNjhjJyxcbiAgICBsYXZlbmRlcjogJ2U2ZTZmYScsXG4gICAgbGF2ZW5kZXJibHVzaDogJ2ZmZjBmNScsXG4gICAgbGF3bmdyZWVuOiAnN2NmYzAwJyxcbiAgICBsZW1vbmNoaWZmb246ICdmZmZhY2QnLFxuICAgIGxpZ2h0Ymx1ZTogJ2FkZDhlNicsXG4gICAgbGlnaHRjb3JhbDogJ2YwODA4MCcsXG4gICAgbGlnaHRjeWFuOiAnZTBmZmZmJyxcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJ2ZhZmFkMicsXG4gICAgbGlnaHRncmF5OiAnZDNkM2QzJyxcbiAgICBsaWdodGdyZXk6ICdkM2QzZDMnLFxuICAgIGxpZ2h0Z3JlZW46ICc5MGVlOTAnLFxuICAgIGxpZ2h0cGluazogJ2ZmYjZjMScsXG4gICAgbGlnaHRzYWxtb246ICdmZmEwN2EnLFxuICAgIGxpZ2h0c2VhZ3JlZW46ICcyMGIyYWEnLFxuICAgIGxpZ2h0c2t5Ymx1ZTogJzg3Y2VmYScsXG4gICAgbGlnaHRzbGF0ZWdyYXk6ICc3ODknLFxuICAgIGxpZ2h0c2xhdGVncmV5OiAnNzg5JyxcbiAgICBsaWdodHN0ZWVsYmx1ZTogJ2IwYzRkZScsXG4gICAgbGlnaHR5ZWxsb3c6ICdmZmZmZTAnLFxuICAgIGxpbWU6ICcwZjAnLFxuICAgIGxpbWVncmVlbjogJzMyY2QzMicsXG4gICAgbGluZW46ICdmYWYwZTYnLFxuICAgIG1hZ2VudGE6ICdmMGYnLFxuICAgIG1hcm9vbjogJzgwMDAwMCcsXG4gICAgbWVkaXVtYXF1YW1hcmluZTogJzY2Y2RhYScsXG4gICAgbWVkaXVtYmx1ZTogJzAwMDBjZCcsXG4gICAgbWVkaXVtb3JjaGlkOiAnYmE1NWQzJyxcbiAgICBtZWRpdW1wdXJwbGU6ICc5MzcwZDgnLFxuICAgIG1lZGl1bXNlYWdyZWVuOiAnM2NiMzcxJyxcbiAgICBtZWRpdW1zbGF0ZWJsdWU6ICc3YjY4ZWUnLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAnMDBmYTlhJyxcbiAgICBtZWRpdW10dXJxdW9pc2U6ICc0OGQxY2MnLFxuICAgIG1lZGl1bXZpb2xldHJlZDogJ2M3MTU4NScsXG4gICAgbWlkbmlnaHRibHVlOiAnMTkxOTcwJyxcbiAgICBtaW50Y3JlYW06ICdmNWZmZmEnLFxuICAgIG1pc3R5cm9zZTogJ2ZmZTRlMScsXG4gICAgbW9jY2FzaW46ICdmZmU0YjUnLFxuICAgIG5hdmFqb3doaXRlOiAnZmZkZWFkJyxcbiAgICBuYXZ5OiAnMDAwMDgwJyxcbiAgICBvbGRsYWNlOiAnZmRmNWU2JyxcbiAgICBvbGl2ZTogJzgwODAwMCcsXG4gICAgb2xpdmVkcmFiOiAnNmI4ZTIzJyxcbiAgICBvcmFuZ2U6ICdmZmE1MDAnLFxuICAgIG9yYW5nZXJlZDogJ2ZmNDUwMCcsXG4gICAgb3JjaGlkOiAnZGE3MGQ2JyxcbiAgICBwYWxlZ29sZGVucm9kOiAnZWVlOGFhJyxcbiAgICBwYWxlZ3JlZW46ICc5OGZiOTgnLFxuICAgIHBhbGV0dXJxdW9pc2U6ICdhZmVlZWUnLFxuICAgIHBhbGV2aW9sZXRyZWQ6ICdkODcwOTMnLFxuICAgIHBhcGF5YXdoaXA6ICdmZmVmZDUnLFxuICAgIHBlYWNocHVmZjogJ2ZmZGFiOScsXG4gICAgcGVydTogJ2NkODUzZicsXG4gICAgcGluazogJ2ZmYzBjYicsXG4gICAgcGx1bTogJ2RkYTBkZCcsXG4gICAgcG93ZGVyYmx1ZTogJ2IwZTBlNicsXG4gICAgcHVycGxlOiAnODAwMDgwJyxcbiAgICByZWJlY2NhcHVycGxlOiAnNjM5JyxcbiAgICByZWQ6ICdmMDAnLFxuICAgIHJvc3licm93bjogJ2JjOGY4ZicsXG4gICAgcm95YWxibHVlOiAnNDE2OWUxJyxcbiAgICBzYWRkbGVicm93bjogJzhiNDUxMycsXG4gICAgc2FsbW9uOiAnZmE4MDcyJyxcbiAgICBzYW5keWJyb3duOiAnZjRhNDYwJyxcbiAgICBzZWFncmVlbjogJzJlOGI1NycsXG4gICAgc2Vhc2hlbGw6ICdmZmY1ZWUnLFxuICAgIHNpZW5uYTogJ2EwNTIyZCcsXG4gICAgc2lsdmVyOiAnYzBjMGMwJyxcbiAgICBza3libHVlOiAnODdjZWViJyxcbiAgICBzbGF0ZWJsdWU6ICc2YTVhY2QnLFxuICAgIHNsYXRlZ3JheTogJzcwODA5MCcsXG4gICAgc2xhdGVncmV5OiAnNzA4MDkwJyxcbiAgICBzbm93OiAnZmZmYWZhJyxcbiAgICBzcHJpbmdncmVlbjogJzAwZmY3ZicsXG4gICAgc3RlZWxibHVlOiAnNDY4MmI0JyxcbiAgICB0YW46ICdkMmI0OGMnLFxuICAgIHRlYWw6ICcwMDgwODAnLFxuICAgIHRoaXN0bGU6ICdkOGJmZDgnLFxuICAgIHRvbWF0bzogJ2ZmNjM0NycsXG4gICAgdHVycXVvaXNlOiAnNDBlMGQwJyxcbiAgICB2aW9sZXQ6ICdlZTgyZWUnLFxuICAgIHdoZWF0OiAnZjVkZWIzJyxcbiAgICB3aGl0ZTogJ2ZmZicsXG4gICAgd2hpdGVzbW9rZTogJ2Y1ZjVmNScsXG4gICAgeWVsbG93OiAnZmYwJyxcbiAgICB5ZWxsb3dncmVlbjogJzlhY2QzMidcbiAgfTtcbn07XG5cbnZhciBjbGVhcmVyID0gZnVuY3Rpb24gY2xlYXJlcihjb2xvcikge1xuICBjb2xvci5pbnN0YWxsTWV0aG9kKCdjbGVhcmVyJywgZnVuY3Rpb24gKGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzLmFscGhhKGlzTmFOKGFtb3VudCkgPyAtMC4xIDogLWFtb3VudCwgdHJ1ZSk7XG4gIH0pO1xufTtcblxudmFyIGx1bWluYW5jZSA9IGZ1bmN0aW9uIGx1bWluYW5jZShjb2xvcikge1xuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI3JlbGF0aXZlbHVtaW5hbmNlZGVmXG4gIGZ1bmN0aW9uIGNoYW5uZWxMdW1pbmFuY2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPD0gMC4wMzkyOCA/IHZhbHVlIC8gMTIuOTIgOiBNYXRoLnBvdygodmFsdWUgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgfVxuXG4gIGNvbG9yLmluc3RhbGxNZXRob2QoJ2x1bWluYW5jZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmdiID0gdGhpcy5yZ2IoKTtcbiAgICByZXR1cm4gMC4yMTI2ICogY2hhbm5lbEx1bWluYW5jZShyZ2IuX3JlZCkgKyAwLjcxNTIgKiBjaGFubmVsTHVtaW5hbmNlKHJnYi5fZ3JlZW4pICsgMC4wNzIyICogY2hhbm5lbEx1bWluYW5jZShyZ2IuX2JsdWUpO1xuICB9KTtcbn07XG5cbnZhciBjb250cmFzdCA9IGZ1bmN0aW9uIGNvbnRyYXN0KGNvbG9yKSB7XG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jY29udHJhc3QtcmF0aW9kZWZcbiAgY29sb3IudXNlKGx1bWluYW5jZSk7XG4gIGNvbG9yLmluc3RhbGxNZXRob2QoJ2NvbnRyYXN0JywgZnVuY3Rpb24gKGNvbG9yMikge1xuICAgIHZhciBsdW0xID0gdGhpcy5sdW1pbmFuY2UoKTtcbiAgICB2YXIgbHVtMiA9IGNvbG9yMi5sdW1pbmFuY2UoKTtcblxuICAgIGlmIChsdW0xID4gbHVtMikge1xuICAgICAgcmV0dXJuIChsdW0xICsgMC4wNSkgLyAobHVtMiArIDAuMDUpO1xuICAgIH1cblxuICAgIHJldHVybiAobHVtMiArIDAuMDUpIC8gKGx1bTEgKyAwLjA1KTtcbiAgfSk7XG59O1xuXG52YXIgZGFya2VuID0gZnVuY3Rpb24gZGFya2VuKGNvbG9yKSB7XG4gIGNvbG9yLnVzZShIU0wpO1xuICBjb2xvci5pbnN0YWxsTWV0aG9kKCdkYXJrZW4nLCBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgcmV0dXJuIHRoaXMubGlnaHRuZXNzKGlzTmFOKGFtb3VudCkgPyAtMC4xIDogLWFtb3VudCwgdHJ1ZSk7XG4gIH0pO1xufTtcblxudmFyIGRlc2F0dXJhdGUgPSBmdW5jdGlvbiBkZXNhdHVyYXRlKGNvbG9yKSB7XG4gIGNvbG9yLnVzZShIU0wpO1xuICBjb2xvci5pbnN0YWxsTWV0aG9kKCdkZXNhdHVyYXRlJywgZnVuY3Rpb24gKGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzLnNhdHVyYXRpb24oaXNOYU4oYW1vdW50KSA/IC0wLjEgOiAtYW1vdW50LCB0cnVlKTtcbiAgfSk7XG59O1xuXG52YXIgZ3JheXNjYWxlID0gZnVuY3Rpb24gZ3JheXNjYWxlKGNvbG9yKSB7XG4gIGZ1bmN0aW9uIGdzKCkge1xuICAgIC8qanNsaW50IHN0cmljdDpmYWxzZSovXG4gICAgdmFyIHJnYiA9IHRoaXMucmdiKCksXG4gICAgICAgIHZhbCA9IHJnYi5fcmVkICogMC4zICsgcmdiLl9ncmVlbiAqIDAuNTkgKyByZ2IuX2JsdWUgKiAwLjExO1xuICAgIHJldHVybiBuZXcgY29sb3IuUkdCKHZhbCwgdmFsLCB2YWwsIHJnYi5fYWxwaGEpO1xuICB9XG5cbiAgY29sb3IuaW5zdGFsbE1ldGhvZCgnZ3JleXNjYWxlJywgZ3MpLmluc3RhbGxNZXRob2QoJ2dyYXlzY2FsZScsIGdzKTtcbn07XG5cbnZhciBpc0RhcmsgPSBmdW5jdGlvbiBpc0RhcmsoY29sb3IpIHtcbiAgY29sb3IuaW5zdGFsbE1ldGhvZCgnaXNEYXJrJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciByZ2IgPSB0aGlzLnJnYigpOyAvLyBZSVEgZXF1YXRpb24gZnJvbSBodHRwOi8vMjR3YXlzLm9yZy8yMDEwL2NhbGN1bGF0aW5nLWNvbG9yLWNvbnRyYXN0XG5cbiAgICB2YXIgeWlxID0gKHJnYi5fcmVkICogMjU1ICogMjk5ICsgcmdiLl9ncmVlbiAqIDI1NSAqIDU4NyArIHJnYi5fYmx1ZSAqIDI1NSAqIDExNCkgLyAxMDAwO1xuICAgIHJldHVybiB5aXEgPCAxMjg7XG4gIH0pO1xufTtcblxudmFyIGlzTGlnaHQgPSBmdW5jdGlvbiBpc0xpZ2h0KGNvbG9yKSB7XG4gIGNvbG9yLnVzZShpc0RhcmspO1xuICBjb2xvci5pbnN0YWxsTWV0aG9kKCdpc0xpZ2h0JywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhdGhpcy5pc0RhcmsoKTtcbiAgfSk7XG59O1xuXG52YXIgbGlnaHRlbiA9IGZ1bmN0aW9uIGxpZ2h0ZW4oY29sb3IpIHtcbiAgY29sb3IudXNlKEhTTCk7XG4gIGNvbG9yLmluc3RhbGxNZXRob2QoJ2xpZ2h0ZW4nLCBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgcmV0dXJuIHRoaXMubGlnaHRuZXNzKGlzTmFOKGFtb3VudCkgPyAwLjEgOiBhbW91bnQsIHRydWUpO1xuICB9KTtcbn07XG5cbnZhciBtaXggPSBmdW5jdGlvbiBtaXgoY29sb3IpIHtcbiAgY29sb3IuaW5zdGFsbE1ldGhvZCgnbWl4JywgZnVuY3Rpb24gKG90aGVyQ29sb3IsIHdlaWdodCkge1xuICAgIG90aGVyQ29sb3IgPSBjb2xvcihvdGhlckNvbG9yKS5yZ2IoKTtcbiAgICB3ZWlnaHQgPSAxIC0gKGlzTmFOKHdlaWdodCkgPyAwLjUgOiB3ZWlnaHQpO1xuICAgIHZhciB3ID0gd2VpZ2h0ICogMiAtIDEsXG4gICAgICAgIGEgPSB0aGlzLl9hbHBoYSAtIG90aGVyQ29sb3IuX2FscGhhLFxuICAgICAgICB3ZWlnaHQxID0gKCh3ICogYSA9PT0gLTEgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMixcbiAgICAgICAgd2VpZ2h0MiA9IDEgLSB3ZWlnaHQxLFxuICAgICAgICByZ2IgPSB0aGlzLnJnYigpO1xuICAgIHJldHVybiBuZXcgY29sb3IuUkdCKHJnYi5fcmVkICogd2VpZ2h0MSArIG90aGVyQ29sb3IuX3JlZCAqIHdlaWdodDIsIHJnYi5fZ3JlZW4gKiB3ZWlnaHQxICsgb3RoZXJDb2xvci5fZ3JlZW4gKiB3ZWlnaHQyLCByZ2IuX2JsdWUgKiB3ZWlnaHQxICsgb3RoZXJDb2xvci5fYmx1ZSAqIHdlaWdodDIsIHJnYi5fYWxwaGEgKiB3ZWlnaHQgKyBvdGhlckNvbG9yLl9hbHBoYSAqICgxIC0gd2VpZ2h0KSk7XG4gIH0pO1xufTtcblxudmFyIG5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZShjb2xvcikge1xuICBjb2xvci5pbnN0YWxsTWV0aG9kKCduZWdhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJnYiA9IHRoaXMucmdiKCk7XG4gICAgcmV0dXJuIG5ldyBjb2xvci5SR0IoMSAtIHJnYi5fcmVkLCAxIC0gcmdiLl9ncmVlbiwgMSAtIHJnYi5fYmx1ZSwgdGhpcy5fYWxwaGEpO1xuICB9KTtcbn07XG5cbnZhciBvcGFxdWVyID0gZnVuY3Rpb24gb3BhcXVlcihjb2xvcikge1xuICBjb2xvci5pbnN0YWxsTWV0aG9kKCdvcGFxdWVyJywgZnVuY3Rpb24gKGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzLmFscGhhKGlzTmFOKGFtb3VudCkgPyAwLjEgOiBhbW91bnQsIHRydWUpO1xuICB9KTtcbn07XG5cbnZhciByb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUoY29sb3IpIHtcbiAgY29sb3IudXNlKEhTTCk7XG4gIGNvbG9yLmluc3RhbGxNZXRob2QoJ3JvdGF0ZScsIGZ1bmN0aW9uIChkZWdyZWVzKSB7XG4gICAgcmV0dXJuIHRoaXMuaHVlKChkZWdyZWVzIHx8IDApIC8gMzYwLCB0cnVlKTtcbiAgfSk7XG59O1xuXG52YXIgc2F0dXJhdGUgPSBmdW5jdGlvbiBzYXR1cmF0ZShjb2xvcikge1xuICBjb2xvci51c2UoSFNMKTtcbiAgY29sb3IuaW5zdGFsbE1ldGhvZCgnc2F0dXJhdGUnLCBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgcmV0dXJuIHRoaXMuc2F0dXJhdGlvbihpc05hTihhbW91bnQpID8gMC4xIDogYW1vdW50LCB0cnVlKTtcbiAgfSk7XG59O1xuXG4vLyBBZGFwdGVkIGZyb20gaHR0cDovL2dpbXAuc291cmNlYXJjaGl2ZS5jb20vZG9jdW1lbnRhdGlvbi8yLjYuNi0xdWJ1bnR1MS9jb2xvci10by1hbHBoYV84Yy1zb3VyY2UuaHRtbFxuLy8gdG9BbHBoYSByZXR1cm5zIGEgY29sb3Igd2hlcmUgdGhlIHZhbHVlcyBvZiB0aGUgYXJndW1lbnQgaGF2ZSBiZWVuIGNvbnZlcnRlZCB0byBhbHBoYVxudmFyIHRvQWxwaGEgPSBmdW5jdGlvbiB0b0FscGhhKGNvbG9yKSB7XG4gIGNvbG9yLmluc3RhbGxNZXRob2QoJ3RvQWxwaGEnLCBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICB2YXIgbWUgPSB0aGlzLnJnYigpLFxuICAgICAgICBvdGhlciA9IGNvbG9yKGNvbG9yKS5yZ2IoKSxcbiAgICAgICAgZXBzaWxvbiA9IDFlLTEwLFxuICAgICAgICBhID0gbmV3IGNvbG9yLlJHQigwLCAwLCAwLCBtZS5fYWxwaGEpLFxuICAgICAgICBjaGFubmVscyA9IFsnX3JlZCcsICdfZ3JlZW4nLCAnX2JsdWUnXTtcbiAgICBjaGFubmVscy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICBpZiAobWVbY2hhbm5lbF0gPCBlcHNpbG9uKSB7XG4gICAgICAgIGFbY2hhbm5lbF0gPSBtZVtjaGFubmVsXTtcbiAgICAgIH0gZWxzZSBpZiAobWVbY2hhbm5lbF0gPiBvdGhlcltjaGFubmVsXSkge1xuICAgICAgICBhW2NoYW5uZWxdID0gKG1lW2NoYW5uZWxdIC0gb3RoZXJbY2hhbm5lbF0pIC8gKDEgLSBvdGhlcltjaGFubmVsXSk7XG4gICAgICB9IGVsc2UgaWYgKG1lW2NoYW5uZWxdID4gb3RoZXJbY2hhbm5lbF0pIHtcbiAgICAgICAgYVtjaGFubmVsXSA9IChvdGhlcltjaGFubmVsXSAtIG1lW2NoYW5uZWxdKSAvIG90aGVyW2NoYW5uZWxdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYVtjaGFubmVsXSA9IDA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoYS5fcmVkID4gYS5fZ3JlZW4pIHtcbiAgICAgIGlmIChhLl9yZWQgPiBhLl9ibHVlKSB7XG4gICAgICAgIG1lLl9hbHBoYSA9IGEuX3JlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lLl9hbHBoYSA9IGEuX2JsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhLl9ncmVlbiA+IGEuX2JsdWUpIHtcbiAgICAgIG1lLl9hbHBoYSA9IGEuX2dyZWVuO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZS5fYWxwaGEgPSBhLl9ibHVlO1xuICAgIH1cblxuICAgIGlmIChtZS5fYWxwaGEgPCBlcHNpbG9uKSB7XG4gICAgICByZXR1cm4gbWU7XG4gICAgfVxuXG4gICAgY2hhbm5lbHMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgbWVbY2hhbm5lbF0gPSAobWVbY2hhbm5lbF0gLSBvdGhlcltjaGFubmVsXSkgLyBtZS5fYWxwaGEgKyBvdGhlcltjaGFubmVsXTtcbiAgICB9KTtcbiAgICBtZS5fYWxwaGEgKj0gYS5fYWxwaGE7XG4gICAgcmV0dXJuIG1lO1xuICB9KTtcbn07XG5cbnZhciBvbmVjb2xvciA9IGNvbG9yXzEudXNlKFhZWikudXNlKExBQikudXNlKEhTVikudXNlKEhTTCkudXNlKENNWUspIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uc1xuLnVzZShuYW1lZENvbG9ycykudXNlKGNsZWFyZXIpLnVzZShjb250cmFzdCkudXNlKGRhcmtlbikudXNlKGRlc2F0dXJhdGUpLnVzZShncmF5c2NhbGUpLnVzZShpc0RhcmspLnVzZShpc0xpZ2h0KS51c2UobGlnaHRlbikudXNlKGx1bWluYW5jZSkudXNlKG1peCkudXNlKG5lZ2F0ZSkudXNlKG9wYXF1ZXIpLnVzZShyb3RhdGUpLnVzZShzYXR1cmF0ZSkudXNlKHRvQWxwaGEpO1xuXG5mdW5jdGlvbiBnZXRDb250cmFzdFJhdGlvKGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcbiAgdmFyIGJhY2tncm91bmRPbldoaXRlID0gYWxwaGFCbGVuZChiYWNrZ3JvdW5kLCAnI2ZmZicpO1xuICB2YXIgYmFja2dyb3VuZE9uQmxhY2sgPSBhbHBoYUJsZW5kKGJhY2tncm91bmQsICcjMDAwJyk7XG4gIHZhciBMV2hpdGUgPSBnZXRSZWxhdGl2ZUx1bWluYW5jZShiYWNrZ3JvdW5kT25XaGl0ZSk7XG4gIHZhciBMQmxhY2sgPSBnZXRSZWxhdGl2ZUx1bWluYW5jZShiYWNrZ3JvdW5kT25CbGFjayk7XG4gIHZhciBMRm9yZWdyb3VuZCA9IGdldFJlbGF0aXZlTHVtaW5hbmNlKGZvcmVncm91bmQpO1xuXG4gIGlmIChMV2hpdGUgPCBMRm9yZWdyb3VuZCkge1xuICAgIHJldHVybiBnZXRDb250cmFzdFJhdGlvT3BhcXVlKGZvcmVncm91bmQsIGJhY2tncm91bmRPbldoaXRlKTtcbiAgfSBlbHNlIGlmIChMQmxhY2sgPiBMRm9yZWdyb3VuZCkge1xuICAgIHJldHVybiBnZXRDb250cmFzdFJhdGlvT3BhcXVlKGZvcmVncm91bmQsIGJhY2tncm91bmRPbkJsYWNrKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhbHBoYUJsZW5kKGNzc0ZvcmVncm91bmQsIGNzc0JhY2tncm91bmQpIHtcbiAgdmFyIGZvcmVncm91bmQgPSBvbmVjb2xvcihjc3NGb3JlZ3JvdW5kKTtcbiAgdmFyIGJhY2tncm91bmQgPSBvbmVjb2xvcihjc3NCYWNrZ3JvdW5kKTtcbiAgdmFyIHJlc3VsdCA9IG9uZWNvbG9yKCcjZmZmJyk7XG4gIHZhciBhID0gZm9yZWdyb3VuZC5hbHBoYSgpO1xuICByZXN1bHQuX3JlZCA9IGZvcmVncm91bmQuX3JlZCAqIGEgKyBiYWNrZ3JvdW5kLl9yZWQgKiAoMSAtIGEpO1xuICByZXN1bHQuX2dyZWVuID0gZm9yZWdyb3VuZC5fZ3JlZW4gKiBhICsgYmFja2dyb3VuZC5fZ3JlZW4gKiAoMSAtIGEpO1xuICByZXN1bHQuX2JsdWUgPSBmb3JlZ3JvdW5kLl9ibHVlICogYSArIGJhY2tncm91bmQuX2JsdWUgKiAoMSAtIGEpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRDb250cmFzdFJhdGlvT3BhcXVlKGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcbiAgdmFyIEwxID0gZ2V0UmVsYXRpdmVMdW1pbmFuY2UoYmFja2dyb3VuZCk7XG4gIHZhciBMMiA9IGdldFJlbGF0aXZlTHVtaW5hbmNlKGFscGhhQmxlbmQoZm9yZWdyb3VuZCwgYmFja2dyb3VuZCkpOyAvLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMtV0NBRzIwLTIwMDgxMjExLyNjb250cmFzdC1yYXRpb2RlZlxuXG4gIHJldHVybiAoTWF0aC5tYXgoTDEsIEwyKSArIDAuMDUpIC8gKE1hdGgubWluKEwxLCBMMikgKyAwLjA1KTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVMdW1pbmFuY2UoY3NzQ29sb3IpIHtcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgdmFyIGNvbG9yID0gb25lY29sb3IoY3NzQ29sb3IpO1xuICB2YXIgUiA9IGNvbG9yLl9yZWQgPD0gMC4wMzkyOCA/IGNvbG9yLl9yZWQgLyAxMi45MiA6IE1hdGgucG93KChjb2xvci5fcmVkICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gIHZhciBHID0gY29sb3IuX2dyZWVuIDw9IDAuMDM5MjggPyBjb2xvci5fZ3JlZW4gLyAxMi45MiA6IE1hdGgucG93KChjb2xvci5fZ3JlZW4gKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgdmFyIEIgPSBjb2xvci5fYmx1ZSA8PSAwLjAzOTI4ID8gY29sb3IuX2JsdWUgLyAxMi45MiA6IE1hdGgucG93KChjb2xvci5fYmx1ZSArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICB2YXIgTCA9IDAuMjEyNiAqIFIgKyAwLjcxNTIgKiBHICsgMC4wNzIyICogQjtcbiAgcmV0dXJuIEw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldENvbnRyYXN0UmF0aW87XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/color-contrast/dist/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _k_vyn_coloralgorithm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @k-vyn/coloralgorithm */ \"(app-pages-browser)/./node_modules/@k-vyn/coloralgorithm/dist/bundle.js\");\n/* harmony import */ var color_contrast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! color-contrast */ \"(app-pages-browser)/./node_modules/color-contrast/dist/index.esm.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n// Converts a hexadecimal color string into its RGB representation.\nfunction hexToRgb(hex) {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n    } : null;\n}\n// Converts RGB values into HSB (Hue, Saturation, Brightness) format.\nfunction rgbToHsb(r, g, b) {\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const delta = max - min;\n    let h = 0;\n    let s = max === 0 ? 0 : delta / max;\n    let v = max;\n    if (delta !== 0) {\n        if (max === r) {\n            h = (g - b) / delta % 6;\n        } else if (max === g) {\n            h = (b - r) / delta + 2;\n        } else {\n            h = (r - g) / delta + 4;\n        }\n        h = Math.round(h * 60);\n        if (h < 0) h += 360;\n    }\n    return {\n        h,\n        s,\n        b: v\n    };\n}\n// Converts a hexadecimal color string directly into HSB format.\nfunction hexToHsb(hex) {\n    const rgb = hexToRgb(hex);\n    if (!rgb) return {\n        h: 0,\n        s: 0,\n        b: 0\n    };\n    return rgbToHsb(rgb.r, rgb.g, rgb.b);\n}\nfunction getContrastYIQ(hexcolor) {\n    const r = parseInt(hexcolor.slice(1, 3), 16);\n    const g = parseInt(hexcolor.slice(3, 5), 16);\n    const b = parseInt(hexcolor.slice(5, 7), 16);\n    const yiq = (r * 299 + g * 587 + b * 114) / 255000;\n    return yiq >= 0.5 ? '#000000' : '#FFFFFF';\n}\n// Function to calculate contrast for generated colors\nconst calculateContrast = (colors, backgroundColor)=>{\n    const AA_CONTRAST_THRESHOLD = 4.5; // Redefine the threshold\n    return colors.map((color)=>{\n        const contrastValueWhite = (0,color_contrast__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(color.hex, '#FFFFFF'); // Calculate contrast against white\n        const contrastValueBlack = (0,color_contrast__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(color.hex, '#000000'); // Calculate contrast against black\n        const roundedContrastWhite = parseFloat(contrastValueWhite.toFixed(2)); // Round to two decimal places\n        const roundedContrastBlack = parseFloat(contrastValueBlack.toFixed(2)); // Round to two decimal places\n        const textColor = roundedContrastWhite >= AA_CONTRAST_THRESHOLD ? '#FFFFFF' : '#000000'; // Determine text color\n        const step = color.step * 100;\n        return {\n            color: color.hex,\n            contrast: roundedContrastWhite,\n            textColor: textColor,\n            step: step,\n            contrastRatioWhite: roundedContrastWhite,\n            contrastRatioBlack: roundedContrastBlack\n        };\n    });\n};\n// Main com ponent that manages color generation and state based on the provided props.\nfunction App() {\n    _s();\n    const [colors, setColors] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [lockHex, setLockHex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"#1FA846\");\n    const { h } = hexToHsb(lockHex);\n    const props = {\n        steps: 11,\n        hue: {\n            start: h,\n            end: h,\n            curve: \"linear\"\n        },\n        saturation: {\n            start: 0.04,\n            end: 1,\n            curve: \"linear\",\n            rate: 2\n        },\n        brightness: {\n            start: 1,\n            end: 0.11,\n            curve: \"linear\"\n        }\n    };\n    const options = {\n        minorSteps: [\n            0,\n            1\n        ],\n        lockHex,\n        rotation: \"clockwise\"\n    };\n    const isValidHex = (hex)=>/^#([0-9A-Fa-f]{3}){1,2}$/.test(hex);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"App.useEffect\": ()=>{\n            // @ts-ignore - Ignore type checking for the generate function call\n            const result = _k_vyn_coloralgorithm__WEBPACK_IMPORTED_MODULE_2__.generate(props, options);\n            if (result && result.length > 0 && \"colors\" in result[0]) {\n                // @ts-expect-error - Error is expected here\n                setColors(result[0].colors);\n                console.log(\"Color Values:\", result[0].colors);\n                console.log(\"HSB Values for lock hex:\", hexToHsb(lockHex));\n            } else {\n                console.error(\"Result is not defined or empty.\"); // Log an error if result is invalid\n            }\n        }\n    }[\"App.useEffect\"], [\n        lockHex\n    ]);\n    const backgroundColor = '#FFFFFF'; // Example background color\n    const colorContrasts = calculateContrast(colors, backgroundColor);\n    // Find the first color with sufficient contrast\n    const firstSufficientContrast = colorContrasts.find((param)=>{\n        let { contrast } = param;\n        return contrast > 4.5;\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"p-8 min-h-screen bg-gray-100\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"mx-auto max-w-6xl\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-6 bg-white rounded-lg shadow-lg\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex gap-2 items-center mb-6\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                            className: \"text-2xl font-bold text-gray-800\",\n                            children: \"Rally Ramp Generator\"\n                        }, void 0, false, {\n                            fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                            lineNumber: 186,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                        lineNumber: 185,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"space-y-4\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex gap-2 items-center\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"text-sm font-medium text-gray-600\",\n                                        children: \"Lock Hex:\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                        lineNumber: 193,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex items-center\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"px-3 py-2 text-neutral-800 bg-gray-50 border border-r-0 border-gray-300 rounded-l-md\",\n                                                children: \"#\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                                lineNumber: 198,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                type: \"text\",\n                                                value: lockHex.replace(\"#\", \"\"),\n                                                onChange: (e)=>{\n                                                    const value = \"#\" + e.target.value;\n                                                    if (isValidHex(value)) {\n                                                        setLockHex(value);\n                                                    }\n                                                },\n                                                className: \"px-3 py-2 w-24 rounded-r-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 placeholder-neutral-800 text-neutral-800\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                                lineNumber: 201,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                        lineNumber: 197,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"ml-4 text-sm font-medium text-gray-600\",\n                                        children: \"Converted Hue:\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                        lineNumber: 214,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"font-mono text-sm text-neutral-800\",\n                                        children: [\n                                            h,\n                                            \"\\xb0\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                        lineNumber: 217,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                lineNumber: 192,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                className: \"h-[632px] bg-neutral-50\",\n                                children: colorContrasts.map((param, index)=>{\n                                    let { color, contrast, textColor, step, contrastRatioWhite, contrastRatioBlack } = param;\n                                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                        className: \"p-3 flex items-center\",\n                                        style: {\n                                            backgroundColor: color,\n                                            color: textColor\n                                        },\n                                        children: [\n                                            \"\".concat(step, \", Text: \").concat(textColor, \", Background: \").concat(color),\n                                            contrastRatioWhite > 4.5 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"ml-2\",\n                                                style: {\n                                                    color: textColor\n                                                },\n                                                children: [\n                                                    \"Contrast Ratio: \",\n                                                    contrastRatioWhite\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                                lineNumber: 225,\n                                                columnNumber: 21\n                                            }, this),\n                                            contrastRatioBlack > 4.5 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"ml-2\",\n                                                style: {\n                                                    color: textColor\n                                                },\n                                                children: [\n                                                    \"Contrast Ratio: \",\n                                                    contrastRatioBlack\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                                lineNumber: 228,\n                                                columnNumber: 21\n                                            }, this),\n                                            firstSufficientContrast && firstSufficientContrast.color === color && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"p-1 px-3 rounded-full justify-end bg-white text-black ml-auto\",\n                                                children: \"Accent Primary\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                                lineNumber: 231,\n                                                columnNumber: 21\n                                            }, this) // Badge for sufficient contrast\n                                        ]\n                                    }, color, true, {\n                                        fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                        lineNumber: 222,\n                                        columnNumber: 17\n                                    }, this);\n                                })\n                            }, void 0, false, {\n                                fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                lineNumber: 220,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"p-4 mt-4 bg-gray-50 rounded-md\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        className: \"mb-2 text-sm font-medium text-gray-700\",\n                                        children: \"Color Information\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                        lineNumber: 238,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"space-y-2 text-xs text-gray-600\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                children: \" Check the console for detailed color values\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                                lineNumber: 242,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                children: [\n                                                    \" Repo used:\",\n                                                    \" \",\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                                        className: \"underline\",\n                                                        href: \"https://github.com/k-vyn/coloralgorithm\",\n                                                        children: \"https://github.com/k-vyn/coloralgorithm\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                                        lineNumber: 245,\n                                                        columnNumber: 19\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                                lineNumber: 243,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                children: [\n                                                    \" Generated \",\n                                                    colors.length,\n                                                    \" colors with\",\n                                                    \" \",\n                                                    colors.filter((c)=>c.isMajor).length,\n                                                    \" major steps\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                                lineNumber: 252,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                        lineNumber: 241,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                                lineNumber: 237,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                        lineNumber: 191,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n                lineNumber: 184,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n            lineNumber: 183,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/davidebiscuso/Documents/GitHub/color-ramp/app/page.tsx\",\n        lineNumber: 182,\n        columnNumber: 5\n    }, this);\n}\n_s(App, \"6KskpLg4b4JpsQSwcZ6ynLAyyFI=\");\n_c = App;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);\nvar _c;\n$RefreshReg$(_c, \"App\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUM0QztBQUNHO0FBQ0w7QUE4QzFDLG1FQUFtRTtBQUNuRSxTQUFTSSxTQUFTQyxHQUFXO0lBQzNCLE1BQU1DLFNBQVMsNENBQTRDQyxJQUFJLENBQUNGO0lBQ2hFLE9BQU9DLFNBQ0g7UUFDQUUsR0FBR0MsU0FBU0gsTUFBTSxDQUFDLEVBQUUsRUFBRTtRQUN2QkksR0FBR0QsU0FBU0gsTUFBTSxDQUFDLEVBQUUsRUFBRTtRQUN2QkssR0FBR0YsU0FBU0gsTUFBTSxDQUFDLEVBQUUsRUFBRTtJQUN6QixJQUNFO0FBQ047QUFFQSxxRUFBcUU7QUFDckUsU0FBU00sU0FBU0osQ0FBUyxFQUFFRSxDQUFTLEVBQUVDLENBQVM7SUFDL0NILEtBQUs7SUFDTEUsS0FBSztJQUNMQyxLQUFLO0lBRUwsTUFBTUUsTUFBTUMsS0FBS0QsR0FBRyxDQUFDTCxHQUFHRSxHQUFHQztJQUMzQixNQUFNSSxNQUFNRCxLQUFLQyxHQUFHLENBQUNQLEdBQUdFLEdBQUdDO0lBQzNCLE1BQU1LLFFBQVFILE1BQU1FO0lBRXBCLElBQUlFLElBQUk7SUFDUixJQUFJQyxJQUFJTCxRQUFRLElBQUksSUFBSUcsUUFBUUg7SUFDaEMsSUFBSU0sSUFBSU47SUFFUixJQUFJRyxVQUFVLEdBQUc7UUFDZixJQUFJSCxRQUFRTCxHQUFHO1lBQ2JTLElBQUksQ0FBRVAsSUFBSUMsQ0FBQUEsSUFBS0ssUUFBUztRQUMxQixPQUFPLElBQUlILFFBQVFILEdBQUc7WUFDcEJPLElBQUksQ0FBQ04sSUFBSUgsQ0FBQUEsSUFBS1EsUUFBUTtRQUN4QixPQUFPO1lBQ0xDLElBQUksQ0FBQ1QsSUFBSUUsQ0FBQUEsSUFBS00sUUFBUTtRQUN4QjtRQUVBQyxJQUFJSCxLQUFLTSxLQUFLLENBQUNILElBQUk7UUFDbkIsSUFBSUEsSUFBSSxHQUFHQSxLQUFLO0lBQ2xCO0lBRUEsT0FBTztRQUFFQTtRQUFHQztRQUFHUCxHQUFHUTtJQUFFO0FBQ3RCO0FBRUEsZ0VBQWdFO0FBQ2hFLFNBQVNFLFNBQVNoQixHQUFXO0lBQzNCLE1BQU1pQixNQUFNbEIsU0FBU0M7SUFDckIsSUFBSSxDQUFDaUIsS0FBSyxPQUFPO1FBQUVMLEdBQUc7UUFBR0MsR0FBRztRQUFHUCxHQUFHO0lBQUU7SUFDcEMsT0FBT0MsU0FBU1UsSUFBSWQsQ0FBQyxFQUFFYyxJQUFJWixDQUFDLEVBQUVZLElBQUlYLENBQUM7QUFDckM7QUFFQSxTQUFTWSxlQUFlQyxRQUFnQjtJQUN0QyxNQUFNaEIsSUFBSUMsU0FBU2UsU0FBU0MsS0FBSyxDQUFDLEdBQUcsSUFBSTtJQUN6QyxNQUFNZixJQUFJRCxTQUFTZSxTQUFTQyxLQUFLLENBQUMsR0FBRyxJQUFJO0lBQ3pDLE1BQU1kLElBQUlGLFNBQVNlLFNBQVNDLEtBQUssQ0FBQyxHQUFHLElBQUk7SUFDekMsTUFBTUMsTUFBTSxDQUFDbEIsSUFBSSxNQUFNRSxJQUFJLE1BQU1DLElBQUksR0FBRSxJQUFLO0lBQzVDLE9BQU9lLE9BQU8sTUFBTSxZQUFZO0FBQ2xDO0FBRUEsc0RBQXNEO0FBQ3RELE1BQU1DLG9CQUFvQixDQUFDQyxRQUF5Q0M7SUFDbEUsTUFBTUMsd0JBQXdCLEtBQUsseUJBQXlCO0lBQzVELE9BQU9GLE9BQU9HLEdBQUcsQ0FBQyxDQUFDN0I7UUFDakIsTUFBTThCLHFCQUE2QjdCLDBEQUFhQSxDQUFDRCxNQUFNRyxHQUFHLEVBQUUsWUFBWSxtQ0FBbUM7UUFDM0csTUFBTTRCLHFCQUE2QjlCLDBEQUFhQSxDQUFDRCxNQUFNRyxHQUFHLEVBQUUsWUFBWSxtQ0FBbUM7UUFDM0csTUFBTTZCLHVCQUF1QkMsV0FBV0gsbUJBQW1CSSxPQUFPLENBQUMsS0FBSyw4QkFBOEI7UUFDdEcsTUFBTUMsdUJBQXVCRixXQUFXRixtQkFBbUJHLE9BQU8sQ0FBQyxLQUFLLDhCQUE4QjtRQUN0RyxNQUFNRSxZQUFZSix3QkFBd0JKLHdCQUF3QixZQUFZLFdBQVcsdUJBQXVCO1FBQ2hILE1BQU1TLE9BQU9yQyxNQUFNcUMsSUFBSSxHQUFHO1FBQzFCLE9BQU87WUFDTHJDLE9BQU9BLE1BQU1HLEdBQUc7WUFDaEJtQyxVQUFVTjtZQUNWSSxXQUFXQTtZQUNYQyxNQUFNQTtZQUNORSxvQkFBb0JQO1lBQ3BCUSxvQkFBb0JMO1FBQ3RCO0lBQ0Y7QUFDRjtBQUVBLHVGQUF1RjtBQUN2RixTQUFTTTs7SUFDUCxNQUFNLENBQUNmLFFBQVFnQixVQUFVLEdBQUczQywrQ0FBUUEsQ0FBVSxFQUFFO0lBQ2hELE1BQU0sQ0FBQzRDLFNBQVNDLFdBQVcsR0FBRzdDLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sRUFBRWdCLENBQUMsRUFBRSxHQUFHSSxTQUFTd0I7SUFFdkIsTUFBTUUsUUFBZTtRQUNuQkMsT0FBTztRQUNQQyxLQUFLO1lBQ0hDLE9BQU9qQztZQUNQa0MsS0FBS2xDO1lBQ0xtQyxPQUFPO1FBQ1Q7UUFDQUMsWUFBWTtZQUNWSCxPQUFPO1lBQ1BDLEtBQUs7WUFDTEMsT0FBTztZQUNQRSxNQUFNO1FBQ1I7UUFDQUMsWUFBWTtZQUNWTCxPQUFPO1lBQ1BDLEtBQUs7WUFDTEMsT0FBTztRQUNUO0lBQ0Y7SUFFQSxNQUFNSSxVQUFtQjtRQUN2QkMsWUFBWTtZQUFDO1lBQUc7U0FBRTtRQUNsQlo7UUFDQWEsVUFBVTtJQUNaO0lBRUEsTUFBTUMsYUFBYSxDQUFDdEQsTUFBZ0IsMkJBQTJCdUQsSUFBSSxDQUFDdkQ7SUFFcEVMLGdEQUFTQTt5QkFBQztZQUNSLG1FQUFtRTtZQUNuRSxNQUFNTSxTQUFTSiwyREFBYyxDQUFDNkMsT0FBT1M7WUFDckMsSUFBSWxELFVBQVVBLE9BQU93RCxNQUFNLEdBQUcsS0FBSyxZQUFZeEQsTUFBTSxDQUFDLEVBQUUsRUFBRTtnQkFDeEQsNENBQTRDO2dCQUM1Q3NDLFVBQVV0QyxNQUFNLENBQUMsRUFBRSxDQUFDc0IsTUFBTTtnQkFDMUJtQyxRQUFRQyxHQUFHLENBQUMsaUJBQWlCMUQsTUFBTSxDQUFDLEVBQUUsQ0FBQ3NCLE1BQU07Z0JBQzdDbUMsUUFBUUMsR0FBRyxDQUFDLDRCQUE0QjNDLFNBQVN3QjtZQUNuRCxPQUFPO2dCQUNMa0IsUUFBUUUsS0FBSyxDQUFDLG9DQUFvQyxvQ0FBb0M7WUFDeEY7UUFDRjt3QkFBRztRQUFDcEI7S0FBUTtJQUVaLE1BQU1oQixrQkFBa0IsV0FBVywyQkFBMkI7SUFDOUQsTUFBTXFDLGlCQUFpQnZDLGtCQUFrQkMsUUFBUUM7SUFFakQsZ0RBQWdEO0lBQ2hELE1BQU1zQywwQkFBMEJELGVBQWVFLElBQUksQ0FBQztZQUFDLEVBQUU1QixRQUFRLEVBQUU7ZUFBS0EsV0FBVzs7SUFFakYscUJBQ0UsOERBQUM2QjtRQUFJQyxXQUFVO2tCQUNiLDRFQUFDRDtZQUFJQyxXQUFVO3NCQUNiLDRFQUFDRDtnQkFBSUMsV0FBVTs7a0NBQ2IsOERBQUNEO3dCQUFJQyxXQUFVO2tDQUNiLDRFQUFDQzs0QkFBR0QsV0FBVTtzQ0FBbUM7Ozs7Ozs7Ozs7O2tDQUtuRCw4REFBQ0Q7d0JBQUlDLFdBQVU7OzBDQUNiLDhEQUFDRDtnQ0FBSUMsV0FBVTs7a0RBQ2IsOERBQUNFO3dDQUFLRixXQUFVO2tEQUFvQzs7Ozs7O2tEQUlwRCw4REFBQ0Q7d0NBQUlDLFdBQVU7OzBEQUNiLDhEQUFDRTtnREFBS0YsV0FBVTswREFBdUY7Ozs7OzswREFHdkcsOERBQUNHO2dEQUNDQyxNQUFLO2dEQUNMQyxPQUFPOUIsUUFBUStCLE9BQU8sQ0FBQyxLQUFLO2dEQUM1QkMsVUFBVSxDQUFDQztvREFDVCxNQUFNSCxRQUFRLE1BQU1HLEVBQUVDLE1BQU0sQ0FBQ0osS0FBSztvREFDbEMsSUFBSWhCLFdBQVdnQixRQUFRO3dEQUNyQjdCLFdBQVc2QjtvREFDYjtnREFDRjtnREFDQUwsV0FBVTs7Ozs7Ozs7Ozs7O2tEQUlkLDhEQUFDRTt3Q0FBS0YsV0FBVTtrREFBeUM7Ozs7OztrREFHekQsOERBQUNFO3dDQUFLRixXQUFVOzs0Q0FBc0NyRDs0Q0FBRTs7Ozs7Ozs7Ozs7OzswQ0FHMUQsOERBQUMrRDtnQ0FBR1YsV0FBVTswQ0FDWEosZUFBZW5DLEdBQUcsQ0FBQyxRQUErRWtEO3dDQUE5RSxFQUFFL0UsS0FBSyxFQUFFc0MsUUFBUSxFQUFFRixTQUFTLEVBQUVDLElBQUksRUFBRUUsa0JBQWtCLEVBQUVDLGtCQUFrQixFQUFFO3lEQUMvRiw4REFBQ3dDO3dDQUFHWixXQUFVO3dDQUFvQ2EsT0FBTzs0Q0FBRXRELGlCQUFpQjNCOzRDQUFPQSxPQUFPb0M7d0NBQVU7OzRDQUNoRyxHQUFpQkEsT0FBZkMsTUFBSyxZQUFvQ3JDLE9BQTFCb0MsV0FBVSxrQkFBc0IsT0FBTnBDOzRDQUM1Q3VDLHFCQUFxQixxQkFDcEIsOERBQUMrQjtnREFBS0YsV0FBVTtnREFBT2EsT0FBTztvREFBRWpGLE9BQU9vQztnREFBVTs7b0RBQUc7b0RBQWlCRzs7Ozs7Ozs0Q0FFdEVDLHFCQUFxQixxQkFDcEIsOERBQUM4QjtnREFBS0YsV0FBVTtnREFBT2EsT0FBTztvREFBRWpGLE9BQU9vQztnREFBVTs7b0RBQUc7b0RBQWlCSTs7Ozs7Ozs0Q0FFdEV5QiwyQkFBMkJBLHdCQUF3QmpFLEtBQUssS0FBS0EsdUJBQzVELDhEQUFDc0U7Z0RBQUtGLFdBQVU7MERBQWdFOzs7OztxREFBc0IsZ0NBQWdDOzt1Q0FUL0ZwRTs7Ozs7Ozs7Ozs7MENBZS9DLDhEQUFDbUU7Z0NBQUlDLFdBQVU7O2tEQUNiLDhEQUFDYzt3Q0FBR2QsV0FBVTtrREFBeUM7Ozs7OztrREFHdkQsOERBQUNEO3dDQUFJQyxXQUFVOzswREFDYiw4REFBQ2U7MERBQUU7Ozs7OzswREFDSCw4REFBQ0E7O29EQUFFO29EQUNZO2tFQUNiLDhEQUFDQzt3REFDQ2hCLFdBQVU7d0RBQ1ZpQixNQUFLO2tFQUNOOzs7Ozs7Ozs7Ozs7MERBSUgsOERBQUNGOztvREFBRTtvREFDWXpELE9BQU9rQyxNQUFNO29EQUFDO29EQUFhO29EQUN2Q2xDLE9BQU80RCxNQUFNLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUMsT0FBTyxFQUFFNUIsTUFBTTtvREFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFTMUQ7R0F0SVNuQjtLQUFBQTtBQXdJVCxpRUFBZUEsR0FBR0EsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2RhdmlkZWJpc2N1c28vRG9jdW1lbnRzL0dpdEh1Yi9jb2xvci1yYW1wL2FwcC9wYWdlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIGNvbG9yIGZyb20gXCJAay12eW4vY29sb3JhbGdvcml0aG1cIjtcbmltcG9ydCBjb2xvckNvbnRyYXN0IGZyb20gJ2NvbG9yLWNvbnRyYXN0J1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICBzdGVwczogbnVtYmVyO1xuICBodWU6IHtcbiAgICBzdGFydDogbnVtYmVyO1xuICAgIGVuZDogbnVtYmVyO1xuICAgIGN1cnZlOiBzdHJpbmc7XG4gIH07XG4gIHNhdHVyYXRpb246IHtcbiAgICBzdGFydDogbnVtYmVyO1xuICAgIGVuZDogbnVtYmVyO1xuICAgIGN1cnZlOiBzdHJpbmc7XG4gICAgcmF0ZTogbnVtYmVyO1xuICB9O1xuICBicmlnaHRuZXNzOiB7XG4gICAgc3RhcnQ6IG51bWJlcjtcbiAgICBlbmQ6IG51bWJlcjtcbiAgICBjdXJ2ZTogc3RyaW5nO1xuICB9O1xufVxuXG5pbnRlcmZhY2UgT3B0aW9ucyB7XG4gIG1pbm9yU3RlcHM/OiBudW1iZXJbXTtcbiAgbG9ja0hleD86IHN0cmluZztcbiAgcm90YXRpb24/OiBcImNsb2Nrd2lzZVwiIHwgXCJjb3VudGVyY2xvY2t3aXNlXCIgfCBcImN3XCIgfCBcImNjd1wiO1xufVxuXG5pbnRlcmZhY2UgQ29sb3Ige1xuICBzdGVwOiBudW1iZXI7XG4gIGxhYmVsOiBudW1iZXI7XG4gIGhleDogc3RyaW5nO1xuICBodWU6IG51bWJlcjtcbiAgc2F0dXJhdGlvbjogbnVtYmVyO1xuICBicmlnaHRuZXNzOiBudW1iZXI7XG4gIGlzTWFqb3I6IGJvb2xlYW47XG4gIGlzTG9ja2VkOiBib29sZWFuO1xuICBoc2w6IG51bWJlcltdO1xuICBoc3Y6IG51bWJlcltdO1xuICBsYWI6IG51bWJlcltdO1xuICByZ2JTdHJpbmc6IHN0cmluZztcbiAgcmdiQXJyYXk6IG51bWJlcltdO1xuICByZ2JhU3RyaW5nOiBzdHJpbmc7XG4gIHJnYmFBcnJheTogbnVtYmVyW107XG59XG5cbi8vIENvbnZlcnRzIGEgaGV4YWRlY2ltYWwgY29sb3Igc3RyaW5nIGludG8gaXRzIFJHQiByZXByZXNlbnRhdGlvbi5cbmZ1bmN0aW9uIGhleFRvUmdiKGhleDogc3RyaW5nKSB7XG4gIGNvbnN0IHJlc3VsdCA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kuZXhlYyhoZXgpO1xuICByZXR1cm4gcmVzdWx0XG4gICAgPyB7XG4gICAgICByOiBwYXJzZUludChyZXN1bHRbMV0sIDE2KSxcbiAgICAgIGc6IHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpLFxuICAgICAgYjogcGFyc2VJbnQocmVzdWx0WzNdLCAxNiksXG4gICAgfVxuICAgIDogbnVsbDtcbn1cblxuLy8gQ29udmVydHMgUkdCIHZhbHVlcyBpbnRvIEhTQiAoSHVlLCBTYXR1cmF0aW9uLCBCcmlnaHRuZXNzKSBmb3JtYXQuXG5mdW5jdGlvbiByZ2JUb0hzYihyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyKSB7XG4gIHIgLz0gMjU1O1xuICBnIC89IDI1NTtcbiAgYiAvPSAyNTU7XG5cbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICBjb25zdCBkZWx0YSA9IG1heCAtIG1pbjtcblxuICBsZXQgaCA9IDA7XG4gIGxldCBzID0gbWF4ID09PSAwID8gMCA6IGRlbHRhIC8gbWF4O1xuICBsZXQgdiA9IG1heDtcblxuICBpZiAoZGVsdGEgIT09IDApIHtcbiAgICBpZiAobWF4ID09PSByKSB7XG4gICAgICBoID0gKChnIC0gYikgLyBkZWx0YSkgJSA2O1xuICAgIH0gZWxzZSBpZiAobWF4ID09PSBnKSB7XG4gICAgICBoID0gKGIgLSByKSAvIGRlbHRhICsgMjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IChyIC0gZykgLyBkZWx0YSArIDQ7XG4gICAgfVxuXG4gICAgaCA9IE1hdGgucm91bmQoaCAqIDYwKTtcbiAgICBpZiAoaCA8IDApIGggKz0gMzYwO1xuICB9XG5cbiAgcmV0dXJuIHsgaCwgcywgYjogdiB9O1xufVxuXG4vLyBDb252ZXJ0cyBhIGhleGFkZWNpbWFsIGNvbG9yIHN0cmluZyBkaXJlY3RseSBpbnRvIEhTQiBmb3JtYXQuXG5mdW5jdGlvbiBoZXhUb0hzYihoZXg6IHN0cmluZykge1xuICBjb25zdCByZ2IgPSBoZXhUb1JnYihoZXgpO1xuICBpZiAoIXJnYikgcmV0dXJuIHsgaDogMCwgczogMCwgYjogMCB9O1xuICByZXR1cm4gcmdiVG9Ic2IocmdiLnIsIHJnYi5nLCByZ2IuYik7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRyYXN0WUlRKGhleGNvbG9yOiBzdHJpbmcpIHtcbiAgY29uc3QgciA9IHBhcnNlSW50KGhleGNvbG9yLnNsaWNlKDEsIDMpLCAxNik7XG4gIGNvbnN0IGcgPSBwYXJzZUludChoZXhjb2xvci5zbGljZSgzLCA1KSwgMTYpO1xuICBjb25zdCBiID0gcGFyc2VJbnQoaGV4Y29sb3Iuc2xpY2UoNSwgNyksIDE2KTtcbiAgY29uc3QgeWlxID0gKHIgKiAyOTkgKyBnICogNTg3ICsgYiAqIDExNCkgLyAyNTUwMDA7XG4gIHJldHVybiB5aXEgPj0gMC41ID8gJyMwMDAwMDAnIDogJyNGRkZGRkYnO1xufVxuXG4vLyBGdW5jdGlvbiB0byBjYWxjdWxhdGUgY29udHJhc3QgZm9yIGdlbmVyYXRlZCBjb2xvcnNcbmNvbnN0IGNhbGN1bGF0ZUNvbnRyYXN0ID0gKGNvbG9yczogeyBoZXg6IHN0cmluZzsgc3RlcDogbnVtYmVyIH1bXSwgYmFja2dyb3VuZENvbG9yOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgQUFfQ09OVFJBU1RfVEhSRVNIT0xEID0gNC41OyAvLyBSZWRlZmluZSB0aGUgdGhyZXNob2xkXG4gIHJldHVybiBjb2xvcnMubWFwKChjb2xvcjogeyBoZXg6IHN0cmluZzsgc3RlcDogbnVtYmVyIH0pID0+IHtcbiAgICBjb25zdCBjb250cmFzdFZhbHVlV2hpdGU6IG51bWJlciA9IGNvbG9yQ29udHJhc3QoY29sb3IuaGV4LCAnI0ZGRkZGRicpOyAvLyBDYWxjdWxhdGUgY29udHJhc3QgYWdhaW5zdCB3aGl0ZVxuICAgIGNvbnN0IGNvbnRyYXN0VmFsdWVCbGFjazogbnVtYmVyID0gY29sb3JDb250cmFzdChjb2xvci5oZXgsICcjMDAwMDAwJyk7IC8vIENhbGN1bGF0ZSBjb250cmFzdCBhZ2FpbnN0IGJsYWNrXG4gICAgY29uc3Qgcm91bmRlZENvbnRyYXN0V2hpdGUgPSBwYXJzZUZsb2F0KGNvbnRyYXN0VmFsdWVXaGl0ZS50b0ZpeGVkKDIpKTsgLy8gUm91bmQgdG8gdHdvIGRlY2ltYWwgcGxhY2VzXG4gICAgY29uc3Qgcm91bmRlZENvbnRyYXN0QmxhY2sgPSBwYXJzZUZsb2F0KGNvbnRyYXN0VmFsdWVCbGFjay50b0ZpeGVkKDIpKTsgLy8gUm91bmQgdG8gdHdvIGRlY2ltYWwgcGxhY2VzXG4gICAgY29uc3QgdGV4dENvbG9yID0gcm91bmRlZENvbnRyYXN0V2hpdGUgPj0gQUFfQ09OVFJBU1RfVEhSRVNIT0xEID8gJyNGRkZGRkYnIDogJyMwMDAwMDAnOyAvLyBEZXRlcm1pbmUgdGV4dCBjb2xvclxuICAgIGNvbnN0IHN0ZXAgPSBjb2xvci5zdGVwICogMTAwO1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogY29sb3IuaGV4LFxuICAgICAgY29udHJhc3Q6IHJvdW5kZWRDb250cmFzdFdoaXRlLCAvLyBVc2UgdGhlIHJvdW5kZWQgY29udHJhc3QgdmFsdWUgYWdhaW5zdCB3aGl0ZVxuICAgICAgdGV4dENvbG9yOiB0ZXh0Q29sb3IsXG4gICAgICBzdGVwOiBzdGVwLFxuICAgICAgY29udHJhc3RSYXRpb1doaXRlOiByb3VuZGVkQ29udHJhc3RXaGl0ZSwgLy8gUmV0dXJuIHRoZSBjb250cmFzdCByYXRpbyBhZ2FpbnN0IHdoaXRlXG4gICAgICBjb250cmFzdFJhdGlvQmxhY2s6IHJvdW5kZWRDb250cmFzdEJsYWNrLCAvLyBSZXR1cm4gdGhlIGNvbnRyYXN0IHJhdGlvIGFnYWluc3QgYmxhY2tcbiAgICB9O1xuICB9KTtcbn07XG5cbi8vIE1haW4gY29tIHBvbmVudCB0aGF0IG1hbmFnZXMgY29sb3IgZ2VuZXJhdGlvbiBhbmQgc3RhdGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHByb3BzLlxuZnVuY3Rpb24gQXBwKCkge1xuICBjb25zdCBbY29sb3JzLCBzZXRDb2xvcnNdID0gdXNlU3RhdGU8Q29sb3JbXT4oW10pO1xuICBjb25zdCBbbG9ja0hleCwgc2V0TG9ja0hleF0gPSB1c2VTdGF0ZShcIiMxRkE4NDZcIik7XG4gIGNvbnN0IHsgaCB9ID0gaGV4VG9Ic2IobG9ja0hleCk7XG5cbiAgY29uc3QgcHJvcHM6IFByb3BzID0ge1xuICAgIHN0ZXBzOiAxMSxcbiAgICBodWU6IHtcbiAgICAgIHN0YXJ0OiBoLFxuICAgICAgZW5kOiBoLFxuICAgICAgY3VydmU6IFwibGluZWFyXCIsXG4gICAgfSxcbiAgICBzYXR1cmF0aW9uOiB7XG4gICAgICBzdGFydDogMC4wNCxcbiAgICAgIGVuZDogMSxcbiAgICAgIGN1cnZlOiBcImxpbmVhclwiLFxuICAgICAgcmF0ZTogMixcbiAgICB9LFxuICAgIGJyaWdodG5lc3M6IHtcbiAgICAgIHN0YXJ0OiAxLFxuICAgICAgZW5kOiAwLjExLFxuICAgICAgY3VydmU6IFwibGluZWFyXCIsXG4gICAgfSxcbiAgfTtcblxuICBjb25zdCBvcHRpb25zOiBPcHRpb25zID0ge1xuICAgIG1pbm9yU3RlcHM6IFswLCAxXSxcbiAgICBsb2NrSGV4LFxuICAgIHJvdGF0aW9uOiBcImNsb2Nrd2lzZVwiLFxuICB9O1xuXG4gIGNvbnN0IGlzVmFsaWRIZXggPSAoaGV4OiBzdHJpbmcpID0+IC9eIyhbMC05QS1GYS1mXXszfSl7MSwyfSQvLnRlc3QoaGV4KTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmUgLSBJZ25vcmUgdHlwZSBjaGVja2luZyBmb3IgdGhlIGdlbmVyYXRlIGZ1bmN0aW9uIGNhbGxcbiAgICBjb25zdCByZXN1bHQgPSBjb2xvci5nZW5lcmF0ZShwcm9wcywgb3B0aW9ucyk7XG4gICAgaWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMCAmJiBcImNvbG9yc1wiIGluIHJlc3VsdFswXSkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIEVycm9yIGlzIGV4cGVjdGVkIGhlcmVcbiAgICAgIHNldENvbG9ycyhyZXN1bHRbMF0uY29sb3JzKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiQ29sb3IgVmFsdWVzOlwiLCByZXN1bHRbMF0uY29sb3JzKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiSFNCIFZhbHVlcyBmb3IgbG9jayBoZXg6XCIsIGhleFRvSHNiKGxvY2tIZXgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihcIlJlc3VsdCBpcyBub3QgZGVmaW5lZCBvciBlbXB0eS5cIik7IC8vIExvZyBhbiBlcnJvciBpZiByZXN1bHQgaXMgaW52YWxpZFxuICAgIH1cbiAgfSwgW2xvY2tIZXhdKTtcblxuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSAnI0ZGRkZGRic7IC8vIEV4YW1wbGUgYmFja2dyb3VuZCBjb2xvclxuICBjb25zdCBjb2xvckNvbnRyYXN0cyA9IGNhbGN1bGF0ZUNvbnRyYXN0KGNvbG9ycywgYmFja2dyb3VuZENvbG9yKTtcblxuICAvLyBGaW5kIHRoZSBmaXJzdCBjb2xvciB3aXRoIHN1ZmZpY2llbnQgY29udHJhc3RcbiAgY29uc3QgZmlyc3RTdWZmaWNpZW50Q29udHJhc3QgPSBjb2xvckNvbnRyYXN0cy5maW5kKCh7IGNvbnRyYXN0IH0pID0+IGNvbnRyYXN0ID4gNC41KTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwicC04IG1pbi1oLXNjcmVlbiBiZy1ncmF5LTEwMFwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJteC1hdXRvIG1heC13LTZ4bFwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNiBiZy13aGl0ZSByb3VuZGVkLWxnIHNoYWRvdy1sZ1wiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBnYXAtMiBpdGVtcy1jZW50ZXIgbWItNlwiPlxuICAgICAgICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQtMnhsIGZvbnQtYm9sZCB0ZXh0LWdyYXktODAwXCI+XG4gICAgICAgICAgICAgIFJhbGx5IFJhbXAgR2VuZXJhdG9yXG4gICAgICAgICAgICA8L2gxPlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTRcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBnYXAtMiBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktNjAwXCI+XG4gICAgICAgICAgICAgICAgTG9jayBIZXg6XG4gICAgICAgICAgICAgIDwvc3Bhbj5cblxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwicHgtMyBweS0yIHRleHQtbmV1dHJhbC04MDAgYmctZ3JheS01MCBib3JkZXIgYm9yZGVyLXItMCBib3JkZXItZ3JheS0zMDAgcm91bmRlZC1sLW1kXCI+XG4gICAgICAgICAgICAgICAgICAjXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgdmFsdWU9e2xvY2tIZXgucmVwbGFjZShcIiNcIiwgXCJcIil9XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBcIiNcIiArIGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZEhleCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRMb2NrSGV4KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTMgcHktMiB3LTI0IHJvdW5kZWQtci1tZCBib3JkZXIgYm9yZGVyLWdyYXktMzAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ibHVlLTUwMCBmb2N1czpib3JkZXItYmx1ZS01MDAgcGxhY2Vob2xkZXItbmV1dHJhbC04MDAgdGV4dC1uZXV0cmFsLTgwMFwiXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibWwtNCB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS02MDBcIj5cbiAgICAgICAgICAgICAgICBDb252ZXJ0ZWQgSHVlOlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtbW9ubyB0ZXh0LXNtIHRleHQtbmV1dHJhbC04MDBcIj57aH3CsDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwiaC1bNjMycHhdIGJnLW5ldXRyYWwtNTBcIj5cbiAgICAgICAgICAgICAge2NvbG9yQ29udHJhc3RzLm1hcCgoeyBjb2xvciwgY29udHJhc3QsIHRleHRDb2xvciwgc3RlcCwgY29udHJhc3RSYXRpb1doaXRlLCBjb250cmFzdFJhdGlvQmxhY2sgfSwgaW5kZXgpID0+IChcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwicC0zIGZsZXggaXRlbXMtY2VudGVyXCIga2V5PXtjb2xvcn0gc3R5bGU9e3sgYmFja2dyb3VuZENvbG9yOiBjb2xvciwgY29sb3I6IHRleHRDb2xvciB9fT5cbiAgICAgICAgICAgICAgICAgIHtgJHtzdGVwfSwgVGV4dDogJHt0ZXh0Q29sb3J9LCBCYWNrZ3JvdW5kOiAke2NvbG9yfWB9XG4gICAgICAgICAgICAgICAgICB7Y29udHJhc3RSYXRpb1doaXRlID4gNC41ICYmIChcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibWwtMlwiIHN0eWxlPXt7IGNvbG9yOiB0ZXh0Q29sb3IgfX0+Q29udHJhc3QgUmF0aW86IHtjb250cmFzdFJhdGlvV2hpdGV9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgIHtjb250cmFzdFJhdGlvQmxhY2sgPiA0LjUgJiYgKFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJtbC0yXCIgc3R5bGU9e3sgY29sb3I6IHRleHRDb2xvciB9fT5Db250cmFzdCBSYXRpbzoge2NvbnRyYXN0UmF0aW9CbGFja308L3NwYW4+XG4gICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAge2ZpcnN0U3VmZmljaWVudENvbnRyYXN0ICYmIGZpcnN0U3VmZmljaWVudENvbnRyYXN0LmNvbG9yID09PSBjb2xvciAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInAtMSBweC0zIHJvdW5kZWQtZnVsbCBqdXN0aWZ5LWVuZCBiZy13aGl0ZSB0ZXh0LWJsYWNrIG1sLWF1dG9cIj5BY2NlbnQgUHJpbWFyeTwvc3Bhbj4gLy8gQmFkZ2UgZm9yIHN1ZmZpY2llbnQgY29udHJhc3RcbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICA8L3VsPlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNCBtdC00IGJnLWdyYXktNTAgcm91bmRlZC1tZFwiPlxuICAgICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwibWItMiB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS03MDBcIj5cbiAgICAgICAgICAgICAgICBDb2xvciBJbmZvcm1hdGlvblxuICAgICAgICAgICAgICA8L2gyPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktMiB0ZXh0LXhzIHRleHQtZ3JheS02MDBcIj5cbiAgICAgICAgICAgICAgICA8cD7igKIgQ2hlY2sgdGhlIGNvbnNvbGUgZm9yIGRldGFpbGVkIGNvbG9yIHZhbHVlczwvcD5cbiAgICAgICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgICAgIOKAoiBSZXBvIHVzZWQ6e1wiIFwifVxuICAgICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidW5kZXJsaW5lXCJcbiAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9rLXZ5bi9jb2xvcmFsZ29yaXRobVwiXG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9rLXZ5bi9jb2xvcmFsZ29yaXRobVxuICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgICAgIOKAoiBHZW5lcmF0ZWQge2NvbG9ycy5sZW5ndGh9IGNvbG9ycyB3aXRoe1wiIFwifVxuICAgICAgICAgICAgICAgICAge2NvbG9ycy5maWx0ZXIoKGMpID0+IGMuaXNNYWpvcikubGVuZ3RofSBtYWpvciBzdGVwc1xuICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQXBwO1xuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiY29sb3IiLCJjb2xvckNvbnRyYXN0IiwiaGV4VG9SZ2IiLCJoZXgiLCJyZXN1bHQiLCJleGVjIiwiciIsInBhcnNlSW50IiwiZyIsImIiLCJyZ2JUb0hzYiIsIm1heCIsIk1hdGgiLCJtaW4iLCJkZWx0YSIsImgiLCJzIiwidiIsInJvdW5kIiwiaGV4VG9Ic2IiLCJyZ2IiLCJnZXRDb250cmFzdFlJUSIsImhleGNvbG9yIiwic2xpY2UiLCJ5aXEiLCJjYWxjdWxhdGVDb250cmFzdCIsImNvbG9ycyIsImJhY2tncm91bmRDb2xvciIsIkFBX0NPTlRSQVNUX1RIUkVTSE9MRCIsIm1hcCIsImNvbnRyYXN0VmFsdWVXaGl0ZSIsImNvbnRyYXN0VmFsdWVCbGFjayIsInJvdW5kZWRDb250cmFzdFdoaXRlIiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJyb3VuZGVkQ29udHJhc3RCbGFjayIsInRleHRDb2xvciIsInN0ZXAiLCJjb250cmFzdCIsImNvbnRyYXN0UmF0aW9XaGl0ZSIsImNvbnRyYXN0UmF0aW9CbGFjayIsIkFwcCIsInNldENvbG9ycyIsImxvY2tIZXgiLCJzZXRMb2NrSGV4IiwicHJvcHMiLCJzdGVwcyIsImh1ZSIsInN0YXJ0IiwiZW5kIiwiY3VydmUiLCJzYXR1cmF0aW9uIiwicmF0ZSIsImJyaWdodG5lc3MiLCJvcHRpb25zIiwibWlub3JTdGVwcyIsInJvdGF0aW9uIiwiaXNWYWxpZEhleCIsInRlc3QiLCJnZW5lcmF0ZSIsImxlbmd0aCIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsImNvbG9yQ29udHJhc3RzIiwiZmlyc3RTdWZmaWNpZW50Q29udHJhc3QiLCJmaW5kIiwiZGl2IiwiY2xhc3NOYW1lIiwiaDEiLCJzcGFuIiwiaW5wdXQiLCJ0eXBlIiwidmFsdWUiLCJyZXBsYWNlIiwib25DaGFuZ2UiLCJlIiwidGFyZ2V0IiwidWwiLCJpbmRleCIsImxpIiwic3R5bGUiLCJoMiIsInAiLCJhIiwiaHJlZiIsImZpbHRlciIsImMiLCJpc01ham9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE$2\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeUnknownElementTypeFrameInDEV(type) {\n      if (null == type) return \"\";\n      if (\"function\" === typeof type) {\n        var prototype = type.prototype;\n        return describeNativeComponentFrame(\n          type,\n          !(!prototype || !prototype.isReactComponent)\n        );\n      }\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return (type = describeNativeComponentFrame(type.render, !1)), type;\n          case REACT_MEMO_TYPE:\n            return describeUnknownElementTypeFrameInDEV(type.type);\n          case REACT_LAZY_TYPE:\n            prototype = type._payload;\n            type = type._init;\n            try {\n              return describeUnknownElementTypeFrameInDEV(type(prototype));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, self, source, owner, props) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      if (\n        \"string\" === typeof type ||\n        \"function\" === typeof type ||\n        type === REACT_FRAGMENT_TYPE ||\n        type === REACT_PROFILER_TYPE ||\n        type === REACT_STRICT_MODE_TYPE ||\n        type === REACT_SUSPENSE_TYPE ||\n        type === REACT_SUSPENSE_LIST_TYPE ||\n        type === REACT_OFFSCREEN_TYPE ||\n        (\"object\" === typeof type &&\n          null !== type &&\n          (type.$$typeof === REACT_LAZY_TYPE ||\n            type.$$typeof === REACT_MEMO_TYPE ||\n            type.$$typeof === REACT_CONTEXT_TYPE ||\n            type.$$typeof === REACT_CONSUMER_TYPE ||\n            type.$$typeof === REACT_FORWARD_REF_TYPE ||\n            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||\n            void 0 !== type.getModuleId))\n      ) {\n        var children = config.children;\n        if (void 0 !== children)\n          if (isStaticChildren)\n            if (isArrayImpl(children)) {\n              for (\n                isStaticChildren = 0;\n                isStaticChildren < children.length;\n                isStaticChildren++\n              )\n                validateChildKeys(children[isStaticChildren], type);\n              Object.freeze && Object.freeze(children);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else validateChildKeys(children, type);\n      } else {\n        children = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          children +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        null === type\n          ? (isStaticChildren = \"null\")\n          : isArrayImpl(type)\n            ? (isStaticChildren = \"array\")\n            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE\n              ? ((isStaticChildren =\n                  \"<\" +\n                  (getComponentNameFromType(type.type) || \"Unknown\") +\n                  \" />\"),\n                (children =\n                  \" Did you accidentally export a JSX literal instead of a component?\"))\n              : (isStaticChildren = typeof type);\n        console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          isStaticChildren,\n          children\n        );\n      }\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(type, children, self, source, getOwner(), maybeKey);\n    }\n    function validateChildKeys(node, parentType) {\n      if (\n        \"object\" === typeof node &&\n        node &&\n        node.$$typeof !== REACT_CLIENT_REFERENCE\n      )\n        if (isArrayImpl(node))\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n            isValidElement(child) && validateExplicitKey(child, parentType);\n          }\n        else if (isValidElement(node))\n          node._store && (node._store.validated = 1);\n        else if (\n          (null === node || \"object\" !== typeof node\n            ? (i = null)\n            : ((i =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (i = \"function\" === typeof i ? i : null)),\n          \"function\" === typeof i &&\n            i !== node.entries &&\n            ((i = i.call(node)), i !== node))\n        )\n          for (; !(node = i.next()).done; )\n            isValidElement(node.value) &&\n              validateExplicitKey(node.value, parentType);\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function validateExplicitKey(element, parentType) {\n      if (\n        element._store &&\n        !element._store.validated &&\n        null == element.key &&\n        ((element._store.validated = 1),\n        (parentType = getCurrentComponentErrorInfo(parentType)),\n        !ownerHasKeyUseWarning[parentType])\n      ) {\n        ownerHasKeyUseWarning[parentType] = !0;\n        var childOwner = \"\";\n        element &&\n          null != element._owner &&\n          element._owner !== getOwner() &&\n          ((childOwner = null),\n          \"number\" === typeof element._owner.tag\n            ? (childOwner = getComponentNameFromType(element._owner.type))\n            : \"string\" === typeof element._owner.name &&\n              (childOwner = element._owner.name),\n          (childOwner = \" It was passed a child from \" + childOwner + \".\"));\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = function () {\n          var stack = describeUnknownElementTypeFrameInDEV(element.type);\n          prevGetCurrentStack && (stack += prevGetCurrentStack() || \"\");\n          return stack;\n        };\n        console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          parentType,\n          childOwner\n        );\n        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n      }\n    }\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = \"\",\n        owner = getOwner();\n      owner &&\n        (owner = getComponentNameFromType(owner.type)) &&\n        (info = \"\\n\\nCheck the render method of `\" + owner + \"`.\");\n      info ||\n        ((parentType = getComponentNameFromType(parentType)) &&\n          (info =\n            \"\\n\\nCheck the top-level render call using <\" + parentType + \">.\"));\n      return info;\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      assign = Object.assign,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      isArrayImpl = Array.isArray,\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {},\n      ownerHasKeyUseWarning = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL2RhdmlkZWJpc2N1c28vRG9jdW1lbnRzL0dpdEh1Yi9jb2xvci1yYW1wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDJcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICAhKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZSA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIsICExKSksIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBwcm90b3R5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUocHJvdG90eXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8XG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8XG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZ2V0TW9kdWxlSWQpKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dLCB0eXBlKTtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgKVxuICAgICAgICAgIGNoaWxkcmVuICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIG51bGwgPT09IHR5cGVcbiAgICAgICAgICA/IChpc1N0YXRpY0NoaWxkcmVuID0gXCJudWxsXCIpXG4gICAgICAgICAgOiBpc0FycmF5SW1wbCh0eXBlKVxuICAgICAgICAgICAgPyAoaXNTdGF0aWNDaGlsZHJlbiA9IFwiYXJyYXlcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICA/ICgoaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgOiAoaXNTdGF0aWNDaGlsZHJlbiA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLFxuICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBjaGlsZHJlbiwgc2VsZiwgc291cmNlLCBnZXRPd25lcigpLCBtYXliZUtleSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mICE9PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICApXG4gICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSlcbiAgICAgICAgICBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChudWxsID09PSBub2RlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgICA/IChpID0gbnVsbClcbiAgICAgICAgICAgIDogKChpID1cbiAgICAgICAgICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG5vZGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgICAgICAgICBub2RlW1wiQEBpdGVyYXRvclwiXSksXG4gICAgICAgICAgICAgIChpID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSA/IGkgOiBudWxsKSksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSAmJlxuICAgICAgICAgICAgaSAhPT0gbm9kZS5lbnRyaWVzICYmXG4gICAgICAgICAgICAoKGkgPSBpLmNhbGwobm9kZSkpLCBpICE9PSBub2RlKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAoOyAhKG5vZGUgPSBpLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQobm9kZS52YWx1ZSkgJiZcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShub2RlLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQuX3N0b3JlICYmXG4gICAgICAgICFlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgJiZcbiAgICAgICAgbnVsbCA9PSBlbGVtZW50LmtleSAmJlxuICAgICAgICAoKGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IDEpLFxuICAgICAgICAocGFyZW50VHlwZSA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkpLFxuICAgICAgICAhb3duZXJIYXNLZXlVc2VXYXJuaW5nW3BhcmVudFR5cGVdKVxuICAgICAgKSB7XG4gICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSA9ICEwO1xuICAgICAgICB2YXIgY2hpbGRPd25lciA9IFwiXCI7XG4gICAgICAgIGVsZW1lbnQgJiZcbiAgICAgICAgICBudWxsICE9IGVsZW1lbnQuX293bmVyICYmXG4gICAgICAgICAgZWxlbWVudC5fb3duZXIgIT09IGdldE93bmVyKCkgJiZcbiAgICAgICAgICAoKGNoaWxkT3duZXIgPSBudWxsKSxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIudGFnXG4gICAgICAgICAgICA/IChjaGlsZE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpKVxuICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIubmFtZSAmJlxuICAgICAgICAgICAgICAoY2hpbGRPd25lciA9IGVsZW1lbnQuX293bmVyLm5hbWUpLFxuICAgICAgICAgIChjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjaGlsZE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlKTtcbiAgICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrICYmIChzdGFjayArPSBwcmV2R2V0Q3VycmVudFN0YWNrKCkgfHwgXCJcIik7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgIGNoaWxkT3duZXJcbiAgICAgICAgKTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9IFwiXCIsXG4gICAgICAgIG93bmVyID0gZ2V0T3duZXIoKTtcbiAgICAgIG93bmVyICYmXG4gICAgICAgIChvd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvd25lci50eXBlKSkgJiZcbiAgICAgICAgKGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIG93bmVyICsgXCJgLlwiKTtcbiAgICAgIGluZm8gfHxcbiAgICAgICAgKChwYXJlbnRUeXBlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpKSAmJlxuICAgICAgICAgIChpbmZvID1cbiAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnRUeXBlICsgXCI+LlwiKSk7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG4gICAgdmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge30sXG4gICAgICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICByZXR1cm4ganN4REVWSW1wbCh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXZpZGViaXNjdXNvL0RvY3VtZW50cy9HaXRIdWIvY29sb3ItcmFtcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/chroma-js/dist/chroma.cjs":
/*!************************************************!*\
  !*** ./node_modules/chroma-js/dist/chroma.cjs ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * chroma.js - JavaScript library for color conversions\n *\n * Copyright (c) 2011-2024, Gregor Aisch\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name Gregor Aisch may not be used to endorse or promote products\n * derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * -------------------------------------------------------\n *\n * chroma.js includes colors from colorbrewer2.org, which are released under\n * the following license:\n *\n * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,\n * and The Pennsylvania State University.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific\n * language governing permissions and limitations under the License.\n *\n * ------------------------------------------------------\n *\n * Named colors are taken from X11 Color Names.\n * http://www.w3.org/TR/css3-color/#svg-color\n *\n * @preserve\n */\n\n(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n})(this, (function () { 'use strict';\n\n    var min$4 = Math.min;\n    var max$4 = Math.max;\n\n    function limit (x, low, high) {\n        if ( low === void 0 ) low = 0;\n        if ( high === void 0 ) high = 1;\n\n        return min$4(max$4(low, x), high);\n    }\n\n    function clip_rgb (rgb) {\n        rgb._clipped = false;\n        rgb._unclipped = rgb.slice(0);\n        for (var i = 0; i <= 3; i++) {\n            if (i < 3) {\n                if (rgb[i] < 0 || rgb[i] > 255) { rgb._clipped = true; }\n                rgb[i] = limit(rgb[i], 0, 255);\n            } else if (i === 3) {\n                rgb[i] = limit(rgb[i], 0, 1);\n            }\n        }\n        return rgb;\n    }\n\n    // ported from jQuery's $.type\n    var classToType = {};\n    for (var i = 0, list = [\n        'Boolean',\n        'Number',\n        'String',\n        'Function',\n        'Array',\n        'Date',\n        'RegExp',\n        'Undefined',\n        'Null'\n    ]; i < list.length; i += 1) {\n        var name = list[i];\n\n        classToType[(\"[object \" + name + \"]\")] = name.toLowerCase();\n    }\n    function type (obj) {\n        return classToType[Object.prototype.toString.call(obj)] || 'object';\n    }\n\n    function unpack (args, keyOrder) {\n        if ( keyOrder === void 0 ) keyOrder = null;\n\n        // if called with more than 3 arguments, we return the arguments\n        if (args.length >= 3) { return Array.prototype.slice.call(args); }\n        // with less than 3 args we check if first arg is object\n        // and use the keyOrder string to extract and sort properties\n        if (type(args[0]) == 'object' && keyOrder) {\n            return keyOrder\n                .split('')\n                .filter(function (k) { return args[0][k] !== undefined; })\n                .map(function (k) { return args[0][k]; });\n        }\n        // otherwise we just return the first argument\n        // (which we suppose is an array of args)\n        return args[0].slice(0);\n    }\n\n    function last (args) {\n        if (args.length < 2) { return null; }\n        var l = args.length - 1;\n        if (type(args[l]) == 'string') { return args[l].toLowerCase(); }\n        return null;\n    }\n\n    var PI$2 = Math.PI;\n    var min$3 = Math.min;\n    var max$3 = Math.max;\n\n    var rnd2 = function (a) { return Math.round(a * 100) / 100; };\n    var rnd3 = function (a) { return Math.round(a * 100) / 100; };\n\n    var TWOPI = PI$2 * 2;\n    var PITHIRD = PI$2 / 3;\n    var DEG2RAD = PI$2 / 180;\n    var RAD2DEG = 180 / PI$2;\n\n    /**\n     * Reverse the first three elements of an array\n     *\n     * @param {any[]} arr\n     * @returns {any[]}\n     */\n    function reverse3(arr) {\n        return arr.slice(0, 3).reverse().concat( arr.slice(3));\n    }\n\n    var input = {\n        format: {},\n        autodetect: []\n    };\n\n    var Color = function Color() {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var me = this;\n        if (\n            type(args[0]) === 'object' &&\n            args[0].constructor &&\n            args[0].constructor === this.constructor\n        ) {\n            // the argument is already a Color instance\n            return args[0];\n        }\n        // last argument could be the mode\n        var mode = last(args);\n        var autodetect = false;\n        if (!mode) {\n            autodetect = true;\n\n            if (!input.sorted) {\n                input.autodetect = input.autodetect.sort(function (a, b) { return b.p - a.p; });\n                input.sorted = true;\n            }\n\n            // auto-detect format\n            for (var i = 0, list = input.autodetect; i < list.length; i += 1) {\n                var chk = list[i];\n\n                mode = chk.test.apply(chk, args);\n                if (mode) { break; }\n            }\n        }\n        if (input.format[mode]) {\n            var rgb = input.format[mode].apply(\n                null,\n                autodetect ? args : args.slice(0, -1)\n            );\n            me._rgb = clip_rgb(rgb);\n        } else {\n            throw new Error('unknown format: ' + args);\n        }\n        // add alpha channel\n        if (me._rgb.length === 3) { me._rgb.push(1); }\n    };\n    Color.prototype.toString = function toString () {\n        if (type(this.hex) == 'function') { return this.hex(); }\n        return (\"[\" + (this._rgb.join(',')) + \"]\");\n    };\n\n    // this gets updated automatically\n    var version = '3.1.2';\n\n    var chroma = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args) ));\n    };\n\n    chroma.version = version;\n\n    var cmyk2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack(args, 'cmyk');\n        var c = args[0];\n        var m = args[1];\n        var y = args[2];\n        var k = args[3];\n        var alpha = args.length > 4 ? args[4] : 1;\n        if (k === 1) { return [0, 0, 0, alpha]; }\n        return [\n            c >= 1 ? 0 : 255 * (1 - c) * (1 - k), // r\n            m >= 1 ? 0 : 255 * (1 - m) * (1 - k), // g\n            y >= 1 ? 0 : 255 * (1 - y) * (1 - k), // b\n            alpha\n        ];\n    };\n\n    var max$2 = Math.max;\n\n    var rgb2cmyk = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        r = r / 255;\n        g = g / 255;\n        b = b / 255;\n        var k = 1 - max$2(r, max$2(g, b));\n        var f = k < 1 ? 1 / (1 - k) : 0;\n        var c = (1 - r - k) * f;\n        var m = (1 - g - k) * f;\n        var y = (1 - b - k) * f;\n        return [c, m, y, k];\n    };\n\n    Color.prototype.cmyk = function () {\n        return rgb2cmyk(this._rgb);\n    };\n\n    var cmyk = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['cmyk']) ));\n    };\n    Object.assign(chroma, { cmyk: cmyk });\n\n    input.format.cmyk = cmyk2rgb;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack(args, 'cmyk');\n            if (type(args) === 'array' && args.length === 4) {\n                return 'cmyk';\n            }\n        }\n    });\n\n    /*\n     * supported arguments:\n     * - hsl2css(h,s,l)\n     * - hsl2css(h,s,l,a)\n     * - hsl2css([h,s,l], mode)\n     * - hsl2css([h,s,l,a], mode)\n     * - hsl2css({h,s,l,a}, mode)\n     */\n    var hsl2css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var hsla = unpack(args, 'hsla');\n        var mode = last(args) || 'lsa';\n        hsla[0] = rnd2(hsla[0] || 0) + 'deg';\n        hsla[1] = rnd2(hsla[1] * 100) + '%';\n        hsla[2] = rnd2(hsla[2] * 100) + '%';\n        if (mode === 'hsla' || (hsla.length > 3 && hsla[3] < 1)) {\n            hsla[3] = '/ ' + (hsla.length > 3 ? hsla[3] : 1);\n            mode = 'hsla';\n        } else {\n            hsla.length = 3;\n        }\n        return ((mode.substr(0, 3)) + \"(\" + (hsla.join(' ')) + \")\");\n    };\n\n    /*\n     * supported arguments:\n     * - rgb2hsl(r,g,b)\n     * - rgb2hsl(r,g,b,a)\n     * - rgb2hsl([r,g,b])\n     * - rgb2hsl([r,g,b,a])\n     * - rgb2hsl({r,g,b,a})\n     */\n    var rgb2hsl$1 = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack(args, 'rgba');\n        var r = args[0];\n        var g = args[1];\n        var b = args[2];\n\n        r /= 255;\n        g /= 255;\n        b /= 255;\n\n        var minRgb = min$3(r, g, b);\n        var maxRgb = max$3(r, g, b);\n\n        var l = (maxRgb + minRgb) / 2;\n        var s, h;\n\n        if (maxRgb === minRgb) {\n            s = 0;\n            h = Number.NaN;\n        } else {\n            s =\n                l < 0.5\n                    ? (maxRgb - minRgb) / (maxRgb + minRgb)\n                    : (maxRgb - minRgb) / (2 - maxRgb - minRgb);\n        }\n\n        if (r == maxRgb) { h = (g - b) / (maxRgb - minRgb); }\n        else if (g == maxRgb) { h = 2 + (b - r) / (maxRgb - minRgb); }\n        else if (b == maxRgb) { h = 4 + (r - g) / (maxRgb - minRgb); }\n\n        h *= 60;\n        if (h < 0) { h += 360; }\n        if (args.length > 3 && args[3] !== undefined) { return [h, s, l, args[3]]; }\n        return [h, s, l];\n    };\n\n    /*\n     * supported arguments:\n     * - lab2css(l,a,b)\n     * - lab2css(l,a,b,alpha)\n     * - lab2css([l,a,b], mode)\n     * - lab2css([l,a,b,alpha], mode)\n     */\n    var lab2css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var laba = unpack(args, 'lab');\n        var mode = last(args) || 'lab';\n        laba[0] = rnd2(laba[0]) + '%';\n        laba[1] = rnd2(laba[1]);\n        laba[2] = rnd2(laba[2]);\n        if (mode === 'laba' || (laba.length > 3 && laba[3] < 1)) {\n            laba[3] = '/ ' + (laba.length > 3 ? laba[3] : 1);\n        } else {\n            laba.length = 3;\n        }\n        return (\"lab(\" + (laba.join(' ')) + \")\");\n    };\n\n    var labConstants = {\n        // Corresponds roughly to RGB brighter/darker\n        Kn: 18,\n\n        // D65 standard referent\n        labWhitePoint: 'd65',\n        Xn: 0.95047,\n        Yn: 1,\n        Zn: 1.08883,\n\n        t0: 0.137931034, // 4 / 29\n        t1: 0.206896552, // 6 / 29\n        t2: 0.12841855, // 3 * t1 * t1\n        t3: 0.008856452, // t1 * t1 * t1,\n\n        kE: 216.0 / 24389.0,\n        kKE: 8.0,\n        kK: 24389.0 / 27.0,\n\n        RefWhiteRGB: {\n            // sRGB\n            X: 0.95047,\n            Y: 1,\n            Z: 1.08883\n        },\n\n        MtxRGB2XYZ: {\n            m00: 0.4124564390896922,\n            m01: 0.21267285140562253,\n            m02: 0.0193338955823293,\n            m10: 0.357576077643909,\n            m11: 0.715152155287818,\n            m12: 0.11919202588130297,\n            m20: 0.18043748326639894,\n            m21: 0.07217499330655958,\n            m22: 0.9503040785363679\n        },\n\n        MtxXYZ2RGB: {\n            m00: 3.2404541621141045,\n            m01: -0.9692660305051868,\n            m02: 0.055643430959114726,\n            m10: -1.5371385127977166,\n            m11: 1.8760108454466942,\n            m12: -0.2040259135167538,\n            m20: -0.498531409556016,\n            m21: 0.041556017530349834,\n            m22: 1.0572251882231791\n        },\n\n        // used in rgb2xyz\n        As: 0.9414285350000001,\n        Bs: 1.040417467,\n        Cs: 1.089532651,\n\n        MtxAdaptMa: {\n            m00: 0.8951,\n            m01: -0.7502,\n            m02: 0.0389,\n            m10: 0.2664,\n            m11: 1.7135,\n            m12: -0.0685,\n            m20: -0.1614,\n            m21: 0.0367,\n            m22: 1.0296\n        },\n\n        MtxAdaptMaI: {\n            m00: 0.9869929054667123,\n            m01: 0.43230526972339456,\n            m02: -0.008528664575177328,\n            m10: -0.14705425642099013,\n            m11: 0.5183602715367776,\n            m12: 0.04004282165408487,\n            m20: 0.15996265166373125,\n            m21: 0.0492912282128556,\n            m22: 0.9684866957875502\n        }\n    };\n\n    // taken from https://de.mathworks.com/help/images/ref/whitepoint.html\n    var ILLUMINANTS = new Map([\n        // ASTM E308-01\n        ['a', [1.0985, 0.35585]],\n        // Wyszecki & Stiles, p. 769\n        ['b', [1.0985, 0.35585]],\n        // C ASTM E308-01\n        ['c', [0.98074, 1.18232]],\n        // D50 (ASTM E308-01)\n        ['d50', [0.96422, 0.82521]],\n        // D55 (ASTM E308-01)\n        ['d55', [0.95682, 0.92149]],\n        // D65 (ASTM E308-01)\n        ['d65', [0.95047, 1.08883]],\n        // E (ASTM E308-01)\n        ['e', [1, 1, 1]],\n        // F2 (ASTM E308-01)\n        ['f2', [0.99186, 0.67393]],\n        // F7 (ASTM E308-01)\n        ['f7', [0.95041, 1.08747]],\n        // F11 (ASTM E308-01)\n        ['f11', [1.00962, 0.6435]],\n        ['icc', [0.96422, 0.82521]]\n    ]);\n\n    function setLabWhitePoint(name) {\n        var ill = ILLUMINANTS.get(String(name).toLowerCase());\n        if (!ill) {\n            throw new Error('unknown Lab illuminant ' + name);\n        }\n        labConstants.labWhitePoint = name;\n        labConstants.Xn = ill[0];\n        labConstants.Zn = ill[1];\n    }\n\n    function getLabWhitePoint() {\n        return labConstants.labWhitePoint;\n    }\n\n    var rgb2lab = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var rest = ref.slice(3);\n        var ref$1 = rgb2xyz(r, g, b);\n        var x = ref$1[0];\n        var y = ref$1[1];\n        var z = ref$1[2];\n        var ref$2 = xyz2lab(x, y, z);\n        var L = ref$2[0];\n        var a = ref$2[1];\n        var b_ = ref$2[2];\n        return [L, a, b_ ].concat( (rest.length > 0 && rest[0] < 1 ? [rest[0]] : []));\n    };\n\n    function xyz2lab(x, y, z) {\n        var Xn = labConstants.Xn;\n        var Yn = labConstants.Yn;\n        var Zn = labConstants.Zn;\n        var kE = labConstants.kE;\n        var kK = labConstants.kK;\n        var xr = x / Xn;\n        var yr = y / Yn;\n        var zr = z / Zn;\n\n        var fx = xr > kE ? Math.pow(xr, 1.0 / 3.0) : (kK * xr + 16.0) / 116.0;\n        var fy = yr > kE ? Math.pow(yr, 1.0 / 3.0) : (kK * yr + 16.0) / 116.0;\n        var fz = zr > kE ? Math.pow(zr, 1.0 / 3.0) : (kK * zr + 16.0) / 116.0;\n\n        return [116.0 * fy - 16.0, 500.0 * (fx - fy), 200.0 * (fy - fz)];\n    }\n\n    function gammaAdjustSRGB(companded) {\n        var sign = Math.sign(companded);\n        companded = Math.abs(companded);\n        var linear =\n            companded <= 0.04045\n                ? companded / 12.92\n                : Math.pow((companded + 0.055) / 1.055, 2.4);\n        return linear * sign;\n    }\n\n    var rgb2xyz = function (r, g, b) {\n        // normalize and gamma adjust\n        r = gammaAdjustSRGB(r / 255);\n        g = gammaAdjustSRGB(g / 255);\n        b = gammaAdjustSRGB(b / 255);\n\n        var MtxRGB2XYZ = labConstants.MtxRGB2XYZ;\n        var MtxAdaptMa = labConstants.MtxAdaptMa;\n        var MtxAdaptMaI = labConstants.MtxAdaptMaI;\n        var Xn = labConstants.Xn;\n        var Yn = labConstants.Yn;\n        var Zn = labConstants.Zn;\n        var As = labConstants.As;\n        var Bs = labConstants.Bs;\n        var Cs = labConstants.Cs;\n\n        var x = r * MtxRGB2XYZ.m00 + g * MtxRGB2XYZ.m10 + b * MtxRGB2XYZ.m20;\n        var y = r * MtxRGB2XYZ.m01 + g * MtxRGB2XYZ.m11 + b * MtxRGB2XYZ.m21;\n        var z = r * MtxRGB2XYZ.m02 + g * MtxRGB2XYZ.m12 + b * MtxRGB2XYZ.m22;\n\n        var Ad = Xn * MtxAdaptMa.m00 + Yn * MtxAdaptMa.m10 + Zn * MtxAdaptMa.m20;\n        var Bd = Xn * MtxAdaptMa.m01 + Yn * MtxAdaptMa.m11 + Zn * MtxAdaptMa.m21;\n        var Cd = Xn * MtxAdaptMa.m02 + Yn * MtxAdaptMa.m12 + Zn * MtxAdaptMa.m22;\n\n        var X = x * MtxAdaptMa.m00 + y * MtxAdaptMa.m10 + z * MtxAdaptMa.m20;\n        var Y = x * MtxAdaptMa.m01 + y * MtxAdaptMa.m11 + z * MtxAdaptMa.m21;\n        var Z = x * MtxAdaptMa.m02 + y * MtxAdaptMa.m12 + z * MtxAdaptMa.m22;\n\n        X *= Ad / As;\n        Y *= Bd / Bs;\n        Z *= Cd / Cs;\n\n        x = X * MtxAdaptMaI.m00 + Y * MtxAdaptMaI.m10 + Z * MtxAdaptMaI.m20;\n        y = X * MtxAdaptMaI.m01 + Y * MtxAdaptMaI.m11 + Z * MtxAdaptMaI.m21;\n        z = X * MtxAdaptMaI.m02 + Y * MtxAdaptMaI.m12 + Z * MtxAdaptMaI.m22;\n\n        return [x, y, z];\n    };\n\n    /*\n     * supported arguments:\n     * - lab2css(l,a,b)\n     * - lab2css(l,a,b,alpha)\n     * - lab2css([l,a,b], mode)\n     * - lab2css([l,a,b,alpha], mode)\n     */\n    var lch2css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var lcha = unpack(args, 'lch');\n        var mode = last(args) || 'lab';\n        lcha[0] = rnd2(lcha[0]) + '%';\n        lcha[1] = rnd2(lcha[1]);\n        lcha[2] = isNaN(lcha[2]) ? 'none' : rnd2(lcha[2]) + 'deg'; // add deg unit to hue\n        if (mode === 'lcha' || (lcha.length > 3 && lcha[3] < 1)) {\n            lcha[3] = '/ ' + (lcha.length > 3 ? lcha[3] : 1);\n        } else {\n            lcha.length = 3;\n        }\n        return (\"lch(\" + (lcha.join(' ')) + \")\");\n    };\n\n    var sqrt$4 = Math.sqrt;\n    var atan2$2 = Math.atan2;\n    var round$5 = Math.round;\n\n    var lab2lch = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack(args, 'lab');\n        var l = ref[0];\n        var a = ref[1];\n        var b = ref[2];\n        var c = sqrt$4(a * a + b * b);\n        var h = (atan2$2(b, a) * RAD2DEG + 360) % 360;\n        if (round$5(c * 10000) === 0) { h = Number.NaN; }\n        return [l, c, h];\n    };\n\n    var rgb2lch = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var rest = ref.slice(3);\n        var ref$1 = rgb2lab(r, g, b);\n        var l = ref$1[0];\n        var a = ref$1[1];\n        var b_ = ref$1[2];\n        var ref$2 = lab2lch(l, a, b_);\n        var L = ref$2[0];\n        var c = ref$2[1];\n        var h = ref$2[2];\n        return [L, c, h ].concat( (rest.length > 0 && rest[0] < 1 ? [rest[0]] : []));\n    };\n\n    // from https://www.w3.org/TR/css-color-4/multiply-matrices.js\n    function multiplyMatrices(A, B) {\n        var m = A.length;\n\n        if (!Array.isArray(A[0])) {\n            // A is vector, convert to [[a, b, c, ...]]\n            A = [A];\n        }\n\n        if (!Array.isArray(B[0])) {\n            // B is vector, convert to [[a], [b], [c], ...]]\n            B = B.map(function (x) { return [x]; });\n        }\n\n        var p = B[0].length;\n        var B_cols = B[0].map(function (_, i) { return B.map(function (x) { return x[i]; }); }); // transpose B\n        var product = A.map(function (row) { return B_cols.map(function (col) {\n                if (!Array.isArray(row)) {\n                    return col.reduce(function (a, c) { return a + c * row; }, 0);\n                }\n\n                return row.reduce(function (a, c, i) { return a + c * (col[i] || 0); }, 0);\n            }); }\n        );\n\n        if (m === 1) {\n            product = product[0]; // Avoid [[a, b, c, ...]]\n        }\n\n        if (p === 1) {\n            return product.map(function (x) { return x[0]; }); // Avoid [[a], [b], [c], ...]]\n        }\n\n        return product;\n    }\n\n    var rgb2oklab = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var rest = ref.slice(3);\n        var xyz = rgb2xyz(r, g, b);\n        var oklab = XYZ_to_OKLab(xyz);\n        return oklab.concat( (rest.length > 0 && rest[0] < 1 ? [rest[0]] : []));\n    };\n\n    // from https://www.w3.org/TR/css-color-4/#color-conversion-code\n    function XYZ_to_OKLab(XYZ) {\n        // Given XYZ relative to D65, convert to OKLab\n        var XYZtoLMS = [\n            [0.819022437996703, 0.3619062600528904, -0.1288737815209879],\n            [0.0329836539323885, 0.9292868615863434, 0.0361446663506424],\n            [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]\n        ];\n        var LMStoOKLab = [\n            [0.210454268309314, 0.7936177747023054, -0.0040720430116193],\n            [1.9779985324311684, -2.4285922420485799, 0.450593709617411],\n            [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]\n        ];\n\n        var LMS = multiplyMatrices(XYZtoLMS, XYZ);\n        // JavaScript Math.cbrt returns a sign-matched cube root\n        // beware if porting to other languages\n        // especially if tempted to use a general power function\n        return multiplyMatrices(\n            LMStoOKLab,\n            LMS.map(function (c) { return Math.cbrt(c); })\n        );\n        // L in range [0,1]. For use in CSS, multiply by 100 and add a percent\n    }\n\n    var oklab2css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var laba = unpack(args, 'lab');\n        laba[0] = rnd2(laba[0] * 100) + '%';\n        laba[1] = rnd3(laba[1]);\n        laba[2] = rnd3(laba[2]);\n        if (laba.length > 3 && laba[3] < 1) {\n            laba[3] = '/ ' + (laba.length > 3 ? laba[3] : 1);\n        } else {\n            laba.length = 3;\n        }\n        return (\"oklab(\" + (laba.join(' ')) + \")\");\n    };\n\n    var rgb2oklch = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var rest = ref.slice(3);\n        var ref$1 = rgb2oklab(r, g, b);\n        var l = ref$1[0];\n        var a = ref$1[1];\n        var b_ = ref$1[2];\n        var ref$2 = lab2lch(l, a, b_);\n        var L = ref$2[0];\n        var c = ref$2[1];\n        var h = ref$2[2];\n        return [L, c, h ].concat( (rest.length > 0 && rest[0] < 1 ? [rest[0]] : []));\n    };\n\n    var oklch2css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var lcha = unpack(args, 'lch');\n        lcha[0] = rnd2(lcha[0] * 100) + '%';\n        lcha[1] = rnd3(lcha[1]);\n        lcha[2] = isNaN(lcha[2]) ? 'none' : rnd2(lcha[2]) + 'deg'; // add deg unit to hue\n        if (lcha.length > 3 && lcha[3] < 1) {\n            lcha[3] = '/ ' + (lcha.length > 3 ? lcha[3] : 1);\n        } else {\n            lcha.length = 3;\n        }\n        return (\"oklch(\" + (lcha.join(' ')) + \")\");\n    };\n\n    var round$4 = Math.round;\n\n    /*\n     * supported arguments:\n     * - rgb2css(r,g,b)\n     * - rgb2css(r,g,b,a)\n     * - rgb2css([r,g,b], mode)\n     * - rgb2css([r,g,b,a], mode)\n     * - rgb2css({r,g,b,a}, mode)\n     */\n    var rgb2css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgba = unpack(args, 'rgba');\n        var mode = last(args) || 'rgb';\n        if (mode.substr(0, 3) === 'hsl') {\n            return hsl2css(rgb2hsl$1(rgba), mode);\n        }\n        if (mode.substr(0, 3) === 'lab') {\n            // change to D50 lab whitepoint since this is what W3C is using for CSS Lab colors\n            var prevWhitePoint = getLabWhitePoint();\n            setLabWhitePoint('d50');\n            var cssColor = lab2css(rgb2lab(rgba), mode);\n            setLabWhitePoint(prevWhitePoint);\n            return cssColor;\n        }\n        if (mode.substr(0, 3) === 'lch') {\n            // change to D50 lab whitepoint since this is what W3C is using for CSS Lab colors\n            var prevWhitePoint$1 = getLabWhitePoint();\n            setLabWhitePoint('d50');\n            var cssColor$1 = lch2css(rgb2lch(rgba), mode);\n            setLabWhitePoint(prevWhitePoint$1);\n            return cssColor$1;\n        }\n        if (mode.substr(0, 5) === 'oklab') {\n            return oklab2css(rgb2oklab(rgba));\n        }\n        if (mode.substr(0, 5) === 'oklch') {\n            return oklch2css(rgb2oklch(rgba));\n        }\n        rgba[0] = round$4(rgba[0]);\n        rgba[1] = round$4(rgba[1]);\n        rgba[2] = round$4(rgba[2]);\n        if (mode === 'rgba' || (rgba.length > 3 && rgba[3] < 1)) {\n            rgba[3] = '/ ' + (rgba.length > 3 ? rgba[3] : 1);\n            mode = 'rgba';\n        }\n        return ((mode.substr(0, 3)) + \"(\" + (rgba.slice(0, mode === 'rgb' ? 3 : 4).join(' ')) + \")\");\n    };\n\n    var hsl2rgb = function () {\n        var assign;\n\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n        args = unpack(args, 'hsl');\n        var h = args[0];\n        var s = args[1];\n        var l = args[2];\n        var r, g, b;\n        if (s === 0) {\n            r = g = b = l * 255;\n        } else {\n            var t3 = [0, 0, 0];\n            var c = [0, 0, 0];\n            var t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;\n            var t1 = 2 * l - t2;\n            var h_ = h / 360;\n            t3[0] = h_ + 1 / 3;\n            t3[1] = h_;\n            t3[2] = h_ - 1 / 3;\n            for (var i = 0; i < 3; i++) {\n                if (t3[i] < 0) { t3[i] += 1; }\n                if (t3[i] > 1) { t3[i] -= 1; }\n                if (6 * t3[i] < 1) { c[i] = t1 + (t2 - t1) * 6 * t3[i]; }\n                else if (2 * t3[i] < 1) { c[i] = t2; }\n                else if (3 * t3[i] < 2) { c[i] = t1 + (t2 - t1) * (2 / 3 - t3[i]) * 6; }\n                else { c[i] = t1; }\n            }\n            (assign = [c[0] * 255, c[1] * 255, c[2] * 255], r = assign[0], g = assign[1], b = assign[2]);\n        }\n        if (args.length > 3) {\n            // keep alpha channel\n            return [r, g, b, args[3]];\n        }\n        return [r, g, b, 1];\n    };\n\n    /*\n     * L* [0..100]\n     * a [-100..100]\n     * b [-100..100]\n     */\n    var lab2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack(args, 'lab');\n        var L = args[0];\n        var a = args[1];\n        var b = args[2];\n        var ref = lab2xyz(L, a, b);\n        var x = ref[0];\n        var y = ref[1];\n        var z = ref[2];\n        var ref$1 = xyz2rgb(x, y, z);\n        var r = ref$1[0];\n        var g = ref$1[1];\n        var b_ = ref$1[2];\n        return [r, g, b_, args.length > 3 ? args[3] : 1];\n    };\n\n    var lab2xyz = function (L, a, b) {\n        var kE = labConstants.kE;\n        var kK = labConstants.kK;\n        var kKE = labConstants.kKE;\n        var Xn = labConstants.Xn;\n        var Yn = labConstants.Yn;\n        var Zn = labConstants.Zn;\n\n        var fy = (L + 16.0) / 116.0;\n        var fx = 0.002 * a + fy;\n        var fz = fy - 0.005 * b;\n\n        var fx3 = fx * fx * fx;\n        var fz3 = fz * fz * fz;\n\n        var xr = fx3 > kE ? fx3 : (116.0 * fx - 16.0) / kK;\n        var yr = L > kKE ? Math.pow((L + 16.0) / 116.0, 3.0) : L / kK;\n        var zr = fz3 > kE ? fz3 : (116.0 * fz - 16.0) / kK;\n\n        var x = xr * Xn;\n        var y = yr * Yn;\n        var z = zr * Zn;\n\n        return [x, y, z];\n    };\n\n    var compand = function (linear) {\n        /* sRGB */\n        var sign = Math.sign(linear);\n        linear = Math.abs(linear);\n        return (\n            (linear <= 0.0031308\n                ? linear * 12.92\n                : 1.055 * Math.pow(linear, 1.0 / 2.4) - 0.055) * sign\n        );\n    };\n\n    var xyz2rgb = function (x, y, z) {\n        var MtxAdaptMa = labConstants.MtxAdaptMa;\n        var MtxAdaptMaI = labConstants.MtxAdaptMaI;\n        var MtxXYZ2RGB = labConstants.MtxXYZ2RGB;\n        var RefWhiteRGB = labConstants.RefWhiteRGB;\n        var Xn = labConstants.Xn;\n        var Yn = labConstants.Yn;\n        var Zn = labConstants.Zn;\n\n        var As = Xn * MtxAdaptMa.m00 + Yn * MtxAdaptMa.m10 + Zn * MtxAdaptMa.m20;\n        var Bs = Xn * MtxAdaptMa.m01 + Yn * MtxAdaptMa.m11 + Zn * MtxAdaptMa.m21;\n        var Cs = Xn * MtxAdaptMa.m02 + Yn * MtxAdaptMa.m12 + Zn * MtxAdaptMa.m22;\n\n        var Ad =\n            RefWhiteRGB.X * MtxAdaptMa.m00 +\n            RefWhiteRGB.Y * MtxAdaptMa.m10 +\n            RefWhiteRGB.Z * MtxAdaptMa.m20;\n        var Bd =\n            RefWhiteRGB.X * MtxAdaptMa.m01 +\n            RefWhiteRGB.Y * MtxAdaptMa.m11 +\n            RefWhiteRGB.Z * MtxAdaptMa.m21;\n        var Cd =\n            RefWhiteRGB.X * MtxAdaptMa.m02 +\n            RefWhiteRGB.Y * MtxAdaptMa.m12 +\n            RefWhiteRGB.Z * MtxAdaptMa.m22;\n\n        var X1 =\n            (x * MtxAdaptMa.m00 + y * MtxAdaptMa.m10 + z * MtxAdaptMa.m20) *\n            (Ad / As);\n        var Y1 =\n            (x * MtxAdaptMa.m01 + y * MtxAdaptMa.m11 + z * MtxAdaptMa.m21) *\n            (Bd / Bs);\n        var Z1 =\n            (x * MtxAdaptMa.m02 + y * MtxAdaptMa.m12 + z * MtxAdaptMa.m22) *\n            (Cd / Cs);\n\n        var X2 =\n            X1 * MtxAdaptMaI.m00 + Y1 * MtxAdaptMaI.m10 + Z1 * MtxAdaptMaI.m20;\n        var Y2 =\n            X1 * MtxAdaptMaI.m01 + Y1 * MtxAdaptMaI.m11 + Z1 * MtxAdaptMaI.m21;\n        var Z2 =\n            X1 * MtxAdaptMaI.m02 + Y1 * MtxAdaptMaI.m12 + Z1 * MtxAdaptMaI.m22;\n\n        var r = compand(\n            X2 * MtxXYZ2RGB.m00 + Y2 * MtxXYZ2RGB.m10 + Z2 * MtxXYZ2RGB.m20\n        );\n        var g = compand(\n            X2 * MtxXYZ2RGB.m01 + Y2 * MtxXYZ2RGB.m11 + Z2 * MtxXYZ2RGB.m21\n        );\n        var b = compand(\n            X2 * MtxXYZ2RGB.m02 + Y2 * MtxXYZ2RGB.m12 + Z2 * MtxXYZ2RGB.m22\n        );\n\n        return [r * 255, g * 255, b * 255];\n    };\n\n    var sin$3 = Math.sin;\n    var cos$4 = Math.cos;\n\n    var lch2lab = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        /*\n        Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.\n        These formulas were invented by David Dalrymple to obtain maximum contrast without going\n        out of gamut if the parameters are in the range 0-1.\n\n        A saturation multiplier was added by Gregor Aisch\n        */\n        var ref = unpack(args, 'lch');\n        var l = ref[0];\n        var c = ref[1];\n        var h = ref[2];\n        if (isNaN(h)) { h = 0; }\n        h = h * DEG2RAD;\n        return [l, cos$4(h) * c, sin$3(h) * c];\n    };\n\n    var lch2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack(args, 'lch');\n        var l = args[0];\n        var c = args[1];\n        var h = args[2];\n        var ref = lch2lab(l, c, h);\n        var L = ref[0];\n        var a = ref[1];\n        var b_ = ref[2];\n        var ref$1 = lab2rgb(L, a, b_);\n        var r = ref$1[0];\n        var g = ref$1[1];\n        var b = ref$1[2];\n        return [r, g, b, args.length > 3 ? args[3] : 1];\n    };\n\n    var oklab2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack(args, 'lab');\n        var L = args[0];\n        var a = args[1];\n        var b = args[2];\n        var rest = args.slice(3);\n        var ref = OKLab_to_XYZ([L, a, b]);\n        var X = ref[0];\n        var Y = ref[1];\n        var Z = ref[2];\n        var ref$1 = xyz2rgb(X, Y, Z);\n        var r = ref$1[0];\n        var g = ref$1[1];\n        var b_ = ref$1[2];\n        return [r, g, b_ ].concat( (rest.length > 0 && rest[0] < 1 ? [rest[0]] : []));\n    };\n\n    // from https://www.w3.org/TR/css-color-4/#color-conversion-code\n    function OKLab_to_XYZ(OKLab) {\n        // Given OKLab, convert to XYZ relative to D65\n        var LMStoXYZ = [\n            [1.2268798758459243, -0.5578149944602171, 0.2813910456659647],\n            [-0.0405757452148008, 1.112286803280317, -0.0717110580655164],\n            [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]\n        ];\n        var OKLabtoLMS = [\n            [1.0, 0.3963377773761749, 0.2158037573099136],\n            [1.0, -0.1055613458156586, -0.0638541728258133],\n            [1.0, -0.0894841775298119, -1.2914855480194092]\n        ];\n\n        var LMSnl = multiplyMatrices(OKLabtoLMS, OKLab);\n        return multiplyMatrices(\n            LMStoXYZ,\n            LMSnl.map(function (c) { return Math.pow( c, 3 ); })\n        );\n    }\n\n    var oklch2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack(args, 'lch');\n        var l = args[0];\n        var c = args[1];\n        var h = args[2];\n        var rest = args.slice(3);\n        var ref = lch2lab(l, c, h);\n        var L = ref[0];\n        var a = ref[1];\n        var b_ = ref[2];\n        var ref$1 = oklab2rgb(L, a, b_);\n        var r = ref$1[0];\n        var g = ref$1[1];\n        var b = ref$1[2];\n        return [r, g, b ].concat( (rest.length > 0 && rest[0] < 1 ? [rest[0]] : []));\n    };\n\n    var INT_OR_PCT = /((?:-?\\d+)|(?:-?\\d+(?:\\.\\d+)?)%|none)/.source;\n    var FLOAT_OR_PCT = /((?:-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)%?)|none)/.source;\n    var PCT = /((?:-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)%)|none)/.source;\n    var RE_S = /\\s*/.source;\n    var SEP = /\\s+/.source;\n    var COMMA = /\\s*,\\s*/.source;\n    var ANLGE = /((?:-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:deg)?)|none)/.source;\n    var ALPHA = /\\s*(?:\\/\\s*((?:[01]|[01]?\\.\\d+)|\\d+(?:\\.\\d+)?%))?/.source;\n\n    // e.g. rgb(250 20 0), rgb(100% 50% 20%), rgb(100% 50% 20% / 0.5)\n    var RE_RGB = new RegExp(\n        '^rgba?\\\\(' +\n            RE_S +\n            [INT_OR_PCT, INT_OR_PCT, INT_OR_PCT].join(SEP) +\n            ALPHA +\n            '\\\\)$'\n    );\n    var RE_RGB_LEGACY = new RegExp(\n        '^rgb\\\\(' +\n            RE_S +\n            [INT_OR_PCT, INT_OR_PCT, INT_OR_PCT].join(COMMA) +\n            RE_S +\n            '\\\\)$'\n    );\n    var RE_RGBA_LEGACY = new RegExp(\n        '^rgba\\\\(' +\n            RE_S +\n            [INT_OR_PCT, INT_OR_PCT, INT_OR_PCT, FLOAT_OR_PCT].join(COMMA) +\n            RE_S +\n            '\\\\)$'\n    );\n\n    var RE_HSL = new RegExp(\n        '^hsla?\\\\(' + RE_S + [ANLGE, PCT, PCT].join(SEP) + ALPHA + '\\\\)$'\n    );\n    var RE_HSL_LEGACY = new RegExp(\n        '^hsl?\\\\(' + RE_S + [ANLGE, PCT, PCT].join(COMMA) + RE_S + '\\\\)$'\n    );\n    var RE_HSLA_LEGACY =\n        /^hsla\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n\n    var RE_LAB = new RegExp(\n        '^lab\\\\(' +\n            RE_S +\n            [FLOAT_OR_PCT, FLOAT_OR_PCT, FLOAT_OR_PCT].join(SEP) +\n            ALPHA +\n            '\\\\)$'\n    );\n    var RE_LCH = new RegExp(\n        '^lch\\\\(' +\n            RE_S +\n            [FLOAT_OR_PCT, FLOAT_OR_PCT, ANLGE].join(SEP) +\n            ALPHA +\n            '\\\\)$'\n    );\n    var RE_OKLAB = new RegExp(\n        '^oklab\\\\(' +\n            RE_S +\n            [FLOAT_OR_PCT, FLOAT_OR_PCT, FLOAT_OR_PCT].join(SEP) +\n            ALPHA +\n            '\\\\)$'\n    );\n    var RE_OKLCH = new RegExp(\n        '^oklch\\\\(' +\n            RE_S +\n            [FLOAT_OR_PCT, FLOAT_OR_PCT, ANLGE].join(SEP) +\n            ALPHA +\n            '\\\\)$'\n    );\n\n    var round$3 = Math.round;\n\n    var roundRGB = function (rgb) {\n        return rgb.map(function (v, i) { return (i <= 2 ? limit(round$3(v), 0, 255) : v); });\n    };\n\n    var percentToAbsolute = function (pct, min, max, signed) {\n        if ( min === void 0 ) min = 0;\n        if ( max === void 0 ) max = 100;\n        if ( signed === void 0 ) signed = false;\n\n        if (typeof pct === 'string' && pct.endsWith('%')) {\n            pct = parseFloat(pct.substring(0, pct.length - 1)) / 100;\n            if (signed) {\n                // signed percentages are in the range -100% to 100%\n                pct = min + (pct + 1) * 0.5 * (max - min);\n            } else {\n                pct = min + pct * (max - min);\n            }\n        }\n        return +pct;\n    };\n\n    var noneToValue = function (v, noneValue) {\n        return v === 'none' ? noneValue : v;\n    };\n\n    var css2rgb = function (css) {\n        css = css.toLowerCase().trim();\n\n        if (css === 'transparent') {\n            return [0, 0, 0, 0];\n        }\n\n        var m;\n\n        if (input.format.named) {\n            try {\n                return input.format.named(css);\n                // eslint-disable-next-line\n            } catch (e) {}\n        }\n\n        // rgb(250 20 0) or rgb(250,20,0)\n        if ((m = css.match(RE_RGB)) || (m = css.match(RE_RGB_LEGACY))) {\n            var rgb = m.slice(1, 4);\n            for (var i = 0; i < 3; i++) {\n                rgb[i] = +percentToAbsolute(noneToValue(rgb[i], 0), 0, 255);\n            }\n            rgb = roundRGB(rgb);\n            var alpha = m[4] !== undefined ? +percentToAbsolute(m[4], 0, 1) : 1;\n            rgb[3] = alpha; // default alpha\n            return rgb;\n        }\n\n        // rgba(250,20,0,0.4)\n        if ((m = css.match(RE_RGBA_LEGACY))) {\n            var rgb$1 = m.slice(1, 5);\n            for (var i$1 = 0; i$1 < 4; i$1++) {\n                rgb$1[i$1] = +percentToAbsolute(rgb$1[i$1], 0, 255);\n            }\n            return rgb$1;\n        }\n\n        // hsl(0,100%,50%)\n        if ((m = css.match(RE_HSL)) || (m = css.match(RE_HSL_LEGACY))) {\n            var hsl = m.slice(1, 4);\n            hsl[0] = +noneToValue(hsl[0].replace('deg', ''), 0);\n            hsl[1] = +percentToAbsolute(noneToValue(hsl[1], 0), 0, 100) * 0.01;\n            hsl[2] = +percentToAbsolute(noneToValue(hsl[2], 0), 0, 100) * 0.01;\n            var rgb$2 = roundRGB(hsl2rgb(hsl));\n            var alpha$1 = m[4] !== undefined ? +percentToAbsolute(m[4], 0, 1) : 1;\n            rgb$2[3] = alpha$1;\n            return rgb$2;\n        }\n\n        // hsla(0,100%,50%,0.5)\n        if ((m = css.match(RE_HSLA_LEGACY))) {\n            var hsl$1 = m.slice(1, 4);\n            hsl$1[1] *= 0.01;\n            hsl$1[2] *= 0.01;\n            var rgb$3 = hsl2rgb(hsl$1);\n            for (var i$2 = 0; i$2 < 3; i$2++) {\n                rgb$3[i$2] = round$3(rgb$3[i$2]);\n            }\n            rgb$3[3] = +m[4]; // default alpha = 1\n            return rgb$3;\n        }\n\n        if ((m = css.match(RE_LAB))) {\n            var lab = m.slice(1, 4);\n            lab[0] = percentToAbsolute(noneToValue(lab[0], 0), 0, 100);\n            lab[1] = percentToAbsolute(noneToValue(lab[1], 0), -125, 125, true);\n            lab[2] = percentToAbsolute(noneToValue(lab[2], 0), -125, 125, true);\n            // convert to D50 Lab whitepoint\n            var wp = getLabWhitePoint();\n            setLabWhitePoint('d50');\n            var rgb$4 = roundRGB(lab2rgb(lab));\n            // convert back to original Lab whitepoint\n            setLabWhitePoint(wp);\n            var alpha$2 = m[4] !== undefined ? +percentToAbsolute(m[4], 0, 1) : 1;\n            rgb$4[3] = alpha$2;\n            return rgb$4;\n        }\n\n        if ((m = css.match(RE_LCH))) {\n            var lch = m.slice(1, 4);\n            lch[0] = percentToAbsolute(lch[0], 0, 100);\n            lch[1] = percentToAbsolute(noneToValue(lch[1], 0), 0, 150, false);\n            lch[2] = +noneToValue(lch[2].replace('deg', ''), 0);\n            // convert to D50 Lab whitepoint\n            var wp$1 = getLabWhitePoint();\n            setLabWhitePoint('d50');\n            var rgb$5 = roundRGB(lch2rgb(lch));\n            // convert back to original Lab whitepoint\n            setLabWhitePoint(wp$1);\n            var alpha$3 = m[4] !== undefined ? +percentToAbsolute(m[4], 0, 1) : 1;\n            rgb$5[3] = alpha$3;\n            return rgb$5;\n        }\n\n        if ((m = css.match(RE_OKLAB))) {\n            var oklab = m.slice(1, 4);\n            oklab[0] = percentToAbsolute(noneToValue(oklab[0], 0), 0, 1);\n            oklab[1] = percentToAbsolute(noneToValue(oklab[1], 0), -0.4, 0.4, true);\n            oklab[2] = percentToAbsolute(noneToValue(oklab[2], 0), -0.4, 0.4, true);\n            var rgb$6 = roundRGB(oklab2rgb(oklab));\n            var alpha$4 = m[4] !== undefined ? +percentToAbsolute(m[4], 0, 1) : 1;\n            rgb$6[3] = alpha$4;\n            return rgb$6;\n        }\n\n        if ((m = css.match(RE_OKLCH))) {\n            var oklch = m.slice(1, 4);\n            oklch[0] = percentToAbsolute(noneToValue(oklch[0], 0), 0, 1);\n            oklch[1] = percentToAbsolute(noneToValue(oklch[1], 0), 0, 0.4, false);\n            oklch[2] = +noneToValue(oklch[2].replace('deg', ''), 0);\n            var rgb$7 = roundRGB(oklch2rgb(oklch));\n            var alpha$5 = m[4] !== undefined ? +percentToAbsolute(m[4], 0, 1) : 1;\n            rgb$7[3] = alpha$5;\n            return rgb$7;\n        }\n    };\n\n    css2rgb.test = function (s) {\n        return (\n            // modern\n            RE_RGB.test(s) ||\n            RE_HSL.test(s) ||\n            RE_LAB.test(s) ||\n            RE_LCH.test(s) ||\n            RE_OKLAB.test(s) ||\n            RE_OKLCH.test(s) ||\n            // legacy\n            RE_RGB_LEGACY.test(s) ||\n            RE_RGBA_LEGACY.test(s) ||\n            RE_HSL_LEGACY.test(s) ||\n            RE_HSLA_LEGACY.test(s) ||\n            s === 'transparent'\n        );\n    };\n\n    Color.prototype.css = function (mode) {\n        return rgb2css(this._rgb, mode);\n    };\n\n    var css = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['css']) ));\n    };\n    chroma.css = css;\n\n    input.format.css = css2rgb;\n\n    input.autodetect.push({\n        p: 5,\n        test: function (h) {\n            var rest = [], len = arguments.length - 1;\n            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n            if (!rest.length && type(h) === 'string' && css2rgb.test(h)) {\n                return 'css';\n            }\n        }\n    });\n\n    input.format.gl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgb = unpack(args, 'rgba');\n        rgb[0] *= 255;\n        rgb[1] *= 255;\n        rgb[2] *= 255;\n        return rgb;\n    };\n\n    var gl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['gl']) ));\n    };\n    chroma.gl = gl;\n\n    Color.prototype.gl = function () {\n        var rgb = this._rgb;\n        return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, rgb[3]];\n    };\n\n    var floor$3 = Math.floor;\n\n    /*\n     * this is basically just HSV with some minor tweaks\n     *\n     * hue.. [0..360]\n     * chroma .. [0..1]\n     * grayness .. [0..1]\n     */\n\n    var hcg2rgb = function () {\n        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\n\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n        args = unpack(args, 'hcg');\n        var h = args[0];\n        var c = args[1];\n        var _g = args[2];\n        var r, g, b;\n        _g = _g * 255;\n        var _c = c * 255;\n        if (c === 0) {\n            r = g = b = _g;\n        } else {\n            if (h === 360) { h = 0; }\n            if (h > 360) { h -= 360; }\n            if (h < 0) { h += 360; }\n            h /= 60;\n            var i = floor$3(h);\n            var f = h - i;\n            var p = _g * (1 - c);\n            var q = p + _c * (1 - f);\n            var t = p + _c * f;\n            var v = p + _c;\n            switch (i) {\n                case 0:\n                    (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]);\n                    break;\n                case 1:\n                    (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]);\n                    break;\n                case 2:\n                    (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]);\n                    break;\n                case 3:\n                    (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]);\n                    break;\n                case 4:\n                    (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]);\n                    break;\n                case 5:\n                    (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]);\n                    break;\n            }\n        }\n        return [r, g, b, args.length > 3 ? args[3] : 1];\n    };\n\n    var rgb2hcg = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var minRgb = min$3(r, g, b);\n        var maxRgb = max$3(r, g, b);\n        var delta = maxRgb - minRgb;\n        var c = (delta * 100) / 255;\n        var _g = (minRgb / (255 - delta)) * 100;\n        var h;\n        if (delta === 0) {\n            h = Number.NaN;\n        } else {\n            if (r === maxRgb) { h = (g - b) / delta; }\n            if (g === maxRgb) { h = 2 + (b - r) / delta; }\n            if (b === maxRgb) { h = 4 + (r - g) / delta; }\n            h *= 60;\n            if (h < 0) { h += 360; }\n        }\n        return [h, c, _g];\n    };\n\n    Color.prototype.hcg = function () {\n        return rgb2hcg(this._rgb);\n    };\n\n    var hcg$1 = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['hcg']) ));\n    };\n    chroma.hcg = hcg$1;\n\n    input.format.hcg = hcg2rgb;\n\n    input.autodetect.push({\n        p: 1,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack(args, 'hcg');\n            if (type(args) === 'array' && args.length === 3) {\n                return 'hcg';\n            }\n        }\n    });\n\n    var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;\n    var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;\n\n    var hex2rgb = function (hex) {\n        if (hex.match(RE_HEX)) {\n            // remove optional leading #\n            if (hex.length === 4 || hex.length === 7) {\n                hex = hex.substr(1);\n            }\n            // expand short-notation to full six-digit\n            if (hex.length === 3) {\n                hex = hex.split('');\n                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n            }\n            var u = parseInt(hex, 16);\n            var r = u >> 16;\n            var g = (u >> 8) & 0xff;\n            var b = u & 0xff;\n            return [r, g, b, 1];\n        }\n\n        // match rgba hex format, eg #FF000077\n        if (hex.match(RE_HEXA)) {\n            if (hex.length === 5 || hex.length === 9) {\n                // remove optional leading #\n                hex = hex.substr(1);\n            }\n            // expand short-notation to full eight-digit\n            if (hex.length === 4) {\n                hex = hex.split('');\n                hex =\n                    hex[0] +\n                    hex[0] +\n                    hex[1] +\n                    hex[1] +\n                    hex[2] +\n                    hex[2] +\n                    hex[3] +\n                    hex[3];\n            }\n            var u$1 = parseInt(hex, 16);\n            var r$1 = (u$1 >> 24) & 0xff;\n            var g$1 = (u$1 >> 16) & 0xff;\n            var b$1 = (u$1 >> 8) & 0xff;\n            var a = Math.round(((u$1 & 0xff) / 0xff) * 100) / 100;\n            return [r$1, g$1, b$1, a];\n        }\n\n        // we used to check for css colors here\n        // if _input.css? and rgb = _input.css hex\n        //     return rgb\n\n        throw new Error((\"unknown hex color: \" + hex));\n    };\n\n    var round$2 = Math.round;\n\n    var rgb2hex = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack(args, 'rgba');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        var a = ref[3];\n        var mode = last(args) || 'auto';\n        if (a === undefined) { a = 1; }\n        if (mode === 'auto') {\n            mode = a < 1 ? 'rgba' : 'rgb';\n        }\n        r = round$2(r);\n        g = round$2(g);\n        b = round$2(b);\n        var u = (r << 16) | (g << 8) | b;\n        var str = '000000' + u.toString(16); //#.toUpperCase();\n        str = str.substr(str.length - 6);\n        var hxa = '0' + round$2(a * 255).toString(16);\n        hxa = hxa.substr(hxa.length - 2);\n        switch (mode.toLowerCase()) {\n            case 'rgba':\n                return (\"#\" + str + hxa);\n            case 'argb':\n                return (\"#\" + hxa + str);\n            default:\n                return (\"#\" + str);\n        }\n    };\n\n    Color.prototype.hex = function (mode) {\n        return rgb2hex(this._rgb, mode);\n    };\n\n    var hex = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['hex']) ));\n    };\n    chroma.hex = hex;\n\n    input.format.hex = hex2rgb;\n    input.autodetect.push({\n        p: 4,\n        test: function (h) {\n            var rest = [], len = arguments.length - 1;\n            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n            if (\n                !rest.length &&\n                type(h) === 'string' &&\n                [3, 4, 5, 6, 7, 8, 9].indexOf(h.length) >= 0\n            ) {\n                return 'hex';\n            }\n        }\n    });\n\n    var cos$3 = Math.cos;\n\n    /*\n     * hue [0..360]\n     * saturation [0..1]\n     * intensity [0..1]\n     */\n    var hsi2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        /*\n        borrowed from here:\n        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp\n        */\n        args = unpack(args, 'hsi');\n        var h = args[0];\n        var s = args[1];\n        var i = args[2];\n        var r, g, b;\n\n        if (isNaN(h)) { h = 0; }\n        if (isNaN(s)) { s = 0; }\n        // normalize hue\n        if (h > 360) { h -= 360; }\n        if (h < 0) { h += 360; }\n        h /= 360;\n        if (h < 1 / 3) {\n            b = (1 - s) / 3;\n            r = (1 + (s * cos$3(TWOPI * h)) / cos$3(PITHIRD - TWOPI * h)) / 3;\n            g = 1 - (b + r);\n        } else if (h < 2 / 3) {\n            h -= 1 / 3;\n            r = (1 - s) / 3;\n            g = (1 + (s * cos$3(TWOPI * h)) / cos$3(PITHIRD - TWOPI * h)) / 3;\n            b = 1 - (r + g);\n        } else {\n            h -= 2 / 3;\n            g = (1 - s) / 3;\n            b = (1 + (s * cos$3(TWOPI * h)) / cos$3(PITHIRD - TWOPI * h)) / 3;\n            r = 1 - (g + b);\n        }\n        r = limit(i * r * 3);\n        g = limit(i * g * 3);\n        b = limit(i * b * 3);\n        return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];\n    };\n\n    var min$2 = Math.min;\n    var sqrt$3 = Math.sqrt;\n    var acos = Math.acos;\n\n    var rgb2hsi = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        /*\n        borrowed from here:\n        http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp\n        */\n        var ref = unpack(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        var h;\n        var min_ = min$2(r, g, b);\n        var i = (r + g + b) / 3;\n        var s = i > 0 ? 1 - min_ / i : 0;\n        if (s === 0) {\n            h = NaN;\n        } else {\n            h = (r - g + (r - b)) / 2;\n            h /= sqrt$3((r - g) * (r - g) + (r - b) * (g - b));\n            h = acos(h);\n            if (b > g) {\n                h = TWOPI - h;\n            }\n            h /= TWOPI;\n        }\n        return [h * 360, s, i];\n    };\n\n    Color.prototype.hsi = function () {\n        return rgb2hsi(this._rgb);\n    };\n\n    var hsi$1 = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['hsi']) ));\n    };\n    chroma.hsi = hsi$1;\n\n    input.format.hsi = hsi2rgb;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack(args, 'hsi');\n            if (type(args) === 'array' && args.length === 3) {\n                return 'hsi';\n            }\n        }\n    });\n\n    Color.prototype.hsl = function () {\n        return rgb2hsl$1(this._rgb);\n    };\n\n    var hsl$1 = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['hsl']) ));\n    };\n    chroma.hsl = hsl$1;\n\n    input.format.hsl = hsl2rgb;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack(args, 'hsl');\n            if (type(args) === 'array' && args.length === 3) {\n                return 'hsl';\n            }\n        }\n    });\n\n    var floor$2 = Math.floor;\n\n    var hsv2rgb = function () {\n        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;\n\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n        args = unpack(args, 'hsv');\n        var h = args[0];\n        var s = args[1];\n        var v = args[2];\n        var r, g, b;\n        v *= 255;\n        if (s === 0) {\n            r = g = b = v;\n        } else {\n            if (h === 360) { h = 0; }\n            if (h > 360) { h -= 360; }\n            if (h < 0) { h += 360; }\n            h /= 60;\n\n            var i = floor$2(h);\n            var f = h - i;\n            var p = v * (1 - s);\n            var q = v * (1 - s * f);\n            var t = v * (1 - s * (1 - f));\n\n            switch (i) {\n                case 0:\n                    (assign = [v, t, p], r = assign[0], g = assign[1], b = assign[2]);\n                    break;\n                case 1:\n                    (assign$1 = [q, v, p], r = assign$1[0], g = assign$1[1], b = assign$1[2]);\n                    break;\n                case 2:\n                    (assign$2 = [p, v, t], r = assign$2[0], g = assign$2[1], b = assign$2[2]);\n                    break;\n                case 3:\n                    (assign$3 = [p, q, v], r = assign$3[0], g = assign$3[1], b = assign$3[2]);\n                    break;\n                case 4:\n                    (assign$4 = [t, p, v], r = assign$4[0], g = assign$4[1], b = assign$4[2]);\n                    break;\n                case 5:\n                    (assign$5 = [v, p, q], r = assign$5[0], g = assign$5[1], b = assign$5[2]);\n                    break;\n            }\n        }\n        return [r, g, b, args.length > 3 ? args[3] : 1];\n    };\n\n    var min$1 = Math.min;\n    var max$1 = Math.max;\n\n    /*\n     * supported arguments:\n     * - rgb2hsv(r,g,b)\n     * - rgb2hsv([r,g,b])\n     * - rgb2hsv({r,g,b})\n     */\n    var rgb2hsl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        args = unpack(args, 'rgb');\n        var r = args[0];\n        var g = args[1];\n        var b = args[2];\n        var min_ = min$1(r, g, b);\n        var max_ = max$1(r, g, b);\n        var delta = max_ - min_;\n        var h, s, v;\n        v = max_ / 255.0;\n        if (max_ === 0) {\n            h = Number.NaN;\n            s = 0;\n        } else {\n            s = delta / max_;\n            if (r === max_) { h = (g - b) / delta; }\n            if (g === max_) { h = 2 + (b - r) / delta; }\n            if (b === max_) { h = 4 + (r - g) / delta; }\n            h *= 60;\n            if (h < 0) { h += 360; }\n        }\n        return [h, s, v];\n    };\n\n    Color.prototype.hsv = function () {\n        return rgb2hsl(this._rgb);\n    };\n\n    var hsv$1 = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['hsv']) ));\n    };\n    chroma.hsv = hsv$1;\n\n    input.format.hsv = hsv2rgb;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack(args, 'hsv');\n            if (type(args) === 'array' && args.length === 3) {\n                return 'hsv';\n            }\n        }\n    });\n\n    Color.prototype.lab = function () {\n        return rgb2lab(this._rgb);\n    };\n\n    var lab$1 = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['lab']) ));\n    };\n    Object.assign(chroma, { lab: lab$1, getLabWhitePoint: getLabWhitePoint, setLabWhitePoint: setLabWhitePoint });\n\n    input.format.lab = lab2rgb;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack(args, 'lab');\n            if (type(args) === 'array' && args.length === 3) {\n                return 'lab';\n            }\n        }\n    });\n\n    var hcl2rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var hcl = reverse3(unpack(args, 'hcl'));\n        return lch2rgb.apply(void 0, hcl);\n    };\n\n    Color.prototype.lch = function () {\n        return rgb2lch(this._rgb);\n    };\n    Color.prototype.hcl = function () {\n        return reverse3(rgb2lch(this._rgb));\n    };\n\n    var lch$1 = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['lch']) ));\n    };\n    var hcl = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['hcl']) ));\n    };\n\n    Object.assign(chroma, { lch: lch$1, hcl: hcl });\n\n    input.format.lch = lch2rgb;\n    input.format.hcl = hcl2rgb;\n    ['lch', 'hcl'].forEach(function (m) { return input.autodetect.push({\n            p: 2,\n            test: function () {\n                var args = [], len = arguments.length;\n                while ( len-- ) args[ len ] = arguments[ len ];\n\n                args = unpack(args, m);\n                if (type(args) === 'array' && args.length === 3) {\n                    return m;\n                }\n            }\n        }); }\n    );\n\n    var num2rgb = function (num) {\n        if (type(num) == 'number' && num >= 0 && num <= 0xffffff) {\n            var r = num >> 16;\n            var g = (num >> 8) & 0xff;\n            var b = num & 0xff;\n            return [r, g, b, 1];\n        }\n        throw new Error('unknown num color: ' + num);\n    };\n\n    var rgb2num = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var ref = unpack(args, 'rgb');\n        var r = ref[0];\n        var g = ref[1];\n        var b = ref[2];\n        return (r << 16) + (g << 8) + b;\n    };\n\n    Color.prototype.num = function () {\n        return rgb2num(this._rgb);\n    };\n\n    var num$1 = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['num']) ));\n    };\n\n    Object.assign(chroma, { num: num$1 });\n\n    input.format.num = num2rgb;\n\n    input.autodetect.push({\n        p: 5,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            if (\n                args.length === 1 &&\n                type(args[0]) === 'number' &&\n                args[0] >= 0 &&\n                args[0] <= 0xffffff\n            ) {\n                return 'num';\n            }\n        }\n    });\n\n    var round$1 = Math.round;\n\n    Color.prototype.rgb = function (rnd) {\n        if ( rnd === void 0 ) rnd = true;\n\n        if (rnd === false) { return this._rgb.slice(0, 3); }\n        return this._rgb.slice(0, 3).map(round$1);\n    };\n\n    Color.prototype.rgba = function (rnd) {\n        if ( rnd === void 0 ) rnd = true;\n\n        return this._rgb.slice(0, 4).map(function (v, i) {\n            return i < 3 ? (rnd === false ? v : round$1(v)) : v;\n        });\n    };\n\n    var rgb$1 = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['rgb']) ));\n    };\n    Object.assign(chroma, { rgb: rgb$1 });\n\n    input.format.rgb = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgba = unpack(args, 'rgba');\n        if (rgba[3] === undefined) { rgba[3] = 1; }\n        return rgba;\n    };\n\n    input.autodetect.push({\n        p: 3,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack(args, 'rgba');\n            if (\n                type(args) === 'array' &&\n                (args.length === 3 ||\n                    (args.length === 4 &&\n                        type(args[3]) == 'number' &&\n                        args[3] >= 0 &&\n                        args[3] <= 1))\n            ) {\n                return 'rgb';\n            }\n        }\n    });\n\n    /*\n     * Based on implementation by Neil Bartlett\n     * https://github.com/neilbartlett/color-temperature\n     */\n\n    var log$1 = Math.log;\n\n    var temperature2rgb = function (kelvin) {\n        var temp = kelvin / 100;\n        var r, g, b;\n        if (temp < 66) {\n            r = 255;\n            g =\n                temp < 6\n                    ? 0\n                    : -155.25485562709179 -\n                      0.44596950469579133 * (g = temp - 2) +\n                      104.49216199393888 * log$1(g);\n            b =\n                temp < 20\n                    ? 0\n                    : -254.76935184120902 +\n                      0.8274096064007395 * (b = temp - 10) +\n                      115.67994401066147 * log$1(b);\n        } else {\n            r =\n                351.97690566805693 +\n                0.114206453784165 * (r = temp - 55) -\n                40.25366309332127 * log$1(r);\n            g =\n                325.4494125711974 +\n                0.07943456536662342 * (g = temp - 50) -\n                28.0852963507957 * log$1(g);\n            b = 255;\n        }\n        return [r, g, b, 1];\n    };\n\n    /*\n     * Based on implementation by Neil Bartlett\n     * https://github.com/neilbartlett/color-temperature\n     **/\n\n    var round = Math.round;\n\n    var rgb2temperature = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        var rgb = unpack(args, 'rgb');\n        var r = rgb[0],\n            b = rgb[2];\n        var minTemp = 1000;\n        var maxTemp = 40000;\n        var eps = 0.4;\n        var temp;\n        while (maxTemp - minTemp > eps) {\n            temp = (maxTemp + minTemp) * 0.5;\n            var rgb$1 = temperature2rgb(temp);\n            if (rgb$1[2] / rgb$1[0] >= b / r) {\n                maxTemp = temp;\n            } else {\n                minTemp = temp;\n            }\n        }\n        return round(temp);\n    };\n\n    Color.prototype.temp =\n        Color.prototype.kelvin =\n        Color.prototype.temperature =\n            function () {\n                return rgb2temperature(this._rgb);\n            };\n\n    var temp = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['temp']) ));\n    };\n    Object.assign(chroma, { temp: temp, kelvin: temp, temperature: temp });\n\n    input.format.temp =\n        input.format.kelvin =\n        input.format.temperature =\n            temperature2rgb;\n\n    Color.prototype.oklab = function () {\n        return rgb2oklab(this._rgb);\n    };\n\n    var oklab$1 = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['oklab']) ));\n    };\n    Object.assign(chroma, { oklab: oklab$1 });\n\n    input.format.oklab = oklab2rgb;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack(args, 'oklab');\n            if (type(args) === 'array' && args.length === 3) {\n                return 'oklab';\n            }\n        }\n    });\n\n    Color.prototype.oklch = function () {\n        return rgb2oklch(this._rgb);\n    };\n\n    var oklch$1 = function () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return new (Function.prototype.bind.apply( Color, [ null ].concat( args, ['oklch']) ));\n    };\n    Object.assign(chroma, { oklch: oklch$1 });\n\n    input.format.oklch = oklch2rgb;\n\n    input.autodetect.push({\n        p: 2,\n        test: function () {\n            var args = [], len = arguments.length;\n            while ( len-- ) args[ len ] = arguments[ len ];\n\n            args = unpack(args, 'oklch');\n            if (type(args) === 'array' && args.length === 3) {\n                return 'oklch';\n            }\n        }\n    });\n\n    /**\n    \tX11 color names\n\n    \thttp://www.w3.org/TR/css3-color/#svg-color\n    */\n\n    var w3cx11 = {\n        aliceblue: '#f0f8ff',\n        antiquewhite: '#faebd7',\n        aqua: '#00ffff',\n        aquamarine: '#7fffd4',\n        azure: '#f0ffff',\n        beige: '#f5f5dc',\n        bisque: '#ffe4c4',\n        black: '#000000',\n        blanchedalmond: '#ffebcd',\n        blue: '#0000ff',\n        blueviolet: '#8a2be2',\n        brown: '#a52a2a',\n        burlywood: '#deb887',\n        cadetblue: '#5f9ea0',\n        chartreuse: '#7fff00',\n        chocolate: '#d2691e',\n        coral: '#ff7f50',\n        cornflowerblue: '#6495ed',\n        cornsilk: '#fff8dc',\n        crimson: '#dc143c',\n        cyan: '#00ffff',\n        darkblue: '#00008b',\n        darkcyan: '#008b8b',\n        darkgoldenrod: '#b8860b',\n        darkgray: '#a9a9a9',\n        darkgreen: '#006400',\n        darkgrey: '#a9a9a9',\n        darkkhaki: '#bdb76b',\n        darkmagenta: '#8b008b',\n        darkolivegreen: '#556b2f',\n        darkorange: '#ff8c00',\n        darkorchid: '#9932cc',\n        darkred: '#8b0000',\n        darksalmon: '#e9967a',\n        darkseagreen: '#8fbc8f',\n        darkslateblue: '#483d8b',\n        darkslategray: '#2f4f4f',\n        darkslategrey: '#2f4f4f',\n        darkturquoise: '#00ced1',\n        darkviolet: '#9400d3',\n        deeppink: '#ff1493',\n        deepskyblue: '#00bfff',\n        dimgray: '#696969',\n        dimgrey: '#696969',\n        dodgerblue: '#1e90ff',\n        firebrick: '#b22222',\n        floralwhite: '#fffaf0',\n        forestgreen: '#228b22',\n        fuchsia: '#ff00ff',\n        gainsboro: '#dcdcdc',\n        ghostwhite: '#f8f8ff',\n        gold: '#ffd700',\n        goldenrod: '#daa520',\n        gray: '#808080',\n        green: '#008000',\n        greenyellow: '#adff2f',\n        grey: '#808080',\n        honeydew: '#f0fff0',\n        hotpink: '#ff69b4',\n        indianred: '#cd5c5c',\n        indigo: '#4b0082',\n        ivory: '#fffff0',\n        khaki: '#f0e68c',\n        laserlemon: '#ffff54',\n        lavender: '#e6e6fa',\n        lavenderblush: '#fff0f5',\n        lawngreen: '#7cfc00',\n        lemonchiffon: '#fffacd',\n        lightblue: '#add8e6',\n        lightcoral: '#f08080',\n        lightcyan: '#e0ffff',\n        lightgoldenrod: '#fafad2',\n        lightgoldenrodyellow: '#fafad2',\n        lightgray: '#d3d3d3',\n        lightgreen: '#90ee90',\n        lightgrey: '#d3d3d3',\n        lightpink: '#ffb6c1',\n        lightsalmon: '#ffa07a',\n        lightseagreen: '#20b2aa',\n        lightskyblue: '#87cefa',\n        lightslategray: '#778899',\n        lightslategrey: '#778899',\n        lightsteelblue: '#b0c4de',\n        lightyellow: '#ffffe0',\n        lime: '#00ff00',\n        limegreen: '#32cd32',\n        linen: '#faf0e6',\n        magenta: '#ff00ff',\n        maroon: '#800000',\n        maroon2: '#7f0000',\n        maroon3: '#b03060',\n        mediumaquamarine: '#66cdaa',\n        mediumblue: '#0000cd',\n        mediumorchid: '#ba55d3',\n        mediumpurple: '#9370db',\n        mediumseagreen: '#3cb371',\n        mediumslateblue: '#7b68ee',\n        mediumspringgreen: '#00fa9a',\n        mediumturquoise: '#48d1cc',\n        mediumvioletred: '#c71585',\n        midnightblue: '#191970',\n        mintcream: '#f5fffa',\n        mistyrose: '#ffe4e1',\n        moccasin: '#ffe4b5',\n        navajowhite: '#ffdead',\n        navy: '#000080',\n        oldlace: '#fdf5e6',\n        olive: '#808000',\n        olivedrab: '#6b8e23',\n        orange: '#ffa500',\n        orangered: '#ff4500',\n        orchid: '#da70d6',\n        palegoldenrod: '#eee8aa',\n        palegreen: '#98fb98',\n        paleturquoise: '#afeeee',\n        palevioletred: '#db7093',\n        papayawhip: '#ffefd5',\n        peachpuff: '#ffdab9',\n        peru: '#cd853f',\n        pink: '#ffc0cb',\n        plum: '#dda0dd',\n        powderblue: '#b0e0e6',\n        purple: '#800080',\n        purple2: '#7f007f',\n        purple3: '#a020f0',\n        rebeccapurple: '#663399',\n        red: '#ff0000',\n        rosybrown: '#bc8f8f',\n        royalblue: '#4169e1',\n        saddlebrown: '#8b4513',\n        salmon: '#fa8072',\n        sandybrown: '#f4a460',\n        seagreen: '#2e8b57',\n        seashell: '#fff5ee',\n        sienna: '#a0522d',\n        silver: '#c0c0c0',\n        skyblue: '#87ceeb',\n        slateblue: '#6a5acd',\n        slategray: '#708090',\n        slategrey: '#708090',\n        snow: '#fffafa',\n        springgreen: '#00ff7f',\n        steelblue: '#4682b4',\n        tan: '#d2b48c',\n        teal: '#008080',\n        thistle: '#d8bfd8',\n        tomato: '#ff6347',\n        turquoise: '#40e0d0',\n        violet: '#ee82ee',\n        wheat: '#f5deb3',\n        white: '#ffffff',\n        whitesmoke: '#f5f5f5',\n        yellow: '#ffff00',\n        yellowgreen: '#9acd32'\n    };\n\n    Color.prototype.name = function () {\n        var hex = rgb2hex(this._rgb, 'rgb');\n        for (var i = 0, list = Object.keys(w3cx11); i < list.length; i += 1) {\n            var n = list[i];\n\n            if (w3cx11[n] === hex) { return n.toLowerCase(); }\n        }\n        return hex;\n    };\n\n    input.format.named = function (name) {\n        name = name.toLowerCase();\n        if (w3cx11[name]) { return hex2rgb(w3cx11[name]); }\n        throw new Error('unknown color name: ' + name);\n    };\n\n    input.autodetect.push({\n        p: 5,\n        test: function (h) {\n            var rest = [], len = arguments.length - 1;\n            while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n            if (!rest.length && type(h) === 'string' && w3cx11[h.toLowerCase()]) {\n                return 'named';\n            }\n        }\n    });\n\n    Color.prototype.alpha = function (a, mutate) {\n        if ( mutate === void 0 ) mutate = false;\n\n        if (a !== undefined && type(a) === 'number') {\n            if (mutate) {\n                this._rgb[3] = a;\n                return this;\n            }\n            return new Color([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');\n        }\n        return this._rgb[3];\n    };\n\n    Color.prototype.clipped = function () {\n        return this._rgb._clipped || false;\n    };\n\n    Color.prototype.darken = function (amount) {\n        if ( amount === void 0 ) amount = 1;\n\n        var me = this;\n        var lab = me.lab();\n        lab[0] -= labConstants.Kn * amount;\n        return new Color(lab, 'lab').alpha(me.alpha(), true);\n    };\n\n    Color.prototype.brighten = function (amount) {\n        if ( amount === void 0 ) amount = 1;\n\n        return this.darken(-amount);\n    };\n\n    Color.prototype.darker = Color.prototype.darken;\n    Color.prototype.brighter = Color.prototype.brighten;\n\n    Color.prototype.get = function (mc) {\n        var ref = mc.split('.');\n        var mode = ref[0];\n        var channel = ref[1];\n        var src = this[mode]();\n        if (channel) {\n            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);\n            if (i > -1) { return src[i]; }\n            throw new Error((\"unknown channel \" + channel + \" in mode \" + mode));\n        } else {\n            return src;\n        }\n    };\n\n    var pow$6 = Math.pow;\n\n    var EPS = 1e-7;\n    var MAX_ITER = 20;\n\n    Color.prototype.luminance = function (lum, mode) {\n        if ( mode === void 0 ) mode = 'rgb';\n\n        if (lum !== undefined && type(lum) === 'number') {\n            if (lum === 0) {\n                // return pure black\n                return new Color([0, 0, 0, this._rgb[3]], 'rgb');\n            }\n            if (lum === 1) {\n                // return pure white\n                return new Color([255, 255, 255, this._rgb[3]], 'rgb');\n            }\n            // compute new color using...\n            var cur_lum = this.luminance();\n            var max_iter = MAX_ITER;\n\n            var test = function (low, high) {\n                var mid = low.interpolate(high, 0.5, mode);\n                var lm = mid.luminance();\n                if (Math.abs(lum - lm) < EPS || !max_iter--) {\n                    // close enough\n                    return mid;\n                }\n                return lm > lum ? test(low, mid) : test(mid, high);\n            };\n\n            var rgb = (\n                cur_lum > lum\n                    ? test(new Color([0, 0, 0]), this)\n                    : test(this, new Color([255, 255, 255]))\n            ).rgb();\n            return new Color(rgb.concat( [this._rgb[3]]));\n        }\n        return rgb2luminance.apply(void 0, this._rgb.slice(0, 3));\n    };\n\n    var rgb2luminance = function (r, g, b) {\n        // relative luminance\n        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n        r = luminance_x(r);\n        g = luminance_x(g);\n        b = luminance_x(b);\n        return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    };\n\n    var luminance_x = function (x) {\n        x /= 255;\n        return x <= 0.03928 ? x / 12.92 : pow$6((x + 0.055) / 1.055, 2.4);\n    };\n\n    var index = {};\n\n    function mix (col1, col2, f) {\n        if ( f === void 0 ) f = 0.5;\n        var rest = [], len = arguments.length - 3;\n        while ( len-- > 0 ) rest[ len ] = arguments[ len + 3 ];\n\n        var mode = rest[0] || 'lrgb';\n        if (!index[mode] && !rest.length) {\n            // fall back to the first supported mode\n            mode = Object.keys(index)[0];\n        }\n        if (!index[mode]) {\n            throw new Error((\"interpolation mode \" + mode + \" is not defined\"));\n        }\n        if (type(col1) !== 'object') { col1 = new Color(col1); }\n        if (type(col2) !== 'object') { col2 = new Color(col2); }\n        return index[mode](col1, col2, f).alpha(\n            col1.alpha() + f * (col2.alpha() - col1.alpha())\n        );\n    }\n\n    Color.prototype.mix = Color.prototype.interpolate = function (\n        col2,\n        f\n    ) {\n        if ( f === void 0 ) f = 0.5;\n        var rest = [], len = arguments.length - 2;\n        while ( len-- > 0 ) rest[ len ] = arguments[ len + 2 ];\n\n        return mix.apply(void 0, [ this, col2, f ].concat( rest ));\n    };\n\n    Color.prototype.premultiply = function (mutate) {\n        if ( mutate === void 0 ) mutate = false;\n\n        var rgb = this._rgb;\n        var a = rgb[3];\n        if (mutate) {\n            this._rgb = [rgb[0] * a, rgb[1] * a, rgb[2] * a, a];\n            return this;\n        } else {\n            return new Color([rgb[0] * a, rgb[1] * a, rgb[2] * a, a], 'rgb');\n        }\n    };\n\n    Color.prototype.saturate = function (amount) {\n        if ( amount === void 0 ) amount = 1;\n\n        var me = this;\n        var lch = me.lch();\n        lch[1] += labConstants.Kn * amount;\n        if (lch[1] < 0) { lch[1] = 0; }\n        return new Color(lch, 'lch').alpha(me.alpha(), true);\n    };\n\n    Color.prototype.desaturate = function (amount) {\n        if ( amount === void 0 ) amount = 1;\n\n        return this.saturate(-amount);\n    };\n\n    Color.prototype.set = function (mc, value, mutate) {\n        if ( mutate === void 0 ) mutate = false;\n\n        var ref = mc.split('.');\n        var mode = ref[0];\n        var channel = ref[1];\n        var src = this[mode]();\n        if (channel) {\n            var i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);\n            if (i > -1) {\n                if (type(value) == 'string') {\n                    switch (value.charAt(0)) {\n                        case '+':\n                            src[i] += +value;\n                            break;\n                        case '-':\n                            src[i] += +value;\n                            break;\n                        case '*':\n                            src[i] *= +value.substr(1);\n                            break;\n                        case '/':\n                            src[i] /= +value.substr(1);\n                            break;\n                        default:\n                            src[i] = +value;\n                    }\n                } else if (type(value) === 'number') {\n                    src[i] = value;\n                } else {\n                    throw new Error(\"unsupported value for Color.set\");\n                }\n                var out = new Color(src, mode);\n                if (mutate) {\n                    this._rgb = out._rgb;\n                    return this;\n                }\n                return out;\n            }\n            throw new Error((\"unknown channel \" + channel + \" in mode \" + mode));\n        } else {\n            return src;\n        }\n    };\n\n    Color.prototype.tint = function (f) {\n        if ( f === void 0 ) f = 0.5;\n        var rest = [], len = arguments.length - 1;\n        while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n        return mix.apply(void 0, [ this, 'white', f ].concat( rest ));\n    };\n\n    Color.prototype.shade = function (f) {\n        if ( f === void 0 ) f = 0.5;\n        var rest = [], len = arguments.length - 1;\n        while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n        return mix.apply(void 0, [ this, 'black', f ].concat( rest ));\n    };\n\n    var rgb = function (col1, col2, f) {\n        var xyz0 = col1._rgb;\n        var xyz1 = col2._rgb;\n        return new Color(\n            xyz0[0] + f * (xyz1[0] - xyz0[0]),\n            xyz0[1] + f * (xyz1[1] - xyz0[1]),\n            xyz0[2] + f * (xyz1[2] - xyz0[2]),\n            'rgb'\n        );\n    };\n\n    // register interpolator\n    index.rgb = rgb;\n\n    var sqrt$2 = Math.sqrt;\n    var pow$5 = Math.pow;\n\n    var lrgb = function (col1, col2, f) {\n        var ref = col1._rgb;\n        var x1 = ref[0];\n        var y1 = ref[1];\n        var z1 = ref[2];\n        var ref$1 = col2._rgb;\n        var x2 = ref$1[0];\n        var y2 = ref$1[1];\n        var z2 = ref$1[2];\n        return new Color(\n            sqrt$2(pow$5(x1, 2) * (1 - f) + pow$5(x2, 2) * f),\n            sqrt$2(pow$5(y1, 2) * (1 - f) + pow$5(y2, 2) * f),\n            sqrt$2(pow$5(z1, 2) * (1 - f) + pow$5(z2, 2) * f),\n            'rgb'\n        );\n    };\n\n    // register interpolator\n    index.lrgb = lrgb;\n\n    var lab = function (col1, col2, f) {\n        var xyz0 = col1.lab();\n        var xyz1 = col2.lab();\n        return new Color(\n            xyz0[0] + f * (xyz1[0] - xyz0[0]),\n            xyz0[1] + f * (xyz1[1] - xyz0[1]),\n            xyz0[2] + f * (xyz1[2] - xyz0[2]),\n            'lab'\n        );\n    };\n\n    // register interpolator\n    index.lab = lab;\n\n    function interpolate_hsx (col1, col2, f, m) {\n        var assign, assign$1;\n\n        var xyz0, xyz1;\n        if (m === 'hsl') {\n            xyz0 = col1.hsl();\n            xyz1 = col2.hsl();\n        } else if (m === 'hsv') {\n            xyz0 = col1.hsv();\n            xyz1 = col2.hsv();\n        } else if (m === 'hcg') {\n            xyz0 = col1.hcg();\n            xyz1 = col2.hcg();\n        } else if (m === 'hsi') {\n            xyz0 = col1.hsi();\n            xyz1 = col2.hsi();\n        } else if (m === 'lch' || m === 'hcl') {\n            m = 'hcl';\n            xyz0 = col1.hcl();\n            xyz1 = col2.hcl();\n        } else if (m === 'oklch') {\n            xyz0 = col1.oklch().reverse();\n            xyz1 = col2.oklch().reverse();\n        }\n\n        var hue0, hue1, sat0, sat1, lbv0, lbv1;\n        if (m.substr(0, 1) === 'h' || m === 'oklch') {\n            (assign = xyz0, hue0 = assign[0], sat0 = assign[1], lbv0 = assign[2]);\n            (assign$1 = xyz1, hue1 = assign$1[0], sat1 = assign$1[1], lbv1 = assign$1[2]);\n        }\n\n        var sat, hue, lbv, dh;\n\n        if (!isNaN(hue0) && !isNaN(hue1)) {\n            // both colors have hue\n            if (hue1 > hue0 && hue1 - hue0 > 180) {\n                dh = hue1 - (hue0 + 360);\n            } else if (hue1 < hue0 && hue0 - hue1 > 180) {\n                dh = hue1 + 360 - hue0;\n            } else {\n                dh = hue1 - hue0;\n            }\n            hue = hue0 + f * dh;\n        } else if (!isNaN(hue0)) {\n            hue = hue0;\n            if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') { sat = sat0; }\n        } else if (!isNaN(hue1)) {\n            hue = hue1;\n            if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') { sat = sat1; }\n        } else {\n            hue = Number.NaN;\n        }\n\n        if (sat === undefined) { sat = sat0 + f * (sat1 - sat0); }\n        lbv = lbv0 + f * (lbv1 - lbv0);\n        return m === 'oklch'\n            ? new Color([lbv, sat, hue], m)\n            : new Color([hue, sat, lbv], m);\n    }\n\n    var lch = function (col1, col2, f) {\n        return interpolate_hsx(col1, col2, f, 'lch');\n    };\n\n    // register interpolator\n    index.lch = lch;\n    index.hcl = lch;\n\n    var num = function (col1, col2, f) {\n        var c1 = col1.num();\n        var c2 = col2.num();\n        return new Color(c1 + f * (c2 - c1), 'num');\n    };\n\n    // register interpolator\n    index.num = num;\n\n    var hcg = function (col1, col2, f) {\n        return interpolate_hsx(col1, col2, f, 'hcg');\n    };\n\n    // register interpolator\n    index.hcg = hcg;\n\n    var hsi = function (col1, col2, f) {\n        return interpolate_hsx(col1, col2, f, 'hsi');\n    };\n\n    // register interpolator\n    index.hsi = hsi;\n\n    var hsl = function (col1, col2, f) {\n        return interpolate_hsx(col1, col2, f, 'hsl');\n    };\n\n    // register interpolator\n    index.hsl = hsl;\n\n    var hsv = function (col1, col2, f) {\n        return interpolate_hsx(col1, col2, f, 'hsv');\n    };\n\n    // register interpolator\n    index.hsv = hsv;\n\n    var oklab = function (col1, col2, f) {\n        var xyz0 = col1.oklab();\n        var xyz1 = col2.oklab();\n        return new Color(\n            xyz0[0] + f * (xyz1[0] - xyz0[0]),\n            xyz0[1] + f * (xyz1[1] - xyz0[1]),\n            xyz0[2] + f * (xyz1[2] - xyz0[2]),\n            'oklab'\n        );\n    };\n\n    // register interpolator\n    index.oklab = oklab;\n\n    var oklch = function (col1, col2, f) {\n        return interpolate_hsx(col1, col2, f, 'oklch');\n    };\n\n    // register interpolator\n    index.oklch = oklch;\n\n    var pow$4 = Math.pow;\n    var sqrt$1 = Math.sqrt;\n    var PI$1 = Math.PI;\n    var cos$2 = Math.cos;\n    var sin$2 = Math.sin;\n    var atan2$1 = Math.atan2;\n\n    function average (colors, mode, weights) {\n        if ( mode === void 0 ) mode = 'lrgb';\n        if ( weights === void 0 ) weights = null;\n\n        var l = colors.length;\n        if (!weights) { weights = Array.from(new Array(l)).map(function () { return 1; }); }\n        // normalize weights\n        var k =\n            l /\n            weights.reduce(function (a, b) {\n                return a + b;\n            });\n        weights.forEach(function (w, i) {\n            weights[i] *= k;\n        });\n        // convert colors to Color objects\n        colors = colors.map(function (c) { return new Color(c); });\n        if (mode === 'lrgb') {\n            return _average_lrgb(colors, weights);\n        }\n        var first = colors.shift();\n        var xyz = first.get(mode);\n        var cnt = [];\n        var dx = 0;\n        var dy = 0;\n        // initial color\n        for (var i = 0; i < xyz.length; i++) {\n            xyz[i] = (xyz[i] || 0) * weights[0];\n            cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);\n            if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {\n                var A = (xyz[i] / 180) * PI$1;\n                dx += cos$2(A) * weights[0];\n                dy += sin$2(A) * weights[0];\n            }\n        }\n\n        var alpha = first.alpha() * weights[0];\n        colors.forEach(function (c, ci) {\n            var xyz2 = c.get(mode);\n            alpha += c.alpha() * weights[ci + 1];\n            for (var i = 0; i < xyz.length; i++) {\n                if (!isNaN(xyz2[i])) {\n                    cnt[i] += weights[ci + 1];\n                    if (mode.charAt(i) === 'h') {\n                        var A = (xyz2[i] / 180) * PI$1;\n                        dx += cos$2(A) * weights[ci + 1];\n                        dy += sin$2(A) * weights[ci + 1];\n                    } else {\n                        xyz[i] += xyz2[i] * weights[ci + 1];\n                    }\n                }\n            }\n        });\n\n        for (var i$1 = 0; i$1 < xyz.length; i$1++) {\n            if (mode.charAt(i$1) === 'h') {\n                var A$1 = (atan2$1(dy / cnt[i$1], dx / cnt[i$1]) / PI$1) * 180;\n                while (A$1 < 0) { A$1 += 360; }\n                while (A$1 >= 360) { A$1 -= 360; }\n                xyz[i$1] = A$1;\n            } else {\n                xyz[i$1] = xyz[i$1] / cnt[i$1];\n            }\n        }\n        alpha /= l;\n        return new Color(xyz, mode).alpha(alpha > 0.99999 ? 1 : alpha, true);\n    }\n    var _average_lrgb = function (colors, weights) {\n        var l = colors.length;\n        var xyz = [0, 0, 0, 0];\n        for (var i = 0; i < colors.length; i++) {\n            var col = colors[i];\n            var f = weights[i] / l;\n            var rgb = col._rgb;\n            xyz[0] += pow$4(rgb[0], 2) * f;\n            xyz[1] += pow$4(rgb[1], 2) * f;\n            xyz[2] += pow$4(rgb[2], 2) * f;\n            xyz[3] += rgb[3] * f;\n        }\n        xyz[0] = sqrt$1(xyz[0]);\n        xyz[1] = sqrt$1(xyz[1]);\n        xyz[2] = sqrt$1(xyz[2]);\n        if (xyz[3] > 0.9999999) { xyz[3] = 1; }\n        return new Color(clip_rgb(xyz));\n    };\n\n    // minimal multi-purpose interface\n\n\n    var pow$3 = Math.pow;\n\n    function scale (colors) {\n        // constructor\n        var _mode = 'rgb';\n        var _nacol = chroma('#ccc');\n        var _spread = 0;\n        // const _fixed = false;\n        var _domain = [0, 1];\n        var _pos = [];\n        var _padding = [0, 0];\n        var _classes = false;\n        var _colors = [];\n        var _out = false;\n        var _min = 0;\n        var _max = 1;\n        var _correctLightness = false;\n        var _colorCache = {};\n        var _useCache = true;\n        var _gamma = 1;\n\n        // private methods\n\n        var setColors = function (colors) {\n            colors = colors || ['#fff', '#000'];\n            if (\n                colors &&\n                type(colors) === 'string' &&\n                chroma.brewer &&\n                chroma.brewer[colors.toLowerCase()]\n            ) {\n                colors = chroma.brewer[colors.toLowerCase()];\n            }\n            if (type(colors) === 'array') {\n                // handle single color\n                if (colors.length === 1) {\n                    colors = [colors[0], colors[0]];\n                }\n                // make a copy of the colors\n                colors = colors.slice(0);\n                // convert to chroma classes\n                for (var c = 0; c < colors.length; c++) {\n                    colors[c] = chroma(colors[c]);\n                }\n                // auto-fill color position\n                _pos.length = 0;\n                for (var c$1 = 0; c$1 < colors.length; c$1++) {\n                    _pos.push(c$1 / (colors.length - 1));\n                }\n            }\n            resetCache();\n            return (_colors = colors);\n        };\n\n        var getClass = function (value) {\n            if (_classes != null) {\n                var n = _classes.length - 1;\n                var i = 0;\n                while (i < n && value >= _classes[i]) {\n                    i++;\n                }\n                return i - 1;\n            }\n            return 0;\n        };\n\n        var tMapLightness = function (t) { return t; };\n        var tMapDomain = function (t) { return t; };\n\n        // const classifyValue = function(value) {\n        //     let val = value;\n        //     if (_classes.length > 2) {\n        //         const n = _classes.length-1;\n        //         const i = getClass(value);\n        //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class\n        //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class\n        //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));\n        //     }\n        //     return val;\n        // };\n\n        var getColor = function (val, bypassMap) {\n            var col, t;\n            if (bypassMap == null) {\n                bypassMap = false;\n            }\n            if (isNaN(val) || val === null) {\n                return _nacol;\n            }\n            if (!bypassMap) {\n                if (_classes && _classes.length > 2) {\n                    // find the class\n                    var c = getClass(val);\n                    t = c / (_classes.length - 2);\n                } else if (_max !== _min) {\n                    // just interpolate between min/max\n                    t = (val - _min) / (_max - _min);\n                } else {\n                    t = 1;\n                }\n            } else {\n                t = val;\n            }\n\n            // domain map\n            t = tMapDomain(t);\n\n            if (!bypassMap) {\n                t = tMapLightness(t); // lightness correction\n            }\n\n            if (_gamma !== 1) {\n                t = pow$3(t, _gamma);\n            }\n\n            t = _padding[0] + t * (1 - _padding[0] - _padding[1]);\n\n            t = limit(t, 0, 1);\n\n            var k = Math.floor(t * 10000);\n\n            if (_useCache && _colorCache[k]) {\n                col = _colorCache[k];\n            } else {\n                if (type(_colors) === 'array') {\n                    //for i in [0.._pos.length-1]\n                    for (var i = 0; i < _pos.length; i++) {\n                        var p = _pos[i];\n                        if (t <= p) {\n                            col = _colors[i];\n                            break;\n                        }\n                        if (t >= p && i === _pos.length - 1) {\n                            col = _colors[i];\n                            break;\n                        }\n                        if (t > p && t < _pos[i + 1]) {\n                            t = (t - p) / (_pos[i + 1] - p);\n                            col = chroma.interpolate(\n                                _colors[i],\n                                _colors[i + 1],\n                                t,\n                                _mode\n                            );\n                            break;\n                        }\n                    }\n                } else if (type(_colors) === 'function') {\n                    col = _colors(t);\n                }\n                if (_useCache) {\n                    _colorCache[k] = col;\n                }\n            }\n            return col;\n        };\n\n        var resetCache = function () { return (_colorCache = {}); };\n\n        setColors(colors);\n\n        // public interface\n\n        var f = function (v) {\n            var c = chroma(getColor(v));\n            if (_out && c[_out]) {\n                return c[_out]();\n            } else {\n                return c;\n            }\n        };\n\n        f.classes = function (classes) {\n            if (classes != null) {\n                if (type(classes) === 'array') {\n                    _classes = classes;\n                    _domain = [classes[0], classes[classes.length - 1]];\n                } else {\n                    var d = chroma.analyze(_domain);\n                    if (classes === 0) {\n                        _classes = [d.min, d.max];\n                    } else {\n                        _classes = chroma.limits(d, 'e', classes);\n                    }\n                }\n                return f;\n            }\n            return _classes;\n        };\n\n        f.domain = function (domain) {\n            if (!arguments.length) {\n                return _domain;\n            }\n            _min = domain[0];\n            _max = domain[domain.length - 1];\n            _pos = [];\n            var k = _colors.length;\n            if (domain.length === k && _min !== _max) {\n                // update positions\n                for (var i = 0, list = Array.from(domain); i < list.length; i += 1) {\n                    var d = list[i];\n\n                    _pos.push((d - _min) / (_max - _min));\n                }\n            } else {\n                for (var c = 0; c < k; c++) {\n                    _pos.push(c / (k - 1));\n                }\n                if (domain.length > 2) {\n                    // set domain map\n                    var tOut = domain.map(function (d, i) { return i / (domain.length - 1); });\n                    var tBreaks = domain.map(function (d) { return (d - _min) / (_max - _min); });\n                    if (!tBreaks.every(function (val, i) { return tOut[i] === val; })) {\n                        tMapDomain = function (t) {\n                            if (t <= 0 || t >= 1) { return t; }\n                            var i = 0;\n                            while (t >= tBreaks[i + 1]) { i++; }\n                            var f =\n                                (t - tBreaks[i]) / (tBreaks[i + 1] - tBreaks[i]);\n                            var out = tOut[i] + f * (tOut[i + 1] - tOut[i]);\n                            return out;\n                        };\n                    }\n                }\n            }\n            _domain = [_min, _max];\n            return f;\n        };\n\n        f.mode = function (_m) {\n            if (!arguments.length) {\n                return _mode;\n            }\n            _mode = _m;\n            resetCache();\n            return f;\n        };\n\n        f.range = function (colors, _pos) {\n            setColors(colors);\n            return f;\n        };\n\n        f.out = function (_o) {\n            _out = _o;\n            return f;\n        };\n\n        f.spread = function (val) {\n            if (!arguments.length) {\n                return _spread;\n            }\n            _spread = val;\n            return f;\n        };\n\n        f.correctLightness = function (v) {\n            if (v == null) {\n                v = true;\n            }\n            _correctLightness = v;\n            resetCache();\n            if (_correctLightness) {\n                tMapLightness = function (t) {\n                    var L0 = getColor(0, true).lab()[0];\n                    var L1 = getColor(1, true).lab()[0];\n                    var pol = L0 > L1;\n                    var L_actual = getColor(t, true).lab()[0];\n                    var L_ideal = L0 + (L1 - L0) * t;\n                    var L_diff = L_actual - L_ideal;\n                    var t0 = 0;\n                    var t1 = 1;\n                    var max_iter = 20;\n                    while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {\n                        (function () {\n                            if (pol) {\n                                L_diff *= -1;\n                            }\n                            if (L_diff < 0) {\n                                t0 = t;\n                                t += (t1 - t) * 0.5;\n                            } else {\n                                t1 = t;\n                                t += (t0 - t) * 0.5;\n                            }\n                            L_actual = getColor(t, true).lab()[0];\n                            return (L_diff = L_actual - L_ideal);\n                        })();\n                    }\n                    return t;\n                };\n            } else {\n                tMapLightness = function (t) { return t; };\n            }\n            return f;\n        };\n\n        f.padding = function (p) {\n            if (p != null) {\n                if (type(p) === 'number') {\n                    p = [p, p];\n                }\n                _padding = p;\n                return f;\n            } else {\n                return _padding;\n            }\n        };\n\n        f.colors = function (numColors, out) {\n            // If no arguments are given, return the original colors that were provided\n            if (arguments.length < 2) {\n                out = 'hex';\n            }\n            var result = [];\n\n            if (arguments.length === 0) {\n                result = _colors.slice(0);\n            } else if (numColors === 1) {\n                result = [f(0.5)];\n            } else if (numColors > 1) {\n                var dm = _domain[0];\n                var dd = _domain[1] - dm;\n                result = __range__(0, numColors).map(function (i) { return f(dm + (i / (numColors - 1)) * dd); }\n                );\n            } else {\n                // returns all colors based on the defined classes\n                colors = [];\n                var samples = [];\n                if (_classes && _classes.length > 2) {\n                    for (\n                        var i = 1, end = _classes.length, asc = 1 <= end;\n                        asc ? i < end : i > end;\n                        asc ? i++ : i--\n                    ) {\n                        samples.push((_classes[i - 1] + _classes[i]) * 0.5);\n                    }\n                } else {\n                    samples = _domain;\n                }\n                result = samples.map(function (v) { return f(v); });\n            }\n\n            if (chroma[out]) {\n                result = result.map(function (c) { return c[out](); });\n            }\n            return result;\n        };\n\n        f.cache = function (c) {\n            if (c != null) {\n                _useCache = c;\n                return f;\n            } else {\n                return _useCache;\n            }\n        };\n\n        f.gamma = function (g) {\n            if (g != null) {\n                _gamma = g;\n                return f;\n            } else {\n                return _gamma;\n            }\n        };\n\n        f.nodata = function (d) {\n            if (d != null) {\n                _nacol = chroma(d);\n                return f;\n            } else {\n                return _nacol;\n            }\n        };\n\n        return f;\n    }\n\n    function __range__(left, right, inclusive) {\n        var range = [];\n        var ascending = left < right;\n        var end = right ;\n        for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n            range.push(i);\n        }\n        return range;\n    }\n\n    //\n    // interpolates between a set of colors uzing a bezier spline\n    //\n\n\n    // nth row of the pascal triangle\n    var binom_row = function (n) {\n        var row = [1, 1];\n        for (var i = 1; i < n; i++) {\n            var newrow = [1];\n            for (var j = 1; j <= row.length; j++) {\n                newrow[j] = (row[j] || 0) + row[j - 1];\n            }\n            row = newrow;\n        }\n        return row;\n    };\n\n    var bezier = function (colors) {\n        var assign, assign$1, assign$2;\n\n        var I, lab0, lab1, lab2;\n        colors = colors.map(function (c) { return new Color(c); });\n        if (colors.length === 2) {\n            // linear interpolation\n            (assign = colors.map(function (c) { return c.lab(); }), lab0 = assign[0], lab1 = assign[1]);\n            I = function (t) {\n                var lab = [0, 1, 2].map(function (i) { return lab0[i] + t * (lab1[i] - lab0[i]); });\n                return new Color(lab, 'lab');\n            };\n        } else if (colors.length === 3) {\n            // quadratic bezier interpolation\n            (assign$1 = colors.map(function (c) { return c.lab(); }), lab0 = assign$1[0], lab1 = assign$1[1], lab2 = assign$1[2]);\n            I = function (t) {\n                var lab = [0, 1, 2].map(\n                    function (i) { return (1 - t) * (1 - t) * lab0[i] +\n                        2 * (1 - t) * t * lab1[i] +\n                        t * t * lab2[i]; }\n                );\n                return new Color(lab, 'lab');\n            };\n        } else if (colors.length === 4) {\n            // cubic bezier interpolation\n            var lab3;\n            (assign$2 = colors.map(function (c) { return c.lab(); }), lab0 = assign$2[0], lab1 = assign$2[1], lab2 = assign$2[2], lab3 = assign$2[3]);\n            I = function (t) {\n                var lab = [0, 1, 2].map(\n                    function (i) { return (1 - t) * (1 - t) * (1 - t) * lab0[i] +\n                        3 * (1 - t) * (1 - t) * t * lab1[i] +\n                        3 * (1 - t) * t * t * lab2[i] +\n                        t * t * t * lab3[i]; }\n                );\n                return new Color(lab, 'lab');\n            };\n        } else if (colors.length >= 5) {\n            // general case (degree n bezier)\n            var labs, row, n;\n            labs = colors.map(function (c) { return c.lab(); });\n            n = colors.length - 1;\n            row = binom_row(n);\n            I = function (t) {\n                var u = 1 - t;\n                var lab = [0, 1, 2].map(function (i) { return labs.reduce(\n                        function (sum, el, j) { return sum + row[j] * Math.pow( u, (n - j) ) * Math.pow( t, j ) * el[i]; },\n                        0\n                    ); }\n                );\n                return new Color(lab, 'lab');\n            };\n        } else {\n            throw new RangeError('No point in running bezier with only one color.');\n        }\n        return I;\n    };\n\n    function bezier$1 (colors) {\n        var f = bezier(colors);\n        f.scale = function () { return scale(f); };\n        return f;\n    }\n\n    /*\n     * interpolates between a set of colors uzing a bezier spline\n     * blend mode formulas taken from https://web.archive.org/web/20180110014946/http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/\n     */\n\n\n    var blend = function (bottom, top, mode) {\n        if (!blend[mode]) {\n            throw new Error('unknown blend mode ' + mode);\n        }\n        return blend[mode](bottom, top);\n    };\n\n    var blend_f = function (f) { return function (bottom, top) {\n        var c0 = chroma(top).rgb();\n        var c1 = chroma(bottom).rgb();\n        return chroma.rgb(f(c0, c1));\n    }; };\n\n    var each = function (f) { return function (c0, c1) {\n        var out = [];\n        out[0] = f(c0[0], c1[0]);\n        out[1] = f(c0[1], c1[1]);\n        out[2] = f(c0[2], c1[2]);\n        return out;\n    }; };\n\n    var normal = function (a) { return a; };\n    var multiply = function (a, b) { return (a * b) / 255; };\n    var darken = function (a, b) { return (a > b ? b : a); };\n    var lighten = function (a, b) { return (a > b ? a : b); };\n    var screen = function (a, b) { return 255 * (1 - (1 - a / 255) * (1 - b / 255)); };\n    var overlay = function (a, b) { return b < 128 ? (2 * a * b) / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255)); };\n    var burn = function (a, b) { return 255 * (1 - (1 - b / 255) / (a / 255)); };\n    var dodge = function (a, b) {\n        if (a === 255) { return 255; }\n        a = (255 * (b / 255)) / (1 - a / 255);\n        return a > 255 ? 255 : a;\n    };\n\n    // # add = (a,b) ->\n    // #     if (a + b > 255) then 255 else a + b\n\n    blend.normal = blend_f(each(normal));\n    blend.multiply = blend_f(each(multiply));\n    blend.screen = blend_f(each(screen));\n    blend.overlay = blend_f(each(overlay));\n    blend.darken = blend_f(each(darken));\n    blend.lighten = blend_f(each(lighten));\n    blend.dodge = blend_f(each(dodge));\n    blend.burn = blend_f(each(burn));\n\n    // cubehelix interpolation\n    // based on D.A. Green \"A colour scheme for the display of astronomical intensity images\"\n    // http://astron-soc.in/bulletin/11June/289392011.pdf\n    var pow$2 = Math.pow;\n    var sin$1 = Math.sin;\n    var cos$1 = Math.cos;\n\n    function cubehelix (\n        start,\n        rotations,\n        hue,\n        gamma,\n        lightness\n    ) {\n        if ( start === void 0 ) start = 300;\n        if ( rotations === void 0 ) rotations = -1.5;\n        if ( hue === void 0 ) hue = 1;\n        if ( gamma === void 0 ) gamma = 1;\n        if ( lightness === void 0 ) lightness = [0, 1];\n\n        var dh = 0,\n            dl;\n        if (type(lightness) === 'array') {\n            dl = lightness[1] - lightness[0];\n        } else {\n            dl = 0;\n            lightness = [lightness, lightness];\n        }\n        var f = function (fract) {\n            var a = TWOPI * ((start + 120) / 360 + rotations * fract);\n            var l = pow$2(lightness[0] + dl * fract, gamma);\n            var h = dh !== 0 ? hue[0] + fract * dh : hue;\n            var amp = (h * l * (1 - l)) / 2;\n            var cos_a = cos$1(a);\n            var sin_a = sin$1(a);\n            var r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);\n            var g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);\n            var b = l + amp * (+1.97294 * cos_a);\n            return chroma(clip_rgb([r * 255, g * 255, b * 255, 1]));\n        };\n        f.start = function (s) {\n            if (s == null) {\n                return start;\n            }\n            start = s;\n            return f;\n        };\n        f.rotations = function (r) {\n            if (r == null) {\n                return rotations;\n            }\n            rotations = r;\n            return f;\n        };\n        f.gamma = function (g) {\n            if (g == null) {\n                return gamma;\n            }\n            gamma = g;\n            return f;\n        };\n        f.hue = function (h) {\n            if (h == null) {\n                return hue;\n            }\n            hue = h;\n            if (type(hue) === 'array') {\n                dh = hue[1] - hue[0];\n                if (dh === 0) {\n                    hue = hue[1];\n                }\n            } else {\n                dh = 0;\n            }\n            return f;\n        };\n        f.lightness = function (h) {\n            if (h == null) {\n                return lightness;\n            }\n            if (type(h) === 'array') {\n                lightness = h;\n                dl = h[1] - h[0];\n            } else {\n                lightness = [h, h];\n                dl = 0;\n            }\n            return f;\n        };\n        f.scale = function () { return chroma.scale(f); };\n        f.hue(hue);\n        return f;\n    }\n\n    var digits = '0123456789abcdef';\n\n    var floor$1 = Math.floor;\n    var random = Math.random;\n\n    function random$1 () {\n        var code = '#';\n        for (var i = 0; i < 6; i++) {\n            code += digits.charAt(floor$1(random() * 16));\n        }\n        return new Color(code, 'hex');\n    }\n\n    var log = Math.log;\n    var pow$1 = Math.pow;\n    var floor = Math.floor;\n    var abs$1 = Math.abs;\n\n    function analyze(data, key) {\n        if ( key === void 0 ) key = null;\n\n        var r = {\n            min: Number.MAX_VALUE,\n            max: Number.MAX_VALUE * -1,\n            sum: 0,\n            values: [],\n            count: 0\n        };\n        if (type(data) === 'object') {\n            data = Object.values(data);\n        }\n        data.forEach(function (val) {\n            if (key && type(val) === 'object') { val = val[key]; }\n            if (val !== undefined && val !== null && !isNaN(val)) {\n                r.values.push(val);\n                r.sum += val;\n                if (val < r.min) { r.min = val; }\n                if (val > r.max) { r.max = val; }\n                r.count += 1;\n            }\n        });\n\n        r.domain = [r.min, r.max];\n\n        r.limits = function (mode, num) { return limits(r, mode, num); };\n\n        return r;\n    }\n\n    function limits(data, mode, num) {\n        if ( mode === void 0 ) mode = 'equal';\n        if ( num === void 0 ) num = 7;\n\n        if (type(data) == 'array') {\n            data = analyze(data);\n        }\n        var min = data.min;\n        var max = data.max;\n        var values = data.values.sort(function (a, b) { return a - b; });\n\n        if (num === 1) {\n            return [min, max];\n        }\n\n        var limits = [];\n\n        if (mode.substr(0, 1) === 'c') {\n            // continuous\n            limits.push(min);\n            limits.push(max);\n        }\n\n        if (mode.substr(0, 1) === 'e') {\n            // equal interval\n            limits.push(min);\n            for (var i = 1; i < num; i++) {\n                limits.push(min + (i / num) * (max - min));\n            }\n            limits.push(max);\n        } else if (mode.substr(0, 1) === 'l') {\n            // log scale\n            if (min <= 0) {\n                throw new Error(\n                    'Logarithmic scales are only possible for values > 0'\n                );\n            }\n            var min_log = Math.LOG10E * log(min);\n            var max_log = Math.LOG10E * log(max);\n            limits.push(min);\n            for (var i$1 = 1; i$1 < num; i$1++) {\n                limits.push(pow$1(10, min_log + (i$1 / num) * (max_log - min_log)));\n            }\n            limits.push(max);\n        } else if (mode.substr(0, 1) === 'q') {\n            // quantile scale\n            limits.push(min);\n            for (var i$2 = 1; i$2 < num; i$2++) {\n                var p = ((values.length - 1) * i$2) / num;\n                var pb = floor(p);\n                if (pb === p) {\n                    limits.push(values[pb]);\n                } else {\n                    // p > pb\n                    var pr = p - pb;\n                    limits.push(values[pb] * (1 - pr) + values[pb + 1] * pr);\n                }\n            }\n            limits.push(max);\n        } else if (mode.substr(0, 1) === 'k') {\n            // k-means clustering\n            /*\n            implementation based on\n            http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n            simplified for 1-d input values\n            */\n            var cluster;\n            var n = values.length;\n            var assignments = new Array(n);\n            var clusterSizes = new Array(num);\n            var repeat = true;\n            var nb_iters = 0;\n            var centroids = null;\n\n            // get seed values\n            centroids = [];\n            centroids.push(min);\n            for (var i$3 = 1; i$3 < num; i$3++) {\n                centroids.push(min + (i$3 / num) * (max - min));\n            }\n            centroids.push(max);\n\n            while (repeat) {\n                // assignment step\n                for (var j = 0; j < num; j++) {\n                    clusterSizes[j] = 0;\n                }\n                for (var i$4 = 0; i$4 < n; i$4++) {\n                    var value = values[i$4];\n                    var mindist = Number.MAX_VALUE;\n                    var best = (void 0);\n                    for (var j$1 = 0; j$1 < num; j$1++) {\n                        var dist = abs$1(centroids[j$1] - value);\n                        if (dist < mindist) {\n                            mindist = dist;\n                            best = j$1;\n                        }\n                        clusterSizes[best]++;\n                        assignments[i$4] = best;\n                    }\n                }\n\n                // update centroids step\n                var newCentroids = new Array(num);\n                for (var j$2 = 0; j$2 < num; j$2++) {\n                    newCentroids[j$2] = null;\n                }\n                for (var i$5 = 0; i$5 < n; i$5++) {\n                    cluster = assignments[i$5];\n                    if (newCentroids[cluster] === null) {\n                        newCentroids[cluster] = values[i$5];\n                    } else {\n                        newCentroids[cluster] += values[i$5];\n                    }\n                }\n                for (var j$3 = 0; j$3 < num; j$3++) {\n                    newCentroids[j$3] *= 1 / clusterSizes[j$3];\n                }\n\n                // check convergence\n                repeat = false;\n                for (var j$4 = 0; j$4 < num; j$4++) {\n                    if (newCentroids[j$4] !== centroids[j$4]) {\n                        repeat = true;\n                        break;\n                    }\n                }\n\n                centroids = newCentroids;\n                nb_iters++;\n\n                if (nb_iters > 200) {\n                    repeat = false;\n                }\n            }\n\n            // finished k-means clustering\n            // the next part is borrowed from gabrielflor.it\n            var kClusters = {};\n            for (var j$5 = 0; j$5 < num; j$5++) {\n                kClusters[j$5] = [];\n            }\n            for (var i$6 = 0; i$6 < n; i$6++) {\n                cluster = assignments[i$6];\n                kClusters[cluster].push(values[i$6]);\n            }\n            var tmpKMeansBreaks = [];\n            for (var j$6 = 0; j$6 < num; j$6++) {\n                tmpKMeansBreaks.push(kClusters[j$6][0]);\n                tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length - 1]);\n            }\n            tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a, b) { return a - b; });\n            limits.push(tmpKMeansBreaks[0]);\n            for (var i$7 = 1; i$7 < tmpKMeansBreaks.length; i$7 += 2) {\n                var v = tmpKMeansBreaks[i$7];\n                if (!isNaN(v) && limits.indexOf(v) === -1) {\n                    limits.push(v);\n                }\n            }\n        }\n        return limits;\n    }\n\n    function contrast (a, b) {\n        // WCAG contrast ratio\n        // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n        a = new Color(a);\n        b = new Color(b);\n        var l1 = a.luminance();\n        var l2 = b.luminance();\n        return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);\n    }\n\n    /**\n     * @license\n     *\n     * The APCA contrast prediction algorithm is based of the formulas published\n     * in the APCA-1.0.98G specification by Myndex. The specification is available at:\n     * https://raw.githubusercontent.com/Myndex/apca-w3/master/images/APCAw3_0.1.17_APCA0.0.98G.svg\n     *\n     * Note that the APCA implementation is still beta, so please update to\n     * future versions of chroma.js when they become available.\n     *\n     * You can read more about the APCA Readability Criterion at\n     * https://readtech.org/ARC/\n     */\n\n    // constants\n    var W_offset = 0.027;\n    var P_in = 0.0005;\n    var P_out = 0.1;\n    var R_scale = 1.14;\n    var B_threshold = 0.022;\n    var B_exp = 1.414;\n\n    function contrastAPCA (text, bg) {\n        // parse input colors\n        text = new Color(text);\n        bg = new Color(bg);\n        // if text color has alpha, blend against background\n        if (text.alpha() < 1) {\n            text = mix(bg, text, text.alpha(), 'rgb');\n        }\n        var l_text = lum.apply(void 0, text.rgb());\n        var l_bg = lum.apply(void 0, bg.rgb());\n\n        // soft clamp black levels\n        var Y_text =\n            l_text >= B_threshold\n                ? l_text\n                : l_text + Math.pow(B_threshold - l_text, B_exp);\n        var Y_bg =\n            l_bg >= B_threshold ? l_bg : l_bg + Math.pow(B_threshold - l_bg, B_exp);\n\n        // normal polarity (dark text on light background)\n        var S_norm = Math.pow(Y_bg, 0.56) - Math.pow(Y_text, 0.57);\n        // reverse polarity (light text on dark background)\n        var S_rev = Math.pow(Y_bg, 0.65) - Math.pow(Y_text, 0.62);\n        // clamp noise then scale\n        var C =\n            Math.abs(Y_bg - Y_text) < P_in\n                ? 0\n                : Y_text < Y_bg\n                  ? S_norm * R_scale\n                  : S_rev * R_scale;\n        // clamp minimum contrast then offset\n        var S_apc = Math.abs(C) < P_out ? 0 : C > 0 ? C - W_offset : C + W_offset;\n        // scale to 100\n        return S_apc * 100;\n    }\n    function lum(r, g, b) {\n        return (\n            0.2126729 * Math.pow(r / 255, 2.4) +\n            0.7151522 * Math.pow(g / 255, 2.4) +\n            0.072175 * Math.pow(b / 255, 2.4)\n        );\n    }\n\n    var sqrt = Math.sqrt;\n    var pow = Math.pow;\n    var min = Math.min;\n    var max = Math.max;\n    var atan2 = Math.atan2;\n    var abs = Math.abs;\n    var cos = Math.cos;\n    var sin = Math.sin;\n    var exp = Math.exp;\n    var PI = Math.PI;\n\n    function deltaE (a, b, Kl, Kc, Kh) {\n        if ( Kl === void 0 ) Kl = 1;\n        if ( Kc === void 0 ) Kc = 1;\n        if ( Kh === void 0 ) Kh = 1;\n\n        // Delta E (CIE 2000)\n        // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE2000.html\n        var rad2deg = function (rad) {\n            return (360 * rad) / (2 * PI);\n        };\n        var deg2rad = function (deg) {\n            return (2 * PI * deg) / 360;\n        };\n        a = new Color(a);\n        b = new Color(b);\n        var ref = Array.from(a.lab());\n        var L1 = ref[0];\n        var a1 = ref[1];\n        var b1 = ref[2];\n        var ref$1 = Array.from(b.lab());\n        var L2 = ref$1[0];\n        var a2 = ref$1[1];\n        var b2 = ref$1[2];\n        var avgL = (L1 + L2) / 2;\n        var C1 = sqrt(pow(a1, 2) + pow(b1, 2));\n        var C2 = sqrt(pow(a2, 2) + pow(b2, 2));\n        var avgC = (C1 + C2) / 2;\n        var G = 0.5 * (1 - sqrt(pow(avgC, 7) / (pow(avgC, 7) + pow(25, 7))));\n        var a1p = a1 * (1 + G);\n        var a2p = a2 * (1 + G);\n        var C1p = sqrt(pow(a1p, 2) + pow(b1, 2));\n        var C2p = sqrt(pow(a2p, 2) + pow(b2, 2));\n        var avgCp = (C1p + C2p) / 2;\n        var arctan1 = rad2deg(atan2(b1, a1p));\n        var arctan2 = rad2deg(atan2(b2, a2p));\n        var h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;\n        var h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;\n        var avgHp =\n            abs(h1p - h2p) > 180 ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;\n        var T =\n            1 -\n            0.17 * cos(deg2rad(avgHp - 30)) +\n            0.24 * cos(deg2rad(2 * avgHp)) +\n            0.32 * cos(deg2rad(3 * avgHp + 6)) -\n            0.2 * cos(deg2rad(4 * avgHp - 63));\n        var deltaHp = h2p - h1p;\n        deltaHp =\n            abs(deltaHp) <= 180\n                ? deltaHp\n                : h2p <= h1p\n                  ? deltaHp + 360\n                  : deltaHp - 360;\n        deltaHp = 2 * sqrt(C1p * C2p) * sin(deg2rad(deltaHp) / 2);\n        var deltaL = L2 - L1;\n        var deltaCp = C2p - C1p;\n        var sl = 1 + (0.015 * pow(avgL - 50, 2)) / sqrt(20 + pow(avgL - 50, 2));\n        var sc = 1 + 0.045 * avgCp;\n        var sh = 1 + 0.015 * avgCp * T;\n        var deltaTheta = 30 * exp(-pow((avgHp - 275) / 25, 2));\n        var Rc = 2 * sqrt(pow(avgCp, 7) / (pow(avgCp, 7) + pow(25, 7)));\n        var Rt = -Rc * sin(2 * deg2rad(deltaTheta));\n        var result = sqrt(\n            pow(deltaL / (Kl * sl), 2) +\n                pow(deltaCp / (Kc * sc), 2) +\n                pow(deltaHp / (Kh * sh), 2) +\n                Rt * (deltaCp / (Kc * sc)) * (deltaHp / (Kh * sh))\n        );\n        return max(0, min(100, result));\n    }\n\n    // simple Euclidean distance\n    function distance (a, b, mode) {\n        if ( mode === void 0 ) mode = 'lab';\n\n        // Delta E (CIE 1976)\n        // see http://www.brucelindbloom.com/index.html?Equations.html\n        a = new Color(a);\n        b = new Color(b);\n        var l1 = a.get(mode);\n        var l2 = b.get(mode);\n        var sum_sq = 0;\n        for (var i in l1) {\n            var d = (l1[i] || 0) - (l2[i] || 0);\n            sum_sq += d * d;\n        }\n        return Math.sqrt(sum_sq);\n    }\n\n    function valid () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        try {\n            new (Function.prototype.bind.apply( Color, [ null ].concat( args) ));\n            return true;\n            // eslint-disable-next-line\n        } catch (e) {\n            return false;\n        }\n    }\n\n    // some pre-defined color scales:\n\n    var scales = {\n        cool: function cool() {\n            return scale([chroma.hsl(180, 1, 0.9), chroma.hsl(250, 0.7, 0.4)]);\n        },\n        hot: function hot() {\n            return scale(['#000', '#f00', '#ff0', '#fff']).mode(\n                'rgb'\n            );\n        }\n    };\n\n    /**\n        ColorBrewer colors for chroma.js\n\n        Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The\n        Pennsylvania State University.\n\n        Licensed under the Apache License, Version 2.0 (the \"License\");\n        you may not use this file except in compliance with the License.\n        You may obtain a copy of the License at\n        http://www.apache.org/licenses/LICENSE-2.0\n\n        Unless required by applicable law or agreed to in writing, software distributed\n        under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n        CONDITIONS OF ANY KIND, either express or implied. See the License for the\n        specific language governing permissions and limitations under the License.\n    */\n\n    var colorbrewer = {\n        // sequential\n        OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],\n        PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],\n        BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],\n        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],\n        BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],\n        YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],\n        YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],\n        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],\n        RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],\n        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],\n        YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],\n        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],\n        GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],\n        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],\n        YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],\n        PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],\n        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],\n        PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],\n        Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],\n\n        // diverging\n        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],\n        RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],\n        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],\n        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],\n        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],\n        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],\n        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],\n        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],\n        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],\n\n        // qualitative\n        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],\n        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],\n        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],\n        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],\n        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],\n        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],\n        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],\n        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2']\n    };\n\n    var colorbrewerTypes = Object.keys(colorbrewer);\n    var typeMap = new Map(colorbrewerTypes.map(function (key) { return [key.toLowerCase(), key]; }));\n\n    // use Proxy to allow case-insensitive access to palettes\n    var colorbrewerProxy =\n        typeof Proxy === 'function'\n            ? new Proxy(colorbrewer, {\n                  get: function get(target, prop) {\n                      var lower = prop.toLowerCase();\n                      if (typeMap.has(lower)) {\n                          return target[typeMap.get(lower)];\n                      }\n                  },\n                  getOwnPropertyNames: function getOwnPropertyNames() {\n                      return Object.getOwnPropertyNames(colorbrewerTypes);\n                  }\n              })\n            : colorbrewer;\n\n    // feel free to comment out anything to rollup\n    // a smaller chroma.js bundle\n\n    Object.assign(chroma, {\n        analyze: analyze,\n        average: average,\n        bezier: bezier$1,\n        blend: blend,\n        brewer: colorbrewerProxy,\n        Color: Color,\n        colors: w3cx11,\n        contrast: contrast,\n        contrastAPCA: contrastAPCA,\n        cubehelix: cubehelix,\n        deltaE: deltaE,\n        distance: distance,\n        input: input,\n        interpolate: mix,\n        limits: limits,\n        mix: mix,\n        random: random$1,\n        scale: scale,\n        scales: scales,\n        valid: valid,\n        cmyk: cmyk,\n        css: css,\n        gl: gl,\n        hcg: hcg$1,\n        hex: hex,\n        hsi: hsi$1,\n        hsl: hsl$1,\n        hsv: hsv$1,\n        lab: lab$1,\n        lch: lch$1,\n        hcl: hcl,\n        num: num$1,\n        rgb: rgb$1,\n        temp: temp,\n        kelvin: temp,\n        temperature: temp,\n        oklab: oklab$1,\n        oklch: oklch$1,\n        getLabWhitePoint: getLabWhitePoint,\n        setLabWhitePoint: setLabWhitePoint\n    });\n\n    return chroma;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaHJvbWEtanMvZGlzdC9jaHJvbWEuY2pzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUE0RDtBQUNoRSxJQUFJLENBQ3FHO0FBQ3pHLENBQUMsdUJBQXVCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxpQkFBaUI7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0NBQWtDO0FBQ3pFLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUIsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkUsbUJBQW1CO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQsaUJBQWlCO0FBQ3RFOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQixnQ0FBZ0M7QUFDaEMsZ0NBQWdDOztBQUVoQztBQUNBLHFCQUFxQjtBQUNyQix3REFBd0Q7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYTtBQUNsRDs7QUFFQTtBQUNBLGdEQUFnRCw0QkFBNEIsY0FBYyxJQUFJLEdBQUc7QUFDakcsNkNBQTZDO0FBQzdDO0FBQ0Esd0RBQXdELHFCQUFxQjtBQUM3RTs7QUFFQSx1REFBdUQsK0JBQStCO0FBQ3RGLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBLDhDQUE4QyxjQUFjLEdBQUc7QUFDL0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQkFBc0I7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLHFDQUFxQztBQUNyQywwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUNBQXlDLGtEQUFrRDtBQUMzRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxrQ0FBa0MsRUFBRSxhQUFhLEVBQUU7QUFDbkQsbUNBQW1DLEVBQUUsYUFBYSxFQUFFOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQSx1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLG9GQUFvRjs7QUFFaEg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QixzQkFBc0I7O0FBRWxEO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCLFlBQVk7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixZQUFZOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qiw2Q0FBNkM7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMERBQTBEO0FBQzFELFVBQVU7QUFDVjtBQUNBLDBEQUEwRDtBQUMxRCxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IscURBQXFELFdBQVc7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLHFDQUFxQztBQUNyQztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQyx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEcsd0dBQXdHO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1Qyx3QkFBd0I7O0FBRS9EOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxpQkFBaUI7QUFDNUU7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQ0FBaUM7QUFDN0YsNERBQTRELG9DQUFvQztBQUNoRywyREFBMkQseUJBQXlCO0FBQ3BGO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFOztBQUVBO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrQkFBK0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsc0JBQXNCO0FBQ2pFO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0EsdURBQXVELDJDQUEyQztBQUNsRztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esa0RBQWtELGlCQUFpQjtBQUNuRTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGtEQUFrRCxpQkFBaUI7QUFDbkU7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsZ0RBQWdELDBFQUEwRTtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQyxxQ0FBcUM7QUFDckMsbUNBQW1DO0FBQ25DLG9DQUFvQztBQUNwQyxtQ0FBbUM7QUFDbkMsb0NBQW9DO0FBQ3BDLGlDQUFpQztBQUNqQztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZUFBZTs7QUFFdkU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7QUFDN0M7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGVBQWU7QUFDcEY7QUFDQSw4QkFBOEIsOEJBQThCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0Usa0NBQWtDOztBQUVsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2RhdmlkZWJpc2N1c28vRG9jdW1lbnRzL0dpdEh1Yi9jb2xvci1yYW1wL25vZGVfbW9kdWxlcy9jaHJvbWEtanMvZGlzdC9jaHJvbWEuY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogY2hyb21hLmpzIC0gSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBjb2xvciBjb252ZXJzaW9uc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDI0LCBHcmVnb3IgQWlzY2hcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIFRoZSBuYW1lIEdyZWdvciBBaXNjaCBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4gKiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBHUkVHT1IgQUlTQ0ggT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCxcbiAqIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLFxuICogQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUllcbiAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXG4gKiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBjaHJvbWEuanMgaW5jbHVkZXMgY29sb3JzIGZyb20gY29sb3JicmV3ZXIyLm9yZywgd2hpY2ggYXJlIHJlbGVhc2VkIHVuZGVyXG4gKiB0aGUgZm9sbG93aW5nIGxpY2Vuc2U6XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDAyIEN5bnRoaWEgQnJld2VyLCBNYXJrIEhhcnJvd2VyLFxuICogYW5kIFRoZSBQZW5uc3lsdmFuaWEgU3RhdGUgVW5pdmVyc2l0eS5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCxcbiAqIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljXG4gKiBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIE5hbWVkIGNvbG9ycyBhcmUgdGFrZW4gZnJvbSBYMTEgQ29sb3IgTmFtZXMuXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3JcbiAqXG4gKiBAcHJlc2VydmVcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5jaHJvbWEgPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG1pbiQ0ID0gTWF0aC5taW47XG4gICAgdmFyIG1heCQ0ID0gTWF0aC5tYXg7XG5cbiAgICBmdW5jdGlvbiBsaW1pdCAoeCwgbG93LCBoaWdoKSB7XG4gICAgICAgIGlmICggbG93ID09PSB2b2lkIDAgKSBsb3cgPSAwO1xuICAgICAgICBpZiAoIGhpZ2ggPT09IHZvaWQgMCApIGhpZ2ggPSAxO1xuXG4gICAgICAgIHJldHVybiBtaW4kNChtYXgkNChsb3csIHgpLCBoaWdoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGlwX3JnYiAocmdiKSB7XG4gICAgICAgIHJnYi5fY2xpcHBlZCA9IGZhbHNlO1xuICAgICAgICByZ2IuX3VuY2xpcHBlZCA9IHJnYi5zbGljZSgwKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gMzsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmdiW2ldIDwgMCB8fCByZ2JbaV0gPiAyNTUpIHsgcmdiLl9jbGlwcGVkID0gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIHJnYltpXSA9IGxpbWl0KHJnYltpXSwgMCwgMjU1KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJnYltpXSA9IGxpbWl0KHJnYltpXSwgMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJnYjtcbiAgICB9XG5cbiAgICAvLyBwb3J0ZWQgZnJvbSBqUXVlcnkncyAkLnR5cGVcbiAgICB2YXIgY2xhc3NUb1R5cGUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IFtcbiAgICAgICAgJ0Jvb2xlYW4nLFxuICAgICAgICAnTnVtYmVyJyxcbiAgICAgICAgJ1N0cmluZycsXG4gICAgICAgICdGdW5jdGlvbicsXG4gICAgICAgICdBcnJheScsXG4gICAgICAgICdEYXRlJyxcbiAgICAgICAgJ1JlZ0V4cCcsXG4gICAgICAgICdVbmRlZmluZWQnLFxuICAgICAgICAnTnVsbCdcbiAgICBdOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICAgICAgY2xhc3NUb1R5cGVbKFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIildID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0eXBlIChvYmopIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzVG9UeXBlW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopXSB8fCAnb2JqZWN0JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnBhY2sgKGFyZ3MsIGtleU9yZGVyKSB7XG4gICAgICAgIGlmICgga2V5T3JkZXIgPT09IHZvaWQgMCApIGtleU9yZGVyID0gbnVsbDtcblxuICAgICAgICAvLyBpZiBjYWxsZWQgd2l0aCBtb3JlIHRoYW4gMyBhcmd1bWVudHMsIHdlIHJldHVybiB0aGUgYXJndW1lbnRzXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+PSAzKSB7IHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTsgfVxuICAgICAgICAvLyB3aXRoIGxlc3MgdGhhbiAzIGFyZ3Mgd2UgY2hlY2sgaWYgZmlyc3QgYXJnIGlzIG9iamVjdFxuICAgICAgICAvLyBhbmQgdXNlIHRoZSBrZXlPcmRlciBzdHJpbmcgdG8gZXh0cmFjdCBhbmQgc29ydCBwcm9wZXJ0aWVzXG4gICAgICAgIGlmICh0eXBlKGFyZ3NbMF0pID09ICdvYmplY3QnICYmIGtleU9yZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5T3JkZXJcbiAgICAgICAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gYXJnc1swXVtrXSAhPT0gdW5kZWZpbmVkOyB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGFyZ3NbMF1ba107IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSB3ZSBqdXN0IHJldHVybiB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgICAgLy8gKHdoaWNoIHdlIHN1cHBvc2UgaXMgYW4gYXJyYXkgb2YgYXJncylcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF0uc2xpY2UoMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFzdCAoYXJncykge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHZhciBsID0gYXJncy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAodHlwZShhcmdzW2xdKSA9PSAnc3RyaW5nJykgeyByZXR1cm4gYXJnc1tsXS50b0xvd2VyQ2FzZSgpOyB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBQSSQyID0gTWF0aC5QSTtcbiAgICB2YXIgbWluJDMgPSBNYXRoLm1pbjtcbiAgICB2YXIgbWF4JDMgPSBNYXRoLm1heDtcblxuICAgIHZhciBybmQyID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIE1hdGgucm91bmQoYSAqIDEwMCkgLyAxMDA7IH07XG4gICAgdmFyIHJuZDMgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gTWF0aC5yb3VuZChhICogMTAwKSAvIDEwMDsgfTtcblxuICAgIHZhciBUV09QSSA9IFBJJDIgKiAyO1xuICAgIHZhciBQSVRISVJEID0gUEkkMiAvIDM7XG4gICAgdmFyIERFRzJSQUQgPSBQSSQyIC8gMTgwO1xuICAgIHZhciBSQUQyREVHID0gMTgwIC8gUEkkMjtcblxuICAgIC8qKlxuICAgICAqIFJldmVyc2UgdGhlIGZpcnN0IHRocmVlIGVsZW1lbnRzIG9mIGFuIGFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueVtdfSBhcnJcbiAgICAgKiBAcmV0dXJucyB7YW55W119XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV2ZXJzZTMoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnIuc2xpY2UoMCwgMykucmV2ZXJzZSgpLmNvbmNhdCggYXJyLnNsaWNlKDMpKTtcbiAgICB9XG5cbiAgICB2YXIgaW5wdXQgPSB7XG4gICAgICAgIGZvcm1hdDoge30sXG4gICAgICAgIGF1dG9kZXRlY3Q6IFtdXG4gICAgfTtcblxuICAgIHZhciBDb2xvciA9IGZ1bmN0aW9uIENvbG9yKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGUoYXJnc1swXSkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBhcmdzWzBdLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICBhcmdzWzBdLmNvbnN0cnVjdG9yID09PSB0aGlzLmNvbnN0cnVjdG9yXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gdGhlIGFyZ3VtZW50IGlzIGFscmVhZHkgYSBDb2xvciBpbnN0YW5jZVxuICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGFzdCBhcmd1bWVudCBjb3VsZCBiZSB0aGUgbW9kZVxuICAgICAgICB2YXIgbW9kZSA9IGxhc3QoYXJncyk7XG4gICAgICAgIHZhciBhdXRvZGV0ZWN0ID0gZmFsc2U7XG4gICAgICAgIGlmICghbW9kZSkge1xuICAgICAgICAgICAgYXV0b2RldGVjdCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghaW5wdXQuc29ydGVkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuYXV0b2RldGVjdCA9IGlucHV0LmF1dG9kZXRlY3Quc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYi5wIC0gYS5wOyB9KTtcbiAgICAgICAgICAgICAgICBpbnB1dC5zb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhdXRvLWRldGVjdCBmb3JtYXRcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gaW5wdXQuYXV0b2RldGVjdDsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hrID0gbGlzdFtpXTtcblxuICAgICAgICAgICAgICAgIG1vZGUgPSBjaGsudGVzdC5hcHBseShjaGssIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LmZvcm1hdFttb2RlXSkge1xuICAgICAgICAgICAgdmFyIHJnYiA9IGlucHV0LmZvcm1hdFttb2RlXS5hcHBseShcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGF1dG9kZXRlY3QgPyBhcmdzIDogYXJncy5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtZS5fcmdiID0gY2xpcF9yZ2IocmdiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBmb3JtYXQ6ICcgKyBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgYWxwaGEgY2hhbm5lbFxuICAgICAgICBpZiAobWUuX3JnYi5sZW5ndGggPT09IDMpIHsgbWUuX3JnYi5wdXNoKDEpOyB9XG4gICAgfTtcbiAgICBDb2xvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIGlmICh0eXBlKHRoaXMuaGV4KSA9PSAnZnVuY3Rpb24nKSB7IHJldHVybiB0aGlzLmhleCgpOyB9XG4gICAgICAgIHJldHVybiAoXCJbXCIgKyAodGhpcy5fcmdiLmpvaW4oJywnKSkgKyBcIl1cIik7XG4gICAgfTtcblxuICAgIC8vIHRoaXMgZ2V0cyB1cGRhdGVkIGF1dG9tYXRpY2FsbHlcbiAgICB2YXIgdmVyc2lvbiA9ICczLjEuMic7XG5cbiAgICB2YXIgY2hyb21hID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciwgWyBudWxsIF0uY29uY2F0KCBhcmdzKSApKTtcbiAgICB9O1xuXG4gICAgY2hyb21hLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4gICAgdmFyIGNteWsycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2NteWsnKTtcbiAgICAgICAgdmFyIGMgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgbSA9IGFyZ3NbMV07XG4gICAgICAgIHZhciB5ID0gYXJnc1syXTtcbiAgICAgICAgdmFyIGsgPSBhcmdzWzNdO1xuICAgICAgICB2YXIgYWxwaGEgPSBhcmdzLmxlbmd0aCA+IDQgPyBhcmdzWzRdIDogMTtcbiAgICAgICAgaWYgKGsgPT09IDEpIHsgcmV0dXJuIFswLCAwLCAwLCBhbHBoYV07IH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGMgPj0gMSA/IDAgOiAyNTUgKiAoMSAtIGMpICogKDEgLSBrKSwgLy8gclxuICAgICAgICAgICAgbSA+PSAxID8gMCA6IDI1NSAqICgxIC0gbSkgKiAoMSAtIGspLCAvLyBnXG4gICAgICAgICAgICB5ID49IDEgPyAwIDogMjU1ICogKDEgLSB5KSAqICgxIC0gayksIC8vIGJcbiAgICAgICAgICAgIGFscGhhXG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIHZhciBtYXgkMiA9IE1hdGgubWF4O1xuXG4gICAgdmFyIHJnYjJjbXlrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2soYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICByID0gciAvIDI1NTtcbiAgICAgICAgZyA9IGcgLyAyNTU7XG4gICAgICAgIGIgPSBiIC8gMjU1O1xuICAgICAgICB2YXIgayA9IDEgLSBtYXgkMihyLCBtYXgkMihnLCBiKSk7XG4gICAgICAgIHZhciBmID0gayA8IDEgPyAxIC8gKDEgLSBrKSA6IDA7XG4gICAgICAgIHZhciBjID0gKDEgLSByIC0gaykgKiBmO1xuICAgICAgICB2YXIgbSA9ICgxIC0gZyAtIGspICogZjtcbiAgICAgICAgdmFyIHkgPSAoMSAtIGIgLSBrKSAqIGY7XG4gICAgICAgIHJldHVybiBbYywgbSwgeSwga107XG4gICAgfTtcblxuICAgIENvbG9yLnByb3RvdHlwZS5jbXlrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmdiMmNteWsodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgdmFyIGNteWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnY215ayddKSApKTtcbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24oY2hyb21hLCB7IGNteWs6IGNteWsgfSk7XG5cbiAgICBpbnB1dC5mb3JtYXQuY215ayA9IGNteWsycmdiO1xuXG4gICAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2NteWsnKTtcbiAgICAgICAgICAgIGlmICh0eXBlKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjbXlrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLypcbiAgICAgKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICAgICAqIC0gaHNsMmNzcyhoLHMsbClcbiAgICAgKiAtIGhzbDJjc3MoaCxzLGwsYSlcbiAgICAgKiAtIGhzbDJjc3MoW2gscyxsXSwgbW9kZSlcbiAgICAgKiAtIGhzbDJjc3MoW2gscyxsLGFdLCBtb2RlKVxuICAgICAqIC0gaHNsMmNzcyh7aCxzLGwsYX0sIG1vZGUpXG4gICAgICovXG4gICAgdmFyIGhzbDJjc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIGhzbGEgPSB1bnBhY2soYXJncywgJ2hzbGEnKTtcbiAgICAgICAgdmFyIG1vZGUgPSBsYXN0KGFyZ3MpIHx8ICdsc2EnO1xuICAgICAgICBoc2xhWzBdID0gcm5kMihoc2xhWzBdIHx8IDApICsgJ2RlZyc7XG4gICAgICAgIGhzbGFbMV0gPSBybmQyKGhzbGFbMV0gKiAxMDApICsgJyUnO1xuICAgICAgICBoc2xhWzJdID0gcm5kMihoc2xhWzJdICogMTAwKSArICclJztcbiAgICAgICAgaWYgKG1vZGUgPT09ICdoc2xhJyB8fCAoaHNsYS5sZW5ndGggPiAzICYmIGhzbGFbM10gPCAxKSkge1xuICAgICAgICAgICAgaHNsYVszXSA9ICcvICcgKyAoaHNsYS5sZW5ndGggPiAzID8gaHNsYVszXSA6IDEpO1xuICAgICAgICAgICAgbW9kZSA9ICdoc2xhJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhzbGEubGVuZ3RoID0gMztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKChtb2RlLnN1YnN0cigwLCAzKSkgKyBcIihcIiArIChoc2xhLmpvaW4oJyAnKSkgKyBcIilcIik7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAgICAgKiAtIHJnYjJoc2wocixnLGIpXG4gICAgICogLSByZ2IyaHNsKHIsZyxiLGEpXG4gICAgICogLSByZ2IyaHNsKFtyLGcsYl0pXG4gICAgICogLSByZ2IyaHNsKFtyLGcsYixhXSlcbiAgICAgKiAtIHJnYjJoc2woe3IsZyxiLGF9KVxuICAgICAqL1xuICAgIHZhciByZ2IyaHNsJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgYXJncyA9IHVucGFjayhhcmdzLCAncmdiYScpO1xuICAgICAgICB2YXIgciA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBnID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGIgPSBhcmdzWzJdO1xuXG4gICAgICAgIHIgLz0gMjU1O1xuICAgICAgICBnIC89IDI1NTtcbiAgICAgICAgYiAvPSAyNTU7XG5cbiAgICAgICAgdmFyIG1pblJnYiA9IG1pbiQzKHIsIGcsIGIpO1xuICAgICAgICB2YXIgbWF4UmdiID0gbWF4JDMociwgZywgYik7XG5cbiAgICAgICAgdmFyIGwgPSAobWF4UmdiICsgbWluUmdiKSAvIDI7XG4gICAgICAgIHZhciBzLCBoO1xuXG4gICAgICAgIGlmIChtYXhSZ2IgPT09IG1pblJnYikge1xuICAgICAgICAgICAgcyA9IDA7XG4gICAgICAgICAgICBoID0gTnVtYmVyLk5hTjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPVxuICAgICAgICAgICAgICAgIGwgPCAwLjVcbiAgICAgICAgICAgICAgICAgICAgPyAobWF4UmdiIC0gbWluUmdiKSAvIChtYXhSZ2IgKyBtaW5SZ2IpXG4gICAgICAgICAgICAgICAgICAgIDogKG1heFJnYiAtIG1pblJnYikgLyAoMiAtIG1heFJnYiAtIG1pblJnYik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAociA9PSBtYXhSZ2IpIHsgaCA9IChnIC0gYikgLyAobWF4UmdiIC0gbWluUmdiKTsgfVxuICAgICAgICBlbHNlIGlmIChnID09IG1heFJnYikgeyBoID0gMiArIChiIC0gcikgLyAobWF4UmdiIC0gbWluUmdiKTsgfVxuICAgICAgICBlbHNlIGlmIChiID09IG1heFJnYikgeyBoID0gNCArIChyIC0gZykgLyAobWF4UmdiIC0gbWluUmdiKTsgfVxuXG4gICAgICAgIGggKj0gNjA7XG4gICAgICAgIGlmIChoIDwgMCkgeyBoICs9IDM2MDsgfVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAzICYmIGFyZ3NbM10gIT09IHVuZGVmaW5lZCkgeyByZXR1cm4gW2gsIHMsIGwsIGFyZ3NbM11dOyB9XG4gICAgICAgIHJldHVybiBbaCwgcywgbF07XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAgICAgKiAtIGxhYjJjc3MobCxhLGIpXG4gICAgICogLSBsYWIyY3NzKGwsYSxiLGFscGhhKVxuICAgICAqIC0gbGFiMmNzcyhbbCxhLGJdLCBtb2RlKVxuICAgICAqIC0gbGFiMmNzcyhbbCxhLGIsYWxwaGFdLCBtb2RlKVxuICAgICAqL1xuICAgIHZhciBsYWIyY3NzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciBsYWJhID0gdW5wYWNrKGFyZ3MsICdsYWInKTtcbiAgICAgICAgdmFyIG1vZGUgPSBsYXN0KGFyZ3MpIHx8ICdsYWInO1xuICAgICAgICBsYWJhWzBdID0gcm5kMihsYWJhWzBdKSArICclJztcbiAgICAgICAgbGFiYVsxXSA9IHJuZDIobGFiYVsxXSk7XG4gICAgICAgIGxhYmFbMl0gPSBybmQyKGxhYmFbMl0pO1xuICAgICAgICBpZiAobW9kZSA9PT0gJ2xhYmEnIHx8IChsYWJhLmxlbmd0aCA+IDMgJiYgbGFiYVszXSA8IDEpKSB7XG4gICAgICAgICAgICBsYWJhWzNdID0gJy8gJyArIChsYWJhLmxlbmd0aCA+IDMgPyBsYWJhWzNdIDogMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYWJhLmxlbmd0aCA9IDM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcImxhYihcIiArIChsYWJhLmpvaW4oJyAnKSkgKyBcIilcIik7XG4gICAgfTtcblxuICAgIHZhciBsYWJDb25zdGFudHMgPSB7XG4gICAgICAgIC8vIENvcnJlc3BvbmRzIHJvdWdobHkgdG8gUkdCIGJyaWdodGVyL2RhcmtlclxuICAgICAgICBLbjogMTgsXG5cbiAgICAgICAgLy8gRDY1IHN0YW5kYXJkIHJlZmVyZW50XG4gICAgICAgIGxhYldoaXRlUG9pbnQ6ICdkNjUnLFxuICAgICAgICBYbjogMC45NTA0NyxcbiAgICAgICAgWW46IDEsXG4gICAgICAgIFpuOiAxLjA4ODgzLFxuXG4gICAgICAgIHQwOiAwLjEzNzkzMTAzNCwgLy8gNCAvIDI5XG4gICAgICAgIHQxOiAwLjIwNjg5NjU1MiwgLy8gNiAvIDI5XG4gICAgICAgIHQyOiAwLjEyODQxODU1LCAvLyAzICogdDEgKiB0MVxuICAgICAgICB0MzogMC4wMDg4NTY0NTIsIC8vIHQxICogdDEgKiB0MSxcblxuICAgICAgICBrRTogMjE2LjAgLyAyNDM4OS4wLFxuICAgICAgICBrS0U6IDguMCxcbiAgICAgICAga0s6IDI0Mzg5LjAgLyAyNy4wLFxuXG4gICAgICAgIFJlZldoaXRlUkdCOiB7XG4gICAgICAgICAgICAvLyBzUkdCXG4gICAgICAgICAgICBYOiAwLjk1MDQ3LFxuICAgICAgICAgICAgWTogMSxcbiAgICAgICAgICAgIFo6IDEuMDg4ODNcbiAgICAgICAgfSxcblxuICAgICAgICBNdHhSR0IyWFlaOiB7XG4gICAgICAgICAgICBtMDA6IDAuNDEyNDU2NDM5MDg5NjkyMixcbiAgICAgICAgICAgIG0wMTogMC4yMTI2NzI4NTE0MDU2MjI1MyxcbiAgICAgICAgICAgIG0wMjogMC4wMTkzMzM4OTU1ODIzMjkzLFxuICAgICAgICAgICAgbTEwOiAwLjM1NzU3NjA3NzY0MzkwOSxcbiAgICAgICAgICAgIG0xMTogMC43MTUxNTIxNTUyODc4MTgsXG4gICAgICAgICAgICBtMTI6IDAuMTE5MTkyMDI1ODgxMzAyOTcsXG4gICAgICAgICAgICBtMjA6IDAuMTgwNDM3NDgzMjY2Mzk4OTQsXG4gICAgICAgICAgICBtMjE6IDAuMDcyMTc0OTkzMzA2NTU5NTgsXG4gICAgICAgICAgICBtMjI6IDAuOTUwMzA0MDc4NTM2MzY3OVxuICAgICAgICB9LFxuXG4gICAgICAgIE10eFhZWjJSR0I6IHtcbiAgICAgICAgICAgIG0wMDogMy4yNDA0NTQxNjIxMTQxMDQ1LFxuICAgICAgICAgICAgbTAxOiAtMC45NjkyNjYwMzA1MDUxODY4LFxuICAgICAgICAgICAgbTAyOiAwLjA1NTY0MzQzMDk1OTExNDcyNixcbiAgICAgICAgICAgIG0xMDogLTEuNTM3MTM4NTEyNzk3NzE2NixcbiAgICAgICAgICAgIG0xMTogMS44NzYwMTA4NDU0NDY2OTQyLFxuICAgICAgICAgICAgbTEyOiAtMC4yMDQwMjU5MTM1MTY3NTM4LFxuICAgICAgICAgICAgbTIwOiAtMC40OTg1MzE0MDk1NTYwMTYsXG4gICAgICAgICAgICBtMjE6IDAuMDQxNTU2MDE3NTMwMzQ5ODM0LFxuICAgICAgICAgICAgbTIyOiAxLjA1NzIyNTE4ODIyMzE3OTFcbiAgICAgICAgfSxcblxuICAgICAgICAvLyB1c2VkIGluIHJnYjJ4eXpcbiAgICAgICAgQXM6IDAuOTQxNDI4NTM1MDAwMDAwMSxcbiAgICAgICAgQnM6IDEuMDQwNDE3NDY3LFxuICAgICAgICBDczogMS4wODk1MzI2NTEsXG5cbiAgICAgICAgTXR4QWRhcHRNYToge1xuICAgICAgICAgICAgbTAwOiAwLjg5NTEsXG4gICAgICAgICAgICBtMDE6IC0wLjc1MDIsXG4gICAgICAgICAgICBtMDI6IDAuMDM4OSxcbiAgICAgICAgICAgIG0xMDogMC4yNjY0LFxuICAgICAgICAgICAgbTExOiAxLjcxMzUsXG4gICAgICAgICAgICBtMTI6IC0wLjA2ODUsXG4gICAgICAgICAgICBtMjA6IC0wLjE2MTQsXG4gICAgICAgICAgICBtMjE6IDAuMDM2NyxcbiAgICAgICAgICAgIG0yMjogMS4wMjk2XG4gICAgICAgIH0sXG5cbiAgICAgICAgTXR4QWRhcHRNYUk6IHtcbiAgICAgICAgICAgIG0wMDogMC45ODY5OTI5MDU0NjY3MTIzLFxuICAgICAgICAgICAgbTAxOiAwLjQzMjMwNTI2OTcyMzM5NDU2LFxuICAgICAgICAgICAgbTAyOiAtMC4wMDg1Mjg2NjQ1NzUxNzczMjgsXG4gICAgICAgICAgICBtMTA6IC0wLjE0NzA1NDI1NjQyMDk5MDEzLFxuICAgICAgICAgICAgbTExOiAwLjUxODM2MDI3MTUzNjc3NzYsXG4gICAgICAgICAgICBtMTI6IDAuMDQwMDQyODIxNjU0MDg0ODcsXG4gICAgICAgICAgICBtMjA6IDAuMTU5OTYyNjUxNjYzNzMxMjUsXG4gICAgICAgICAgICBtMjE6IDAuMDQ5MjkxMjI4MjEyODU1NixcbiAgICAgICAgICAgIG0yMjogMC45Njg0ODY2OTU3ODc1NTAyXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gdGFrZW4gZnJvbSBodHRwczovL2RlLm1hdGh3b3Jrcy5jb20vaGVscC9pbWFnZXMvcmVmL3doaXRlcG9pbnQuaHRtbFxuICAgIHZhciBJTExVTUlOQU5UUyA9IG5ldyBNYXAoW1xuICAgICAgICAvLyBBU1RNIEUzMDgtMDFcbiAgICAgICAgWydhJywgWzEuMDk4NSwgMC4zNTU4NV1dLFxuICAgICAgICAvLyBXeXN6ZWNraSAmIFN0aWxlcywgcC4gNzY5XG4gICAgICAgIFsnYicsIFsxLjA5ODUsIDAuMzU1ODVdXSxcbiAgICAgICAgLy8gQyBBU1RNIEUzMDgtMDFcbiAgICAgICAgWydjJywgWzAuOTgwNzQsIDEuMTgyMzJdXSxcbiAgICAgICAgLy8gRDUwIChBU1RNIEUzMDgtMDEpXG4gICAgICAgIFsnZDUwJywgWzAuOTY0MjIsIDAuODI1MjFdXSxcbiAgICAgICAgLy8gRDU1IChBU1RNIEUzMDgtMDEpXG4gICAgICAgIFsnZDU1JywgWzAuOTU2ODIsIDAuOTIxNDldXSxcbiAgICAgICAgLy8gRDY1IChBU1RNIEUzMDgtMDEpXG4gICAgICAgIFsnZDY1JywgWzAuOTUwNDcsIDEuMDg4ODNdXSxcbiAgICAgICAgLy8gRSAoQVNUTSBFMzA4LTAxKVxuICAgICAgICBbJ2UnLCBbMSwgMSwgMV1dLFxuICAgICAgICAvLyBGMiAoQVNUTSBFMzA4LTAxKVxuICAgICAgICBbJ2YyJywgWzAuOTkxODYsIDAuNjczOTNdXSxcbiAgICAgICAgLy8gRjcgKEFTVE0gRTMwOC0wMSlcbiAgICAgICAgWydmNycsIFswLjk1MDQxLCAxLjA4NzQ3XV0sXG4gICAgICAgIC8vIEYxMSAoQVNUTSBFMzA4LTAxKVxuICAgICAgICBbJ2YxMScsIFsxLjAwOTYyLCAwLjY0MzVdXSxcbiAgICAgICAgWydpY2MnLCBbMC45NjQyMiwgMC44MjUyMV1dXG4gICAgXSk7XG5cbiAgICBmdW5jdGlvbiBzZXRMYWJXaGl0ZVBvaW50KG5hbWUpIHtcbiAgICAgICAgdmFyIGlsbCA9IElMTFVNSU5BTlRTLmdldChTdHJpbmcobmFtZSkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICghaWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gTGFiIGlsbHVtaW5hbnQgJyArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxhYkNvbnN0YW50cy5sYWJXaGl0ZVBvaW50ID0gbmFtZTtcbiAgICAgICAgbGFiQ29uc3RhbnRzLlhuID0gaWxsWzBdO1xuICAgICAgICBsYWJDb25zdGFudHMuWm4gPSBpbGxbMV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TGFiV2hpdGVQb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIGxhYkNvbnN0YW50cy5sYWJXaGl0ZVBvaW50O1xuICAgIH1cblxuICAgIHZhciByZ2IybGFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2soYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICB2YXIgcmVzdCA9IHJlZi5zbGljZSgzKTtcbiAgICAgICAgdmFyIHJlZiQxID0gcmdiMnh5eihyLCBnLCBiKTtcbiAgICAgICAgdmFyIHggPSByZWYkMVswXTtcbiAgICAgICAgdmFyIHkgPSByZWYkMVsxXTtcbiAgICAgICAgdmFyIHogPSByZWYkMVsyXTtcbiAgICAgICAgdmFyIHJlZiQyID0geHl6MmxhYih4LCB5LCB6KTtcbiAgICAgICAgdmFyIEwgPSByZWYkMlswXTtcbiAgICAgICAgdmFyIGEgPSByZWYkMlsxXTtcbiAgICAgICAgdmFyIGJfID0gcmVmJDJbMl07XG4gICAgICAgIHJldHVybiBbTCwgYSwgYl8gXS5jb25jYXQoIChyZXN0Lmxlbmd0aCA+IDAgJiYgcmVzdFswXSA8IDEgPyBbcmVzdFswXV0gOiBbXSkpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB4eXoybGFiKHgsIHksIHopIHtcbiAgICAgICAgdmFyIFhuID0gbGFiQ29uc3RhbnRzLlhuO1xuICAgICAgICB2YXIgWW4gPSBsYWJDb25zdGFudHMuWW47XG4gICAgICAgIHZhciBabiA9IGxhYkNvbnN0YW50cy5abjtcbiAgICAgICAgdmFyIGtFID0gbGFiQ29uc3RhbnRzLmtFO1xuICAgICAgICB2YXIga0sgPSBsYWJDb25zdGFudHMua0s7XG4gICAgICAgIHZhciB4ciA9IHggLyBYbjtcbiAgICAgICAgdmFyIHlyID0geSAvIFluO1xuICAgICAgICB2YXIgenIgPSB6IC8gWm47XG5cbiAgICAgICAgdmFyIGZ4ID0geHIgPiBrRSA/IE1hdGgucG93KHhyLCAxLjAgLyAzLjApIDogKGtLICogeHIgKyAxNi4wKSAvIDExNi4wO1xuICAgICAgICB2YXIgZnkgPSB5ciA+IGtFID8gTWF0aC5wb3coeXIsIDEuMCAvIDMuMCkgOiAoa0sgKiB5ciArIDE2LjApIC8gMTE2LjA7XG4gICAgICAgIHZhciBmeiA9IHpyID4ga0UgPyBNYXRoLnBvdyh6ciwgMS4wIC8gMy4wKSA6IChrSyAqIHpyICsgMTYuMCkgLyAxMTYuMDtcblxuICAgICAgICByZXR1cm4gWzExNi4wICogZnkgLSAxNi4wLCA1MDAuMCAqIChmeCAtIGZ5KSwgMjAwLjAgKiAoZnkgLSBmeildO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdhbW1hQWRqdXN0U1JHQihjb21wYW5kZWQpIHtcbiAgICAgICAgdmFyIHNpZ24gPSBNYXRoLnNpZ24oY29tcGFuZGVkKTtcbiAgICAgICAgY29tcGFuZGVkID0gTWF0aC5hYnMoY29tcGFuZGVkKTtcbiAgICAgICAgdmFyIGxpbmVhciA9XG4gICAgICAgICAgICBjb21wYW5kZWQgPD0gMC4wNDA0NVxuICAgICAgICAgICAgICAgID8gY29tcGFuZGVkIC8gMTIuOTJcbiAgICAgICAgICAgICAgICA6IE1hdGgucG93KChjb21wYW5kZWQgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgICAgICAgcmV0dXJuIGxpbmVhciAqIHNpZ247XG4gICAgfVxuXG4gICAgdmFyIHJnYjJ4eXogPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgICAgICAvLyBub3JtYWxpemUgYW5kIGdhbW1hIGFkanVzdFxuICAgICAgICByID0gZ2FtbWFBZGp1c3RTUkdCKHIgLyAyNTUpO1xuICAgICAgICBnID0gZ2FtbWFBZGp1c3RTUkdCKGcgLyAyNTUpO1xuICAgICAgICBiID0gZ2FtbWFBZGp1c3RTUkdCKGIgLyAyNTUpO1xuXG4gICAgICAgIHZhciBNdHhSR0IyWFlaID0gbGFiQ29uc3RhbnRzLk10eFJHQjJYWVo7XG4gICAgICAgIHZhciBNdHhBZGFwdE1hID0gbGFiQ29uc3RhbnRzLk10eEFkYXB0TWE7XG4gICAgICAgIHZhciBNdHhBZGFwdE1hSSA9IGxhYkNvbnN0YW50cy5NdHhBZGFwdE1hSTtcbiAgICAgICAgdmFyIFhuID0gbGFiQ29uc3RhbnRzLlhuO1xuICAgICAgICB2YXIgWW4gPSBsYWJDb25zdGFudHMuWW47XG4gICAgICAgIHZhciBabiA9IGxhYkNvbnN0YW50cy5abjtcbiAgICAgICAgdmFyIEFzID0gbGFiQ29uc3RhbnRzLkFzO1xuICAgICAgICB2YXIgQnMgPSBsYWJDb25zdGFudHMuQnM7XG4gICAgICAgIHZhciBDcyA9IGxhYkNvbnN0YW50cy5DcztcblxuICAgICAgICB2YXIgeCA9IHIgKiBNdHhSR0IyWFlaLm0wMCArIGcgKiBNdHhSR0IyWFlaLm0xMCArIGIgKiBNdHhSR0IyWFlaLm0yMDtcbiAgICAgICAgdmFyIHkgPSByICogTXR4UkdCMlhZWi5tMDEgKyBnICogTXR4UkdCMlhZWi5tMTEgKyBiICogTXR4UkdCMlhZWi5tMjE7XG4gICAgICAgIHZhciB6ID0gciAqIE10eFJHQjJYWVoubTAyICsgZyAqIE10eFJHQjJYWVoubTEyICsgYiAqIE10eFJHQjJYWVoubTIyO1xuXG4gICAgICAgIHZhciBBZCA9IFhuICogTXR4QWRhcHRNYS5tMDAgKyBZbiAqIE10eEFkYXB0TWEubTEwICsgWm4gKiBNdHhBZGFwdE1hLm0yMDtcbiAgICAgICAgdmFyIEJkID0gWG4gKiBNdHhBZGFwdE1hLm0wMSArIFluICogTXR4QWRhcHRNYS5tMTEgKyBabiAqIE10eEFkYXB0TWEubTIxO1xuICAgICAgICB2YXIgQ2QgPSBYbiAqIE10eEFkYXB0TWEubTAyICsgWW4gKiBNdHhBZGFwdE1hLm0xMiArIFpuICogTXR4QWRhcHRNYS5tMjI7XG5cbiAgICAgICAgdmFyIFggPSB4ICogTXR4QWRhcHRNYS5tMDAgKyB5ICogTXR4QWRhcHRNYS5tMTAgKyB6ICogTXR4QWRhcHRNYS5tMjA7XG4gICAgICAgIHZhciBZID0geCAqIE10eEFkYXB0TWEubTAxICsgeSAqIE10eEFkYXB0TWEubTExICsgeiAqIE10eEFkYXB0TWEubTIxO1xuICAgICAgICB2YXIgWiA9IHggKiBNdHhBZGFwdE1hLm0wMiArIHkgKiBNdHhBZGFwdE1hLm0xMiArIHogKiBNdHhBZGFwdE1hLm0yMjtcblxuICAgICAgICBYICo9IEFkIC8gQXM7XG4gICAgICAgIFkgKj0gQmQgLyBCcztcbiAgICAgICAgWiAqPSBDZCAvIENzO1xuXG4gICAgICAgIHggPSBYICogTXR4QWRhcHRNYUkubTAwICsgWSAqIE10eEFkYXB0TWFJLm0xMCArIFogKiBNdHhBZGFwdE1hSS5tMjA7XG4gICAgICAgIHkgPSBYICogTXR4QWRhcHRNYUkubTAxICsgWSAqIE10eEFkYXB0TWFJLm0xMSArIFogKiBNdHhBZGFwdE1hSS5tMjE7XG4gICAgICAgIHogPSBYICogTXR4QWRhcHRNYUkubTAyICsgWSAqIE10eEFkYXB0TWFJLm0xMiArIFogKiBNdHhBZGFwdE1hSS5tMjI7XG5cbiAgICAgICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICAgICAqIC0gbGFiMmNzcyhsLGEsYilcbiAgICAgKiAtIGxhYjJjc3MobCxhLGIsYWxwaGEpXG4gICAgICogLSBsYWIyY3NzKFtsLGEsYl0sIG1vZGUpXG4gICAgICogLSBsYWIyY3NzKFtsLGEsYixhbHBoYV0sIG1vZGUpXG4gICAgICovXG4gICAgdmFyIGxjaDJjc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIGxjaGEgPSB1bnBhY2soYXJncywgJ2xjaCcpO1xuICAgICAgICB2YXIgbW9kZSA9IGxhc3QoYXJncykgfHwgJ2xhYic7XG4gICAgICAgIGxjaGFbMF0gPSBybmQyKGxjaGFbMF0pICsgJyUnO1xuICAgICAgICBsY2hhWzFdID0gcm5kMihsY2hhWzFdKTtcbiAgICAgICAgbGNoYVsyXSA9IGlzTmFOKGxjaGFbMl0pID8gJ25vbmUnIDogcm5kMihsY2hhWzJdKSArICdkZWcnOyAvLyBhZGQgZGVnIHVuaXQgdG8gaHVlXG4gICAgICAgIGlmIChtb2RlID09PSAnbGNoYScgfHwgKGxjaGEubGVuZ3RoID4gMyAmJiBsY2hhWzNdIDwgMSkpIHtcbiAgICAgICAgICAgIGxjaGFbM10gPSAnLyAnICsgKGxjaGEubGVuZ3RoID4gMyA/IGxjaGFbM10gOiAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxjaGEubGVuZ3RoID0gMztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFwibGNoKFwiICsgKGxjaGEuam9pbignICcpKSArIFwiKVwiKTtcbiAgICB9O1xuXG4gICAgdmFyIHNxcnQkNCA9IE1hdGguc3FydDtcbiAgICB2YXIgYXRhbjIkMiA9IE1hdGguYXRhbjI7XG4gICAgdmFyIHJvdW5kJDUgPSBNYXRoLnJvdW5kO1xuXG4gICAgdmFyIGxhYjJsY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayhhcmdzLCAnbGFiJyk7XG4gICAgICAgIHZhciBsID0gcmVmWzBdO1xuICAgICAgICB2YXIgYSA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciBjID0gc3FydCQ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgICB2YXIgaCA9IChhdGFuMiQyKGIsIGEpICogUkFEMkRFRyArIDM2MCkgJSAzNjA7XG4gICAgICAgIGlmIChyb3VuZCQ1KGMgKiAxMDAwMCkgPT09IDApIHsgaCA9IE51bWJlci5OYU47IH1cbiAgICAgICAgcmV0dXJuIFtsLCBjLCBoXTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJsY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayhhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciByZXN0ID0gcmVmLnNsaWNlKDMpO1xuICAgICAgICB2YXIgcmVmJDEgPSByZ2IybGFiKHIsIGcsIGIpO1xuICAgICAgICB2YXIgbCA9IHJlZiQxWzBdO1xuICAgICAgICB2YXIgYSA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgYl8gPSByZWYkMVsyXTtcbiAgICAgICAgdmFyIHJlZiQyID0gbGFiMmxjaChsLCBhLCBiXyk7XG4gICAgICAgIHZhciBMID0gcmVmJDJbMF07XG4gICAgICAgIHZhciBjID0gcmVmJDJbMV07XG4gICAgICAgIHZhciBoID0gcmVmJDJbMl07XG4gICAgICAgIHJldHVybiBbTCwgYywgaCBdLmNvbmNhdCggKHJlc3QubGVuZ3RoID4gMCAmJiByZXN0WzBdIDwgMSA/IFtyZXN0WzBdXSA6IFtdKSk7XG4gICAgfTtcblxuICAgIC8vIGZyb20gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci00L211bHRpcGx5LW1hdHJpY2VzLmpzXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlNYXRyaWNlcyhBLCBCKSB7XG4gICAgICAgIHZhciBtID0gQS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KEFbMF0pKSB7XG4gICAgICAgICAgICAvLyBBIGlzIHZlY3RvciwgY29udmVydCB0byBbW2EsIGIsIGMsIC4uLl1dXG4gICAgICAgICAgICBBID0gW0FdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KEJbMF0pKSB7XG4gICAgICAgICAgICAvLyBCIGlzIHZlY3RvciwgY29udmVydCB0byBbW2FdLCBbYl0sIFtjXSwgLi4uXV1cbiAgICAgICAgICAgIEIgPSBCLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gW3hdOyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwID0gQlswXS5sZW5ndGg7XG4gICAgICAgIHZhciBCX2NvbHMgPSBCWzBdLm1hcChmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gQi5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHhbaV07IH0pOyB9KTsgLy8gdHJhbnNwb3NlIEJcbiAgICAgICAgdmFyIHByb2R1Y3QgPSBBLm1hcChmdW5jdGlvbiAocm93KSB7IHJldHVybiBCX2NvbHMubWFwKGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sLnJlZHVjZShmdW5jdGlvbiAoYSwgYykgeyByZXR1cm4gYSArIGMgKiByb3c7IH0sIDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByb3cucmVkdWNlKGZ1bmN0aW9uIChhLCBjLCBpKSB7IHJldHVybiBhICsgYyAqIChjb2xbaV0gfHwgMCk7IH0sIDApO1xuICAgICAgICAgICAgfSk7IH1cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobSA9PT0gMSkge1xuICAgICAgICAgICAgcHJvZHVjdCA9IHByb2R1Y3RbMF07IC8vIEF2b2lkIFtbYSwgYiwgYywgLi4uXV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvZHVjdC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHhbMF07IH0pOyAvLyBBdm9pZCBbW2FdLCBbYl0sIFtjXSwgLi4uXV1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9kdWN0O1xuICAgIH1cblxuICAgIHZhciByZ2Iyb2tsYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayhhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciByZXN0ID0gcmVmLnNsaWNlKDMpO1xuICAgICAgICB2YXIgeHl6ID0gcmdiMnh5eihyLCBnLCBiKTtcbiAgICAgICAgdmFyIG9rbGFiID0gWFlaX3RvX09LTGFiKHh5eik7XG4gICAgICAgIHJldHVybiBva2xhYi5jb25jYXQoIChyZXN0Lmxlbmd0aCA+IDAgJiYgcmVzdFswXSA8IDEgPyBbcmVzdFswXV0gOiBbXSkpO1xuICAgIH07XG5cbiAgICAvLyBmcm9tIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItNC8jY29sb3ItY29udmVyc2lvbi1jb2RlXG4gICAgZnVuY3Rpb24gWFlaX3RvX09LTGFiKFhZWikge1xuICAgICAgICAvLyBHaXZlbiBYWVogcmVsYXRpdmUgdG8gRDY1LCBjb252ZXJ0IHRvIE9LTGFiXG4gICAgICAgIHZhciBYWVp0b0xNUyA9IFtcbiAgICAgICAgICAgIFswLjgxOTAyMjQzNzk5NjcwMywgMC4zNjE5MDYyNjAwNTI4OTA0LCAtMC4xMjg4NzM3ODE1MjA5ODc5XSxcbiAgICAgICAgICAgIFswLjAzMjk4MzY1MzkzMjM4ODUsIDAuOTI5Mjg2ODYxNTg2MzQzNCwgMC4wMzYxNDQ2NjYzNTA2NDI0XSxcbiAgICAgICAgICAgIFswLjA0ODE3NzE4OTM1OTYyNDIsIDAuMjY0MjM5NTMxNzUyNzMwOCwgMC42MzM1NDc4Mjg0Njk0MzA5XVxuICAgICAgICBdO1xuICAgICAgICB2YXIgTE1TdG9PS0xhYiA9IFtcbiAgICAgICAgICAgIFswLjIxMDQ1NDI2ODMwOTMxNCwgMC43OTM2MTc3NzQ3MDIzMDU0LCAtMC4wMDQwNzIwNDMwMTE2MTkzXSxcbiAgICAgICAgICAgIFsxLjk3Nzk5ODUzMjQzMTE2ODQsIC0yLjQyODU5MjI0MjA0ODU3OTksIDAuNDUwNTkzNzA5NjE3NDExXSxcbiAgICAgICAgICAgIFswLjAyNTkwNDA0MjQ2NTU0NzgsIDAuNzgyNzcxNzEyNDU3NTI5NiwgLTAuODA4Njc1NzU0OTIzMDc3NF1cbiAgICAgICAgXTtcblxuICAgICAgICB2YXIgTE1TID0gbXVsdGlwbHlNYXRyaWNlcyhYWVp0b0xNUywgWFlaKTtcbiAgICAgICAgLy8gSmF2YVNjcmlwdCBNYXRoLmNicnQgcmV0dXJucyBhIHNpZ24tbWF0Y2hlZCBjdWJlIHJvb3RcbiAgICAgICAgLy8gYmV3YXJlIGlmIHBvcnRpbmcgdG8gb3RoZXIgbGFuZ3VhZ2VzXG4gICAgICAgIC8vIGVzcGVjaWFsbHkgaWYgdGVtcHRlZCB0byB1c2UgYSBnZW5lcmFsIHBvd2VyIGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiBtdWx0aXBseU1hdHJpY2VzKFxuICAgICAgICAgICAgTE1TdG9PS0xhYixcbiAgICAgICAgICAgIExNUy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIE1hdGguY2JydChjKTsgfSlcbiAgICAgICAgKTtcbiAgICAgICAgLy8gTCBpbiByYW5nZSBbMCwxXS4gRm9yIHVzZSBpbiBDU1MsIG11bHRpcGx5IGJ5IDEwMCBhbmQgYWRkIGEgcGVyY2VudFxuICAgIH1cblxuICAgIHZhciBva2xhYjJjc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIGxhYmEgPSB1bnBhY2soYXJncywgJ2xhYicpO1xuICAgICAgICBsYWJhWzBdID0gcm5kMihsYWJhWzBdICogMTAwKSArICclJztcbiAgICAgICAgbGFiYVsxXSA9IHJuZDMobGFiYVsxXSk7XG4gICAgICAgIGxhYmFbMl0gPSBybmQzKGxhYmFbMl0pO1xuICAgICAgICBpZiAobGFiYS5sZW5ndGggPiAzICYmIGxhYmFbM10gPCAxKSB7XG4gICAgICAgICAgICBsYWJhWzNdID0gJy8gJyArIChsYWJhLmxlbmd0aCA+IDMgPyBsYWJhWzNdIDogMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYWJhLmxlbmd0aCA9IDM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcIm9rbGFiKFwiICsgKGxhYmEuam9pbignICcpKSArIFwiKVwiKTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJva2xjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrKGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSByZWZbMF07XG4gICAgICAgIHZhciBnID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlc3QgPSByZWYuc2xpY2UoMyk7XG4gICAgICAgIHZhciByZWYkMSA9IHJnYjJva2xhYihyLCBnLCBiKTtcbiAgICAgICAgdmFyIGwgPSByZWYkMVswXTtcbiAgICAgICAgdmFyIGEgPSByZWYkMVsxXTtcbiAgICAgICAgdmFyIGJfID0gcmVmJDFbMl07XG4gICAgICAgIHZhciByZWYkMiA9IGxhYjJsY2gobCwgYSwgYl8pO1xuICAgICAgICB2YXIgTCA9IHJlZiQyWzBdO1xuICAgICAgICB2YXIgYyA9IHJlZiQyWzFdO1xuICAgICAgICB2YXIgaCA9IHJlZiQyWzJdO1xuICAgICAgICByZXR1cm4gW0wsIGMsIGggXS5jb25jYXQoIChyZXN0Lmxlbmd0aCA+IDAgJiYgcmVzdFswXSA8IDEgPyBbcmVzdFswXV0gOiBbXSkpO1xuICAgIH07XG5cbiAgICB2YXIgb2tsY2gyY3NzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciBsY2hhID0gdW5wYWNrKGFyZ3MsICdsY2gnKTtcbiAgICAgICAgbGNoYVswXSA9IHJuZDIobGNoYVswXSAqIDEwMCkgKyAnJSc7XG4gICAgICAgIGxjaGFbMV0gPSBybmQzKGxjaGFbMV0pO1xuICAgICAgICBsY2hhWzJdID0gaXNOYU4obGNoYVsyXSkgPyAnbm9uZScgOiBybmQyKGxjaGFbMl0pICsgJ2RlZyc7IC8vIGFkZCBkZWcgdW5pdCB0byBodWVcbiAgICAgICAgaWYgKGxjaGEubGVuZ3RoID4gMyAmJiBsY2hhWzNdIDwgMSkge1xuICAgICAgICAgICAgbGNoYVszXSA9ICcvICcgKyAobGNoYS5sZW5ndGggPiAzID8gbGNoYVszXSA6IDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGNoYS5sZW5ndGggPSAzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXCJva2xjaChcIiArIChsY2hhLmpvaW4oJyAnKSkgKyBcIilcIik7XG4gICAgfTtcblxuICAgIHZhciByb3VuZCQ0ID0gTWF0aC5yb3VuZDtcblxuICAgIC8qXG4gICAgICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAgICAgKiAtIHJnYjJjc3MocixnLGIpXG4gICAgICogLSByZ2IyY3NzKHIsZyxiLGEpXG4gICAgICogLSByZ2IyY3NzKFtyLGcsYl0sIG1vZGUpXG4gICAgICogLSByZ2IyY3NzKFtyLGcsYixhXSwgbW9kZSlcbiAgICAgKiAtIHJnYjJjc3Moe3IsZyxiLGF9LCBtb2RlKVxuICAgICAqL1xuICAgIHZhciByZ2IyY3NzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciByZ2JhID0gdW5wYWNrKGFyZ3MsICdyZ2JhJyk7XG4gICAgICAgIHZhciBtb2RlID0gbGFzdChhcmdzKSB8fCAncmdiJztcbiAgICAgICAgaWYgKG1vZGUuc3Vic3RyKDAsIDMpID09PSAnaHNsJykge1xuICAgICAgICAgICAgcmV0dXJuIGhzbDJjc3MocmdiMmhzbCQxKHJnYmEpLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kZS5zdWJzdHIoMCwgMykgPT09ICdsYWInKSB7XG4gICAgICAgICAgICAvLyBjaGFuZ2UgdG8gRDUwIGxhYiB3aGl0ZXBvaW50IHNpbmNlIHRoaXMgaXMgd2hhdCBXM0MgaXMgdXNpbmcgZm9yIENTUyBMYWIgY29sb3JzXG4gICAgICAgICAgICB2YXIgcHJldldoaXRlUG9pbnQgPSBnZXRMYWJXaGl0ZVBvaW50KCk7XG4gICAgICAgICAgICBzZXRMYWJXaGl0ZVBvaW50KCdkNTAnKTtcbiAgICAgICAgICAgIHZhciBjc3NDb2xvciA9IGxhYjJjc3MocmdiMmxhYihyZ2JhKSwgbW9kZSk7XG4gICAgICAgICAgICBzZXRMYWJXaGl0ZVBvaW50KHByZXZXaGl0ZVBvaW50KTtcbiAgICAgICAgICAgIHJldHVybiBjc3NDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kZS5zdWJzdHIoMCwgMykgPT09ICdsY2gnKSB7XG4gICAgICAgICAgICAvLyBjaGFuZ2UgdG8gRDUwIGxhYiB3aGl0ZXBvaW50IHNpbmNlIHRoaXMgaXMgd2hhdCBXM0MgaXMgdXNpbmcgZm9yIENTUyBMYWIgY29sb3JzXG4gICAgICAgICAgICB2YXIgcHJldldoaXRlUG9pbnQkMSA9IGdldExhYldoaXRlUG9pbnQoKTtcbiAgICAgICAgICAgIHNldExhYldoaXRlUG9pbnQoJ2Q1MCcpO1xuICAgICAgICAgICAgdmFyIGNzc0NvbG9yJDEgPSBsY2gyY3NzKHJnYjJsY2gocmdiYSksIG1vZGUpO1xuICAgICAgICAgICAgc2V0TGFiV2hpdGVQb2ludChwcmV2V2hpdGVQb2ludCQxKTtcbiAgICAgICAgICAgIHJldHVybiBjc3NDb2xvciQxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RlLnN1YnN0cigwLCA1KSA9PT0gJ29rbGFiJykge1xuICAgICAgICAgICAgcmV0dXJuIG9rbGFiMmNzcyhyZ2Iyb2tsYWIocmdiYSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RlLnN1YnN0cigwLCA1KSA9PT0gJ29rbGNoJykge1xuICAgICAgICAgICAgcmV0dXJuIG9rbGNoMmNzcyhyZ2Iyb2tsY2gocmdiYSkpO1xuICAgICAgICB9XG4gICAgICAgIHJnYmFbMF0gPSByb3VuZCQ0KHJnYmFbMF0pO1xuICAgICAgICByZ2JhWzFdID0gcm91bmQkNChyZ2JhWzFdKTtcbiAgICAgICAgcmdiYVsyXSA9IHJvdW5kJDQocmdiYVsyXSk7XG4gICAgICAgIGlmIChtb2RlID09PSAncmdiYScgfHwgKHJnYmEubGVuZ3RoID4gMyAmJiByZ2JhWzNdIDwgMSkpIHtcbiAgICAgICAgICAgIHJnYmFbM10gPSAnLyAnICsgKHJnYmEubGVuZ3RoID4gMyA/IHJnYmFbM10gOiAxKTtcbiAgICAgICAgICAgIG1vZGUgPSAncmdiYSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgobW9kZS5zdWJzdHIoMCwgMykpICsgXCIoXCIgKyAocmdiYS5zbGljZSgwLCBtb2RlID09PSAncmdiJyA/IDMgOiA0KS5qb2luKCcgJykpICsgXCIpXCIpO1xuICAgIH07XG5cbiAgICB2YXIgaHNsMnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFzc2lnbjtcblxuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuICAgICAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdoc2wnKTtcbiAgICAgICAgdmFyIGggPSBhcmdzWzBdO1xuICAgICAgICB2YXIgcyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBsID0gYXJnc1syXTtcbiAgICAgICAgdmFyIHIsIGcsIGI7XG4gICAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgICAgICByID0gZyA9IGIgPSBsICogMjU1O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHQzID0gWzAsIDAsIDBdO1xuICAgICAgICAgICAgdmFyIGMgPSBbMCwgMCwgMF07XG4gICAgICAgICAgICB2YXIgdDIgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICAgICAgdmFyIHQxID0gMiAqIGwgLSB0MjtcbiAgICAgICAgICAgIHZhciBoXyA9IGggLyAzNjA7XG4gICAgICAgICAgICB0M1swXSA9IGhfICsgMSAvIDM7XG4gICAgICAgICAgICB0M1sxXSA9IGhfO1xuICAgICAgICAgICAgdDNbMl0gPSBoXyAtIDEgLyAzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodDNbaV0gPCAwKSB7IHQzW2ldICs9IDE7IH1cbiAgICAgICAgICAgICAgICBpZiAodDNbaV0gPiAxKSB7IHQzW2ldIC09IDE7IH1cbiAgICAgICAgICAgICAgICBpZiAoNiAqIHQzW2ldIDwgMSkgeyBjW2ldID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDNbaV07IH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgyICogdDNbaV0gPCAxKSB7IGNbaV0gPSB0MjsgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKDMgKiB0M1tpXSA8IDIpIHsgY1tpXSA9IHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDNbaV0pICogNjsgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyBjW2ldID0gdDE7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChhc3NpZ24gPSBbY1swXSAqIDI1NSwgY1sxXSAqIDI1NSwgY1syXSAqIDI1NV0sIHIgPSBhc3NpZ25bMF0sIGcgPSBhc3NpZ25bMV0sIGIgPSBhc3NpZ25bMl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIC8vIGtlZXAgYWxwaGEgY2hhbm5lbFxuICAgICAgICAgICAgcmV0dXJuIFtyLCBnLCBiLCBhcmdzWzNdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3IsIGcsIGIsIDFdO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIEwqIFswLi4xMDBdXG4gICAgICogYSBbLTEwMC4uMTAwXVxuICAgICAqIGIgWy0xMDAuLjEwMF1cbiAgICAgKi9cbiAgICB2YXIgbGFiMnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdsYWInKTtcbiAgICAgICAgdmFyIEwgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgYSA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBiID0gYXJnc1syXTtcbiAgICAgICAgdmFyIHJlZiA9IGxhYjJ4eXooTCwgYSwgYik7XG4gICAgICAgIHZhciB4ID0gcmVmWzBdO1xuICAgICAgICB2YXIgeSA9IHJlZlsxXTtcbiAgICAgICAgdmFyIHogPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IHh5ejJyZ2IoeCwgeSwgeik7XG4gICAgICAgIHZhciByID0gcmVmJDFbMF07XG4gICAgICAgIHZhciBnID0gcmVmJDFbMV07XG4gICAgICAgIHZhciBiXyA9IHJlZiQxWzJdO1xuICAgICAgICByZXR1cm4gW3IsIGcsIGJfLCBhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMV07XG4gICAgfTtcblxuICAgIHZhciBsYWIyeHl6ID0gZnVuY3Rpb24gKEwsIGEsIGIpIHtcbiAgICAgICAgdmFyIGtFID0gbGFiQ29uc3RhbnRzLmtFO1xuICAgICAgICB2YXIga0sgPSBsYWJDb25zdGFudHMua0s7XG4gICAgICAgIHZhciBrS0UgPSBsYWJDb25zdGFudHMua0tFO1xuICAgICAgICB2YXIgWG4gPSBsYWJDb25zdGFudHMuWG47XG4gICAgICAgIHZhciBZbiA9IGxhYkNvbnN0YW50cy5ZbjtcbiAgICAgICAgdmFyIFpuID0gbGFiQ29uc3RhbnRzLlpuO1xuXG4gICAgICAgIHZhciBmeSA9IChMICsgMTYuMCkgLyAxMTYuMDtcbiAgICAgICAgdmFyIGZ4ID0gMC4wMDIgKiBhICsgZnk7XG4gICAgICAgIHZhciBmeiA9IGZ5IC0gMC4wMDUgKiBiO1xuXG4gICAgICAgIHZhciBmeDMgPSBmeCAqIGZ4ICogZng7XG4gICAgICAgIHZhciBmejMgPSBmeiAqIGZ6ICogZno7XG5cbiAgICAgICAgdmFyIHhyID0gZngzID4ga0UgPyBmeDMgOiAoMTE2LjAgKiBmeCAtIDE2LjApIC8ga0s7XG4gICAgICAgIHZhciB5ciA9IEwgPiBrS0UgPyBNYXRoLnBvdygoTCArIDE2LjApIC8gMTE2LjAsIDMuMCkgOiBMIC8ga0s7XG4gICAgICAgIHZhciB6ciA9IGZ6MyA+IGtFID8gZnozIDogKDExNi4wICogZnogLSAxNi4wKSAvIGtLO1xuXG4gICAgICAgIHZhciB4ID0geHIgKiBYbjtcbiAgICAgICAgdmFyIHkgPSB5ciAqIFluO1xuICAgICAgICB2YXIgeiA9IHpyICogWm47XG5cbiAgICAgICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbXBhbmQgPSBmdW5jdGlvbiAobGluZWFyKSB7XG4gICAgICAgIC8qIHNSR0IgKi9cbiAgICAgICAgdmFyIHNpZ24gPSBNYXRoLnNpZ24obGluZWFyKTtcbiAgICAgICAgbGluZWFyID0gTWF0aC5hYnMobGluZWFyKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChsaW5lYXIgPD0gMC4wMDMxMzA4XG4gICAgICAgICAgICAgICAgPyBsaW5lYXIgKiAxMi45MlxuICAgICAgICAgICAgICAgIDogMS4wNTUgKiBNYXRoLnBvdyhsaW5lYXIsIDEuMCAvIDIuNCkgLSAwLjA1NSkgKiBzaWduXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciB4eXoycmdiID0gZnVuY3Rpb24gKHgsIHksIHopIHtcbiAgICAgICAgdmFyIE10eEFkYXB0TWEgPSBsYWJDb25zdGFudHMuTXR4QWRhcHRNYTtcbiAgICAgICAgdmFyIE10eEFkYXB0TWFJID0gbGFiQ29uc3RhbnRzLk10eEFkYXB0TWFJO1xuICAgICAgICB2YXIgTXR4WFlaMlJHQiA9IGxhYkNvbnN0YW50cy5NdHhYWVoyUkdCO1xuICAgICAgICB2YXIgUmVmV2hpdGVSR0IgPSBsYWJDb25zdGFudHMuUmVmV2hpdGVSR0I7XG4gICAgICAgIHZhciBYbiA9IGxhYkNvbnN0YW50cy5YbjtcbiAgICAgICAgdmFyIFluID0gbGFiQ29uc3RhbnRzLlluO1xuICAgICAgICB2YXIgWm4gPSBsYWJDb25zdGFudHMuWm47XG5cbiAgICAgICAgdmFyIEFzID0gWG4gKiBNdHhBZGFwdE1hLm0wMCArIFluICogTXR4QWRhcHRNYS5tMTAgKyBabiAqIE10eEFkYXB0TWEubTIwO1xuICAgICAgICB2YXIgQnMgPSBYbiAqIE10eEFkYXB0TWEubTAxICsgWW4gKiBNdHhBZGFwdE1hLm0xMSArIFpuICogTXR4QWRhcHRNYS5tMjE7XG4gICAgICAgIHZhciBDcyA9IFhuICogTXR4QWRhcHRNYS5tMDIgKyBZbiAqIE10eEFkYXB0TWEubTEyICsgWm4gKiBNdHhBZGFwdE1hLm0yMjtcblxuICAgICAgICB2YXIgQWQgPVxuICAgICAgICAgICAgUmVmV2hpdGVSR0IuWCAqIE10eEFkYXB0TWEubTAwICtcbiAgICAgICAgICAgIFJlZldoaXRlUkdCLlkgKiBNdHhBZGFwdE1hLm0xMCArXG4gICAgICAgICAgICBSZWZXaGl0ZVJHQi5aICogTXR4QWRhcHRNYS5tMjA7XG4gICAgICAgIHZhciBCZCA9XG4gICAgICAgICAgICBSZWZXaGl0ZVJHQi5YICogTXR4QWRhcHRNYS5tMDEgK1xuICAgICAgICAgICAgUmVmV2hpdGVSR0IuWSAqIE10eEFkYXB0TWEubTExICtcbiAgICAgICAgICAgIFJlZldoaXRlUkdCLlogKiBNdHhBZGFwdE1hLm0yMTtcbiAgICAgICAgdmFyIENkID1cbiAgICAgICAgICAgIFJlZldoaXRlUkdCLlggKiBNdHhBZGFwdE1hLm0wMiArXG4gICAgICAgICAgICBSZWZXaGl0ZVJHQi5ZICogTXR4QWRhcHRNYS5tMTIgK1xuICAgICAgICAgICAgUmVmV2hpdGVSR0IuWiAqIE10eEFkYXB0TWEubTIyO1xuXG4gICAgICAgIHZhciBYMSA9XG4gICAgICAgICAgICAoeCAqIE10eEFkYXB0TWEubTAwICsgeSAqIE10eEFkYXB0TWEubTEwICsgeiAqIE10eEFkYXB0TWEubTIwKSAqXG4gICAgICAgICAgICAoQWQgLyBBcyk7XG4gICAgICAgIHZhciBZMSA9XG4gICAgICAgICAgICAoeCAqIE10eEFkYXB0TWEubTAxICsgeSAqIE10eEFkYXB0TWEubTExICsgeiAqIE10eEFkYXB0TWEubTIxKSAqXG4gICAgICAgICAgICAoQmQgLyBCcyk7XG4gICAgICAgIHZhciBaMSA9XG4gICAgICAgICAgICAoeCAqIE10eEFkYXB0TWEubTAyICsgeSAqIE10eEFkYXB0TWEubTEyICsgeiAqIE10eEFkYXB0TWEubTIyKSAqXG4gICAgICAgICAgICAoQ2QgLyBDcyk7XG5cbiAgICAgICAgdmFyIFgyID1cbiAgICAgICAgICAgIFgxICogTXR4QWRhcHRNYUkubTAwICsgWTEgKiBNdHhBZGFwdE1hSS5tMTAgKyBaMSAqIE10eEFkYXB0TWFJLm0yMDtcbiAgICAgICAgdmFyIFkyID1cbiAgICAgICAgICAgIFgxICogTXR4QWRhcHRNYUkubTAxICsgWTEgKiBNdHhBZGFwdE1hSS5tMTEgKyBaMSAqIE10eEFkYXB0TWFJLm0yMTtcbiAgICAgICAgdmFyIFoyID1cbiAgICAgICAgICAgIFgxICogTXR4QWRhcHRNYUkubTAyICsgWTEgKiBNdHhBZGFwdE1hSS5tMTIgKyBaMSAqIE10eEFkYXB0TWFJLm0yMjtcblxuICAgICAgICB2YXIgciA9IGNvbXBhbmQoXG4gICAgICAgICAgICBYMiAqIE10eFhZWjJSR0IubTAwICsgWTIgKiBNdHhYWVoyUkdCLm0xMCArIFoyICogTXR4WFlaMlJHQi5tMjBcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGcgPSBjb21wYW5kKFxuICAgICAgICAgICAgWDIgKiBNdHhYWVoyUkdCLm0wMSArIFkyICogTXR4WFlaMlJHQi5tMTEgKyBaMiAqIE10eFhZWjJSR0IubTIxXG4gICAgICAgICk7XG4gICAgICAgIHZhciBiID0gY29tcGFuZChcbiAgICAgICAgICAgIFgyICogTXR4WFlaMlJHQi5tMDIgKyBZMiAqIE10eFhZWjJSR0IubTEyICsgWjIgKiBNdHhYWVoyUkdCLm0yMlxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG4gICAgfTtcblxuICAgIHZhciBzaW4kMyA9IE1hdGguc2luO1xuICAgIHZhciBjb3MkNCA9IE1hdGguY29zO1xuXG4gICAgdmFyIGxjaDJsYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgLypcbiAgICAgICAgQ29udmVydCBmcm9tIGEgcXVhbGl0YXRpdmUgcGFyYW1ldGVyIGggYW5kIGEgcXVhbnRpdGF0aXZlIHBhcmFtZXRlciBsIHRvIGEgMjQtYml0IHBpeGVsLlxuICAgICAgICBUaGVzZSBmb3JtdWxhcyB3ZXJlIGludmVudGVkIGJ5IERhdmlkIERhbHJ5bXBsZSB0byBvYnRhaW4gbWF4aW11bSBjb250cmFzdCB3aXRob3V0IGdvaW5nXG4gICAgICAgIG91dCBvZiBnYW11dCBpZiB0aGUgcGFyYW1ldGVycyBhcmUgaW4gdGhlIHJhbmdlIDAtMS5cblxuICAgICAgICBBIHNhdHVyYXRpb24gbXVsdGlwbGllciB3YXMgYWRkZWQgYnkgR3JlZ29yIEFpc2NoXG4gICAgICAgICovXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2soYXJncywgJ2xjaCcpO1xuICAgICAgICB2YXIgbCA9IHJlZlswXTtcbiAgICAgICAgdmFyIGMgPSByZWZbMV07XG4gICAgICAgIHZhciBoID0gcmVmWzJdO1xuICAgICAgICBpZiAoaXNOYU4oaCkpIHsgaCA9IDA7IH1cbiAgICAgICAgaCA9IGggKiBERUcyUkFEO1xuICAgICAgICByZXR1cm4gW2wsIGNvcyQ0KGgpICogYywgc2luJDMoaCkgKiBjXTtcbiAgICB9O1xuXG4gICAgdmFyIGxjaDJyZ2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgYXJncyA9IHVucGFjayhhcmdzLCAnbGNoJyk7XG4gICAgICAgIHZhciBsID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGMgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgaCA9IGFyZ3NbMl07XG4gICAgICAgIHZhciByZWYgPSBsY2gybGFiKGwsIGMsIGgpO1xuICAgICAgICB2YXIgTCA9IHJlZlswXTtcbiAgICAgICAgdmFyIGEgPSByZWZbMV07XG4gICAgICAgIHZhciBiXyA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlZiQxID0gbGFiMnJnYihMLCBhLCBiXyk7XG4gICAgICAgIHZhciByID0gcmVmJDFbMF07XG4gICAgICAgIHZhciBnID0gcmVmJDFbMV07XG4gICAgICAgIHZhciBiID0gcmVmJDFbMl07XG4gICAgICAgIHJldHVybiBbciwgZywgYiwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xuICAgIH07XG5cbiAgICB2YXIgb2tsYWIycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2xhYicpO1xuICAgICAgICB2YXIgTCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBhID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGIgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgcmVzdCA9IGFyZ3Muc2xpY2UoMyk7XG4gICAgICAgIHZhciByZWYgPSBPS0xhYl90b19YWVooW0wsIGEsIGJdKTtcbiAgICAgICAgdmFyIFggPSByZWZbMF07XG4gICAgICAgIHZhciBZID0gcmVmWzFdO1xuICAgICAgICB2YXIgWiA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlZiQxID0geHl6MnJnYihYLCBZLCBaKTtcbiAgICAgICAgdmFyIHIgPSByZWYkMVswXTtcbiAgICAgICAgdmFyIGcgPSByZWYkMVsxXTtcbiAgICAgICAgdmFyIGJfID0gcmVmJDFbMl07XG4gICAgICAgIHJldHVybiBbciwgZywgYl8gXS5jb25jYXQoIChyZXN0Lmxlbmd0aCA+IDAgJiYgcmVzdFswXSA8IDEgPyBbcmVzdFswXV0gOiBbXSkpO1xuICAgIH07XG5cbiAgICAvLyBmcm9tIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItNC8jY29sb3ItY29udmVyc2lvbi1jb2RlXG4gICAgZnVuY3Rpb24gT0tMYWJfdG9fWFlaKE9LTGFiKSB7XG4gICAgICAgIC8vIEdpdmVuIE9LTGFiLCBjb252ZXJ0IHRvIFhZWiByZWxhdGl2ZSB0byBENjVcbiAgICAgICAgdmFyIExNU3RvWFlaID0gW1xuICAgICAgICAgICAgWzEuMjI2ODc5ODc1ODQ1OTI0MywgLTAuNTU3ODE0OTk0NDYwMjE3MSwgMC4yODEzOTEwNDU2NjU5NjQ3XSxcbiAgICAgICAgICAgIFstMC4wNDA1NzU3NDUyMTQ4MDA4LCAxLjExMjI4NjgwMzI4MDMxNywgLTAuMDcxNzExMDU4MDY1NTE2NF0sXG4gICAgICAgICAgICBbLTAuMDc2MzcyOTM2Njc0NjYwMSwgLTAuNDIxNDkzMzMyNDAyMjQzMiwgMS41ODY5MjQwMTk4MzY3ODE2XVxuICAgICAgICBdO1xuICAgICAgICB2YXIgT0tMYWJ0b0xNUyA9IFtcbiAgICAgICAgICAgIFsxLjAsIDAuMzk2MzM3Nzc3Mzc2MTc0OSwgMC4yMTU4MDM3NTczMDk5MTM2XSxcbiAgICAgICAgICAgIFsxLjAsIC0wLjEwNTU2MTM0NTgxNTY1ODYsIC0wLjA2Mzg1NDE3MjgyNTgxMzNdLFxuICAgICAgICAgICAgWzEuMCwgLTAuMDg5NDg0MTc3NTI5ODExOSwgLTEuMjkxNDg1NTQ4MDE5NDA5Ml1cbiAgICAgICAgXTtcblxuICAgICAgICB2YXIgTE1TbmwgPSBtdWx0aXBseU1hdHJpY2VzKE9LTGFidG9MTVMsIE9LTGFiKTtcbiAgICAgICAgcmV0dXJuIG11bHRpcGx5TWF0cmljZXMoXG4gICAgICAgICAgICBMTVN0b1hZWixcbiAgICAgICAgICAgIExNU25sLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gTWF0aC5wb3coIGMsIDMgKTsgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgb2tsY2gycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2xjaCcpO1xuICAgICAgICB2YXIgbCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBjID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGggPSBhcmdzWzJdO1xuICAgICAgICB2YXIgcmVzdCA9IGFyZ3Muc2xpY2UoMyk7XG4gICAgICAgIHZhciByZWYgPSBsY2gybGFiKGwsIGMsIGgpO1xuICAgICAgICB2YXIgTCA9IHJlZlswXTtcbiAgICAgICAgdmFyIGEgPSByZWZbMV07XG4gICAgICAgIHZhciBiXyA9IHJlZlsyXTtcbiAgICAgICAgdmFyIHJlZiQxID0gb2tsYWIycmdiKEwsIGEsIGJfKTtcbiAgICAgICAgdmFyIHIgPSByZWYkMVswXTtcbiAgICAgICAgdmFyIGcgPSByZWYkMVsxXTtcbiAgICAgICAgdmFyIGIgPSByZWYkMVsyXTtcbiAgICAgICAgcmV0dXJuIFtyLCBnLCBiIF0uY29uY2F0KCAocmVzdC5sZW5ndGggPiAwICYmIHJlc3RbMF0gPCAxID8gW3Jlc3RbMF1dIDogW10pKTtcbiAgICB9O1xuXG4gICAgdmFyIElOVF9PUl9QQ1QgPSAvKCg/Oi0/XFxkKyl8KD86LT9cXGQrKD86XFwuXFxkKyk/KSV8bm9uZSkvLnNvdXJjZTtcbiAgICB2YXIgRkxPQVRfT1JfUENUID0gLygoPzotPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKyklPyl8bm9uZSkvLnNvdXJjZTtcbiAgICB2YXIgUENUID0gLygoPzotPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKyklKXxub25lKS8uc291cmNlO1xuICAgIHZhciBSRV9TID0gL1xccyovLnNvdXJjZTtcbiAgICB2YXIgU0VQID0gL1xccysvLnNvdXJjZTtcbiAgICB2YXIgQ09NTUEgPSAvXFxzKixcXHMqLy5zb3VyY2U7XG4gICAgdmFyIEFOTEdFID0gLygoPzotPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzpkZWcpPyl8bm9uZSkvLnNvdXJjZTtcbiAgICB2YXIgQUxQSEEgPSAvXFxzKig/OlxcL1xccyooKD86WzAxXXxbMDFdP1xcLlxcZCspfFxcZCsoPzpcXC5cXGQrKT8lKSk/Ly5zb3VyY2U7XG5cbiAgICAvLyBlLmcuIHJnYigyNTAgMjAgMCksIHJnYigxMDAlIDUwJSAyMCUpLCByZ2IoMTAwJSA1MCUgMjAlIC8gMC41KVxuICAgIHZhciBSRV9SR0IgPSBuZXcgUmVnRXhwKFxuICAgICAgICAnXnJnYmE/XFxcXCgnICtcbiAgICAgICAgICAgIFJFX1MgK1xuICAgICAgICAgICAgW0lOVF9PUl9QQ1QsIElOVF9PUl9QQ1QsIElOVF9PUl9QQ1RdLmpvaW4oU0VQKSArXG4gICAgICAgICAgICBBTFBIQSArXG4gICAgICAgICAgICAnXFxcXCkkJ1xuICAgICk7XG4gICAgdmFyIFJFX1JHQl9MRUdBQ1kgPSBuZXcgUmVnRXhwKFxuICAgICAgICAnXnJnYlxcXFwoJyArXG4gICAgICAgICAgICBSRV9TICtcbiAgICAgICAgICAgIFtJTlRfT1JfUENULCBJTlRfT1JfUENULCBJTlRfT1JfUENUXS5qb2luKENPTU1BKSArXG4gICAgICAgICAgICBSRV9TICtcbiAgICAgICAgICAgICdcXFxcKSQnXG4gICAgKTtcbiAgICB2YXIgUkVfUkdCQV9MRUdBQ1kgPSBuZXcgUmVnRXhwKFxuICAgICAgICAnXnJnYmFcXFxcKCcgK1xuICAgICAgICAgICAgUkVfUyArXG4gICAgICAgICAgICBbSU5UX09SX1BDVCwgSU5UX09SX1BDVCwgSU5UX09SX1BDVCwgRkxPQVRfT1JfUENUXS5qb2luKENPTU1BKSArXG4gICAgICAgICAgICBSRV9TICtcbiAgICAgICAgICAgICdcXFxcKSQnXG4gICAgKTtcblxuICAgIHZhciBSRV9IU0wgPSBuZXcgUmVnRXhwKFxuICAgICAgICAnXmhzbGE/XFxcXCgnICsgUkVfUyArIFtBTkxHRSwgUENULCBQQ1RdLmpvaW4oU0VQKSArIEFMUEhBICsgJ1xcXFwpJCdcbiAgICApO1xuICAgIHZhciBSRV9IU0xfTEVHQUNZID0gbmV3IFJlZ0V4cChcbiAgICAgICAgJ15oc2w/XFxcXCgnICsgUkVfUyArIFtBTkxHRSwgUENULCBQQ1RdLmpvaW4oQ09NTUEpICsgUkVfUyArICdcXFxcKSQnXG4gICAgKTtcbiAgICB2YXIgUkVfSFNMQV9MRUdBQ1kgPVxuICAgICAgICAvXmhzbGFcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyksXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcblxuICAgIHZhciBSRV9MQUIgPSBuZXcgUmVnRXhwKFxuICAgICAgICAnXmxhYlxcXFwoJyArXG4gICAgICAgICAgICBSRV9TICtcbiAgICAgICAgICAgIFtGTE9BVF9PUl9QQ1QsIEZMT0FUX09SX1BDVCwgRkxPQVRfT1JfUENUXS5qb2luKFNFUCkgK1xuICAgICAgICAgICAgQUxQSEEgK1xuICAgICAgICAgICAgJ1xcXFwpJCdcbiAgICApO1xuICAgIHZhciBSRV9MQ0ggPSBuZXcgUmVnRXhwKFxuICAgICAgICAnXmxjaFxcXFwoJyArXG4gICAgICAgICAgICBSRV9TICtcbiAgICAgICAgICAgIFtGTE9BVF9PUl9QQ1QsIEZMT0FUX09SX1BDVCwgQU5MR0VdLmpvaW4oU0VQKSArXG4gICAgICAgICAgICBBTFBIQSArXG4gICAgICAgICAgICAnXFxcXCkkJ1xuICAgICk7XG4gICAgdmFyIFJFX09LTEFCID0gbmV3IFJlZ0V4cChcbiAgICAgICAgJ15va2xhYlxcXFwoJyArXG4gICAgICAgICAgICBSRV9TICtcbiAgICAgICAgICAgIFtGTE9BVF9PUl9QQ1QsIEZMT0FUX09SX1BDVCwgRkxPQVRfT1JfUENUXS5qb2luKFNFUCkgK1xuICAgICAgICAgICAgQUxQSEEgK1xuICAgICAgICAgICAgJ1xcXFwpJCdcbiAgICApO1xuICAgIHZhciBSRV9PS0xDSCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICdeb2tsY2hcXFxcKCcgK1xuICAgICAgICAgICAgUkVfUyArXG4gICAgICAgICAgICBbRkxPQVRfT1JfUENULCBGTE9BVF9PUl9QQ1QsIEFOTEdFXS5qb2luKFNFUCkgK1xuICAgICAgICAgICAgQUxQSEEgK1xuICAgICAgICAgICAgJ1xcXFwpJCdcbiAgICApO1xuXG4gICAgdmFyIHJvdW5kJDMgPSBNYXRoLnJvdW5kO1xuXG4gICAgdmFyIHJvdW5kUkdCID0gZnVuY3Rpb24gKHJnYikge1xuICAgICAgICByZXR1cm4gcmdiLm1hcChmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gKGkgPD0gMiA/IGxpbWl0KHJvdW5kJDModiksIDAsIDI1NSkgOiB2KTsgfSk7XG4gICAgfTtcblxuICAgIHZhciBwZXJjZW50VG9BYnNvbHV0ZSA9IGZ1bmN0aW9uIChwY3QsIG1pbiwgbWF4LCBzaWduZWQpIHtcbiAgICAgICAgaWYgKCBtaW4gPT09IHZvaWQgMCApIG1pbiA9IDA7XG4gICAgICAgIGlmICggbWF4ID09PSB2b2lkIDAgKSBtYXggPSAxMDA7XG4gICAgICAgIGlmICggc2lnbmVkID09PSB2b2lkIDAgKSBzaWduZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAodHlwZW9mIHBjdCA9PT0gJ3N0cmluZycgJiYgcGN0LmVuZHNXaXRoKCclJykpIHtcbiAgICAgICAgICAgIHBjdCA9IHBhcnNlRmxvYXQocGN0LnN1YnN0cmluZygwLCBwY3QubGVuZ3RoIC0gMSkpIC8gMTAwO1xuICAgICAgICAgICAgaWYgKHNpZ25lZCkge1xuICAgICAgICAgICAgICAgIC8vIHNpZ25lZCBwZXJjZW50YWdlcyBhcmUgaW4gdGhlIHJhbmdlIC0xMDAlIHRvIDEwMCVcbiAgICAgICAgICAgICAgICBwY3QgPSBtaW4gKyAocGN0ICsgMSkgKiAwLjUgKiAobWF4IC0gbWluKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGN0ID0gbWluICsgcGN0ICogKG1heCAtIG1pbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICtwY3Q7XG4gICAgfTtcblxuICAgIHZhciBub25lVG9WYWx1ZSA9IGZ1bmN0aW9uICh2LCBub25lVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHYgPT09ICdub25lJyA/IG5vbmVWYWx1ZSA6IHY7XG4gICAgfTtcblxuICAgIHZhciBjc3MycmdiID0gZnVuY3Rpb24gKGNzcykge1xuICAgICAgICBjc3MgPSBjc3MudG9Mb3dlckNhc2UoKS50cmltKCk7XG5cbiAgICAgICAgaWYgKGNzcyA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtO1xuXG4gICAgICAgIGlmIChpbnB1dC5mb3JtYXQubmFtZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0LmZvcm1hdC5uYW1lZChjc3MpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJnYigyNTAgMjAgMCkgb3IgcmdiKDI1MCwyMCwwKVxuICAgICAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfUkdCKSkgfHwgKG0gPSBjc3MubWF0Y2goUkVfUkdCX0xFR0FDWSkpKSB7XG4gICAgICAgICAgICB2YXIgcmdiID0gbS5zbGljZSgxLCA0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmdiW2ldID0gK3BlcmNlbnRUb0Fic29sdXRlKG5vbmVUb1ZhbHVlKHJnYltpXSwgMCksIDAsIDI1NSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZ2IgPSByb3VuZFJHQihyZ2IpO1xuICAgICAgICAgICAgdmFyIGFscGhhID0gbVs0XSAhPT0gdW5kZWZpbmVkID8gK3BlcmNlbnRUb0Fic29sdXRlKG1bNF0sIDAsIDEpIDogMTtcbiAgICAgICAgICAgIHJnYlszXSA9IGFscGhhOyAvLyBkZWZhdWx0IGFscGhhXG4gICAgICAgICAgICByZXR1cm4gcmdiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmdiYSgyNTAsMjAsMCwwLjQpXG4gICAgICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9SR0JBX0xFR0FDWSkpKSB7XG4gICAgICAgICAgICB2YXIgcmdiJDEgPSBtLnNsaWNlKDEsIDUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgNDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICByZ2IkMVtpJDFdID0gK3BlcmNlbnRUb0Fic29sdXRlKHJnYiQxW2kkMV0sIDAsIDI1NSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmdiJDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoc2woMCwxMDAlLDUwJSlcbiAgICAgICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX0hTTCkpIHx8IChtID0gY3NzLm1hdGNoKFJFX0hTTF9MRUdBQ1kpKSkge1xuICAgICAgICAgICAgdmFyIGhzbCA9IG0uc2xpY2UoMSwgNCk7XG4gICAgICAgICAgICBoc2xbMF0gPSArbm9uZVRvVmFsdWUoaHNsWzBdLnJlcGxhY2UoJ2RlZycsICcnKSwgMCk7XG4gICAgICAgICAgICBoc2xbMV0gPSArcGVyY2VudFRvQWJzb2x1dGUobm9uZVRvVmFsdWUoaHNsWzFdLCAwKSwgMCwgMTAwKSAqIDAuMDE7XG4gICAgICAgICAgICBoc2xbMl0gPSArcGVyY2VudFRvQWJzb2x1dGUobm9uZVRvVmFsdWUoaHNsWzJdLCAwKSwgMCwgMTAwKSAqIDAuMDE7XG4gICAgICAgICAgICB2YXIgcmdiJDIgPSByb3VuZFJHQihoc2wycmdiKGhzbCkpO1xuICAgICAgICAgICAgdmFyIGFscGhhJDEgPSBtWzRdICE9PSB1bmRlZmluZWQgPyArcGVyY2VudFRvQWJzb2x1dGUobVs0XSwgMCwgMSkgOiAxO1xuICAgICAgICAgICAgcmdiJDJbM10gPSBhbHBoYSQxO1xuICAgICAgICAgICAgcmV0dXJuIHJnYiQyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHNsYSgwLDEwMCUsNTAlLDAuNSlcbiAgICAgICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX0hTTEFfTEVHQUNZKSkpIHtcbiAgICAgICAgICAgIHZhciBoc2wkMSA9IG0uc2xpY2UoMSwgNCk7XG4gICAgICAgICAgICBoc2wkMVsxXSAqPSAwLjAxO1xuICAgICAgICAgICAgaHNsJDFbMl0gKj0gMC4wMTtcbiAgICAgICAgICAgIHZhciByZ2IkMyA9IGhzbDJyZ2IoaHNsJDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgMzsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICByZ2IkM1tpJDJdID0gcm91bmQkMyhyZ2IkM1tpJDJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJnYiQzWzNdID0gK21bNF07IC8vIGRlZmF1bHQgYWxwaGEgPSAxXG4gICAgICAgICAgICByZXR1cm4gcmdiJDM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfTEFCKSkpIHtcbiAgICAgICAgICAgIHZhciBsYWIgPSBtLnNsaWNlKDEsIDQpO1xuICAgICAgICAgICAgbGFiWzBdID0gcGVyY2VudFRvQWJzb2x1dGUobm9uZVRvVmFsdWUobGFiWzBdLCAwKSwgMCwgMTAwKTtcbiAgICAgICAgICAgIGxhYlsxXSA9IHBlcmNlbnRUb0Fic29sdXRlKG5vbmVUb1ZhbHVlKGxhYlsxXSwgMCksIC0xMjUsIDEyNSwgdHJ1ZSk7XG4gICAgICAgICAgICBsYWJbMl0gPSBwZXJjZW50VG9BYnNvbHV0ZShub25lVG9WYWx1ZShsYWJbMl0sIDApLCAtMTI1LCAxMjUsIHRydWUpO1xuICAgICAgICAgICAgLy8gY29udmVydCB0byBENTAgTGFiIHdoaXRlcG9pbnRcbiAgICAgICAgICAgIHZhciB3cCA9IGdldExhYldoaXRlUG9pbnQoKTtcbiAgICAgICAgICAgIHNldExhYldoaXRlUG9pbnQoJ2Q1MCcpO1xuICAgICAgICAgICAgdmFyIHJnYiQ0ID0gcm91bmRSR0IobGFiMnJnYihsYWIpKTtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgYmFjayB0byBvcmlnaW5hbCBMYWIgd2hpdGVwb2ludFxuICAgICAgICAgICAgc2V0TGFiV2hpdGVQb2ludCh3cCk7XG4gICAgICAgICAgICB2YXIgYWxwaGEkMiA9IG1bNF0gIT09IHVuZGVmaW5lZCA/ICtwZXJjZW50VG9BYnNvbHV0ZShtWzRdLCAwLCAxKSA6IDE7XG4gICAgICAgICAgICByZ2IkNFszXSA9IGFscGhhJDI7XG4gICAgICAgICAgICByZXR1cm4gcmdiJDQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfTENIKSkpIHtcbiAgICAgICAgICAgIHZhciBsY2ggPSBtLnNsaWNlKDEsIDQpO1xuICAgICAgICAgICAgbGNoWzBdID0gcGVyY2VudFRvQWJzb2x1dGUobGNoWzBdLCAwLCAxMDApO1xuICAgICAgICAgICAgbGNoWzFdID0gcGVyY2VudFRvQWJzb2x1dGUobm9uZVRvVmFsdWUobGNoWzFdLCAwKSwgMCwgMTUwLCBmYWxzZSk7XG4gICAgICAgICAgICBsY2hbMl0gPSArbm9uZVRvVmFsdWUobGNoWzJdLnJlcGxhY2UoJ2RlZycsICcnKSwgMCk7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvIEQ1MCBMYWIgd2hpdGVwb2ludFxuICAgICAgICAgICAgdmFyIHdwJDEgPSBnZXRMYWJXaGl0ZVBvaW50KCk7XG4gICAgICAgICAgICBzZXRMYWJXaGl0ZVBvaW50KCdkNTAnKTtcbiAgICAgICAgICAgIHZhciByZ2IkNSA9IHJvdW5kUkdCKGxjaDJyZ2IobGNoKSk7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IGJhY2sgdG8gb3JpZ2luYWwgTGFiIHdoaXRlcG9pbnRcbiAgICAgICAgICAgIHNldExhYldoaXRlUG9pbnQod3AkMSk7XG4gICAgICAgICAgICB2YXIgYWxwaGEkMyA9IG1bNF0gIT09IHVuZGVmaW5lZCA/ICtwZXJjZW50VG9BYnNvbHV0ZShtWzRdLCAwLCAxKSA6IDE7XG4gICAgICAgICAgICByZ2IkNVszXSA9IGFscGhhJDM7XG4gICAgICAgICAgICByZXR1cm4gcmdiJDU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfT0tMQUIpKSkge1xuICAgICAgICAgICAgdmFyIG9rbGFiID0gbS5zbGljZSgxLCA0KTtcbiAgICAgICAgICAgIG9rbGFiWzBdID0gcGVyY2VudFRvQWJzb2x1dGUobm9uZVRvVmFsdWUob2tsYWJbMF0sIDApLCAwLCAxKTtcbiAgICAgICAgICAgIG9rbGFiWzFdID0gcGVyY2VudFRvQWJzb2x1dGUobm9uZVRvVmFsdWUob2tsYWJbMV0sIDApLCAtMC40LCAwLjQsIHRydWUpO1xuICAgICAgICAgICAgb2tsYWJbMl0gPSBwZXJjZW50VG9BYnNvbHV0ZShub25lVG9WYWx1ZShva2xhYlsyXSwgMCksIC0wLjQsIDAuNCwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcmdiJDYgPSByb3VuZFJHQihva2xhYjJyZ2Iob2tsYWIpKTtcbiAgICAgICAgICAgIHZhciBhbHBoYSQ0ID0gbVs0XSAhPT0gdW5kZWZpbmVkID8gK3BlcmNlbnRUb0Fic29sdXRlKG1bNF0sIDAsIDEpIDogMTtcbiAgICAgICAgICAgIHJnYiQ2WzNdID0gYWxwaGEkNDtcbiAgICAgICAgICAgIHJldHVybiByZ2IkNjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9PS0xDSCkpKSB7XG4gICAgICAgICAgICB2YXIgb2tsY2ggPSBtLnNsaWNlKDEsIDQpO1xuICAgICAgICAgICAgb2tsY2hbMF0gPSBwZXJjZW50VG9BYnNvbHV0ZShub25lVG9WYWx1ZShva2xjaFswXSwgMCksIDAsIDEpO1xuICAgICAgICAgICAgb2tsY2hbMV0gPSBwZXJjZW50VG9BYnNvbHV0ZShub25lVG9WYWx1ZShva2xjaFsxXSwgMCksIDAsIDAuNCwgZmFsc2UpO1xuICAgICAgICAgICAgb2tsY2hbMl0gPSArbm9uZVRvVmFsdWUob2tsY2hbMl0ucmVwbGFjZSgnZGVnJywgJycpLCAwKTtcbiAgICAgICAgICAgIHZhciByZ2IkNyA9IHJvdW5kUkdCKG9rbGNoMnJnYihva2xjaCkpO1xuICAgICAgICAgICAgdmFyIGFscGhhJDUgPSBtWzRdICE9PSB1bmRlZmluZWQgPyArcGVyY2VudFRvQWJzb2x1dGUobVs0XSwgMCwgMSkgOiAxO1xuICAgICAgICAgICAgcmdiJDdbM10gPSBhbHBoYSQ1O1xuICAgICAgICAgICAgcmV0dXJuIHJnYiQ3O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNzczJyZ2IudGVzdCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvLyBtb2Rlcm5cbiAgICAgICAgICAgIFJFX1JHQi50ZXN0KHMpIHx8XG4gICAgICAgICAgICBSRV9IU0wudGVzdChzKSB8fFxuICAgICAgICAgICAgUkVfTEFCLnRlc3QocykgfHxcbiAgICAgICAgICAgIFJFX0xDSC50ZXN0KHMpIHx8XG4gICAgICAgICAgICBSRV9PS0xBQi50ZXN0KHMpIHx8XG4gICAgICAgICAgICBSRV9PS0xDSC50ZXN0KHMpIHx8XG4gICAgICAgICAgICAvLyBsZWdhY3lcbiAgICAgICAgICAgIFJFX1JHQl9MRUdBQ1kudGVzdChzKSB8fFxuICAgICAgICAgICAgUkVfUkdCQV9MRUdBQ1kudGVzdChzKSB8fFxuICAgICAgICAgICAgUkVfSFNMX0xFR0FDWS50ZXN0KHMpIHx8XG4gICAgICAgICAgICBSRV9IU0xBX0xFR0FDWS50ZXN0KHMpIHx8XG4gICAgICAgICAgICBzID09PSAndHJhbnNwYXJlbnQnXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIENvbG9yLnByb3RvdHlwZS5jc3MgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgICAgICByZXR1cm4gcmdiMmNzcyh0aGlzLl9yZ2IsIG1vZGUpO1xuICAgIH07XG5cbiAgICB2YXIgY3NzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2NzcyddKSApKTtcbiAgICB9O1xuICAgIGNocm9tYS5jc3MgPSBjc3M7XG5cbiAgICBpbnB1dC5mb3JtYXQuY3NzID0gY3NzMnJnYjtcblxuICAgIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDUsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdCA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gPiAwICkgcmVzdFsgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgICAgICAgICAgaWYgKCFyZXN0Lmxlbmd0aCAmJiB0eXBlKGgpID09PSAnc3RyaW5nJyAmJiBjc3MycmdiLnRlc3QoaCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Nzcyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlucHV0LmZvcm1hdC5nbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmdiID0gdW5wYWNrKGFyZ3MsICdyZ2JhJyk7XG4gICAgICAgIHJnYlswXSAqPSAyNTU7XG4gICAgICAgIHJnYlsxXSAqPSAyNTU7XG4gICAgICAgIHJnYlsyXSAqPSAyNTU7XG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfTtcblxuICAgIHZhciBnbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydnbCddKSApKTtcbiAgICB9O1xuICAgIGNocm9tYS5nbCA9IGdsO1xuXG4gICAgQ29sb3IucHJvdG90eXBlLmdsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmdiID0gdGhpcy5fcmdiO1xuICAgICAgICByZXR1cm4gW3JnYlswXSAvIDI1NSwgcmdiWzFdIC8gMjU1LCByZ2JbMl0gLyAyNTUsIHJnYlszXV07XG4gICAgfTtcblxuICAgIHZhciBmbG9vciQzID0gTWF0aC5mbG9vcjtcblxuICAgIC8qXG4gICAgICogdGhpcyBpcyBiYXNpY2FsbHkganVzdCBIU1Ygd2l0aCBzb21lIG1pbm9yIHR3ZWFrc1xuICAgICAqXG4gICAgICogaHVlLi4gWzAuLjM2MF1cbiAgICAgKiBjaHJvbWEgLi4gWzAuLjFdXG4gICAgICogZ3JheW5lc3MgLi4gWzAuLjFdXG4gICAgICovXG5cbiAgICB2YXIgaGNnMnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFzc2lnbiwgYXNzaWduJDEsIGFzc2lnbiQyLCBhc3NpZ24kMywgYXNzaWduJDQsIGFzc2lnbiQ1O1xuXG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG4gICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2hjZycpO1xuICAgICAgICB2YXIgaCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBjID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIF9nID0gYXJnc1syXTtcbiAgICAgICAgdmFyIHIsIGcsIGI7XG4gICAgICAgIF9nID0gX2cgKiAyNTU7XG4gICAgICAgIHZhciBfYyA9IGMgKiAyNTU7XG4gICAgICAgIGlmIChjID09PSAwKSB7XG4gICAgICAgICAgICByID0gZyA9IGIgPSBfZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoID09PSAzNjApIHsgaCA9IDA7IH1cbiAgICAgICAgICAgIGlmIChoID4gMzYwKSB7IGggLT0gMzYwOyB9XG4gICAgICAgICAgICBpZiAoaCA8IDApIHsgaCArPSAzNjA7IH1cbiAgICAgICAgICAgIGggLz0gNjA7XG4gICAgICAgICAgICB2YXIgaSA9IGZsb29yJDMoaCk7XG4gICAgICAgICAgICB2YXIgZiA9IGggLSBpO1xuICAgICAgICAgICAgdmFyIHAgPSBfZyAqICgxIC0gYyk7XG4gICAgICAgICAgICB2YXIgcSA9IHAgKyBfYyAqICgxIC0gZik7XG4gICAgICAgICAgICB2YXIgdCA9IHAgKyBfYyAqIGY7XG4gICAgICAgICAgICB2YXIgdiA9IHAgKyBfYztcbiAgICAgICAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgKGFzc2lnbiA9IFt2LCB0LCBwXSwgciA9IGFzc2lnblswXSwgZyA9IGFzc2lnblsxXSwgYiA9IGFzc2lnblsyXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgKGFzc2lnbiQxID0gW3EsIHYsIHBdLCByID0gYXNzaWduJDFbMF0sIGcgPSBhc3NpZ24kMVsxXSwgYiA9IGFzc2lnbiQxWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAoYXNzaWduJDIgPSBbcCwgdiwgdF0sIHIgPSBhc3NpZ24kMlswXSwgZyA9IGFzc2lnbiQyWzFdLCBiID0gYXNzaWduJDJbMl0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIChhc3NpZ24kMyA9IFtwLCBxLCB2XSwgciA9IGFzc2lnbiQzWzBdLCBnID0gYXNzaWduJDNbMV0sIGIgPSBhc3NpZ24kM1syXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgKGFzc2lnbiQ0ID0gW3QsIHAsIHZdLCByID0gYXNzaWduJDRbMF0sIGcgPSBhc3NpZ24kNFsxXSwgYiA9IGFzc2lnbiQ0WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAoYXNzaWduJDUgPSBbdiwgcCwgcV0sIHIgPSBhc3NpZ24kNVswXSwgZyA9IGFzc2lnbiQ1WzFdLCBiID0gYXNzaWduJDVbMl0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3IsIGcsIGIsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJoY2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgdmFyIHJlZiA9IHVucGFjayhhcmdzLCAncmdiJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciBtaW5SZ2IgPSBtaW4kMyhyLCBnLCBiKTtcbiAgICAgICAgdmFyIG1heFJnYiA9IG1heCQzKHIsIGcsIGIpO1xuICAgICAgICB2YXIgZGVsdGEgPSBtYXhSZ2IgLSBtaW5SZ2I7XG4gICAgICAgIHZhciBjID0gKGRlbHRhICogMTAwKSAvIDI1NTtcbiAgICAgICAgdmFyIF9nID0gKG1pblJnYiAvICgyNTUgLSBkZWx0YSkpICogMTAwO1xuICAgICAgICB2YXIgaDtcbiAgICAgICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgICAgICBoID0gTnVtYmVyLk5hTjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyID09PSBtYXhSZ2IpIHsgaCA9IChnIC0gYikgLyBkZWx0YTsgfVxuICAgICAgICAgICAgaWYgKGcgPT09IG1heFJnYikgeyBoID0gMiArIChiIC0gcikgLyBkZWx0YTsgfVxuICAgICAgICAgICAgaWYgKGIgPT09IG1heFJnYikgeyBoID0gNCArIChyIC0gZykgLyBkZWx0YTsgfVxuICAgICAgICAgICAgaCAqPSA2MDtcbiAgICAgICAgICAgIGlmIChoIDwgMCkgeyBoICs9IDM2MDsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbaCwgYywgX2ddO1xuICAgIH07XG5cbiAgICBDb2xvci5wcm90b3R5cGUuaGNnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmdiMmhjZyh0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICB2YXIgaGNnJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaGNnJ10pICkpO1xuICAgIH07XG4gICAgY2hyb21hLmhjZyA9IGhjZyQxO1xuXG4gICAgaW5wdXQuZm9ybWF0LmhjZyA9IGhjZzJyZ2I7XG5cbiAgICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAxLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayhhcmdzLCAnaGNnJyk7XG4gICAgICAgICAgICBpZiAodHlwZShhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaGNnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIFJFX0hFWCA9IC9eIz8oW0EtRmEtZjAtOV17Nn18W0EtRmEtZjAtOV17M30pJC87XG4gICAgdmFyIFJFX0hFWEEgPSAvXiM/KFtBLUZhLWYwLTldezh9fFtBLUZhLWYwLTldezR9KSQvO1xuXG4gICAgdmFyIGhleDJyZ2IgPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgICAgIGlmIChoZXgubWF0Y2goUkVfSEVYKSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG9wdGlvbmFsIGxlYWRpbmcgI1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDQgfHwgaGV4Lmxlbmd0aCA9PT0gNykge1xuICAgICAgICAgICAgICAgIGhleCA9IGhleC5zdWJzdHIoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBleHBhbmQgc2hvcnQtbm90YXRpb24gdG8gZnVsbCBzaXgtZGlnaXRcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gaGV4LnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICBoZXggPSBoZXhbMF0gKyBoZXhbMF0gKyBoZXhbMV0gKyBoZXhbMV0gKyBoZXhbMl0gKyBoZXhbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICAgICAgdmFyIHIgPSB1ID4+IDE2O1xuICAgICAgICAgICAgdmFyIGcgPSAodSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICB2YXIgYiA9IHUgJiAweGZmO1xuICAgICAgICAgICAgcmV0dXJuIFtyLCBnLCBiLCAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1hdGNoIHJnYmEgaGV4IGZvcm1hdCwgZWcgI0ZGMDAwMDc3XG4gICAgICAgIGlmIChoZXgubWF0Y2goUkVfSEVYQSkpIHtcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoID09PSA1IHx8IGhleC5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgb3B0aW9uYWwgbGVhZGluZyAjXG4gICAgICAgICAgICAgICAgaGV4ID0gaGV4LnN1YnN0cigxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGV4cGFuZCBzaG9ydC1ub3RhdGlvbiB0byBmdWxsIGVpZ2h0LWRpZ2l0XG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGhleCA9IGhleC5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgaGV4ID1cbiAgICAgICAgICAgICAgICAgICAgaGV4WzBdICtcbiAgICAgICAgICAgICAgICAgICAgaGV4WzBdICtcbiAgICAgICAgICAgICAgICAgICAgaGV4WzFdICtcbiAgICAgICAgICAgICAgICAgICAgaGV4WzFdICtcbiAgICAgICAgICAgICAgICAgICAgaGV4WzJdICtcbiAgICAgICAgICAgICAgICAgICAgaGV4WzJdICtcbiAgICAgICAgICAgICAgICAgICAgaGV4WzNdICtcbiAgICAgICAgICAgICAgICAgICAgaGV4WzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHUkMSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICAgICAgdmFyIHIkMSA9ICh1JDEgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgICAgIHZhciBnJDEgPSAodSQxID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICB2YXIgYiQxID0gKHUkMSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICB2YXIgYSA9IE1hdGgucm91bmQoKCh1JDEgJiAweGZmKSAvIDB4ZmYpICogMTAwKSAvIDEwMDtcbiAgICAgICAgICAgIHJldHVybiBbciQxLCBnJDEsIGIkMSwgYV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSB1c2VkIHRvIGNoZWNrIGZvciBjc3MgY29sb3JzIGhlcmVcbiAgICAgICAgLy8gaWYgX2lucHV0LmNzcz8gYW5kIHJnYiA9IF9pbnB1dC5jc3MgaGV4XG4gICAgICAgIC8vICAgICByZXR1cm4gcmdiXG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcInVua25vd24gaGV4IGNvbG9yOiBcIiArIGhleCkpO1xuICAgIH07XG5cbiAgICB2YXIgcm91bmQkMiA9IE1hdGgucm91bmQ7XG5cbiAgICB2YXIgcmdiMmhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrKGFyZ3MsICdyZ2JhJyk7XG4gICAgICAgIHZhciByID0gcmVmWzBdO1xuICAgICAgICB2YXIgZyA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMl07XG4gICAgICAgIHZhciBhID0gcmVmWzNdO1xuICAgICAgICB2YXIgbW9kZSA9IGxhc3QoYXJncykgfHwgJ2F1dG8nO1xuICAgICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7IGEgPSAxOyB9XG4gICAgICAgIGlmIChtb2RlID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIG1vZGUgPSBhIDwgMSA/ICdyZ2JhJyA6ICdyZ2InO1xuICAgICAgICB9XG4gICAgICAgIHIgPSByb3VuZCQyKHIpO1xuICAgICAgICBnID0gcm91bmQkMihnKTtcbiAgICAgICAgYiA9IHJvdW5kJDIoYik7XG4gICAgICAgIHZhciB1ID0gKHIgPDwgMTYpIHwgKGcgPDwgOCkgfCBiO1xuICAgICAgICB2YXIgc3RyID0gJzAwMDAwMCcgKyB1LnRvU3RyaW5nKDE2KTsgLy8jLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoc3RyLmxlbmd0aCAtIDYpO1xuICAgICAgICB2YXIgaHhhID0gJzAnICsgcm91bmQkMihhICogMjU1KS50b1N0cmluZygxNik7XG4gICAgICAgIGh4YSA9IGh4YS5zdWJzdHIoaHhhLmxlbmd0aCAtIDIpO1xuICAgICAgICBzd2l0Y2ggKG1vZGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcIiNcIiArIHN0ciArIGh4YSk7XG4gICAgICAgICAgICBjYXNlICdhcmdiJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKFwiI1wiICsgaHhhICsgc3RyKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcIiNcIiArIHN0cik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29sb3IucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgICAgIHJldHVybiByZ2IyaGV4KHRoaXMuX3JnYiwgbW9kZSk7XG4gICAgfTtcblxuICAgIHZhciBoZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnaGV4J10pICkpO1xuICAgIH07XG4gICAgY2hyb21hLmhleCA9IGhleDtcblxuICAgIGlucHV0LmZvcm1hdC5oZXggPSBoZXgycmdiO1xuICAgIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDQsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdCA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gPiAwICkgcmVzdFsgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFyZXN0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHR5cGUoaCkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgWzMsIDQsIDUsIDYsIDcsIDgsIDldLmluZGV4T2YoaC5sZW5ndGgpID49IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaGV4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGNvcyQzID0gTWF0aC5jb3M7XG5cbiAgICAvKlxuICAgICAqIGh1ZSBbMC4uMzYwXVxuICAgICAqIHNhdHVyYXRpb24gWzAuLjFdXG4gICAgICogaW50ZW5zaXR5IFswLi4xXVxuICAgICAqL1xuICAgIHZhciBoc2kycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIC8qXG4gICAgICAgIGJvcnJvd2VkIGZyb20gaGVyZTpcbiAgICAgICAgaHR0cDovL2h1bW1lci5zdGFuZm9yZC5lZHUvbXVzZWluZm8vZG9jL2V4YW1wbGVzL2h1bWRydW0va2V5c2NhcGUyL2hzaTJyZ2IuY3BwXG4gICAgICAgICovXG4gICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2hzaScpO1xuICAgICAgICB2YXIgaCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBzID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGkgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgciwgZywgYjtcblxuICAgICAgICBpZiAoaXNOYU4oaCkpIHsgaCA9IDA7IH1cbiAgICAgICAgaWYgKGlzTmFOKHMpKSB7IHMgPSAwOyB9XG4gICAgICAgIC8vIG5vcm1hbGl6ZSBodWVcbiAgICAgICAgaWYgKGggPiAzNjApIHsgaCAtPSAzNjA7IH1cbiAgICAgICAgaWYgKGggPCAwKSB7IGggKz0gMzYwOyB9XG4gICAgICAgIGggLz0gMzYwO1xuICAgICAgICBpZiAoaCA8IDEgLyAzKSB7XG4gICAgICAgICAgICBiID0gKDEgLSBzKSAvIDM7XG4gICAgICAgICAgICByID0gKDEgKyAocyAqIGNvcyQzKFRXT1BJICogaCkpIC8gY29zJDMoUElUSElSRCAtIFRXT1BJICogaCkpIC8gMztcbiAgICAgICAgICAgIGcgPSAxIC0gKGIgKyByKTtcbiAgICAgICAgfSBlbHNlIGlmIChoIDwgMiAvIDMpIHtcbiAgICAgICAgICAgIGggLT0gMSAvIDM7XG4gICAgICAgICAgICByID0gKDEgLSBzKSAvIDM7XG4gICAgICAgICAgICBnID0gKDEgKyAocyAqIGNvcyQzKFRXT1BJICogaCkpIC8gY29zJDMoUElUSElSRCAtIFRXT1BJICogaCkpIC8gMztcbiAgICAgICAgICAgIGIgPSAxIC0gKHIgKyBnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGggLT0gMiAvIDM7XG4gICAgICAgICAgICBnID0gKDEgLSBzKSAvIDM7XG4gICAgICAgICAgICBiID0gKDEgKyAocyAqIGNvcyQzKFRXT1BJICogaCkpIC8gY29zJDMoUElUSElSRCAtIFRXT1BJICogaCkpIC8gMztcbiAgICAgICAgICAgIHIgPSAxIC0gKGcgKyBiKTtcbiAgICAgICAgfVxuICAgICAgICByID0gbGltaXQoaSAqIHIgKiAzKTtcbiAgICAgICAgZyA9IGxpbWl0KGkgKiBnICogMyk7XG4gICAgICAgIGIgPSBsaW1pdChpICogYiAqIDMpO1xuICAgICAgICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTUsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgICB9O1xuXG4gICAgdmFyIG1pbiQyID0gTWF0aC5taW47XG4gICAgdmFyIHNxcnQkMyA9IE1hdGguc3FydDtcbiAgICB2YXIgYWNvcyA9IE1hdGguYWNvcztcblxuICAgIHZhciByZ2IyaHNpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIC8qXG4gICAgICAgIGJvcnJvd2VkIGZyb20gaGVyZTpcbiAgICAgICAgaHR0cDovL2h1bW1lci5zdGFuZm9yZC5lZHUvbXVzZWluZm8vZG9jL2V4YW1wbGVzL2h1bWRydW0va2V5c2NhcGUyL3JnYjJoc2kuY3BwXG4gICAgICAgICovXG4gICAgICAgIHZhciByZWYgPSB1bnBhY2soYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IHJlZlswXTtcbiAgICAgICAgdmFyIGcgPSByZWZbMV07XG4gICAgICAgIHZhciBiID0gcmVmWzJdO1xuICAgICAgICByIC89IDI1NTtcbiAgICAgICAgZyAvPSAyNTU7XG4gICAgICAgIGIgLz0gMjU1O1xuICAgICAgICB2YXIgaDtcbiAgICAgICAgdmFyIG1pbl8gPSBtaW4kMihyLCBnLCBiKTtcbiAgICAgICAgdmFyIGkgPSAociArIGcgKyBiKSAvIDM7XG4gICAgICAgIHZhciBzID0gaSA+IDAgPyAxIC0gbWluXyAvIGkgOiAwO1xuICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgaCA9IE5hTjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGggPSAociAtIGcgKyAociAtIGIpKSAvIDI7XG4gICAgICAgICAgICBoIC89IHNxcnQkMygociAtIGcpICogKHIgLSBnKSArIChyIC0gYikgKiAoZyAtIGIpKTtcbiAgICAgICAgICAgIGggPSBhY29zKGgpO1xuICAgICAgICAgICAgaWYgKGIgPiBnKSB7XG4gICAgICAgICAgICAgICAgaCA9IFRXT1BJIC0gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGggLz0gVFdPUEk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtoICogMzYwLCBzLCBpXTtcbiAgICB9O1xuXG4gICAgQ29sb3IucHJvdG90eXBlLmhzaSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJoc2kodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgdmFyIGhzaSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2hzaSddKSApKTtcbiAgICB9O1xuICAgIGNocm9tYS5oc2kgPSBoc2kkMTtcblxuICAgIGlucHV0LmZvcm1hdC5oc2kgPSBoc2kycmdiO1xuXG4gICAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2hzaScpO1xuICAgICAgICAgICAgaWYgKHR5cGUoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hzaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIENvbG9yLnByb3RvdHlwZS5oc2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZ2IyaHNsJDEodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgdmFyIGhzbCQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2hzbCddKSApKTtcbiAgICB9O1xuICAgIGNocm9tYS5oc2wgPSBoc2wkMTtcblxuICAgIGlucHV0LmZvcm1hdC5oc2wgPSBoc2wycmdiO1xuXG4gICAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2hzbCcpO1xuICAgICAgICAgICAgaWYgKHR5cGUoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hzbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBmbG9vciQyID0gTWF0aC5mbG9vcjtcblxuICAgIHZhciBoc3YycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXNzaWduLCBhc3NpZ24kMSwgYXNzaWduJDIsIGFzc2lnbiQzLCBhc3NpZ24kNCwgYXNzaWduJDU7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcbiAgICAgICAgYXJncyA9IHVucGFjayhhcmdzLCAnaHN2Jyk7XG4gICAgICAgIHZhciBoID0gYXJnc1swXTtcbiAgICAgICAgdmFyIHMgPSBhcmdzWzFdO1xuICAgICAgICB2YXIgdiA9IGFyZ3NbMl07XG4gICAgICAgIHZhciByLCBnLCBiO1xuICAgICAgICB2ICo9IDI1NTtcbiAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIHIgPSBnID0gYiA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaCA9PT0gMzYwKSB7IGggPSAwOyB9XG4gICAgICAgICAgICBpZiAoaCA+IDM2MCkgeyBoIC09IDM2MDsgfVxuICAgICAgICAgICAgaWYgKGggPCAwKSB7IGggKz0gMzYwOyB9XG4gICAgICAgICAgICBoIC89IDYwO1xuXG4gICAgICAgICAgICB2YXIgaSA9IGZsb29yJDIoaCk7XG4gICAgICAgICAgICB2YXIgZiA9IGggLSBpO1xuICAgICAgICAgICAgdmFyIHAgPSB2ICogKDEgLSBzKTtcbiAgICAgICAgICAgIHZhciBxID0gdiAqICgxIC0gcyAqIGYpO1xuICAgICAgICAgICAgdmFyIHQgPSB2ICogKDEgLSBzICogKDEgLSBmKSk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgKGFzc2lnbiA9IFt2LCB0LCBwXSwgciA9IGFzc2lnblswXSwgZyA9IGFzc2lnblsxXSwgYiA9IGFzc2lnblsyXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgKGFzc2lnbiQxID0gW3EsIHYsIHBdLCByID0gYXNzaWduJDFbMF0sIGcgPSBhc3NpZ24kMVsxXSwgYiA9IGFzc2lnbiQxWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAoYXNzaWduJDIgPSBbcCwgdiwgdF0sIHIgPSBhc3NpZ24kMlswXSwgZyA9IGFzc2lnbiQyWzFdLCBiID0gYXNzaWduJDJbMl0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIChhc3NpZ24kMyA9IFtwLCBxLCB2XSwgciA9IGFzc2lnbiQzWzBdLCBnID0gYXNzaWduJDNbMV0sIGIgPSBhc3NpZ24kM1syXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgKGFzc2lnbiQ0ID0gW3QsIHAsIHZdLCByID0gYXNzaWduJDRbMF0sIGcgPSBhc3NpZ24kNFsxXSwgYiA9IGFzc2lnbiQ0WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAoYXNzaWduJDUgPSBbdiwgcCwgcV0sIHIgPSBhc3NpZ24kNVswXSwgZyA9IGFzc2lnbiQ1WzFdLCBiID0gYXNzaWduJDVbMl0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3IsIGcsIGIsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbiAgICB9O1xuXG4gICAgdmFyIG1pbiQxID0gTWF0aC5taW47XG4gICAgdmFyIG1heCQxID0gTWF0aC5tYXg7XG5cbiAgICAvKlxuICAgICAqIHN1cHBvcnRlZCBhcmd1bWVudHM6XG4gICAgICogLSByZ2IyaHN2KHIsZyxiKVxuICAgICAqIC0gcmdiMmhzdihbcixnLGJdKVxuICAgICAqIC0gcmdiMmhzdih7cixnLGJ9KVxuICAgICAqL1xuICAgIHZhciByZ2IyaHNsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ3JnYicpO1xuICAgICAgICB2YXIgciA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBnID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGIgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgbWluXyA9IG1pbiQxKHIsIGcsIGIpO1xuICAgICAgICB2YXIgbWF4XyA9IG1heCQxKHIsIGcsIGIpO1xuICAgICAgICB2YXIgZGVsdGEgPSBtYXhfIC0gbWluXztcbiAgICAgICAgdmFyIGgsIHMsIHY7XG4gICAgICAgIHYgPSBtYXhfIC8gMjU1LjA7XG4gICAgICAgIGlmIChtYXhfID09PSAwKSB7XG4gICAgICAgICAgICBoID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgIHMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcyA9IGRlbHRhIC8gbWF4XztcbiAgICAgICAgICAgIGlmIChyID09PSBtYXhfKSB7IGggPSAoZyAtIGIpIC8gZGVsdGE7IH1cbiAgICAgICAgICAgIGlmIChnID09PSBtYXhfKSB7IGggPSAyICsgKGIgLSByKSAvIGRlbHRhOyB9XG4gICAgICAgICAgICBpZiAoYiA9PT0gbWF4XykgeyBoID0gNCArIChyIC0gZykgLyBkZWx0YTsgfVxuICAgICAgICAgICAgaCAqPSA2MDtcbiAgICAgICAgICAgIGlmIChoIDwgMCkgeyBoICs9IDM2MDsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbaCwgcywgdl07XG4gICAgfTtcblxuICAgIENvbG9yLnByb3RvdHlwZS5oc3YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZ2IyaHNsKHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIHZhciBoc3YkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydoc3YnXSkgKSk7XG4gICAgfTtcbiAgICBjaHJvbWEuaHN2ID0gaHN2JDE7XG5cbiAgICBpbnB1dC5mb3JtYXQuaHN2ID0gaHN2MnJnYjtcblxuICAgIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDIsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdoc3YnKTtcbiAgICAgICAgICAgIGlmICh0eXBlKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdoc3YnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBDb2xvci5wcm90b3R5cGUubGFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmdiMmxhYih0aGlzLl9yZ2IpO1xuICAgIH07XG5cbiAgICB2YXIgbGFiJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnbGFiJ10pICkpO1xuICAgIH07XG4gICAgT2JqZWN0LmFzc2lnbihjaHJvbWEsIHsgbGFiOiBsYWIkMSwgZ2V0TGFiV2hpdGVQb2ludDogZ2V0TGFiV2hpdGVQb2ludCwgc2V0TGFiV2hpdGVQb2ludDogc2V0TGFiV2hpdGVQb2ludCB9KTtcblxuICAgIGlucHV0LmZvcm1hdC5sYWIgPSBsYWIycmdiO1xuXG4gICAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogMixcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2xhYicpO1xuICAgICAgICAgICAgaWYgKHR5cGUoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2xhYic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBoY2wycmdiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHZhciBoY2wgPSByZXZlcnNlMyh1bnBhY2soYXJncywgJ2hjbCcpKTtcbiAgICAgICAgcmV0dXJuIGxjaDJyZ2IuYXBwbHkodm9pZCAwLCBoY2wpO1xuICAgIH07XG5cbiAgICBDb2xvci5wcm90b3R5cGUubGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmdiMmxjaCh0aGlzLl9yZ2IpO1xuICAgIH07XG4gICAgQ29sb3IucHJvdG90eXBlLmhjbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJldmVyc2UzKHJnYjJsY2godGhpcy5fcmdiKSk7XG4gICAgfTtcblxuICAgIHZhciBsY2gkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydsY2gnXSkgKSk7XG4gICAgfTtcbiAgICB2YXIgaGNsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ2hjbCddKSApKTtcbiAgICB9O1xuXG4gICAgT2JqZWN0LmFzc2lnbihjaHJvbWEsIHsgbGNoOiBsY2gkMSwgaGNsOiBoY2wgfSk7XG5cbiAgICBpbnB1dC5mb3JtYXQubGNoID0gbGNoMnJnYjtcbiAgICBpbnB1dC5mb3JtYXQuaGNsID0gaGNsMnJnYjtcbiAgICBbJ2xjaCcsICdoY2wnXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldHVybiBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICAgICAgcDogMixcbiAgICAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgICAgICBhcmdzID0gdW5wYWNrKGFyZ3MsIG0pO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7IH1cbiAgICApO1xuXG4gICAgdmFyIG51bTJyZ2IgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgIGlmICh0eXBlKG51bSkgPT0gJ251bWJlcicgJiYgbnVtID49IDAgJiYgbnVtIDw9IDB4ZmZmZmZmKSB7XG4gICAgICAgICAgICB2YXIgciA9IG51bSA+PiAxNjtcbiAgICAgICAgICAgIHZhciBnID0gKG51bSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICB2YXIgYiA9IG51bSAmIDB4ZmY7XG4gICAgICAgICAgICByZXR1cm4gW3IsIGcsIGIsIDFdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBudW0gY29sb3I6ICcgKyBudW0pO1xuICAgIH07XG5cbiAgICB2YXIgcmdiMm51bSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmVmID0gdW5wYWNrKGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSByZWZbMF07XG4gICAgICAgIHZhciBnID0gcmVmWzFdO1xuICAgICAgICB2YXIgYiA9IHJlZlsyXTtcbiAgICAgICAgcmV0dXJuIChyIDw8IDE2KSArIChnIDw8IDgpICsgYjtcbiAgICB9O1xuXG4gICAgQ29sb3IucHJvdG90eXBlLm51bSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJnYjJudW0odGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgdmFyIG51bSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ251bSddKSApKTtcbiAgICB9O1xuXG4gICAgT2JqZWN0LmFzc2lnbihjaHJvbWEsIHsgbnVtOiBudW0kMSB9KTtcblxuICAgIGlucHV0LmZvcm1hdC5udW0gPSBudW0ycmdiO1xuXG4gICAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogNSxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBhcmdzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIHR5cGUoYXJnc1swXSkgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgYXJnc1swXSA+PSAwICYmXG4gICAgICAgICAgICAgICAgYXJnc1swXSA8PSAweGZmZmZmZlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudW0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcm91bmQkMSA9IE1hdGgucm91bmQ7XG5cbiAgICBDb2xvci5wcm90b3R5cGUucmdiID0gZnVuY3Rpb24gKHJuZCkge1xuICAgICAgICBpZiAoIHJuZCA9PT0gdm9pZCAwICkgcm5kID0gdHJ1ZTtcblxuICAgICAgICBpZiAocm5kID09PSBmYWxzZSkgeyByZXR1cm4gdGhpcy5fcmdiLnNsaWNlKDAsIDMpOyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZ2Iuc2xpY2UoMCwgMykubWFwKHJvdW5kJDEpO1xuICAgIH07XG5cbiAgICBDb2xvci5wcm90b3R5cGUucmdiYSA9IGZ1bmN0aW9uIChybmQpIHtcbiAgICAgICAgaWYgKCBybmQgPT09IHZvaWQgMCApIHJuZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JnYi5zbGljZSgwLCA0KS5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpIDwgMyA/IChybmQgPT09IGZhbHNlID8gdiA6IHJvdW5kJDEodikpIDogdjtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciByZ2IkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWydyZ2InXSkgKSk7XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKGNocm9tYSwgeyByZ2I6IHJnYiQxIH0pO1xuXG4gICAgaW5wdXQuZm9ybWF0LnJnYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmdiYSA9IHVucGFjayhhcmdzLCAncmdiYScpO1xuICAgICAgICBpZiAocmdiYVszXSA9PT0gdW5kZWZpbmVkKSB7IHJnYmFbM10gPSAxOyB9XG4gICAgICAgIHJldHVybiByZ2JhO1xuICAgIH07XG5cbiAgICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAzLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayhhcmdzLCAncmdiYScpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGUoYXJncykgPT09ICdhcnJheScgJiZcbiAgICAgICAgICAgICAgICAoYXJncy5sZW5ndGggPT09IDMgfHxcbiAgICAgICAgICAgICAgICAgICAgKGFyZ3MubGVuZ3RoID09PSA0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlKGFyZ3NbM10pID09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzNdID49IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbM10gPD0gMSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JnYic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qXG4gICAgICogQmFzZWQgb24gaW1wbGVtZW50YXRpb24gYnkgTmVpbCBCYXJ0bGV0dFxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWlsYmFydGxldHQvY29sb3ItdGVtcGVyYXR1cmVcbiAgICAgKi9cblxuICAgIHZhciBsb2ckMSA9IE1hdGgubG9nO1xuXG4gICAgdmFyIHRlbXBlcmF0dXJlMnJnYiA9IGZ1bmN0aW9uIChrZWx2aW4pIHtcbiAgICAgICAgdmFyIHRlbXAgPSBrZWx2aW4gLyAxMDA7XG4gICAgICAgIHZhciByLCBnLCBiO1xuICAgICAgICBpZiAodGVtcCA8IDY2KSB7XG4gICAgICAgICAgICByID0gMjU1O1xuICAgICAgICAgICAgZyA9XG4gICAgICAgICAgICAgICAgdGVtcCA8IDZcbiAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgIDogLTE1NS4yNTQ4NTU2MjcwOTE3OSAtXG4gICAgICAgICAgICAgICAgICAgICAgMC40NDU5Njk1MDQ2OTU3OTEzMyAqIChnID0gdGVtcCAtIDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAxMDQuNDkyMTYxOTkzOTM4ODggKiBsb2ckMShnKTtcbiAgICAgICAgICAgIGIgPVxuICAgICAgICAgICAgICAgIHRlbXAgPCAyMFxuICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgOiAtMjU0Ljc2OTM1MTg0MTIwOTAyICtcbiAgICAgICAgICAgICAgICAgICAgICAwLjgyNzQwOTYwNjQwMDczOTUgKiAoYiA9IHRlbXAgLSAxMCkgK1xuICAgICAgICAgICAgICAgICAgICAgIDExNS42Nzk5NDQwMTA2NjE0NyAqIGxvZyQxKGIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgciA9XG4gICAgICAgICAgICAgICAgMzUxLjk3NjkwNTY2ODA1NjkzICtcbiAgICAgICAgICAgICAgICAwLjExNDIwNjQ1Mzc4NDE2NSAqIChyID0gdGVtcCAtIDU1KSAtXG4gICAgICAgICAgICAgICAgNDAuMjUzNjYzMDkzMzIxMjcgKiBsb2ckMShyKTtcbiAgICAgICAgICAgIGcgPVxuICAgICAgICAgICAgICAgIDMyNS40NDk0MTI1NzExOTc0ICtcbiAgICAgICAgICAgICAgICAwLjA3OTQzNDU2NTM2NjYyMzQyICogKGcgPSB0ZW1wIC0gNTApIC1cbiAgICAgICAgICAgICAgICAyOC4wODUyOTYzNTA3OTU3ICogbG9nJDEoZyk7XG4gICAgICAgICAgICBiID0gMjU1O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbciwgZywgYiwgMV07XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogQmFzZWQgb24gaW1wbGVtZW50YXRpb24gYnkgTmVpbCBCYXJ0bGV0dFxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWlsYmFydGxldHQvY29sb3ItdGVtcGVyYXR1cmVcbiAgICAgKiovXG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuXG4gICAgdmFyIHJnYjJ0ZW1wZXJhdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB2YXIgcmdiID0gdW5wYWNrKGFyZ3MsICdyZ2InKTtcbiAgICAgICAgdmFyIHIgPSByZ2JbMF0sXG4gICAgICAgICAgICBiID0gcmdiWzJdO1xuICAgICAgICB2YXIgbWluVGVtcCA9IDEwMDA7XG4gICAgICAgIHZhciBtYXhUZW1wID0gNDAwMDA7XG4gICAgICAgIHZhciBlcHMgPSAwLjQ7XG4gICAgICAgIHZhciB0ZW1wO1xuICAgICAgICB3aGlsZSAobWF4VGVtcCAtIG1pblRlbXAgPiBlcHMpIHtcbiAgICAgICAgICAgIHRlbXAgPSAobWF4VGVtcCArIG1pblRlbXApICogMC41O1xuICAgICAgICAgICAgdmFyIHJnYiQxID0gdGVtcGVyYXR1cmUycmdiKHRlbXApO1xuICAgICAgICAgICAgaWYgKHJnYiQxWzJdIC8gcmdiJDFbMF0gPj0gYiAvIHIpIHtcbiAgICAgICAgICAgICAgICBtYXhUZW1wID0gdGVtcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWluVGVtcCA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdW5kKHRlbXApO1xuICAgIH07XG5cbiAgICBDb2xvci5wcm90b3R5cGUudGVtcCA9XG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5rZWx2aW4gPVxuICAgICAgICBDb2xvci5wcm90b3R5cGUudGVtcGVyYXR1cmUgPVxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZ2IydGVtcGVyYXR1cmUodGhpcy5fcmdiKTtcbiAgICAgICAgICAgIH07XG5cbiAgICB2YXIgdGVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IsIFsgbnVsbCBdLmNvbmNhdCggYXJncywgWyd0ZW1wJ10pICkpO1xuICAgIH07XG4gICAgT2JqZWN0LmFzc2lnbihjaHJvbWEsIHsgdGVtcDogdGVtcCwga2VsdmluOiB0ZW1wLCB0ZW1wZXJhdHVyZTogdGVtcCB9KTtcblxuICAgIGlucHV0LmZvcm1hdC50ZW1wID1cbiAgICAgICAgaW5wdXQuZm9ybWF0LmtlbHZpbiA9XG4gICAgICAgIGlucHV0LmZvcm1hdC50ZW1wZXJhdHVyZSA9XG4gICAgICAgICAgICB0ZW1wZXJhdHVyZTJyZ2I7XG5cbiAgICBDb2xvci5wcm90b3R5cGUub2tsYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZ2Iyb2tsYWIodGhpcy5fcmdiKTtcbiAgICB9O1xuXG4gICAgdmFyIG9rbGFiJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoIENvbG9yLCBbIG51bGwgXS5jb25jYXQoIGFyZ3MsIFsnb2tsYWInXSkgKSk7XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKGNocm9tYSwgeyBva2xhYjogb2tsYWIkMSB9KTtcblxuICAgIGlucHV0LmZvcm1hdC5va2xhYiA9IG9rbGFiMnJnYjtcblxuICAgIGlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgICAgIHA6IDIsXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgICAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdva2xhYicpO1xuICAgICAgICAgICAgaWYgKHR5cGUoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29rbGFiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgQ29sb3IucHJvdG90eXBlLm9rbGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmdiMm9rbGNoKHRoaXMuX3JnYik7XG4gICAgfTtcblxuICAgIHZhciBva2xjaCQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KCBDb2xvciwgWyBudWxsIF0uY29uY2F0KCBhcmdzLCBbJ29rbGNoJ10pICkpO1xuICAgIH07XG4gICAgT2JqZWN0LmFzc2lnbihjaHJvbWEsIHsgb2tsY2g6IG9rbGNoJDEgfSk7XG5cbiAgICBpbnB1dC5mb3JtYXQub2tsY2ggPSBva2xjaDJyZ2I7XG5cbiAgICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAyLFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICAgICAgYXJncyA9IHVucGFjayhhcmdzLCAnb2tsY2gnKTtcbiAgICAgICAgICAgIGlmICh0eXBlKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdva2xjaCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgIFx0WDExIGNvbG9yIG5hbWVzXG5cbiAgICBcdGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvI3N2Zy1jb2xvclxuICAgICovXG5cbiAgICB2YXIgdzNjeDExID0ge1xuICAgICAgICBhbGljZWJsdWU6ICcjZjBmOGZmJyxcbiAgICAgICAgYW50aXF1ZXdoaXRlOiAnI2ZhZWJkNycsXG4gICAgICAgIGFxdWE6ICcjMDBmZmZmJyxcbiAgICAgICAgYXF1YW1hcmluZTogJyM3ZmZmZDQnLFxuICAgICAgICBhenVyZTogJyNmMGZmZmYnLFxuICAgICAgICBiZWlnZTogJyNmNWY1ZGMnLFxuICAgICAgICBiaXNxdWU6ICcjZmZlNGM0JyxcbiAgICAgICAgYmxhY2s6ICcjMDAwMDAwJyxcbiAgICAgICAgYmxhbmNoZWRhbG1vbmQ6ICcjZmZlYmNkJyxcbiAgICAgICAgYmx1ZTogJyMwMDAwZmYnLFxuICAgICAgICBibHVldmlvbGV0OiAnIzhhMmJlMicsXG4gICAgICAgIGJyb3duOiAnI2E1MmEyYScsXG4gICAgICAgIGJ1cmx5d29vZDogJyNkZWI4ODcnLFxuICAgICAgICBjYWRldGJsdWU6ICcjNWY5ZWEwJyxcbiAgICAgICAgY2hhcnRyZXVzZTogJyM3ZmZmMDAnLFxuICAgICAgICBjaG9jb2xhdGU6ICcjZDI2OTFlJyxcbiAgICAgICAgY29yYWw6ICcjZmY3ZjUwJyxcbiAgICAgICAgY29ybmZsb3dlcmJsdWU6ICcjNjQ5NWVkJyxcbiAgICAgICAgY29ybnNpbGs6ICcjZmZmOGRjJyxcbiAgICAgICAgY3JpbXNvbjogJyNkYzE0M2MnLFxuICAgICAgICBjeWFuOiAnIzAwZmZmZicsXG4gICAgICAgIGRhcmtibHVlOiAnIzAwMDA4YicsXG4gICAgICAgIGRhcmtjeWFuOiAnIzAwOGI4YicsXG4gICAgICAgIGRhcmtnb2xkZW5yb2Q6ICcjYjg4NjBiJyxcbiAgICAgICAgZGFya2dyYXk6ICcjYTlhOWE5JyxcbiAgICAgICAgZGFya2dyZWVuOiAnIzAwNjQwMCcsXG4gICAgICAgIGRhcmtncmV5OiAnI2E5YTlhOScsXG4gICAgICAgIGRhcmtraGFraTogJyNiZGI3NmInLFxuICAgICAgICBkYXJrbWFnZW50YTogJyM4YjAwOGInLFxuICAgICAgICBkYXJrb2xpdmVncmVlbjogJyM1NTZiMmYnLFxuICAgICAgICBkYXJrb3JhbmdlOiAnI2ZmOGMwMCcsXG4gICAgICAgIGRhcmtvcmNoaWQ6ICcjOTkzMmNjJyxcbiAgICAgICAgZGFya3JlZDogJyM4YjAwMDAnLFxuICAgICAgICBkYXJrc2FsbW9uOiAnI2U5OTY3YScsXG4gICAgICAgIGRhcmtzZWFncmVlbjogJyM4ZmJjOGYnLFxuICAgICAgICBkYXJrc2xhdGVibHVlOiAnIzQ4M2Q4YicsXG4gICAgICAgIGRhcmtzbGF0ZWdyYXk6ICcjMmY0ZjRmJyxcbiAgICAgICAgZGFya3NsYXRlZ3JleTogJyMyZjRmNGYnLFxuICAgICAgICBkYXJrdHVycXVvaXNlOiAnIzAwY2VkMScsXG4gICAgICAgIGRhcmt2aW9sZXQ6ICcjOTQwMGQzJyxcbiAgICAgICAgZGVlcHBpbms6ICcjZmYxNDkzJyxcbiAgICAgICAgZGVlcHNreWJsdWU6ICcjMDBiZmZmJyxcbiAgICAgICAgZGltZ3JheTogJyM2OTY5NjknLFxuICAgICAgICBkaW1ncmV5OiAnIzY5Njk2OScsXG4gICAgICAgIGRvZGdlcmJsdWU6ICcjMWU5MGZmJyxcbiAgICAgICAgZmlyZWJyaWNrOiAnI2IyMjIyMicsXG4gICAgICAgIGZsb3JhbHdoaXRlOiAnI2ZmZmFmMCcsXG4gICAgICAgIGZvcmVzdGdyZWVuOiAnIzIyOGIyMicsXG4gICAgICAgIGZ1Y2hzaWE6ICcjZmYwMGZmJyxcbiAgICAgICAgZ2FpbnNib3JvOiAnI2RjZGNkYycsXG4gICAgICAgIGdob3N0d2hpdGU6ICcjZjhmOGZmJyxcbiAgICAgICAgZ29sZDogJyNmZmQ3MDAnLFxuICAgICAgICBnb2xkZW5yb2Q6ICcjZGFhNTIwJyxcbiAgICAgICAgZ3JheTogJyM4MDgwODAnLFxuICAgICAgICBncmVlbjogJyMwMDgwMDAnLFxuICAgICAgICBncmVlbnllbGxvdzogJyNhZGZmMmYnLFxuICAgICAgICBncmV5OiAnIzgwODA4MCcsXG4gICAgICAgIGhvbmV5ZGV3OiAnI2YwZmZmMCcsXG4gICAgICAgIGhvdHBpbms6ICcjZmY2OWI0JyxcbiAgICAgICAgaW5kaWFucmVkOiAnI2NkNWM1YycsXG4gICAgICAgIGluZGlnbzogJyM0YjAwODInLFxuICAgICAgICBpdm9yeTogJyNmZmZmZjAnLFxuICAgICAgICBraGFraTogJyNmMGU2OGMnLFxuICAgICAgICBsYXNlcmxlbW9uOiAnI2ZmZmY1NCcsXG4gICAgICAgIGxhdmVuZGVyOiAnI2U2ZTZmYScsXG4gICAgICAgIGxhdmVuZGVyYmx1c2g6ICcjZmZmMGY1JyxcbiAgICAgICAgbGF3bmdyZWVuOiAnIzdjZmMwMCcsXG4gICAgICAgIGxlbW9uY2hpZmZvbjogJyNmZmZhY2QnLFxuICAgICAgICBsaWdodGJsdWU6ICcjYWRkOGU2JyxcbiAgICAgICAgbGlnaHRjb3JhbDogJyNmMDgwODAnLFxuICAgICAgICBsaWdodGN5YW46ICcjZTBmZmZmJyxcbiAgICAgICAgbGlnaHRnb2xkZW5yb2Q6ICcjZmFmYWQyJyxcbiAgICAgICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjZmFmYWQyJyxcbiAgICAgICAgbGlnaHRncmF5OiAnI2QzZDNkMycsXG4gICAgICAgIGxpZ2h0Z3JlZW46ICcjOTBlZTkwJyxcbiAgICAgICAgbGlnaHRncmV5OiAnI2QzZDNkMycsXG4gICAgICAgIGxpZ2h0cGluazogJyNmZmI2YzEnLFxuICAgICAgICBsaWdodHNhbG1vbjogJyNmZmEwN2EnLFxuICAgICAgICBsaWdodHNlYWdyZWVuOiAnIzIwYjJhYScsXG4gICAgICAgIGxpZ2h0c2t5Ymx1ZTogJyM4N2NlZmEnLFxuICAgICAgICBsaWdodHNsYXRlZ3JheTogJyM3Nzg4OTknLFxuICAgICAgICBsaWdodHNsYXRlZ3JleTogJyM3Nzg4OTknLFxuICAgICAgICBsaWdodHN0ZWVsYmx1ZTogJyNiMGM0ZGUnLFxuICAgICAgICBsaWdodHllbGxvdzogJyNmZmZmZTAnLFxuICAgICAgICBsaW1lOiAnIzAwZmYwMCcsXG4gICAgICAgIGxpbWVncmVlbjogJyMzMmNkMzInLFxuICAgICAgICBsaW5lbjogJyNmYWYwZTYnLFxuICAgICAgICBtYWdlbnRhOiAnI2ZmMDBmZicsXG4gICAgICAgIG1hcm9vbjogJyM4MDAwMDAnLFxuICAgICAgICBtYXJvb24yOiAnIzdmMDAwMCcsXG4gICAgICAgIG1hcm9vbjM6ICcjYjAzMDYwJyxcbiAgICAgICAgbWVkaXVtYXF1YW1hcmluZTogJyM2NmNkYWEnLFxuICAgICAgICBtZWRpdW1ibHVlOiAnIzAwMDBjZCcsXG4gICAgICAgIG1lZGl1bW9yY2hpZDogJyNiYTU1ZDMnLFxuICAgICAgICBtZWRpdW1wdXJwbGU6ICcjOTM3MGRiJyxcbiAgICAgICAgbWVkaXVtc2VhZ3JlZW46ICcjM2NiMzcxJyxcbiAgICAgICAgbWVkaXVtc2xhdGVibHVlOiAnIzdiNjhlZScsXG4gICAgICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAnIzAwZmE5YScsXG4gICAgICAgIG1lZGl1bXR1cnF1b2lzZTogJyM0OGQxY2MnLFxuICAgICAgICBtZWRpdW12aW9sZXRyZWQ6ICcjYzcxNTg1JyxcbiAgICAgICAgbWlkbmlnaHRibHVlOiAnIzE5MTk3MCcsXG4gICAgICAgIG1pbnRjcmVhbTogJyNmNWZmZmEnLFxuICAgICAgICBtaXN0eXJvc2U6ICcjZmZlNGUxJyxcbiAgICAgICAgbW9jY2FzaW46ICcjZmZlNGI1JyxcbiAgICAgICAgbmF2YWpvd2hpdGU6ICcjZmZkZWFkJyxcbiAgICAgICAgbmF2eTogJyMwMDAwODAnLFxuICAgICAgICBvbGRsYWNlOiAnI2ZkZjVlNicsXG4gICAgICAgIG9saXZlOiAnIzgwODAwMCcsXG4gICAgICAgIG9saXZlZHJhYjogJyM2YjhlMjMnLFxuICAgICAgICBvcmFuZ2U6ICcjZmZhNTAwJyxcbiAgICAgICAgb3JhbmdlcmVkOiAnI2ZmNDUwMCcsXG4gICAgICAgIG9yY2hpZDogJyNkYTcwZDYnLFxuICAgICAgICBwYWxlZ29sZGVucm9kOiAnI2VlZThhYScsXG4gICAgICAgIHBhbGVncmVlbjogJyM5OGZiOTgnLFxuICAgICAgICBwYWxldHVycXVvaXNlOiAnI2FmZWVlZScsXG4gICAgICAgIHBhbGV2aW9sZXRyZWQ6ICcjZGI3MDkzJyxcbiAgICAgICAgcGFwYXlhd2hpcDogJyNmZmVmZDUnLFxuICAgICAgICBwZWFjaHB1ZmY6ICcjZmZkYWI5JyxcbiAgICAgICAgcGVydTogJyNjZDg1M2YnLFxuICAgICAgICBwaW5rOiAnI2ZmYzBjYicsXG4gICAgICAgIHBsdW06ICcjZGRhMGRkJyxcbiAgICAgICAgcG93ZGVyYmx1ZTogJyNiMGUwZTYnLFxuICAgICAgICBwdXJwbGU6ICcjODAwMDgwJyxcbiAgICAgICAgcHVycGxlMjogJyM3ZjAwN2YnLFxuICAgICAgICBwdXJwbGUzOiAnI2EwMjBmMCcsXG4gICAgICAgIHJlYmVjY2FwdXJwbGU6ICcjNjYzMzk5JyxcbiAgICAgICAgcmVkOiAnI2ZmMDAwMCcsXG4gICAgICAgIHJvc3licm93bjogJyNiYzhmOGYnLFxuICAgICAgICByb3lhbGJsdWU6ICcjNDE2OWUxJyxcbiAgICAgICAgc2FkZGxlYnJvd246ICcjOGI0NTEzJyxcbiAgICAgICAgc2FsbW9uOiAnI2ZhODA3MicsXG4gICAgICAgIHNhbmR5YnJvd246ICcjZjRhNDYwJyxcbiAgICAgICAgc2VhZ3JlZW46ICcjMmU4YjU3JyxcbiAgICAgICAgc2Vhc2hlbGw6ICcjZmZmNWVlJyxcbiAgICAgICAgc2llbm5hOiAnI2EwNTIyZCcsXG4gICAgICAgIHNpbHZlcjogJyNjMGMwYzAnLFxuICAgICAgICBza3libHVlOiAnIzg3Y2VlYicsXG4gICAgICAgIHNsYXRlYmx1ZTogJyM2YTVhY2QnLFxuICAgICAgICBzbGF0ZWdyYXk6ICcjNzA4MDkwJyxcbiAgICAgICAgc2xhdGVncmV5OiAnIzcwODA5MCcsXG4gICAgICAgIHNub3c6ICcjZmZmYWZhJyxcbiAgICAgICAgc3ByaW5nZ3JlZW46ICcjMDBmZjdmJyxcbiAgICAgICAgc3RlZWxibHVlOiAnIzQ2ODJiNCcsXG4gICAgICAgIHRhbjogJyNkMmI0OGMnLFxuICAgICAgICB0ZWFsOiAnIzAwODA4MCcsXG4gICAgICAgIHRoaXN0bGU6ICcjZDhiZmQ4JyxcbiAgICAgICAgdG9tYXRvOiAnI2ZmNjM0NycsXG4gICAgICAgIHR1cnF1b2lzZTogJyM0MGUwZDAnLFxuICAgICAgICB2aW9sZXQ6ICcjZWU4MmVlJyxcbiAgICAgICAgd2hlYXQ6ICcjZjVkZWIzJyxcbiAgICAgICAgd2hpdGU6ICcjZmZmZmZmJyxcbiAgICAgICAgd2hpdGVzbW9rZTogJyNmNWY1ZjUnLFxuICAgICAgICB5ZWxsb3c6ICcjZmZmZjAwJyxcbiAgICAgICAgeWVsbG93Z3JlZW46ICcjOWFjZDMyJ1xuICAgIH07XG5cbiAgICBDb2xvci5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhleCA9IHJnYjJoZXgodGhpcy5fcmdiLCAncmdiJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gT2JqZWN0LmtleXModzNjeDExKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBuID0gbGlzdFtpXTtcblxuICAgICAgICAgICAgaWYgKHczY3gxMVtuXSA9PT0gaGV4KSB7IHJldHVybiBuLnRvTG93ZXJDYXNlKCk7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4O1xuICAgIH07XG5cbiAgICBpbnB1dC5mb3JtYXQubmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodzNjeDExW25hbWVdKSB7IHJldHVybiBoZXgycmdiKHczY3gxMVtuYW1lXSk7IH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbG9yIG5hbWU6ICcgKyBuYW1lKTtcbiAgICB9O1xuXG4gICAgaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICAgICAgcDogNSxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIHZhciByZXN0ID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSA+IDAgKSByZXN0WyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3QubGVuZ3RoICYmIHR5cGUoaCkgPT09ICdzdHJpbmcnICYmIHczY3gxMVtoLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICduYW1lZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIENvbG9yLnByb3RvdHlwZS5hbHBoYSA9IGZ1bmN0aW9uIChhLCBtdXRhdGUpIHtcbiAgICAgICAgaWYgKCBtdXRhdGUgPT09IHZvaWQgMCApIG11dGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChhICE9PSB1bmRlZmluZWQgJiYgdHlwZShhKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmIChtdXRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZ2JbM10gPSBhO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihbdGhpcy5fcmdiWzBdLCB0aGlzLl9yZ2JbMV0sIHRoaXMuX3JnYlsyXSwgYV0sICdyZ2InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmdiWzNdO1xuICAgIH07XG5cbiAgICBDb2xvci5wcm90b3R5cGUuY2xpcHBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JnYi5fY2xpcHBlZCB8fCBmYWxzZTtcbiAgICB9O1xuXG4gICAgQ29sb3IucHJvdG90eXBlLmRhcmtlbiA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKCBhbW91bnQgPT09IHZvaWQgMCApIGFtb3VudCA9IDE7XG5cbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgdmFyIGxhYiA9IG1lLmxhYigpO1xuICAgICAgICBsYWJbMF0gLT0gbGFiQ29uc3RhbnRzLktuICogYW1vdW50O1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yKGxhYiwgJ2xhYicpLmFscGhhKG1lLmFscGhhKCksIHRydWUpO1xuICAgIH07XG5cbiAgICBDb2xvci5wcm90b3R5cGUuYnJpZ2h0ZW4gPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmICggYW1vdW50ID09PSB2b2lkIDAgKSBhbW91bnQgPSAxO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRhcmtlbigtYW1vdW50KTtcbiAgICB9O1xuXG4gICAgQ29sb3IucHJvdG90eXBlLmRhcmtlciA9IENvbG9yLnByb3RvdHlwZS5kYXJrZW47XG4gICAgQ29sb3IucHJvdG90eXBlLmJyaWdodGVyID0gQ29sb3IucHJvdG90eXBlLmJyaWdodGVuO1xuXG4gICAgQ29sb3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChtYykge1xuICAgICAgICB2YXIgcmVmID0gbWMuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIG1vZGUgPSByZWZbMF07XG4gICAgICAgIHZhciBjaGFubmVsID0gcmVmWzFdO1xuICAgICAgICB2YXIgc3JjID0gdGhpc1ttb2RlXSgpO1xuICAgICAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgdmFyIGkgPSBtb2RlLmluZGV4T2YoY2hhbm5lbCkgLSAobW9kZS5zdWJzdHIoMCwgMikgPT09ICdvaycgPyAyIDogMCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7IHJldHVybiBzcmNbaV07IH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJ1bmtub3duIGNoYW5uZWwgXCIgKyBjaGFubmVsICsgXCIgaW4gbW9kZSBcIiArIG1vZGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHBvdyQ2ID0gTWF0aC5wb3c7XG5cbiAgICB2YXIgRVBTID0gMWUtNztcbiAgICB2YXIgTUFYX0lURVIgPSAyMDtcblxuICAgIENvbG9yLnByb3RvdHlwZS5sdW1pbmFuY2UgPSBmdW5jdGlvbiAobHVtLCBtb2RlKSB7XG4gICAgICAgIGlmICggbW9kZSA9PT0gdm9pZCAwICkgbW9kZSA9ICdyZ2InO1xuXG4gICAgICAgIGlmIChsdW0gIT09IHVuZGVmaW5lZCAmJiB0eXBlKGx1bSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAobHVtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHB1cmUgYmxhY2tcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKFswLCAwLCAwLCB0aGlzLl9yZ2JbM11dLCAncmdiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobHVtID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHB1cmUgd2hpdGVcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKFsyNTUsIDI1NSwgMjU1LCB0aGlzLl9yZ2JbM11dLCAncmdiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb21wdXRlIG5ldyBjb2xvciB1c2luZy4uLlxuICAgICAgICAgICAgdmFyIGN1cl9sdW0gPSB0aGlzLmx1bWluYW5jZSgpO1xuICAgICAgICAgICAgdmFyIG1heF9pdGVyID0gTUFYX0lURVI7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gZnVuY3Rpb24gKGxvdywgaGlnaCkge1xuICAgICAgICAgICAgICAgIHZhciBtaWQgPSBsb3cuaW50ZXJwb2xhdGUoaGlnaCwgMC41LCBtb2RlKTtcbiAgICAgICAgICAgICAgICB2YXIgbG0gPSBtaWQubHVtaW5hbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGx1bSAtIGxtKSA8IEVQUyB8fCAhbWF4X2l0ZXItLSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbG9zZSBlbm91Z2hcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxtID4gbHVtID8gdGVzdChsb3csIG1pZCkgOiB0ZXN0KG1pZCwgaGlnaCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgcmdiID0gKFxuICAgICAgICAgICAgICAgIGN1cl9sdW0gPiBsdW1cbiAgICAgICAgICAgICAgICAgICAgPyB0ZXN0KG5ldyBDb2xvcihbMCwgMCwgMF0pLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICA6IHRlc3QodGhpcywgbmV3IENvbG9yKFsyNTUsIDI1NSwgMjU1XSkpXG4gICAgICAgICAgICApLnJnYigpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyZ2IuY29uY2F0KCBbdGhpcy5fcmdiWzNdXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZ2IybHVtaW5hbmNlLmFwcGx5KHZvaWQgMCwgdGhpcy5fcmdiLnNsaWNlKDAsIDMpKTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYjJsdW1pbmFuY2UgPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgICAgICAvLyByZWxhdGl2ZSBsdW1pbmFuY2VcbiAgICAgICAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICAgICAgciA9IGx1bWluYW5jZV94KHIpO1xuICAgICAgICBnID0gbHVtaW5hbmNlX3goZyk7XG4gICAgICAgIGIgPSBsdW1pbmFuY2VfeChiKTtcbiAgICAgICAgcmV0dXJuIDAuMjEyNiAqIHIgKyAwLjcxNTIgKiBnICsgMC4wNzIyICogYjtcbiAgICB9O1xuXG4gICAgdmFyIGx1bWluYW5jZV94ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgeCAvPSAyNTU7XG4gICAgICAgIHJldHVybiB4IDw9IDAuMDM5MjggPyB4IC8gMTIuOTIgOiBwb3ckNigoeCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB7fTtcblxuICAgIGZ1bmN0aW9uIG1peCAoY29sMSwgY29sMiwgZikge1xuICAgICAgICBpZiAoIGYgPT09IHZvaWQgMCApIGYgPSAwLjU7XG4gICAgICAgIHZhciByZXN0ID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAzO1xuICAgICAgICB3aGlsZSAoIGxlbi0tID4gMCApIHJlc3RbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAzIF07XG5cbiAgICAgICAgdmFyIG1vZGUgPSByZXN0WzBdIHx8ICdscmdiJztcbiAgICAgICAgaWYgKCFpbmRleFttb2RlXSAmJiAhcmVzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byB0aGUgZmlyc3Qgc3VwcG9ydGVkIG1vZGVcbiAgICAgICAgICAgIG1vZGUgPSBPYmplY3Qua2V5cyhpbmRleClbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbmRleFttb2RlXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcImludGVycG9sYXRpb24gbW9kZSBcIiArIG1vZGUgKyBcIiBpcyBub3QgZGVmaW5lZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUoY29sMSkgIT09ICdvYmplY3QnKSB7IGNvbDEgPSBuZXcgQ29sb3IoY29sMSk7IH1cbiAgICAgICAgaWYgKHR5cGUoY29sMikgIT09ICdvYmplY3QnKSB7IGNvbDIgPSBuZXcgQ29sb3IoY29sMik7IH1cbiAgICAgICAgcmV0dXJuIGluZGV4W21vZGVdKGNvbDEsIGNvbDIsIGYpLmFscGhhKFxuICAgICAgICAgICAgY29sMS5hbHBoYSgpICsgZiAqIChjb2wyLmFscGhhKCkgLSBjb2wxLmFscGhhKCkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgQ29sb3IucHJvdG90eXBlLm1peCA9IENvbG9yLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgICAgY29sMixcbiAgICAgICAgZlxuICAgICkge1xuICAgICAgICBpZiAoIGYgPT09IHZvaWQgMCApIGYgPSAwLjU7XG4gICAgICAgIHZhciByZXN0ID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgICB3aGlsZSAoIGxlbi0tID4gMCApIHJlc3RbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAyIF07XG5cbiAgICAgICAgcmV0dXJuIG1peC5hcHBseSh2b2lkIDAsIFsgdGhpcywgY29sMiwgZiBdLmNvbmNhdCggcmVzdCApKTtcbiAgICB9O1xuXG4gICAgQ29sb3IucHJvdG90eXBlLnByZW11bHRpcGx5ID0gZnVuY3Rpb24gKG11dGF0ZSkge1xuICAgICAgICBpZiAoIG11dGF0ZSA9PT0gdm9pZCAwICkgbXV0YXRlID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIHJnYiA9IHRoaXMuX3JnYjtcbiAgICAgICAgdmFyIGEgPSByZ2JbM107XG4gICAgICAgIGlmIChtdXRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JnYiA9IFtyZ2JbMF0gKiBhLCByZ2JbMV0gKiBhLCByZ2JbMl0gKiBhLCBhXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihbcmdiWzBdICogYSwgcmdiWzFdICogYSwgcmdiWzJdICogYSwgYV0sICdyZ2InKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDb2xvci5wcm90b3R5cGUuc2F0dXJhdGUgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmICggYW1vdW50ID09PSB2b2lkIDAgKSBhbW91bnQgPSAxO1xuXG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHZhciBsY2ggPSBtZS5sY2goKTtcbiAgICAgICAgbGNoWzFdICs9IGxhYkNvbnN0YW50cy5LbiAqIGFtb3VudDtcbiAgICAgICAgaWYgKGxjaFsxXSA8IDApIHsgbGNoWzFdID0gMDsgfVxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKGxjaCwgJ2xjaCcpLmFscGhhKG1lLmFscGhhKCksIHRydWUpO1xuICAgIH07XG5cbiAgICBDb2xvci5wcm90b3R5cGUuZGVzYXR1cmF0ZSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKCBhbW91bnQgPT09IHZvaWQgMCApIGFtb3VudCA9IDE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2F0dXJhdGUoLWFtb3VudCk7XG4gICAgfTtcblxuICAgIENvbG9yLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobWMsIHZhbHVlLCBtdXRhdGUpIHtcbiAgICAgICAgaWYgKCBtdXRhdGUgPT09IHZvaWQgMCApIG11dGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIHZhciByZWYgPSBtYy5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgbW9kZSA9IHJlZlswXTtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSByZWZbMV07XG4gICAgICAgIHZhciBzcmMgPSB0aGlzW21vZGVdKCk7XG4gICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgICB2YXIgaSA9IG1vZGUuaW5kZXhPZihjaGFubmVsKSAtIChtb2RlLnN1YnN0cigwLCAyKSA9PT0gJ29rJyA/IDIgOiAwKTtcbiAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSh2YWx1ZSkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZS5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tpXSArPSArdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNbaV0gKz0gK3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW2ldICo9ICt2YWx1ZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNbaV0gLz0gK3ZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW2ldID0gK3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlKHZhbHVlKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjW2ldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgdmFsdWUgZm9yIENvbG9yLnNldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBDb2xvcihzcmMsIG1vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChtdXRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmdiID0gb3V0Ll9yZ2I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcInVua25vd24gY2hhbm5lbCBcIiArIGNoYW5uZWwgKyBcIiBpbiBtb2RlIFwiICsgbW9kZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDb2xvci5wcm90b3R5cGUudGludCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGlmICggZiA9PT0gdm9pZCAwICkgZiA9IDAuNTtcbiAgICAgICAgdmFyIHJlc3QgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlICggbGVuLS0gPiAwICkgcmVzdFsgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgICAgICByZXR1cm4gbWl4LmFwcGx5KHZvaWQgMCwgWyB0aGlzLCAnd2hpdGUnLCBmIF0uY29uY2F0KCByZXN0ICkpO1xuICAgIH07XG5cbiAgICBDb2xvci5wcm90b3R5cGUuc2hhZGUgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICBpZiAoIGYgPT09IHZvaWQgMCApIGYgPSAwLjU7XG4gICAgICAgIHZhciByZXN0ID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoIGxlbi0tID4gMCApIHJlc3RbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgICAgICAgcmV0dXJuIG1peC5hcHBseSh2b2lkIDAsIFsgdGhpcywgJ2JsYWNrJywgZiBdLmNvbmNhdCggcmVzdCApKTtcbiAgICB9O1xuXG4gICAgdmFyIHJnYiA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIHZhciB4eXowID0gY29sMS5fcmdiO1xuICAgICAgICB2YXIgeHl6MSA9IGNvbDIuX3JnYjtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihcbiAgICAgICAgICAgIHh5ejBbMF0gKyBmICogKHh5ejFbMF0gLSB4eXowWzBdKSxcbiAgICAgICAgICAgIHh5ejBbMV0gKyBmICogKHh5ejFbMV0gLSB4eXowWzFdKSxcbiAgICAgICAgICAgIHh5ejBbMl0gKyBmICogKHh5ejFbMl0gLSB4eXowWzJdKSxcbiAgICAgICAgICAgICdyZ2InXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGluZGV4LnJnYiA9IHJnYjtcblxuICAgIHZhciBzcXJ0JDIgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIHBvdyQ1ID0gTWF0aC5wb3c7XG5cbiAgICB2YXIgbHJnYiA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIHZhciByZWYgPSBjb2wxLl9yZ2I7XG4gICAgICAgIHZhciB4MSA9IHJlZlswXTtcbiAgICAgICAgdmFyIHkxID0gcmVmWzFdO1xuICAgICAgICB2YXIgejEgPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IGNvbDIuX3JnYjtcbiAgICAgICAgdmFyIHgyID0gcmVmJDFbMF07XG4gICAgICAgIHZhciB5MiA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgejIgPSByZWYkMVsyXTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihcbiAgICAgICAgICAgIHNxcnQkMihwb3ckNSh4MSwgMikgKiAoMSAtIGYpICsgcG93JDUoeDIsIDIpICogZiksXG4gICAgICAgICAgICBzcXJ0JDIocG93JDUoeTEsIDIpICogKDEgLSBmKSArIHBvdyQ1KHkyLCAyKSAqIGYpLFxuICAgICAgICAgICAgc3FydCQyKHBvdyQ1KHoxLCAyKSAqICgxIC0gZikgKyBwb3ckNSh6MiwgMikgKiBmKSxcbiAgICAgICAgICAgICdyZ2InXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGluZGV4LmxyZ2IgPSBscmdiO1xuXG4gICAgdmFyIGxhYiA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIHZhciB4eXowID0gY29sMS5sYWIoKTtcbiAgICAgICAgdmFyIHh5ejEgPSBjb2wyLmxhYigpO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yKFxuICAgICAgICAgICAgeHl6MFswXSArIGYgKiAoeHl6MVswXSAtIHh5ejBbMF0pLFxuICAgICAgICAgICAgeHl6MFsxXSArIGYgKiAoeHl6MVsxXSAtIHh5ejBbMV0pLFxuICAgICAgICAgICAgeHl6MFsyXSArIGYgKiAoeHl6MVsyXSAtIHh5ejBbMl0pLFxuICAgICAgICAgICAgJ2xhYidcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW5kZXgubGFiID0gbGFiO1xuXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVfaHN4IChjb2wxLCBjb2wyLCBmLCBtKSB7XG4gICAgICAgIHZhciBhc3NpZ24sIGFzc2lnbiQxO1xuXG4gICAgICAgIHZhciB4eXowLCB4eXoxO1xuICAgICAgICBpZiAobSA9PT0gJ2hzbCcpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhzbCgpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaHNsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2hzdicpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhzdigpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaHN2KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2hjZycpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhjZygpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaGNnKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2hzaScpIHtcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhzaSgpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaHNpKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ2xjaCcgfHwgbSA9PT0gJ2hjbCcpIHtcbiAgICAgICAgICAgIG0gPSAnaGNsJztcbiAgICAgICAgICAgIHh5ejAgPSBjb2wxLmhjbCgpO1xuICAgICAgICAgICAgeHl6MSA9IGNvbDIuaGNsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobSA9PT0gJ29rbGNoJykge1xuICAgICAgICAgICAgeHl6MCA9IGNvbDEub2tsY2goKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICB4eXoxID0gY29sMi5va2xjaCgpLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBodWUwLCBodWUxLCBzYXQwLCBzYXQxLCBsYnYwLCBsYnYxO1xuICAgICAgICBpZiAobS5zdWJzdHIoMCwgMSkgPT09ICdoJyB8fCBtID09PSAnb2tsY2gnKSB7XG4gICAgICAgICAgICAoYXNzaWduID0geHl6MCwgaHVlMCA9IGFzc2lnblswXSwgc2F0MCA9IGFzc2lnblsxXSwgbGJ2MCA9IGFzc2lnblsyXSk7XG4gICAgICAgICAgICAoYXNzaWduJDEgPSB4eXoxLCBodWUxID0gYXNzaWduJDFbMF0sIHNhdDEgPSBhc3NpZ24kMVsxXSwgbGJ2MSA9IGFzc2lnbiQxWzJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzYXQsIGh1ZSwgbGJ2LCBkaDtcblxuICAgICAgICBpZiAoIWlzTmFOKGh1ZTApICYmICFpc05hTihodWUxKSkge1xuICAgICAgICAgICAgLy8gYm90aCBjb2xvcnMgaGF2ZSBodWVcbiAgICAgICAgICAgIGlmIChodWUxID4gaHVlMCAmJiBodWUxIC0gaHVlMCA+IDE4MCkge1xuICAgICAgICAgICAgICAgIGRoID0gaHVlMSAtIChodWUwICsgMzYwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaHVlMSA8IGh1ZTAgJiYgaHVlMCAtIGh1ZTEgPiAxODApIHtcbiAgICAgICAgICAgICAgICBkaCA9IGh1ZTEgKyAzNjAgLSBodWUwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaCA9IGh1ZTEgLSBodWUwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHVlID0gaHVlMCArIGYgKiBkaDtcbiAgICAgICAgfSBlbHNlIGlmICghaXNOYU4oaHVlMCkpIHtcbiAgICAgICAgICAgIGh1ZSA9IGh1ZTA7XG4gICAgICAgICAgICBpZiAoKGxidjEgPT0gMSB8fCBsYnYxID09IDApICYmIG0gIT0gJ2hzdicpIHsgc2F0ID0gc2F0MDsgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihodWUxKSkge1xuICAgICAgICAgICAgaHVlID0gaHVlMTtcbiAgICAgICAgICAgIGlmICgobGJ2MCA9PSAxIHx8IGxidjAgPT0gMCkgJiYgbSAhPSAnaHN2JykgeyBzYXQgPSBzYXQxOyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodWUgPSBOdW1iZXIuTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNhdCA9PT0gdW5kZWZpbmVkKSB7IHNhdCA9IHNhdDAgKyBmICogKHNhdDEgLSBzYXQwKTsgfVxuICAgICAgICBsYnYgPSBsYnYwICsgZiAqIChsYnYxIC0gbGJ2MCk7XG4gICAgICAgIHJldHVybiBtID09PSAnb2tsY2gnXG4gICAgICAgICAgICA/IG5ldyBDb2xvcihbbGJ2LCBzYXQsIGh1ZV0sIG0pXG4gICAgICAgICAgICA6IG5ldyBDb2xvcihbaHVlLCBzYXQsIGxidl0sIG0pO1xuICAgIH1cblxuICAgIHZhciBsY2ggPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVfaHN4KGNvbDEsIGNvbDIsIGYsICdsY2gnKTtcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW5kZXgubGNoID0gbGNoO1xuICAgIGluZGV4LmhjbCA9IGxjaDtcblxuICAgIHZhciBudW0gPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgICAgICB2YXIgYzEgPSBjb2wxLm51bSgpO1xuICAgICAgICB2YXIgYzIgPSBjb2wyLm51bSgpO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yKGMxICsgZiAqIChjMiAtIGMxKSwgJ251bScpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbmRleC5udW0gPSBudW07XG5cbiAgICB2YXIgaGNnID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlX2hzeChjb2wxLCBjb2wyLCBmLCAnaGNnJyk7XG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGluZGV4LmhjZyA9IGhjZztcblxuICAgIHZhciBoc2kgPSBmdW5jdGlvbiAoY29sMSwgY29sMiwgZikge1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVfaHN4KGNvbDEsIGNvbDIsIGYsICdoc2knKTtcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW5kZXguaHNpID0gaHNpO1xuXG4gICAgdmFyIGhzbCA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZV9oc3goY29sMSwgY29sMiwgZiwgJ2hzbCcpO1xuICAgIH07XG5cbiAgICAvLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbiAgICBpbmRleC5oc2wgPSBoc2w7XG5cbiAgICB2YXIgaHN2ID0gZnVuY3Rpb24gKGNvbDEsIGNvbDIsIGYpIHtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlX2hzeChjb2wxLCBjb2wyLCBmLCAnaHN2Jyk7XG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGluZGV4LmhzdiA9IGhzdjtcblxuICAgIHZhciBva2xhYiA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIHZhciB4eXowID0gY29sMS5va2xhYigpO1xuICAgICAgICB2YXIgeHl6MSA9IGNvbDIub2tsYWIoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihcbiAgICAgICAgICAgIHh5ejBbMF0gKyBmICogKHh5ejFbMF0gLSB4eXowWzBdKSxcbiAgICAgICAgICAgIHh5ejBbMV0gKyBmICogKHh5ejFbMV0gLSB4eXowWzFdKSxcbiAgICAgICAgICAgIHh5ejBbMl0gKyBmICogKHh5ejFbMl0gLSB4eXowWzJdKSxcbiAgICAgICAgICAgICdva2xhYidcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG4gICAgaW5kZXgub2tsYWIgPSBva2xhYjtcblxuICAgIHZhciBva2xjaCA9IGZ1bmN0aW9uIChjb2wxLCBjb2wyLCBmKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZV9oc3goY29sMSwgY29sMiwgZiwgJ29rbGNoJyk7XG4gICAgfTtcblxuICAgIC8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuICAgIGluZGV4Lm9rbGNoID0gb2tsY2g7XG5cbiAgICB2YXIgcG93JDQgPSBNYXRoLnBvdztcbiAgICB2YXIgc3FydCQxID0gTWF0aC5zcXJ0O1xuICAgIHZhciBQSSQxID0gTWF0aC5QSTtcbiAgICB2YXIgY29zJDIgPSBNYXRoLmNvcztcbiAgICB2YXIgc2luJDIgPSBNYXRoLnNpbjtcbiAgICB2YXIgYXRhbjIkMSA9IE1hdGguYXRhbjI7XG5cbiAgICBmdW5jdGlvbiBhdmVyYWdlIChjb2xvcnMsIG1vZGUsIHdlaWdodHMpIHtcbiAgICAgICAgaWYgKCBtb2RlID09PSB2b2lkIDAgKSBtb2RlID0gJ2xyZ2InO1xuICAgICAgICBpZiAoIHdlaWdodHMgPT09IHZvaWQgMCApIHdlaWdodHMgPSBudWxsO1xuXG4gICAgICAgIHZhciBsID0gY29sb3JzLmxlbmd0aDtcbiAgICAgICAgaWYgKCF3ZWlnaHRzKSB7IHdlaWdodHMgPSBBcnJheS5mcm9tKG5ldyBBcnJheShsKSkubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE7IH0pOyB9XG4gICAgICAgIC8vIG5vcm1hbGl6ZSB3ZWlnaHRzXG4gICAgICAgIHZhciBrID1cbiAgICAgICAgICAgIGwgL1xuICAgICAgICAgICAgd2VpZ2h0cy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgd2VpZ2h0cy5mb3JFYWNoKGZ1bmN0aW9uICh3LCBpKSB7XG4gICAgICAgICAgICB3ZWlnaHRzW2ldICo9IGs7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjb252ZXJ0IGNvbG9ycyB0byBDb2xvciBvYmplY3RzXG4gICAgICAgIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5ldyBDb2xvcihjKTsgfSk7XG4gICAgICAgIGlmIChtb2RlID09PSAnbHJnYicpIHtcbiAgICAgICAgICAgIHJldHVybiBfYXZlcmFnZV9scmdiKGNvbG9ycywgd2VpZ2h0cyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0ID0gY29sb3JzLnNoaWZ0KCk7XG4gICAgICAgIHZhciB4eXogPSBmaXJzdC5nZXQobW9kZSk7XG4gICAgICAgIHZhciBjbnQgPSBbXTtcbiAgICAgICAgdmFyIGR4ID0gMDtcbiAgICAgICAgdmFyIGR5ID0gMDtcbiAgICAgICAgLy8gaW5pdGlhbCBjb2xvclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHh5ei5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeHl6W2ldID0gKHh5eltpXSB8fCAwKSAqIHdlaWdodHNbMF07XG4gICAgICAgICAgICBjbnQucHVzaChpc05hTih4eXpbaV0pID8gMCA6IHdlaWdodHNbMF0pO1xuICAgICAgICAgICAgaWYgKG1vZGUuY2hhckF0KGkpID09PSAnaCcgJiYgIWlzTmFOKHh5eltpXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgQSA9ICh4eXpbaV0gLyAxODApICogUEkkMTtcbiAgICAgICAgICAgICAgICBkeCArPSBjb3MkMihBKSAqIHdlaWdodHNbMF07XG4gICAgICAgICAgICAgICAgZHkgKz0gc2luJDIoQSkgKiB3ZWlnaHRzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFscGhhID0gZmlyc3QuYWxwaGEoKSAqIHdlaWdodHNbMF07XG4gICAgICAgIGNvbG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBjaSkge1xuICAgICAgICAgICAgdmFyIHh5ejIgPSBjLmdldChtb2RlKTtcbiAgICAgICAgICAgIGFscGhhICs9IGMuYWxwaGEoKSAqIHdlaWdodHNbY2kgKyAxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHl6Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih4eXoyW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjbnRbaV0gKz0gd2VpZ2h0c1tjaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZS5jaGFyQXQoaSkgPT09ICdoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEEgPSAoeHl6MltpXSAvIDE4MCkgKiBQSSQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHggKz0gY29zJDIoQSkgKiB3ZWlnaHRzW2NpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkeSArPSBzaW4kMihBKSAqIHdlaWdodHNbY2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHh5eltpXSArPSB4eXoyW2ldICogd2VpZ2h0c1tjaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB4eXoubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgaWYgKG1vZGUuY2hhckF0KGkkMSkgPT09ICdoJykge1xuICAgICAgICAgICAgICAgIHZhciBBJDEgPSAoYXRhbjIkMShkeSAvIGNudFtpJDFdLCBkeCAvIGNudFtpJDFdKSAvIFBJJDEpICogMTgwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChBJDEgPCAwKSB7IEEkMSArPSAzNjA7IH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoQSQxID49IDM2MCkgeyBBJDEgLT0gMzYwOyB9XG4gICAgICAgICAgICAgICAgeHl6W2kkMV0gPSBBJDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHh5eltpJDFdID0geHl6W2kkMV0gLyBjbnRbaSQxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhbHBoYSAvPSBsO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yKHh5eiwgbW9kZSkuYWxwaGEoYWxwaGEgPiAwLjk5OTk5ID8gMSA6IGFscGhhLCB0cnVlKTtcbiAgICB9XG4gICAgdmFyIF9hdmVyYWdlX2xyZ2IgPSBmdW5jdGlvbiAoY29sb3JzLCB3ZWlnaHRzKSB7XG4gICAgICAgIHZhciBsID0gY29sb3JzLmxlbmd0aDtcbiAgICAgICAgdmFyIHh5eiA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb2wgPSBjb2xvcnNbaV07XG4gICAgICAgICAgICB2YXIgZiA9IHdlaWdodHNbaV0gLyBsO1xuICAgICAgICAgICAgdmFyIHJnYiA9IGNvbC5fcmdiO1xuICAgICAgICAgICAgeHl6WzBdICs9IHBvdyQ0KHJnYlswXSwgMikgKiBmO1xuICAgICAgICAgICAgeHl6WzFdICs9IHBvdyQ0KHJnYlsxXSwgMikgKiBmO1xuICAgICAgICAgICAgeHl6WzJdICs9IHBvdyQ0KHJnYlsyXSwgMikgKiBmO1xuICAgICAgICAgICAgeHl6WzNdICs9IHJnYlszXSAqIGY7XG4gICAgICAgIH1cbiAgICAgICAgeHl6WzBdID0gc3FydCQxKHh5elswXSk7XG4gICAgICAgIHh5elsxXSA9IHNxcnQkMSh4eXpbMV0pO1xuICAgICAgICB4eXpbMl0gPSBzcXJ0JDEoeHl6WzJdKTtcbiAgICAgICAgaWYgKHh5elszXSA+IDAuOTk5OTk5OSkgeyB4eXpbM10gPSAxOyB9XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IoY2xpcF9yZ2IoeHl6KSk7XG4gICAgfTtcblxuICAgIC8vIG1pbmltYWwgbXVsdGktcHVycG9zZSBpbnRlcmZhY2VcblxuXG4gICAgdmFyIHBvdyQzID0gTWF0aC5wb3c7XG5cbiAgICBmdW5jdGlvbiBzY2FsZSAoY29sb3JzKSB7XG4gICAgICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgIHZhciBfbW9kZSA9ICdyZ2InO1xuICAgICAgICB2YXIgX25hY29sID0gY2hyb21hKCcjY2NjJyk7XG4gICAgICAgIHZhciBfc3ByZWFkID0gMDtcbiAgICAgICAgLy8gY29uc3QgX2ZpeGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBfZG9tYWluID0gWzAsIDFdO1xuICAgICAgICB2YXIgX3BvcyA9IFtdO1xuICAgICAgICB2YXIgX3BhZGRpbmcgPSBbMCwgMF07XG4gICAgICAgIHZhciBfY2xhc3NlcyA9IGZhbHNlO1xuICAgICAgICB2YXIgX2NvbG9ycyA9IFtdO1xuICAgICAgICB2YXIgX291dCA9IGZhbHNlO1xuICAgICAgICB2YXIgX21pbiA9IDA7XG4gICAgICAgIHZhciBfbWF4ID0gMTtcbiAgICAgICAgdmFyIF9jb3JyZWN0TGlnaHRuZXNzID0gZmFsc2U7XG4gICAgICAgIHZhciBfY29sb3JDYWNoZSA9IHt9O1xuICAgICAgICB2YXIgX3VzZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9nYW1tYSA9IDE7XG5cbiAgICAgICAgLy8gcHJpdmF0ZSBtZXRob2RzXG5cbiAgICAgICAgdmFyIHNldENvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgICAgICAgICAgIGNvbG9ycyA9IGNvbG9ycyB8fCBbJyNmZmYnLCAnIzAwMCddO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGNvbG9ycyAmJlxuICAgICAgICAgICAgICAgIHR5cGUoY29sb3JzKSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICBjaHJvbWEuYnJld2VyICYmXG4gICAgICAgICAgICAgICAgY2hyb21hLmJyZXdlcltjb2xvcnMudG9Mb3dlckNhc2UoKV1cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbG9ycyA9IGNocm9tYS5icmV3ZXJbY29sb3JzLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUoY29sb3JzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzaW5nbGUgY29sb3JcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnMgPSBbY29sb3JzWzBdLCBjb2xvcnNbMF1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgY29sb3JzXG4gICAgICAgICAgICAgICAgY29sb3JzID0gY29sb3JzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gY2hyb21hIGNsYXNzZXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbG9ycy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnNbY10gPSBjaHJvbWEoY29sb3JzW2NdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYXV0by1maWxsIGNvbG9yIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgX3Bvcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGMkMSA9IDA7IGMkMSA8IGNvbG9ycy5sZW5ndGg7IGMkMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wb3MucHVzaChjJDEgLyAoY29sb3JzLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNldENhY2hlKCk7XG4gICAgICAgICAgICByZXR1cm4gKF9jb2xvcnMgPSBjb2xvcnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRDbGFzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKF9jbGFzc2VzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IF9jbGFzc2VzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbiAmJiB2YWx1ZSA+PSBfY2xhc3Nlc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0TWFwTGlnaHRuZXNzID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH07XG4gICAgICAgIHZhciB0TWFwRG9tYWluID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH07XG5cbiAgICAgICAgLy8gY29uc3QgY2xhc3NpZnlWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vICAgICBsZXQgdmFsID0gdmFsdWU7XG4gICAgICAgIC8vICAgICBpZiAoX2NsYXNzZXMubGVuZ3RoID4gMikge1xuICAgICAgICAvLyAgICAgICAgIGNvbnN0IG4gPSBfY2xhc3Nlcy5sZW5ndGgtMTtcbiAgICAgICAgLy8gICAgICAgICBjb25zdCBpID0gZ2V0Q2xhc3ModmFsdWUpO1xuICAgICAgICAvLyAgICAgICAgIGNvbnN0IG1pbmMgPSBfY2xhc3Nlc1swXSArICgoX2NsYXNzZXNbMV0tX2NsYXNzZXNbMF0pICogKDAgKyAoX3NwcmVhZCAqIDAuNSkpKTsgIC8vIGNlbnRlciBvZiAxc3QgY2xhc3NcbiAgICAgICAgLy8gICAgICAgICBjb25zdCBtYXhjID0gX2NsYXNzZXNbbi0xXSArICgoX2NsYXNzZXNbbl0tX2NsYXNzZXNbbi0xXSkgKiAoMSAtIChfc3ByZWFkICogMC41KSkpOyAgLy8gY2VudGVyIG9mIGxhc3QgY2xhc3NcbiAgICAgICAgLy8gICAgICAgICB2YWwgPSBfbWluICsgKCgoKF9jbGFzc2VzW2ldICsgKChfY2xhc3Nlc1tpKzFdIC0gX2NsYXNzZXNbaV0pICogMC41KSkgLSBtaW5jKSAvIChtYXhjLW1pbmMpKSAqIChfbWF4IC0gX21pbikpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgLy8gfTtcblxuICAgICAgICB2YXIgZ2V0Q29sb3IgPSBmdW5jdGlvbiAodmFsLCBieXBhc3NNYXApIHtcbiAgICAgICAgICAgIHZhciBjb2wsIHQ7XG4gICAgICAgICAgICBpZiAoYnlwYXNzTWFwID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBieXBhc3NNYXAgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05hTih2YWwpIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbmFjb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWJ5cGFzc01hcCkge1xuICAgICAgICAgICAgICAgIGlmIChfY2xhc3NlcyAmJiBfY2xhc3Nlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGNsYXNzXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gZ2V0Q2xhc3ModmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdCA9IGMgLyAoX2NsYXNzZXMubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfbWF4ICE9PSBfbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgaW50ZXJwb2xhdGUgYmV0d2VlbiBtaW4vbWF4XG4gICAgICAgICAgICAgICAgICAgIHQgPSAodmFsIC0gX21pbikgLyAoX21heCAtIF9taW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdCA9IHZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZG9tYWluIG1hcFxuICAgICAgICAgICAgdCA9IHRNYXBEb21haW4odCk7XG5cbiAgICAgICAgICAgIGlmICghYnlwYXNzTWFwKSB7XG4gICAgICAgICAgICAgICAgdCA9IHRNYXBMaWdodG5lc3ModCk7IC8vIGxpZ2h0bmVzcyBjb3JyZWN0aW9uXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfZ2FtbWEgIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0ID0gcG93JDModCwgX2dhbW1hKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdCA9IF9wYWRkaW5nWzBdICsgdCAqICgxIC0gX3BhZGRpbmdbMF0gLSBfcGFkZGluZ1sxXSk7XG5cbiAgICAgICAgICAgIHQgPSBsaW1pdCh0LCAwLCAxKTtcblxuICAgICAgICAgICAgdmFyIGsgPSBNYXRoLmZsb29yKHQgKiAxMDAwMCk7XG5cbiAgICAgICAgICAgIGlmIChfdXNlQ2FjaGUgJiYgX2NvbG9yQ2FjaGVba10pIHtcbiAgICAgICAgICAgICAgICBjb2wgPSBfY29sb3JDYWNoZVtrXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUoX2NvbG9ycykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9mb3IgaSBpbiBbMC4uX3Bvcy5sZW5ndGgtMV1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcG9zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IF9wb3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA8PSBwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gX2NvbG9yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID49IHAgJiYgaSA9PT0gX3Bvcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gX2NvbG9yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ID4gcCAmJiB0IDwgX3Bvc1tpICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKHQgLSBwKSAvIChfcG9zW2kgKyAxXSAtIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IGNocm9tYS5pbnRlcnBvbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbG9yc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbG9yc1tpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9tb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZShfY29sb3JzKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb2wgPSBfY29sb3JzKHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3VzZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb2xvckNhY2hlW2tdID0gY29sO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2w7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlc2V0Q2FjaGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoX2NvbG9yQ2FjaGUgPSB7fSk7IH07XG5cbiAgICAgICAgc2V0Q29sb3JzKGNvbG9ycyk7XG5cbiAgICAgICAgLy8gcHVibGljIGludGVyZmFjZVxuXG4gICAgICAgIHZhciBmID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciBjID0gY2hyb21hKGdldENvbG9yKHYpKTtcbiAgICAgICAgICAgIGlmIChfb3V0ICYmIGNbX291dF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY1tfb3V0XSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmLmNsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3Nlcykge1xuICAgICAgICAgICAgaWYgKGNsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlKGNsYXNzZXMpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc2VzID0gY2xhc3NlcztcbiAgICAgICAgICAgICAgICAgICAgX2RvbWFpbiA9IFtjbGFzc2VzWzBdLCBjbGFzc2VzW2NsYXNzZXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gY2hyb21hLmFuYWx5emUoX2RvbWFpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NlcyA9IFtkLm1pbiwgZC5tYXhdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzZXMgPSBjaHJvbWEubGltaXRzKGQsICdlJywgY2xhc3Nlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2NsYXNzZXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5kb21haW4gPSBmdW5jdGlvbiAoZG9tYWluKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2RvbWFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9taW4gPSBkb21haW5bMF07XG4gICAgICAgICAgICBfbWF4ID0gZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIF9wb3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBrID0gX2NvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZG9tYWluLmxlbmd0aCA9PT0gayAmJiBfbWluICE9PSBfbWF4KSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gQXJyYXkuZnJvbShkb21haW4pOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGxpc3RbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgX3Bvcy5wdXNoKChkIC0gX21pbikgLyAoX21heCAtIF9taW4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgazsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wb3MucHVzaChjIC8gKGsgLSAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkb21haW4ubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgZG9tYWluIG1hcFxuICAgICAgICAgICAgICAgICAgICB2YXIgdE91dCA9IGRvbWFpbi5tYXAoZnVuY3Rpb24gKGQsIGkpIHsgcmV0dXJuIGkgLyAoZG9tYWluLmxlbmd0aCAtIDEpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRCcmVha3MgPSBkb21haW4ubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiAoZCAtIF9taW4pIC8gKF9tYXggLSBfbWluKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdEJyZWFrcy5ldmVyeShmdW5jdGlvbiAodmFsLCBpKSB7IHJldHVybiB0T3V0W2ldID09PSB2YWw7IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0TWFwRG9tYWluID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA8PSAwIHx8IHQgPj0gMSkgeyByZXR1cm4gdDsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodCA+PSB0QnJlYWtzW2kgKyAxXSkgeyBpKys7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0IC0gdEJyZWFrc1tpXSkgLyAodEJyZWFrc1tpICsgMV0gLSB0QnJlYWtzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gdE91dFtpXSArIGYgKiAodE91dFtpICsgMV0gLSB0T3V0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9kb21haW4gPSBbX21pbiwgX21heF07XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLm1vZGUgPSBmdW5jdGlvbiAoX20pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbW9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9tb2RlID0gX207XG4gICAgICAgICAgICByZXNldENhY2hlKCk7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLnJhbmdlID0gZnVuY3Rpb24gKGNvbG9ycywgX3Bvcykge1xuICAgICAgICAgICAgc2V0Q29sb3JzKGNvbG9ycyk7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLm91dCA9IGZ1bmN0aW9uIChfbykge1xuICAgICAgICAgICAgX291dCA9IF9vO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5zcHJlYWQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NwcmVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zcHJlYWQgPSB2YWw7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcblxuICAgICAgICBmLmNvcnJlY3RMaWdodG5lc3MgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHYgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2NvcnJlY3RMaWdodG5lc3MgPSB2O1xuICAgICAgICAgICAgcmVzZXRDYWNoZSgpO1xuICAgICAgICAgICAgaWYgKF9jb3JyZWN0TGlnaHRuZXNzKSB7XG4gICAgICAgICAgICAgICAgdE1hcExpZ2h0bmVzcyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBMMCA9IGdldENvbG9yKDAsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTDEgPSBnZXRDb2xvcigxLCB0cnVlKS5sYWIoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvbCA9IEwwID4gTDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBMX2FjdHVhbCA9IGdldENvbG9yKHQsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTF9pZGVhbCA9IEwwICsgKEwxIC0gTDApICogdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIExfZGlmZiA9IExfYWN0dWFsIC0gTF9pZGVhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQwID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQxID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heF9pdGVyID0gMjA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChNYXRoLmFicyhMX2RpZmYpID4gMWUtMiAmJiBtYXhfaXRlci0tID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExfZGlmZiAqPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKExfZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDAgPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICs9ICh0MSAtIHQpICogMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCArPSAodDAgLSB0KSAqIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTF9hY3R1YWwgPSBnZXRDb2xvcih0LCB0cnVlKS5sYWIoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKExfZGlmZiA9IExfYWN0dWFsIC0gTF9pZGVhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRNYXBMaWdodG5lc3MgPSBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYucGFkZGluZyA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICBpZiAocCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUocCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBbcCwgcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9wYWRkaW5nID0gcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wYWRkaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGYuY29sb3JzID0gZnVuY3Rpb24gKG51bUNvbG9ycywgb3V0KSB7XG4gICAgICAgICAgICAvLyBJZiBubyBhcmd1bWVudHMgYXJlIGdpdmVuLCByZXR1cm4gdGhlIG9yaWdpbmFsIGNvbG9ycyB0aGF0IHdlcmUgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIG91dCA9ICdoZXgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jb2xvcnMuc2xpY2UoMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bUNvbG9ycyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtmKDAuNSldO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1Db2xvcnMgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRtID0gX2RvbWFpblswXTtcbiAgICAgICAgICAgICAgICB2YXIgZGQgPSBfZG9tYWluWzFdIC0gZG07XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX19yYW5nZV9fKDAsIG51bUNvbG9ycykubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBmKGRtICsgKGkgLyAobnVtQ29sb3JzIC0gMSkpICogZGQpOyB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJucyBhbGwgY29sb3JzIGJhc2VkIG9uIHRoZSBkZWZpbmVkIGNsYXNzZXNcbiAgICAgICAgICAgICAgICBjb2xvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgc2FtcGxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChfY2xhc3NlcyAmJiBfY2xhc3Nlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDEsIGVuZCA9IF9jbGFzc2VzLmxlbmd0aCwgYXNjID0gMSA8PSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc2MgPyBpIDwgZW5kIDogaSA+IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzYyA/IGkrKyA6IGktLVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZXMucHVzaCgoX2NsYXNzZXNbaSAtIDFdICsgX2NsYXNzZXNbaV0pICogMC41KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZXMgPSBfZG9tYWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzYW1wbGVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gZih2KTsgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaHJvbWFbb3V0XSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGNbb3V0XSgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgZi5jYWNoZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3VzZUNhY2hlID0gYztcbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF91c2VDYWNoZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmLmdhbW1hID0gZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgICAgIGlmIChnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfZ2FtbWEgPSBnO1xuICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dhbW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGYubm9kYXRhID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmIChkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfbmFjb2wgPSBjaHJvbWEoZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbmFjb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19yYW5nZV9fKGxlZnQsIHJpZ2h0LCBpbmNsdXNpdmUpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gW107XG4gICAgICAgIHZhciBhc2NlbmRpbmcgPSBsZWZ0IDwgcmlnaHQ7XG4gICAgICAgIHZhciBlbmQgPSByaWdodCA7XG4gICAgICAgIGZvciAodmFyIGkgPSBsZWZ0OyBhc2NlbmRpbmcgPyBpIDwgZW5kIDogaSA+IGVuZDsgYXNjZW5kaW5nID8gaSsrIDogaS0tKSB7XG4gICAgICAgICAgICByYW5nZS5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIGludGVycG9sYXRlcyBiZXR3ZWVuIGEgc2V0IG9mIGNvbG9ycyB1emluZyBhIGJlemllciBzcGxpbmVcbiAgICAvL1xuXG5cbiAgICAvLyBudGggcm93IG9mIHRoZSBwYXNjYWwgdHJpYW5nbGVcbiAgICB2YXIgYmlub21fcm93ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdmFyIHJvdyA9IFsxLCAxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuZXdyb3cgPSBbMV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8PSByb3cubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBuZXdyb3dbal0gPSAocm93W2pdIHx8IDApICsgcm93W2ogLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvdyA9IG5ld3JvdztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93O1xuICAgIH07XG5cbiAgICB2YXIgYmV6aWVyID0gZnVuY3Rpb24gKGNvbG9ycykge1xuICAgICAgICB2YXIgYXNzaWduLCBhc3NpZ24kMSwgYXNzaWduJDI7XG5cbiAgICAgICAgdmFyIEksIGxhYjAsIGxhYjEsIGxhYjI7XG4gICAgICAgIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5ldyBDb2xvcihjKTsgfSk7XG4gICAgICAgIGlmIChjb2xvcnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgKGFzc2lnbiA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMubGFiKCk7IH0pLCBsYWIwID0gYXNzaWduWzBdLCBsYWIxID0gYXNzaWduWzFdKTtcbiAgICAgICAgICAgIEkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHZhciBsYWIgPSBbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBsYWIwW2ldICsgdCAqIChsYWIxW2ldIC0gbGFiMFtpXSk7IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobGFiLCAnbGFiJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvbG9ycy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIC8vIHF1YWRyYXRpYyBiZXppZXIgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgKGFzc2lnbiQxID0gY29sb3JzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5sYWIoKTsgfSksIGxhYjAgPSBhc3NpZ24kMVswXSwgbGFiMSA9IGFzc2lnbiQxWzFdLCBsYWIyID0gYXNzaWduJDFbMl0pO1xuICAgICAgICAgICAgSSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYiA9IFswLCAxLCAyXS5tYXAoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChpKSB7IHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqIGxhYjBbaV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgMiAqICgxIC0gdCkgKiB0ICogbGFiMVtpXSArXG4gICAgICAgICAgICAgICAgICAgICAgICB0ICogdCAqIGxhYjJbaV07IH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobGFiLCAnbGFiJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvbG9ycy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIC8vIGN1YmljIGJlemllciBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICB2YXIgbGFiMztcbiAgICAgICAgICAgIChhc3NpZ24kMiA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMubGFiKCk7IH0pLCBsYWIwID0gYXNzaWduJDJbMF0sIGxhYjEgPSBhc3NpZ24kMlsxXSwgbGFiMiA9IGFzc2lnbiQyWzJdLCBsYWIzID0gYXNzaWduJDJbM10pO1xuICAgICAgICAgICAgSSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYiA9IFswLCAxLCAyXS5tYXAoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChpKSB7IHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCkgKiBsYWIwW2ldICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDMgKiAoMSAtIHQpICogKDEgLSB0KSAqIHQgKiBsYWIxW2ldICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDMgKiAoMSAtIHQpICogdCAqIHQgKiBsYWIyW2ldICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgKiB0ICogdCAqIGxhYjNbaV07IH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobGFiLCAnbGFiJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvbG9ycy5sZW5ndGggPj0gNSkge1xuICAgICAgICAgICAgLy8gZ2VuZXJhbCBjYXNlIChkZWdyZWUgbiBiZXppZXIpXG4gICAgICAgICAgICB2YXIgbGFicywgcm93LCBuO1xuICAgICAgICAgICAgbGFicyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMubGFiKCk7IH0pO1xuICAgICAgICAgICAgbiA9IGNvbG9ycy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgcm93ID0gYmlub21fcm93KG4pO1xuICAgICAgICAgICAgSSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHUgPSAxIC0gdDtcbiAgICAgICAgICAgICAgICB2YXIgbGFiID0gWzAsIDEsIDJdLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gbGFicy5yZWR1Y2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoc3VtLCBlbCwgaikgeyByZXR1cm4gc3VtICsgcm93W2pdICogTWF0aC5wb3coIHUsIChuIC0gaikgKSAqIE1hdGgucG93KCB0LCBqICkgKiBlbFtpXTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgKTsgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihsYWIsICdsYWInKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTm8gcG9pbnQgaW4gcnVubmluZyBiZXppZXIgd2l0aCBvbmx5IG9uZSBjb2xvci4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYmV6aWVyJDEgKGNvbG9ycykge1xuICAgICAgICB2YXIgZiA9IGJlemllcihjb2xvcnMpO1xuICAgICAgICBmLnNjYWxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NhbGUoZik7IH07XG4gICAgICAgIHJldHVybiBmO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogaW50ZXJwb2xhdGVzIGJldHdlZW4gYSBzZXQgb2YgY29sb3JzIHV6aW5nIGEgYmV6aWVyIHNwbGluZVxuICAgICAqIGJsZW5kIG1vZGUgZm9ybXVsYXMgdGFrZW4gZnJvbSBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxODAxMTAwMTQ5NDYvaHR0cDovL3d3dy52ZW50dXJlLXdhcmUuY29tL2tldmluL2NvZGluZy9sZXRzLWxlYXJuLW1hdGgtcGhvdG9zaG9wLWJsZW5kLW1vZGVzL1xuICAgICAqL1xuXG5cbiAgICB2YXIgYmxlbmQgPSBmdW5jdGlvbiAoYm90dG9tLCB0b3AsIG1vZGUpIHtcbiAgICAgICAgaWYgKCFibGVuZFttb2RlXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGJsZW5kIG1vZGUgJyArIG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibGVuZFttb2RlXShib3R0b20sIHRvcCk7XG4gICAgfTtcblxuICAgIHZhciBibGVuZF9mID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChib3R0b20sIHRvcCkge1xuICAgICAgICB2YXIgYzAgPSBjaHJvbWEodG9wKS5yZ2IoKTtcbiAgICAgICAgdmFyIGMxID0gY2hyb21hKGJvdHRvbSkucmdiKCk7XG4gICAgICAgIHJldHVybiBjaHJvbWEucmdiKGYoYzAsIGMxKSk7XG4gICAgfTsgfTtcblxuICAgIHZhciBlYWNoID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uIChjMCwgYzEpIHtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBvdXRbMF0gPSBmKGMwWzBdLCBjMVswXSk7XG4gICAgICAgIG91dFsxXSA9IGYoYzBbMV0sIGMxWzFdKTtcbiAgICAgICAgb3V0WzJdID0gZihjMFsyXSwgYzFbMl0pO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07IH07XG5cbiAgICB2YXIgbm9ybWFsID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGE7IH07XG4gICAgdmFyIG11bHRpcGx5ID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChhICogYikgLyAyNTU7IH07XG4gICAgdmFyIGRhcmtlbiA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYSA+IGIgPyBiIDogYSk7IH07XG4gICAgdmFyIGxpZ2h0ZW4gPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKGEgPiBiID8gYSA6IGIpOyB9O1xuICAgIHZhciBzY3JlZW4gPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gMjU1ICogKDEgLSAoMSAtIGEgLyAyNTUpICogKDEgLSBiIC8gMjU1KSk7IH07XG4gICAgdmFyIG92ZXJsYXkgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYiA8IDEyOCA/ICgyICogYSAqIGIpIC8gMjU1IDogMjU1ICogKDEgLSAyICogKDEgLSBhIC8gMjU1KSAqICgxIC0gYiAvIDI1NSkpOyB9O1xuICAgIHZhciBidXJuID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIDI1NSAqICgxIC0gKDEgLSBiIC8gMjU1KSAvIChhIC8gMjU1KSk7IH07XG4gICAgdmFyIGRvZGdlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgPT09IDI1NSkgeyByZXR1cm4gMjU1OyB9XG4gICAgICAgIGEgPSAoMjU1ICogKGIgLyAyNTUpKSAvICgxIC0gYSAvIDI1NSk7XG4gICAgICAgIHJldHVybiBhID4gMjU1ID8gMjU1IDogYTtcbiAgICB9O1xuXG4gICAgLy8gIyBhZGQgPSAoYSxiKSAtPlxuICAgIC8vICMgICAgIGlmIChhICsgYiA+IDI1NSkgdGhlbiAyNTUgZWxzZSBhICsgYlxuXG4gICAgYmxlbmQubm9ybWFsID0gYmxlbmRfZihlYWNoKG5vcm1hbCkpO1xuICAgIGJsZW5kLm11bHRpcGx5ID0gYmxlbmRfZihlYWNoKG11bHRpcGx5KSk7XG4gICAgYmxlbmQuc2NyZWVuID0gYmxlbmRfZihlYWNoKHNjcmVlbikpO1xuICAgIGJsZW5kLm92ZXJsYXkgPSBibGVuZF9mKGVhY2gob3ZlcmxheSkpO1xuICAgIGJsZW5kLmRhcmtlbiA9IGJsZW5kX2YoZWFjaChkYXJrZW4pKTtcbiAgICBibGVuZC5saWdodGVuID0gYmxlbmRfZihlYWNoKGxpZ2h0ZW4pKTtcbiAgICBibGVuZC5kb2RnZSA9IGJsZW5kX2YoZWFjaChkb2RnZSkpO1xuICAgIGJsZW5kLmJ1cm4gPSBibGVuZF9mKGVhY2goYnVybikpO1xuXG4gICAgLy8gY3ViZWhlbGl4IGludGVycG9sYXRpb25cbiAgICAvLyBiYXNlZCBvbiBELkEuIEdyZWVuIFwiQSBjb2xvdXIgc2NoZW1lIGZvciB0aGUgZGlzcGxheSBvZiBhc3Ryb25vbWljYWwgaW50ZW5zaXR5IGltYWdlc1wiXG4gICAgLy8gaHR0cDovL2FzdHJvbi1zb2MuaW4vYnVsbGV0aW4vMTFKdW5lLzI4OTM5MjAxMS5wZGZcbiAgICB2YXIgcG93JDIgPSBNYXRoLnBvdztcbiAgICB2YXIgc2luJDEgPSBNYXRoLnNpbjtcbiAgICB2YXIgY29zJDEgPSBNYXRoLmNvcztcblxuICAgIGZ1bmN0aW9uIGN1YmVoZWxpeCAoXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICByb3RhdGlvbnMsXG4gICAgICAgIGh1ZSxcbiAgICAgICAgZ2FtbWEsXG4gICAgICAgIGxpZ2h0bmVzc1xuICAgICkge1xuICAgICAgICBpZiAoIHN0YXJ0ID09PSB2b2lkIDAgKSBzdGFydCA9IDMwMDtcbiAgICAgICAgaWYgKCByb3RhdGlvbnMgPT09IHZvaWQgMCApIHJvdGF0aW9ucyA9IC0xLjU7XG4gICAgICAgIGlmICggaHVlID09PSB2b2lkIDAgKSBodWUgPSAxO1xuICAgICAgICBpZiAoIGdhbW1hID09PSB2b2lkIDAgKSBnYW1tYSA9IDE7XG4gICAgICAgIGlmICggbGlnaHRuZXNzID09PSB2b2lkIDAgKSBsaWdodG5lc3MgPSBbMCwgMV07XG5cbiAgICAgICAgdmFyIGRoID0gMCxcbiAgICAgICAgICAgIGRsO1xuICAgICAgICBpZiAodHlwZShsaWdodG5lc3MpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICBkbCA9IGxpZ2h0bmVzc1sxXSAtIGxpZ2h0bmVzc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRsID0gMDtcbiAgICAgICAgICAgIGxpZ2h0bmVzcyA9IFtsaWdodG5lc3MsIGxpZ2h0bmVzc107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGYgPSBmdW5jdGlvbiAoZnJhY3QpIHtcbiAgICAgICAgICAgIHZhciBhID0gVFdPUEkgKiAoKHN0YXJ0ICsgMTIwKSAvIDM2MCArIHJvdGF0aW9ucyAqIGZyYWN0KTtcbiAgICAgICAgICAgIHZhciBsID0gcG93JDIobGlnaHRuZXNzWzBdICsgZGwgKiBmcmFjdCwgZ2FtbWEpO1xuICAgICAgICAgICAgdmFyIGggPSBkaCAhPT0gMCA/IGh1ZVswXSArIGZyYWN0ICogZGggOiBodWU7XG4gICAgICAgICAgICB2YXIgYW1wID0gKGggKiBsICogKDEgLSBsKSkgLyAyO1xuICAgICAgICAgICAgdmFyIGNvc19hID0gY29zJDEoYSk7XG4gICAgICAgICAgICB2YXIgc2luX2EgPSBzaW4kMShhKTtcbiAgICAgICAgICAgIHZhciByID0gbCArIGFtcCAqICgtMC4xNDg2MSAqIGNvc19hICsgMS43ODI3NyAqIHNpbl9hKTtcbiAgICAgICAgICAgIHZhciBnID0gbCArIGFtcCAqICgtMC4yOTIyNyAqIGNvc19hIC0gMC45MDY0OSAqIHNpbl9hKTtcbiAgICAgICAgICAgIHZhciBiID0gbCArIGFtcCAqICgrMS45NzI5NCAqIGNvc19hKTtcbiAgICAgICAgICAgIHJldHVybiBjaHJvbWEoY2xpcF9yZ2IoW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTUsIDFdKSk7XG4gICAgICAgIH07XG4gICAgICAgIGYuc3RhcnQgPSBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgaWYgKHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ID0gcztcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9O1xuICAgICAgICBmLnJvdGF0aW9ucyA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICBpZiAociA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdGF0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvdGF0aW9ucyA9IHI7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcbiAgICAgICAgZi5nYW1tYSA9IGZ1bmN0aW9uIChnKSB7XG4gICAgICAgICAgICBpZiAoZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdhbW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2FtbWEgPSBnO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG4gICAgICAgIGYuaHVlID0gZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIGlmIChoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHVlID0gaDtcbiAgICAgICAgICAgIGlmICh0eXBlKGh1ZSkgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBkaCA9IGh1ZVsxXSAtIGh1ZVswXTtcbiAgICAgICAgICAgICAgICBpZiAoZGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaHVlID0gaHVlWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH07XG4gICAgICAgIGYubGlnaHRuZXNzID0gZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIGlmIChoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlnaHRuZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUoaCkgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBsaWdodG5lc3MgPSBoO1xuICAgICAgICAgICAgICAgIGRsID0gaFsxXSAtIGhbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpZ2h0bmVzcyA9IFtoLCBoXTtcbiAgICAgICAgICAgICAgICBkbCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfTtcbiAgICAgICAgZi5zY2FsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNocm9tYS5zY2FsZShmKTsgfTtcbiAgICAgICAgZi5odWUoaHVlKTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfVxuXG4gICAgdmFyIGRpZ2l0cyA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuICAgIHZhciBmbG9vciQxID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgcmFuZG9tID0gTWF0aC5yYW5kb207XG5cbiAgICBmdW5jdGlvbiByYW5kb20kMSAoKSB7XG4gICAgICAgIHZhciBjb2RlID0gJyMnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgY29kZSArPSBkaWdpdHMuY2hhckF0KGZsb29yJDEocmFuZG9tKCkgKiAxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IoY29kZSwgJ2hleCcpO1xuICAgIH1cblxuICAgIHZhciBsb2cgPSBNYXRoLmxvZztcbiAgICB2YXIgcG93JDEgPSBNYXRoLnBvdztcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBhYnMkMSA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gYW5hbHl6ZShkYXRhLCBrZXkpIHtcbiAgICAgICAgaWYgKCBrZXkgPT09IHZvaWQgMCApIGtleSA9IG51bGw7XG5cbiAgICAgICAgdmFyIHIgPSB7XG4gICAgICAgICAgICBtaW46IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBtYXg6IE51bWJlci5NQVhfVkFMVUUgKiAtMSxcbiAgICAgICAgICAgIHN1bTogMCxcbiAgICAgICAgICAgIHZhbHVlczogW10sXG4gICAgICAgICAgICBjb3VudDogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZShkYXRhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGRhdGEgPSBPYmplY3QudmFsdWVzKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICYmIHR5cGUodmFsKSA9PT0gJ29iamVjdCcpIHsgdmFsID0gdmFsW2tleV07IH1cbiAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09IG51bGwgJiYgIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgICAgICByLnZhbHVlcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgci5zdW0gKz0gdmFsO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPCByLm1pbikgeyByLm1pbiA9IHZhbDsgfVxuICAgICAgICAgICAgICAgIGlmICh2YWwgPiByLm1heCkgeyByLm1heCA9IHZhbDsgfVxuICAgICAgICAgICAgICAgIHIuY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgci5kb21haW4gPSBbci5taW4sIHIubWF4XTtcblxuICAgICAgICByLmxpbWl0cyA9IGZ1bmN0aW9uIChtb2RlLCBudW0pIHsgcmV0dXJuIGxpbWl0cyhyLCBtb2RlLCBudW0pOyB9O1xuXG4gICAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbWl0cyhkYXRhLCBtb2RlLCBudW0pIHtcbiAgICAgICAgaWYgKCBtb2RlID09PSB2b2lkIDAgKSBtb2RlID0gJ2VxdWFsJztcbiAgICAgICAgaWYgKCBudW0gPT09IHZvaWQgMCApIG51bSA9IDc7XG5cbiAgICAgICAgaWYgKHR5cGUoZGF0YSkgPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgZGF0YSA9IGFuYWx5emUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbiA9IGRhdGEubWluO1xuICAgICAgICB2YXIgbWF4ID0gZGF0YS5tYXg7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBkYXRhLnZhbHVlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG5cbiAgICAgICAgaWYgKG51bSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGltaXRzID0gW107XG5cbiAgICAgICAgaWYgKG1vZGUuc3Vic3RyKDAsIDEpID09PSAnYycpIHtcbiAgICAgICAgICAgIC8vIGNvbnRpbnVvdXNcbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICAgICAgICBsaW1pdHMucHVzaChtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZGUuc3Vic3RyKDAsIDEpID09PSAnZScpIHtcbiAgICAgICAgICAgIC8vIGVxdWFsIGludGVydmFsXG4gICAgICAgICAgICBsaW1pdHMucHVzaChtaW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBudW07IGkrKykge1xuICAgICAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1pbiArIChpIC8gbnVtKSAqIChtYXggLSBtaW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZS5zdWJzdHIoMCwgMSkgPT09ICdsJykge1xuICAgICAgICAgICAgLy8gbG9nIHNjYWxlXG4gICAgICAgICAgICBpZiAobWluIDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdMb2dhcml0aG1pYyBzY2FsZXMgYXJlIG9ubHkgcG9zc2libGUgZm9yIHZhbHVlcyA+IDAnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaW5fbG9nID0gTWF0aC5MT0cxMEUgKiBsb2cobWluKTtcbiAgICAgICAgICAgIHZhciBtYXhfbG9nID0gTWF0aC5MT0cxMEUgKiBsb2cobWF4KTtcbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAxOyBpJDEgPCBudW07IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgbGltaXRzLnB1c2gocG93JDEoMTAsIG1pbl9sb2cgKyAoaSQxIC8gbnVtKSAqIChtYXhfbG9nIC0gbWluX2xvZykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZS5zdWJzdHIoMCwgMSkgPT09ICdxJykge1xuICAgICAgICAgICAgLy8gcXVhbnRpbGUgc2NhbGVcbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBudW07IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSAoKHZhbHVlcy5sZW5ndGggLSAxKSAqIGkkMikgLyBudW07XG4gICAgICAgICAgICAgICAgdmFyIHBiID0gZmxvb3IocCk7XG4gICAgICAgICAgICAgICAgaWYgKHBiID09PSBwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0cy5wdXNoKHZhbHVlc1twYl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHAgPiBwYlxuICAgICAgICAgICAgICAgICAgICB2YXIgcHIgPSBwIC0gcGI7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0cy5wdXNoKHZhbHVlc1twYl0gKiAoMSAtIHByKSArIHZhbHVlc1twYiArIDFdICogcHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZS5zdWJzdHIoMCwgMSkgPT09ICdrJykge1xuICAgICAgICAgICAgLy8gay1tZWFucyBjbHVzdGVyaW5nXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gYmFzZWQgb25cbiAgICAgICAgICAgIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9maWd1ZS9zb3VyY2UvYnJvd3NlL3RydW5rL2ZpZ3VlLmpzIzMzNlxuICAgICAgICAgICAgc2ltcGxpZmllZCBmb3IgMS1kIGlucHV0IHZhbHVlc1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBjbHVzdGVyO1xuICAgICAgICAgICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGFzc2lnbm1lbnRzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgdmFyIGNsdXN0ZXJTaXplcyA9IG5ldyBBcnJheShudW0pO1xuICAgICAgICAgICAgdmFyIHJlcGVhdCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgbmJfaXRlcnMgPSAwO1xuICAgICAgICAgICAgdmFyIGNlbnRyb2lkcyA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGdldCBzZWVkIHZhbHVlc1xuICAgICAgICAgICAgY2VudHJvaWRzID0gW107XG4gICAgICAgICAgICBjZW50cm9pZHMucHVzaChtaW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQzID0gMTsgaSQzIDwgbnVtOyBpJDMrKykge1xuICAgICAgICAgICAgICAgIGNlbnRyb2lkcy5wdXNoKG1pbiArIChpJDMgLyBudW0pICogKG1heCAtIG1pbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VudHJvaWRzLnB1c2gobWF4KTtcblxuICAgICAgICAgICAgd2hpbGUgKHJlcGVhdCkge1xuICAgICAgICAgICAgICAgIC8vIGFzc2lnbm1lbnQgc3RlcFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2x1c3RlclNpemVzW2pdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgbjsgaSQ0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2kkNF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW5kaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJlc3QgPSAodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgbnVtOyBqJDErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBhYnMkMShjZW50cm9pZHNbaiQxXSAtIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgbWluZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QgPSBqJDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyU2l6ZXNbYmVzdF0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRzW2kkNF0gPSBiZXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNlbnRyb2lkcyBzdGVwXG4gICAgICAgICAgICAgICAgdmFyIG5ld0NlbnRyb2lkcyA9IG5ldyBBcnJheShudW0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGokMiA9IDA7IGokMiA8IG51bTsgaiQyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2VudHJvaWRzW2okMl0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDUgPSAwOyBpJDUgPCBuOyBpJDUrKykge1xuICAgICAgICAgICAgICAgICAgICBjbHVzdGVyID0gYXNzaWdubWVudHNbaSQ1XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0NlbnRyb2lkc1tjbHVzdGVyXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2VudHJvaWRzW2NsdXN0ZXJdID0gdmFsdWVzW2kkNV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDZW50cm9pZHNbY2x1c3Rlcl0gKz0gdmFsdWVzW2kkNV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiQzID0gMDsgaiQzIDwgbnVtOyBqJDMrKykge1xuICAgICAgICAgICAgICAgICAgICBuZXdDZW50cm9pZHNbaiQzXSAqPSAxIC8gY2x1c3RlclNpemVzW2okM107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgY29udmVyZ2VuY2VcbiAgICAgICAgICAgICAgICByZXBlYXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqJDQgPSAwOyBqJDQgPCBudW07IGokNCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdDZW50cm9pZHNbaiQ0XSAhPT0gY2VudHJvaWRzW2okNF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNlbnRyb2lkcyA9IG5ld0NlbnRyb2lkcztcbiAgICAgICAgICAgICAgICBuYl9pdGVycysrO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5iX2l0ZXJzID4gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmluaXNoZWQgay1tZWFucyBjbHVzdGVyaW5nXG4gICAgICAgICAgICAvLyB0aGUgbmV4dCBwYXJ0IGlzIGJvcnJvd2VkIGZyb20gZ2FicmllbGZsb3IuaXRcbiAgICAgICAgICAgIHZhciBrQ2x1c3RlcnMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGokNSA9IDA7IGokNSA8IG51bTsgaiQ1KyspIHtcbiAgICAgICAgICAgICAgICBrQ2x1c3RlcnNbaiQ1XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSQ2ID0gMDsgaSQ2IDwgbjsgaSQ2KyspIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVyID0gYXNzaWdubWVudHNbaSQ2XTtcbiAgICAgICAgICAgICAgICBrQ2x1c3RlcnNbY2x1c3Rlcl0ucHVzaCh2YWx1ZXNbaSQ2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG1wS01lYW5zQnJlYWtzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqJDYgPSAwOyBqJDYgPCBudW07IGokNisrKSB7XG4gICAgICAgICAgICAgICAgdG1wS01lYW5zQnJlYWtzLnB1c2goa0NsdXN0ZXJzW2okNl1bMF0pO1xuICAgICAgICAgICAgICAgIHRtcEtNZWFuc0JyZWFrcy5wdXNoKGtDbHVzdGVyc1tqJDZdW2tDbHVzdGVyc1tqJDZdLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtcEtNZWFuc0JyZWFrcyA9IHRtcEtNZWFuc0JyZWFrcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgICAgICAgICBsaW1pdHMucHVzaCh0bXBLTWVhbnNCcmVha3NbMF0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQ3ID0gMTsgaSQ3IDwgdG1wS01lYW5zQnJlYWtzLmxlbmd0aDsgaSQ3ICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHRtcEtNZWFuc0JyZWFrc1tpJDddO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odikgJiYgbGltaXRzLmluZGV4T2YodikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0cy5wdXNoKHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGltaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRyYXN0IChhLCBiKSB7XG4gICAgICAgIC8vIFdDQUcgY29udHJhc3QgcmF0aW9cbiAgICAgICAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jY29udHJhc3QtcmF0aW9kZWZcbiAgICAgICAgYSA9IG5ldyBDb2xvcihhKTtcbiAgICAgICAgYiA9IG5ldyBDb2xvcihiKTtcbiAgICAgICAgdmFyIGwxID0gYS5sdW1pbmFuY2UoKTtcbiAgICAgICAgdmFyIGwyID0gYi5sdW1pbmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIGwxID4gbDIgPyAobDEgKyAwLjA1KSAvIChsMiArIDAuMDUpIDogKGwyICsgMC4wNSkgLyAobDEgKyAwLjA1KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqXG4gICAgICogVGhlIEFQQ0EgY29udHJhc3QgcHJlZGljdGlvbiBhbGdvcml0aG0gaXMgYmFzZWQgb2YgdGhlIGZvcm11bGFzIHB1Ymxpc2hlZFxuICAgICAqIGluIHRoZSBBUENBLTEuMC45OEcgc3BlY2lmaWNhdGlvbiBieSBNeW5kZXguIFRoZSBzcGVjaWZpY2F0aW9uIGlzIGF2YWlsYWJsZSBhdDpcbiAgICAgKiBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vTXluZGV4L2FwY2EtdzMvbWFzdGVyL2ltYWdlcy9BUENBdzNfMC4xLjE3X0FQQ0EwLjAuOThHLnN2Z1xuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBBUENBIGltcGxlbWVudGF0aW9uIGlzIHN0aWxsIGJldGEsIHNvIHBsZWFzZSB1cGRhdGUgdG9cbiAgICAgKiBmdXR1cmUgdmVyc2lvbnMgb2YgY2hyb21hLmpzIHdoZW4gdGhleSBiZWNvbWUgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgdGhlIEFQQ0EgUmVhZGFiaWxpdHkgQ3JpdGVyaW9uIGF0XG4gICAgICogaHR0cHM6Ly9yZWFkdGVjaC5vcmcvQVJDL1xuICAgICAqL1xuXG4gICAgLy8gY29uc3RhbnRzXG4gICAgdmFyIFdfb2Zmc2V0ID0gMC4wMjc7XG4gICAgdmFyIFBfaW4gPSAwLjAwMDU7XG4gICAgdmFyIFBfb3V0ID0gMC4xO1xuICAgIHZhciBSX3NjYWxlID0gMS4xNDtcbiAgICB2YXIgQl90aHJlc2hvbGQgPSAwLjAyMjtcbiAgICB2YXIgQl9leHAgPSAxLjQxNDtcblxuICAgIGZ1bmN0aW9uIGNvbnRyYXN0QVBDQSAodGV4dCwgYmcpIHtcbiAgICAgICAgLy8gcGFyc2UgaW5wdXQgY29sb3JzXG4gICAgICAgIHRleHQgPSBuZXcgQ29sb3IodGV4dCk7XG4gICAgICAgIGJnID0gbmV3IENvbG9yKGJnKTtcbiAgICAgICAgLy8gaWYgdGV4dCBjb2xvciBoYXMgYWxwaGEsIGJsZW5kIGFnYWluc3QgYmFja2dyb3VuZFxuICAgICAgICBpZiAodGV4dC5hbHBoYSgpIDwgMSkge1xuICAgICAgICAgICAgdGV4dCA9IG1peChiZywgdGV4dCwgdGV4dC5hbHBoYSgpLCAncmdiJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxfdGV4dCA9IGx1bS5hcHBseSh2b2lkIDAsIHRleHQucmdiKCkpO1xuICAgICAgICB2YXIgbF9iZyA9IGx1bS5hcHBseSh2b2lkIDAsIGJnLnJnYigpKTtcblxuICAgICAgICAvLyBzb2Z0IGNsYW1wIGJsYWNrIGxldmVsc1xuICAgICAgICB2YXIgWV90ZXh0ID1cbiAgICAgICAgICAgIGxfdGV4dCA+PSBCX3RocmVzaG9sZFxuICAgICAgICAgICAgICAgID8gbF90ZXh0XG4gICAgICAgICAgICAgICAgOiBsX3RleHQgKyBNYXRoLnBvdyhCX3RocmVzaG9sZCAtIGxfdGV4dCwgQl9leHApO1xuICAgICAgICB2YXIgWV9iZyA9XG4gICAgICAgICAgICBsX2JnID49IEJfdGhyZXNob2xkID8gbF9iZyA6IGxfYmcgKyBNYXRoLnBvdyhCX3RocmVzaG9sZCAtIGxfYmcsIEJfZXhwKTtcblxuICAgICAgICAvLyBub3JtYWwgcG9sYXJpdHkgKGRhcmsgdGV4dCBvbiBsaWdodCBiYWNrZ3JvdW5kKVxuICAgICAgICB2YXIgU19ub3JtID0gTWF0aC5wb3coWV9iZywgMC41NikgLSBNYXRoLnBvdyhZX3RleHQsIDAuNTcpO1xuICAgICAgICAvLyByZXZlcnNlIHBvbGFyaXR5IChsaWdodCB0ZXh0IG9uIGRhcmsgYmFja2dyb3VuZClcbiAgICAgICAgdmFyIFNfcmV2ID0gTWF0aC5wb3coWV9iZywgMC42NSkgLSBNYXRoLnBvdyhZX3RleHQsIDAuNjIpO1xuICAgICAgICAvLyBjbGFtcCBub2lzZSB0aGVuIHNjYWxlXG4gICAgICAgIHZhciBDID1cbiAgICAgICAgICAgIE1hdGguYWJzKFlfYmcgLSBZX3RleHQpIDwgUF9pblxuICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgIDogWV90ZXh0IDwgWV9iZ1xuICAgICAgICAgICAgICAgICAgPyBTX25vcm0gKiBSX3NjYWxlXG4gICAgICAgICAgICAgICAgICA6IFNfcmV2ICogUl9zY2FsZTtcbiAgICAgICAgLy8gY2xhbXAgbWluaW11bSBjb250cmFzdCB0aGVuIG9mZnNldFxuICAgICAgICB2YXIgU19hcGMgPSBNYXRoLmFicyhDKSA8IFBfb3V0ID8gMCA6IEMgPiAwID8gQyAtIFdfb2Zmc2V0IDogQyArIFdfb2Zmc2V0O1xuICAgICAgICAvLyBzY2FsZSB0byAxMDBcbiAgICAgICAgcmV0dXJuIFNfYXBjICogMTAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsdW0ociwgZywgYikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgMC4yMTI2NzI5ICogTWF0aC5wb3cociAvIDI1NSwgMi40KSArXG4gICAgICAgICAgICAwLjcxNTE1MjIgKiBNYXRoLnBvdyhnIC8gMjU1LCAyLjQpICtcbiAgICAgICAgICAgIDAuMDcyMTc1ICogTWF0aC5wb3coYiAvIDI1NSwgMi40KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBwb3cgPSBNYXRoLnBvdztcbiAgICB2YXIgbWluID0gTWF0aC5taW47XG4gICAgdmFyIG1heCA9IE1hdGgubWF4O1xuICAgIHZhciBhdGFuMiA9IE1hdGguYXRhbjI7XG4gICAgdmFyIGFicyA9IE1hdGguYWJzO1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgc2luID0gTWF0aC5zaW47XG4gICAgdmFyIGV4cCA9IE1hdGguZXhwO1xuICAgIHZhciBQSSA9IE1hdGguUEk7XG5cbiAgICBmdW5jdGlvbiBkZWx0YUUgKGEsIGIsIEtsLCBLYywgS2gpIHtcbiAgICAgICAgaWYgKCBLbCA9PT0gdm9pZCAwICkgS2wgPSAxO1xuICAgICAgICBpZiAoIEtjID09PSB2b2lkIDAgKSBLYyA9IDE7XG4gICAgICAgIGlmICggS2ggPT09IHZvaWQgMCApIEtoID0gMTtcblxuICAgICAgICAvLyBEZWx0YSBFIChDSUUgMjAwMClcbiAgICAgICAgLy8gc2VlIGh0dHA6Ly93d3cuYnJ1Y2VsaW5kYmxvb20uY29tL2luZGV4Lmh0bWw/RXFuX0RlbHRhRV9DSUUyMDAwLmh0bWxcbiAgICAgICAgdmFyIHJhZDJkZWcgPSBmdW5jdGlvbiAocmFkKSB7XG4gICAgICAgICAgICByZXR1cm4gKDM2MCAqIHJhZCkgLyAoMiAqIFBJKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlZzJyYWQgPSBmdW5jdGlvbiAoZGVnKSB7XG4gICAgICAgICAgICByZXR1cm4gKDIgKiBQSSAqIGRlZykgLyAzNjA7XG4gICAgICAgIH07XG4gICAgICAgIGEgPSBuZXcgQ29sb3IoYSk7XG4gICAgICAgIGIgPSBuZXcgQ29sb3IoYik7XG4gICAgICAgIHZhciByZWYgPSBBcnJheS5mcm9tKGEubGFiKCkpO1xuICAgICAgICB2YXIgTDEgPSByZWZbMF07XG4gICAgICAgIHZhciBhMSA9IHJlZlsxXTtcbiAgICAgICAgdmFyIGIxID0gcmVmWzJdO1xuICAgICAgICB2YXIgcmVmJDEgPSBBcnJheS5mcm9tKGIubGFiKCkpO1xuICAgICAgICB2YXIgTDIgPSByZWYkMVswXTtcbiAgICAgICAgdmFyIGEyID0gcmVmJDFbMV07XG4gICAgICAgIHZhciBiMiA9IHJlZiQxWzJdO1xuICAgICAgICB2YXIgYXZnTCA9IChMMSArIEwyKSAvIDI7XG4gICAgICAgIHZhciBDMSA9IHNxcnQocG93KGExLCAyKSArIHBvdyhiMSwgMikpO1xuICAgICAgICB2YXIgQzIgPSBzcXJ0KHBvdyhhMiwgMikgKyBwb3coYjIsIDIpKTtcbiAgICAgICAgdmFyIGF2Z0MgPSAoQzEgKyBDMikgLyAyO1xuICAgICAgICB2YXIgRyA9IDAuNSAqICgxIC0gc3FydChwb3coYXZnQywgNykgLyAocG93KGF2Z0MsIDcpICsgcG93KDI1LCA3KSkpKTtcbiAgICAgICAgdmFyIGExcCA9IGExICogKDEgKyBHKTtcbiAgICAgICAgdmFyIGEycCA9IGEyICogKDEgKyBHKTtcbiAgICAgICAgdmFyIEMxcCA9IHNxcnQocG93KGExcCwgMikgKyBwb3coYjEsIDIpKTtcbiAgICAgICAgdmFyIEMycCA9IHNxcnQocG93KGEycCwgMikgKyBwb3coYjIsIDIpKTtcbiAgICAgICAgdmFyIGF2Z0NwID0gKEMxcCArIEMycCkgLyAyO1xuICAgICAgICB2YXIgYXJjdGFuMSA9IHJhZDJkZWcoYXRhbjIoYjEsIGExcCkpO1xuICAgICAgICB2YXIgYXJjdGFuMiA9IHJhZDJkZWcoYXRhbjIoYjIsIGEycCkpO1xuICAgICAgICB2YXIgaDFwID0gYXJjdGFuMSA+PSAwID8gYXJjdGFuMSA6IGFyY3RhbjEgKyAzNjA7XG4gICAgICAgIHZhciBoMnAgPSBhcmN0YW4yID49IDAgPyBhcmN0YW4yIDogYXJjdGFuMiArIDM2MDtcbiAgICAgICAgdmFyIGF2Z0hwID1cbiAgICAgICAgICAgIGFicyhoMXAgLSBoMnApID4gMTgwID8gKGgxcCArIGgycCArIDM2MCkgLyAyIDogKGgxcCArIGgycCkgLyAyO1xuICAgICAgICB2YXIgVCA9XG4gICAgICAgICAgICAxIC1cbiAgICAgICAgICAgIDAuMTcgKiBjb3MoZGVnMnJhZChhdmdIcCAtIDMwKSkgK1xuICAgICAgICAgICAgMC4yNCAqIGNvcyhkZWcycmFkKDIgKiBhdmdIcCkpICtcbiAgICAgICAgICAgIDAuMzIgKiBjb3MoZGVnMnJhZCgzICogYXZnSHAgKyA2KSkgLVxuICAgICAgICAgICAgMC4yICogY29zKGRlZzJyYWQoNCAqIGF2Z0hwIC0gNjMpKTtcbiAgICAgICAgdmFyIGRlbHRhSHAgPSBoMnAgLSBoMXA7XG4gICAgICAgIGRlbHRhSHAgPVxuICAgICAgICAgICAgYWJzKGRlbHRhSHApIDw9IDE4MFxuICAgICAgICAgICAgICAgID8gZGVsdGFIcFxuICAgICAgICAgICAgICAgIDogaDJwIDw9IGgxcFxuICAgICAgICAgICAgICAgICAgPyBkZWx0YUhwICsgMzYwXG4gICAgICAgICAgICAgICAgICA6IGRlbHRhSHAgLSAzNjA7XG4gICAgICAgIGRlbHRhSHAgPSAyICogc3FydChDMXAgKiBDMnApICogc2luKGRlZzJyYWQoZGVsdGFIcCkgLyAyKTtcbiAgICAgICAgdmFyIGRlbHRhTCA9IEwyIC0gTDE7XG4gICAgICAgIHZhciBkZWx0YUNwID0gQzJwIC0gQzFwO1xuICAgICAgICB2YXIgc2wgPSAxICsgKDAuMDE1ICogcG93KGF2Z0wgLSA1MCwgMikpIC8gc3FydCgyMCArIHBvdyhhdmdMIC0gNTAsIDIpKTtcbiAgICAgICAgdmFyIHNjID0gMSArIDAuMDQ1ICogYXZnQ3A7XG4gICAgICAgIHZhciBzaCA9IDEgKyAwLjAxNSAqIGF2Z0NwICogVDtcbiAgICAgICAgdmFyIGRlbHRhVGhldGEgPSAzMCAqIGV4cCgtcG93KChhdmdIcCAtIDI3NSkgLyAyNSwgMikpO1xuICAgICAgICB2YXIgUmMgPSAyICogc3FydChwb3coYXZnQ3AsIDcpIC8gKHBvdyhhdmdDcCwgNykgKyBwb3coMjUsIDcpKSk7XG4gICAgICAgIHZhciBSdCA9IC1SYyAqIHNpbigyICogZGVnMnJhZChkZWx0YVRoZXRhKSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBzcXJ0KFxuICAgICAgICAgICAgcG93KGRlbHRhTCAvIChLbCAqIHNsKSwgMikgK1xuICAgICAgICAgICAgICAgIHBvdyhkZWx0YUNwIC8gKEtjICogc2MpLCAyKSArXG4gICAgICAgICAgICAgICAgcG93KGRlbHRhSHAgLyAoS2ggKiBzaCksIDIpICtcbiAgICAgICAgICAgICAgICBSdCAqIChkZWx0YUNwIC8gKEtjICogc2MpKSAqIChkZWx0YUhwIC8gKEtoICogc2gpKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbWF4KDAsIG1pbigxMDAsIHJlc3VsdCkpO1xuICAgIH1cblxuICAgIC8vIHNpbXBsZSBFdWNsaWRlYW4gZGlzdGFuY2VcbiAgICBmdW5jdGlvbiBkaXN0YW5jZSAoYSwgYiwgbW9kZSkge1xuICAgICAgICBpZiAoIG1vZGUgPT09IHZvaWQgMCApIG1vZGUgPSAnbGFiJztcblxuICAgICAgICAvLyBEZWx0YSBFIChDSUUgMTk3NilcbiAgICAgICAgLy8gc2VlIGh0dHA6Ly93d3cuYnJ1Y2VsaW5kYmxvb20uY29tL2luZGV4Lmh0bWw/RXF1YXRpb25zLmh0bWxcbiAgICAgICAgYSA9IG5ldyBDb2xvcihhKTtcbiAgICAgICAgYiA9IG5ldyBDb2xvcihiKTtcbiAgICAgICAgdmFyIGwxID0gYS5nZXQobW9kZSk7XG4gICAgICAgIHZhciBsMiA9IGIuZ2V0KG1vZGUpO1xuICAgICAgICB2YXIgc3VtX3NxID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBsMSkge1xuICAgICAgICAgICAgdmFyIGQgPSAobDFbaV0gfHwgMCkgLSAobDJbaV0gfHwgMCk7XG4gICAgICAgICAgICBzdW1fc3EgKz0gZCAqIGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChzdW1fc3EpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSggQ29sb3IsIFsgbnVsbCBdLmNvbmNhdCggYXJncykgKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzb21lIHByZS1kZWZpbmVkIGNvbG9yIHNjYWxlczpcblxuICAgIHZhciBzY2FsZXMgPSB7XG4gICAgICAgIGNvb2w6IGZ1bmN0aW9uIGNvb2woKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGUoW2Nocm9tYS5oc2woMTgwLCAxLCAwLjkpLCBjaHJvbWEuaHNsKDI1MCwgMC43LCAwLjQpXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhvdDogZnVuY3Rpb24gaG90KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlKFsnIzAwMCcsICcjZjAwJywgJyNmZjAnLCAnI2ZmZiddKS5tb2RlKFxuICAgICAgICAgICAgICAgICdyZ2InXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAgICBDb2xvckJyZXdlciBjb2xvcnMgZm9yIGNocm9tYS5qc1xuXG4gICAgICAgIENvcHlyaWdodCAoYykgMjAwMiBDeW50aGlhIEJyZXdlciwgTWFyayBIYXJyb3dlciwgYW5kIFRoZVxuICAgICAgICBQZW5uc3lsdmFuaWEgU3RhdGUgVW5pdmVyc2l0eS5cblxuICAgICAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAgICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICAgICAgICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkXG4gICAgICAgIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SXG4gICAgICAgIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gICAgICAgIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAgKi9cblxuICAgIHZhciBjb2xvcmJyZXdlciA9IHtcbiAgICAgICAgLy8gc2VxdWVudGlhbFxuICAgICAgICBPclJkOiBbJyNmZmY3ZWMnLCAnI2ZlZThjOCcsICcjZmRkNDllJywgJyNmZGJiODQnLCAnI2ZjOGQ1OScsICcjZWY2NTQ4JywgJyNkNzMwMWYnLCAnI2IzMDAwMCcsICcjN2YwMDAwJ10sXG4gICAgICAgIFB1QnU6IFsnI2ZmZjdmYicsICcjZWNlN2YyJywgJyNkMGQxZTYnLCAnI2E2YmRkYicsICcjNzRhOWNmJywgJyMzNjkwYzAnLCAnIzA1NzBiMCcsICcjMDQ1YThkJywgJyMwMjM4NTgnXSxcbiAgICAgICAgQnVQdTogWycjZjdmY2ZkJywgJyNlMGVjZjQnLCAnI2JmZDNlNicsICcjOWViY2RhJywgJyM4Yzk2YzYnLCAnIzhjNmJiMScsICcjODg0MTlkJywgJyM4MTBmN2MnLCAnIzRkMDA0YiddLFxuICAgICAgICBPcmFuZ2VzOiBbJyNmZmY1ZWInLCAnI2ZlZTZjZScsICcjZmRkMGEyJywgJyNmZGFlNmInLCAnI2ZkOGQzYycsICcjZjE2OTEzJywgJyNkOTQ4MDEnLCAnI2E2MzYwMycsICcjN2YyNzA0J10sXG4gICAgICAgIEJ1R246IFsnI2Y3ZmNmZCcsICcjZTVmNWY5JywgJyNjY2VjZTYnLCAnIzk5ZDhjOScsICcjNjZjMmE0JywgJyM0MWFlNzYnLCAnIzIzOGI0NScsICcjMDA2ZDJjJywgJyMwMDQ0MWInXSxcbiAgICAgICAgWWxPckJyOiBbJyNmZmZmZTUnLCAnI2ZmZjdiYycsICcjZmVlMzkxJywgJyNmZWM0NGYnLCAnI2ZlOTkyOScsICcjZWM3MDE0JywgJyNjYzRjMDInLCAnIzk5MzQwNCcsICcjNjYyNTA2J10sXG4gICAgICAgIFlsR246IFsnI2ZmZmZlNScsICcjZjdmY2I5JywgJyNkOWYwYTMnLCAnI2FkZGQ4ZScsICcjNzhjNjc5JywgJyM0MWFiNWQnLCAnIzIzODQ0MycsICcjMDA2ODM3JywgJyMwMDQ1MjknXSxcbiAgICAgICAgUmVkczogWycjZmZmNWYwJywgJyNmZWUwZDInLCAnI2ZjYmJhMScsICcjZmM5MjcyJywgJyNmYjZhNGEnLCAnI2VmM2IyYycsICcjY2IxODFkJywgJyNhNTBmMTUnLCAnIzY3MDAwZCddLFxuICAgICAgICBSZFB1OiBbJyNmZmY3ZjMnLCAnI2ZkZTBkZCcsICcjZmNjNWMwJywgJyNmYTlmYjUnLCAnI2Y3NjhhMScsICcjZGQzNDk3JywgJyNhZTAxN2UnLCAnIzdhMDE3NycsICcjNDkwMDZhJ10sXG4gICAgICAgIEdyZWVuczogWycjZjdmY2Y1JywgJyNlNWY1ZTAnLCAnI2M3ZTljMCcsICcjYTFkOTliJywgJyM3NGM0NzYnLCAnIzQxYWI1ZCcsICcjMjM4YjQ1JywgJyMwMDZkMmMnLCAnIzAwNDQxYiddLFxuICAgICAgICBZbEduQnU6IFsnI2ZmZmZkOScsICcjZWRmOGIxJywgJyNjN2U5YjQnLCAnIzdmY2RiYicsICcjNDFiNmM0JywgJyMxZDkxYzAnLCAnIzIyNWVhOCcsICcjMjUzNDk0JywgJyMwODFkNTgnXSxcbiAgICAgICAgUHVycGxlczogWycjZmNmYmZkJywgJyNlZmVkZjUnLCAnI2RhZGFlYicsICcjYmNiZGRjJywgJyM5ZTlhYzgnLCAnIzgwN2RiYScsICcjNmE1MWEzJywgJyM1NDI3OGYnLCAnIzNmMDA3ZCddLFxuICAgICAgICBHbkJ1OiBbJyNmN2ZjZjAnLCAnI2UwZjNkYicsICcjY2NlYmM1JywgJyNhOGRkYjUnLCAnIzdiY2NjNCcsICcjNGViM2QzJywgJyMyYjhjYmUnLCAnIzA4NjhhYycsICcjMDg0MDgxJ10sXG4gICAgICAgIEdyZXlzOiBbJyNmZmZmZmYnLCAnI2YwZjBmMCcsICcjZDlkOWQ5JywgJyNiZGJkYmQnLCAnIzk2OTY5NicsICcjNzM3MzczJywgJyM1MjUyNTInLCAnIzI1MjUyNScsICcjMDAwMDAwJ10sXG4gICAgICAgIFlsT3JSZDogWycjZmZmZmNjJywgJyNmZmVkYTAnLCAnI2ZlZDk3NicsICcjZmViMjRjJywgJyNmZDhkM2MnLCAnI2ZjNGUyYScsICcjZTMxYTFjJywgJyNiZDAwMjYnLCAnIzgwMDAyNiddLFxuICAgICAgICBQdVJkOiBbJyNmN2Y0ZjknLCAnI2U3ZTFlZicsICcjZDRiOWRhJywgJyNjOTk0YzcnLCAnI2RmNjViMCcsICcjZTcyOThhJywgJyNjZTEyNTYnLCAnIzk4MDA0MycsICcjNjcwMDFmJ10sXG4gICAgICAgIEJsdWVzOiBbJyNmN2ZiZmYnLCAnI2RlZWJmNycsICcjYzZkYmVmJywgJyM5ZWNhZTEnLCAnIzZiYWVkNicsICcjNDI5MmM2JywgJyMyMTcxYjUnLCAnIzA4NTE5YycsICcjMDgzMDZiJ10sXG4gICAgICAgIFB1QnVHbjogWycjZmZmN2ZiJywgJyNlY2UyZjAnLCAnI2QwZDFlNicsICcjYTZiZGRiJywgJyM2N2E5Y2YnLCAnIzM2OTBjMCcsICcjMDI4MThhJywgJyMwMTZjNTknLCAnIzAxNDYzNiddLFxuICAgICAgICBWaXJpZGlzOiBbJyM0NDAxNTQnLCAnIzQ4Mjc3NycsICcjM2Y0YThhJywgJyMzMTY3OGUnLCAnIzI2ODM4ZicsICcjMWY5ZDhhJywgJyM2Y2NlNWEnLCAnI2I2ZGUyYicsICcjZmVlODI1J10sXG5cbiAgICAgICAgLy8gZGl2ZXJnaW5nXG4gICAgICAgIFNwZWN0cmFsOiBbJyM5ZTAxNDInLCAnI2Q1M2U0ZicsICcjZjQ2ZDQzJywgJyNmZGFlNjEnLCAnI2ZlZTA4YicsICcjZmZmZmJmJywgJyNlNmY1OTgnLCAnI2FiZGRhNCcsICcjNjZjMmE1JywgJyMzMjg4YmQnLCAnIzVlNGZhMiddLFxuICAgICAgICBSZFlsR246IFsnI2E1MDAyNicsICcjZDczMDI3JywgJyNmNDZkNDMnLCAnI2ZkYWU2MScsICcjZmVlMDhiJywgJyNmZmZmYmYnLCAnI2Q5ZWY4YicsICcjYTZkOTZhJywgJyM2NmJkNjMnLCAnIzFhOTg1MCcsICcjMDA2ODM3J10sXG4gICAgICAgIFJkQnU6IFsnIzY3MDAxZicsICcjYjIxODJiJywgJyNkNjYwNGQnLCAnI2Y0YTU4MicsICcjZmRkYmM3JywgJyNmN2Y3ZjcnLCAnI2QxZTVmMCcsICcjOTJjNWRlJywgJyM0MzkzYzMnLCAnIzIxNjZhYycsICcjMDUzMDYxJ10sXG4gICAgICAgIFBpWUc6IFsnIzhlMDE1MicsICcjYzUxYjdkJywgJyNkZTc3YWUnLCAnI2YxYjZkYScsICcjZmRlMGVmJywgJyNmN2Y3ZjcnLCAnI2U2ZjVkMCcsICcjYjhlMTg2JywgJyM3ZmJjNDEnLCAnIzRkOTIyMScsICcjMjc2NDE5J10sXG4gICAgICAgIFBSR246IFsnIzQwMDA0YicsICcjNzYyYTgzJywgJyM5OTcwYWInLCAnI2MyYTVjZicsICcjZTdkNGU4JywgJyNmN2Y3ZjcnLCAnI2Q5ZjBkMycsICcjYTZkYmEwJywgJyM1YWFlNjEnLCAnIzFiNzgzNycsICcjMDA0NDFiJ10sXG4gICAgICAgIFJkWWxCdTogWycjYTUwMDI2JywgJyNkNzMwMjcnLCAnI2Y0NmQ0MycsICcjZmRhZTYxJywgJyNmZWUwOTAnLCAnI2ZmZmZiZicsICcjZTBmM2Y4JywgJyNhYmQ5ZTknLCAnIzc0YWRkMScsICcjNDU3NWI0JywgJyMzMTM2OTUnXSxcbiAgICAgICAgQnJCRzogWycjNTQzMDA1JywgJyM4YzUxMGEnLCAnI2JmODEyZCcsICcjZGZjMjdkJywgJyNmNmU4YzMnLCAnI2Y1ZjVmNScsICcjYzdlYWU1JywgJyM4MGNkYzEnLCAnIzM1OTc4ZicsICcjMDE2NjVlJywgJyMwMDNjMzAnXSxcbiAgICAgICAgUmRHeTogWycjNjcwMDFmJywgJyNiMjE4MmInLCAnI2Q2NjA0ZCcsICcjZjRhNTgyJywgJyNmZGRiYzcnLCAnI2ZmZmZmZicsICcjZTBlMGUwJywgJyNiYWJhYmEnLCAnIzg3ODc4NycsICcjNGQ0ZDRkJywgJyMxYTFhMWEnXSxcbiAgICAgICAgUHVPcjogWycjN2YzYjA4JywgJyNiMzU4MDYnLCAnI2UwODIxNCcsICcjZmRiODYzJywgJyNmZWUwYjYnLCAnI2Y3ZjdmNycsICcjZDhkYWViJywgJyNiMmFiZDInLCAnIzgwNzNhYycsICcjNTQyNzg4JywgJyMyZDAwNGInXSxcblxuICAgICAgICAvLyBxdWFsaXRhdGl2ZVxuICAgICAgICBTZXQyOiBbJyM2NmMyYTUnLCAnI2ZjOGQ2MicsICcjOGRhMGNiJywgJyNlNzhhYzMnLCAnI2E2ZDg1NCcsICcjZmZkOTJmJywgJyNlNWM0OTQnLCAnI2IzYjNiMyddLFxuICAgICAgICBBY2NlbnQ6IFsnIzdmYzk3ZicsICcjYmVhZWQ0JywgJyNmZGMwODYnLCAnI2ZmZmY5OScsICcjMzg2Y2IwJywgJyNmMDAyN2YnLCAnI2JmNWIxNycsICcjNjY2NjY2J10sXG4gICAgICAgIFNldDE6IFsnI2U0MWExYycsICcjMzc3ZWI4JywgJyM0ZGFmNGEnLCAnIzk4NGVhMycsICcjZmY3ZjAwJywgJyNmZmZmMzMnLCAnI2E2NTYyOCcsICcjZjc4MWJmJywgJyM5OTk5OTknXSxcbiAgICAgICAgU2V0MzogWycjOGRkM2M3JywgJyNmZmZmYjMnLCAnI2JlYmFkYScsICcjZmI4MDcyJywgJyM4MGIxZDMnLCAnI2ZkYjQ2MicsICcjYjNkZTY5JywgJyNmY2NkZTUnLCAnI2Q5ZDlkOScsICcjYmM4MGJkJywgJyNjY2ViYzUnLCAnI2ZmZWQ2ZiddLFxuICAgICAgICBEYXJrMjogWycjMWI5ZTc3JywgJyNkOTVmMDInLCAnIzc1NzBiMycsICcjZTcyOThhJywgJyM2NmE2MWUnLCAnI2U2YWIwMicsICcjYTY3NjFkJywgJyM2NjY2NjYnXSxcbiAgICAgICAgUGFpcmVkOiBbJyNhNmNlZTMnLCAnIzFmNzhiNCcsICcjYjJkZjhhJywgJyMzM2EwMmMnLCAnI2ZiOWE5OScsICcjZTMxYTFjJywgJyNmZGJmNmYnLCAnI2ZmN2YwMCcsICcjY2FiMmQ2JywgJyM2YTNkOWEnLCAnI2ZmZmY5OScsICcjYjE1OTI4J10sXG4gICAgICAgIFBhc3RlbDI6IFsnI2IzZTJjZCcsICcjZmRjZGFjJywgJyNjYmQ1ZTgnLCAnI2Y0Y2FlNCcsICcjZTZmNWM5JywgJyNmZmYyYWUnLCAnI2YxZTJjYycsICcjY2NjY2NjJ10sXG4gICAgICAgIFBhc3RlbDE6IFsnI2ZiYjRhZScsICcjYjNjZGUzJywgJyNjY2ViYzUnLCAnI2RlY2JlNCcsICcjZmVkOWE2JywgJyNmZmZmY2MnLCAnI2U1ZDhiZCcsICcjZmRkYWVjJywgJyNmMmYyZjInXVxuICAgIH07XG5cbiAgICB2YXIgY29sb3JicmV3ZXJUeXBlcyA9IE9iamVjdC5rZXlzKGNvbG9yYnJld2VyKTtcbiAgICB2YXIgdHlwZU1hcCA9IG5ldyBNYXAoY29sb3JicmV3ZXJUeXBlcy5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gW2tleS50b0xvd2VyQ2FzZSgpLCBrZXldOyB9KSk7XG5cbiAgICAvLyB1c2UgUHJveHkgdG8gYWxsb3cgY2FzZS1pbnNlbnNpdGl2ZSBhY2Nlc3MgdG8gcGFsZXR0ZXNcbiAgICB2YXIgY29sb3JicmV3ZXJQcm94eSA9XG4gICAgICAgIHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBuZXcgUHJveHkoY29sb3JicmV3ZXIsIHtcbiAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBsb3dlciA9IHByb3AudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZU1hcC5oYXMobG93ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbdHlwZU1hcC5nZXQobG93ZXIpXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlOYW1lczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY29sb3JicmV3ZXJUeXBlcyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IGNvbG9yYnJld2VyO1xuXG4gICAgLy8gZmVlbCBmcmVlIHRvIGNvbW1lbnQgb3V0IGFueXRoaW5nIHRvIHJvbGx1cFxuICAgIC8vIGEgc21hbGxlciBjaHJvbWEuanMgYnVuZGxlXG5cbiAgICBPYmplY3QuYXNzaWduKGNocm9tYSwge1xuICAgICAgICBhbmFseXplOiBhbmFseXplLFxuICAgICAgICBhdmVyYWdlOiBhdmVyYWdlLFxuICAgICAgICBiZXppZXI6IGJlemllciQxLFxuICAgICAgICBibGVuZDogYmxlbmQsXG4gICAgICAgIGJyZXdlcjogY29sb3JicmV3ZXJQcm94eSxcbiAgICAgICAgQ29sb3I6IENvbG9yLFxuICAgICAgICBjb2xvcnM6IHczY3gxMSxcbiAgICAgICAgY29udHJhc3Q6IGNvbnRyYXN0LFxuICAgICAgICBjb250cmFzdEFQQ0E6IGNvbnRyYXN0QVBDQSxcbiAgICAgICAgY3ViZWhlbGl4OiBjdWJlaGVsaXgsXG4gICAgICAgIGRlbHRhRTogZGVsdGFFLFxuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgIGlucHV0OiBpbnB1dCxcbiAgICAgICAgaW50ZXJwb2xhdGU6IG1peCxcbiAgICAgICAgbGltaXRzOiBsaW1pdHMsXG4gICAgICAgIG1peDogbWl4LFxuICAgICAgICByYW5kb206IHJhbmRvbSQxLFxuICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgIHNjYWxlczogc2NhbGVzLFxuICAgICAgICB2YWxpZDogdmFsaWQsXG4gICAgICAgIGNteWs6IGNteWssXG4gICAgICAgIGNzczogY3NzLFxuICAgICAgICBnbDogZ2wsXG4gICAgICAgIGhjZzogaGNnJDEsXG4gICAgICAgIGhleDogaGV4LFxuICAgICAgICBoc2k6IGhzaSQxLFxuICAgICAgICBoc2w6IGhzbCQxLFxuICAgICAgICBoc3Y6IGhzdiQxLFxuICAgICAgICBsYWI6IGxhYiQxLFxuICAgICAgICBsY2g6IGxjaCQxLFxuICAgICAgICBoY2w6IGhjbCxcbiAgICAgICAgbnVtOiBudW0kMSxcbiAgICAgICAgcmdiOiByZ2IkMSxcbiAgICAgICAgdGVtcDogdGVtcCxcbiAgICAgICAga2VsdmluOiB0ZW1wLFxuICAgICAgICB0ZW1wZXJhdHVyZTogdGVtcCxcbiAgICAgICAgb2tsYWI6IG9rbGFiJDEsXG4gICAgICAgIG9rbGNoOiBva2xjaCQxLFxuICAgICAgICBnZXRMYWJXaGl0ZVBvaW50OiBnZXRMYWJXaGl0ZVBvaW50LFxuICAgICAgICBzZXRMYWJXaGl0ZVBvaW50OiBzZXRMYWJXaGl0ZVBvaW50XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2hyb21hO1xuXG59KSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/chroma-js/dist/chroma.cjs\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fdavidebiscuso%2FDocuments%2FGitHub%2Fcolor-ramp%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);