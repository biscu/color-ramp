"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/color-contrast";
exports.ids = ["vendor-chunks/color-contrast"];
exports.modules = {

/***/ "(ssr)/./node_modules/color-contrast/dist/index.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/color-contrast/dist/index.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar installedColorSpaces = [],\n    undef = function (obj) {\n  return typeof obj === 'undefined';\n},\n    channelRegExp = /\\s*(\\.\\d+|\\d+(?:\\.\\d+)?)(%)?\\s*/,\n    percentageChannelRegExp = /\\s*(\\.\\d+|100|\\d?\\d(?:\\.\\d+)?)%\\s*/,\n    alphaChannelRegExp = /\\s*(\\.\\d+|\\d+(?:\\.\\d+)?)\\s*/,\n    cssColorRegExp = new RegExp('^(rgb|hsl|hsv)a?' + '\\\\(' + channelRegExp.source + ',' + channelRegExp.source + ',' + channelRegExp.source + '(?:,' + alphaChannelRegExp.source + ')?' + '\\\\)$', 'i');\n\nfunction color(obj) {\n  if (Array.isArray(obj)) {\n    if (typeof obj[0] === 'string' && typeof color[obj[0]] === 'function') {\n      // Assumed array from .toJSON()\n      return new color[obj[0]](obj.slice(1, obj.length));\n    } else if (obj.length === 4) {\n      // Assumed 4 element int RGB array from canvas with all channels [0;255]\n      return new color.RGB(obj[0] / 255, obj[1] / 255, obj[2] / 255, obj[3] / 255);\n    }\n  } else if (typeof obj === 'string') {\n    var lowerCased = obj.toLowerCase();\n\n    if (color.namedColors[lowerCased]) {\n      obj = '#' + color.namedColors[lowerCased];\n    }\n\n    if (lowerCased === 'transparent') {\n      obj = 'rgba(0,0,0,0)';\n    } // Test for CSS rgb(....) string\n\n\n    var matchCssSyntax = obj.match(cssColorRegExp);\n\n    if (matchCssSyntax) {\n      var colorSpaceName = matchCssSyntax[1].toUpperCase(),\n          alpha = undef(matchCssSyntax[8]) ? matchCssSyntax[8] : parseFloat(matchCssSyntax[8]),\n          hasHue = colorSpaceName[0] === 'H',\n          firstChannelDivisor = matchCssSyntax[3] ? 100 : hasHue ? 360 : 255,\n          secondChannelDivisor = matchCssSyntax[5] || hasHue ? 100 : 255,\n          thirdChannelDivisor = matchCssSyntax[7] || hasHue ? 100 : 255;\n\n      if (undef(color[colorSpaceName])) {\n        throw new Error('color.' + colorSpaceName + ' is not installed.');\n      }\n\n      return new color[colorSpaceName](parseFloat(matchCssSyntax[2]) / firstChannelDivisor, parseFloat(matchCssSyntax[4]) / secondChannelDivisor, parseFloat(matchCssSyntax[6]) / thirdChannelDivisor, alpha);\n    } // Assume hex syntax\n\n\n    if (obj.length < 6) {\n      // Allow CSS shorthand\n      obj = obj.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, '$1$1$2$2$3$3');\n    } // Split obj into red, green, and blue components\n\n\n    var hexMatch = obj.match(/^#?([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])$/i);\n\n    if (hexMatch) {\n      return new color.RGB(parseInt(hexMatch[1], 16) / 255, parseInt(hexMatch[2], 16) / 255, parseInt(hexMatch[3], 16) / 255);\n    } // No match so far. Lets try the less likely ones\n\n\n    if (color.CMYK) {\n      var cmykMatch = obj.match(new RegExp('^cmyk' + '\\\\(' + percentageChannelRegExp.source + ',' + percentageChannelRegExp.source + ',' + percentageChannelRegExp.source + ',' + percentageChannelRegExp.source + '\\\\)$', 'i'));\n\n      if (cmykMatch) {\n        return new color.CMYK(parseFloat(cmykMatch[1]) / 100, parseFloat(cmykMatch[2]) / 100, parseFloat(cmykMatch[3]) / 100, parseFloat(cmykMatch[4]) / 100);\n      }\n    }\n  } else if (typeof obj === 'object' && obj.isColor) {\n    return obj;\n  }\n\n  return false;\n}\n\ncolor.namedColors = {};\n\ncolor.installColorSpace = function (colorSpaceName, propertyNames, config) {\n  color[colorSpaceName] = function (a1) {\n    // ...\n    var args = Array.isArray(a1) ? a1 : arguments;\n    propertyNames.forEach(function (propertyName, i) {\n      var propertyValue = args[i];\n\n      if (propertyName === 'alpha') {\n        this._alpha = isNaN(propertyValue) || propertyValue > 1 ? 1 : propertyValue < 0 ? 0 : propertyValue;\n      } else {\n        if (isNaN(propertyValue)) {\n          throw new Error('[' + colorSpaceName + ']: Invalid color: (' + propertyNames.join(',') + ')');\n        }\n\n        if (propertyName === 'hue') {\n          this._hue = propertyValue < 0 ? propertyValue - Math.floor(propertyValue) : propertyValue % 1;\n        } else {\n          this['_' + propertyName] = propertyValue < 0 ? 0 : propertyValue > 1 ? 1 : propertyValue;\n        }\n      }\n    }, this);\n  };\n\n  color[colorSpaceName].propertyNames = propertyNames;\n  var prototype = color[colorSpaceName].prototype;\n  ['valueOf', 'hex', 'hexa', 'css', 'cssa'].forEach(function (methodName) {\n    prototype[methodName] = prototype[methodName] || (colorSpaceName === 'RGB' ? prototype.hex : function () {\n      return this.rgb()[methodName]();\n    });\n  });\n  prototype.isColor = true;\n\n  prototype.equals = function (otherColor, epsilon) {\n    if (undef(epsilon)) {\n      epsilon = 1e-10;\n    }\n\n    otherColor = otherColor[colorSpaceName.toLowerCase()]();\n\n    for (var i = 0; i < propertyNames.length; i = i + 1) {\n      if (Math.abs(this['_' + propertyNames[i]] - otherColor['_' + propertyNames[i]]) > epsilon) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  prototype.toJSON = function () {\n    return [colorSpaceName].concat(propertyNames.map(function (propertyName) {\n      return this['_' + propertyName];\n    }, this));\n  };\n\n  for (var propertyName in config) {\n    if (config.hasOwnProperty(propertyName)) {\n      var matchFromColorSpace = propertyName.match(/^from(.*)$/);\n\n      if (matchFromColorSpace) {\n        color[matchFromColorSpace[1].toUpperCase()].prototype[colorSpaceName.toLowerCase()] = config[propertyName];\n      } else {\n        prototype[propertyName] = config[propertyName];\n      }\n    }\n  } // It is pretty easy to implement the conversion to the same color space:\n\n\n  prototype[colorSpaceName.toLowerCase()] = function () {\n    return this;\n  };\n\n  prototype.toString = function () {\n    return '[' + colorSpaceName + ' ' + propertyNames.map(function (propertyName) {\n      return this['_' + propertyName];\n    }, this).join(', ') + ']';\n  }; // Generate getters and setters\n\n\n  propertyNames.forEach(function (propertyName) {\n    var shortName = propertyName === 'black' ? 'k' : propertyName.charAt(0);\n\n    prototype[propertyName] = prototype[shortName] = function (value, isDelta) {\n      // Simple getter mode: color.red()\n      if (typeof value === 'undefined') {\n        return this['_' + propertyName];\n      } else if (isDelta) {\n        // Adjuster: color.red(+.2, true)\n        return new this.constructor(propertyNames.map(function (otherPropertyName) {\n          return this['_' + otherPropertyName] + (propertyName === otherPropertyName ? value : 0);\n        }, this));\n      } else {\n        // Setter: color.red(.2);\n        return new this.constructor(propertyNames.map(function (otherPropertyName) {\n          return propertyName === otherPropertyName ? value : this['_' + otherPropertyName];\n        }, this));\n      }\n    };\n  });\n\n  function installForeignMethods(targetColorSpaceName, sourceColorSpaceName) {\n    var obj = {};\n\n    obj[sourceColorSpaceName.toLowerCase()] = function () {\n      return this.rgb()[sourceColorSpaceName.toLowerCase()]();\n    };\n\n    color[sourceColorSpaceName].propertyNames.forEach(function (propertyName) {\n      var shortName = propertyName === 'black' ? 'k' : propertyName.charAt(0);\n\n      obj[propertyName] = obj[shortName] = function (value, isDelta) {\n        return this[sourceColorSpaceName.toLowerCase()]()[propertyName](value, isDelta);\n      };\n    });\n\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop) && color[targetColorSpaceName].prototype[prop] === undefined) {\n        color[targetColorSpaceName].prototype[prop] = obj[prop];\n      }\n    }\n  }\n\n  installedColorSpaces.forEach(function (otherColorSpaceName) {\n    installForeignMethods(colorSpaceName, otherColorSpaceName);\n    installForeignMethods(otherColorSpaceName, colorSpaceName);\n  });\n  installedColorSpaces.push(colorSpaceName);\n  return color;\n};\n\ncolor.pluginList = [];\n\ncolor.use = function (plugin) {\n  if (color.pluginList.indexOf(plugin) === -1) {\n    this.pluginList.push(plugin);\n    plugin(color);\n  }\n\n  return color;\n};\n\ncolor.installMethod = function (name, fn) {\n  installedColorSpaces.forEach(function (colorSpace) {\n    color[colorSpace].prototype[name] = fn;\n  });\n  return this;\n};\n\ncolor.installColorSpace('RGB', ['red', 'green', 'blue', 'alpha'], {\n  hex: function () {\n    var hexString = (Math.round(255 * this._red) * 0x10000 + Math.round(255 * this._green) * 0x100 + Math.round(255 * this._blue)).toString(16);\n    return '#' + '00000'.substr(0, 6 - hexString.length) + hexString;\n  },\n  hexa: function () {\n    var alphaString = Math.round(this._alpha * 255).toString(16);\n    return '#' + '00'.substr(0, 2 - alphaString.length) + alphaString + this.hex().substr(1, 6);\n  },\n  css: function () {\n    return 'rgb(' + Math.round(255 * this._red) + ',' + Math.round(255 * this._green) + ',' + Math.round(255 * this._blue) + ')';\n  },\n  cssa: function () {\n    return 'rgba(' + Math.round(255 * this._red) + ',' + Math.round(255 * this._green) + ',' + Math.round(255 * this._blue) + ',' + this._alpha + ')';\n  }\n});\nvar color_1 = color;\n\nvar XYZ = function XYZ(color) {\n  color.installColorSpace('XYZ', ['x', 'y', 'z', 'alpha'], {\n    fromRgb: function () {\n      // http://www.easyrgb.com/index.php?X=MATH&H=02#text2\n      var convert = function (channel) {\n        return channel > 0.04045 ? Math.pow((channel + 0.055) / 1.055, 2.4) : channel / 12.92;\n      },\n          r = convert(this._red),\n          g = convert(this._green),\n          b = convert(this._blue); // Reference white point sRGB D65:\n      // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\n\n      return new color.XYZ(r * 0.4124564 + g * 0.3575761 + b * 0.1804375, r * 0.2126729 + g * 0.7151522 + b * 0.0721750, r * 0.0193339 + g * 0.1191920 + b * 0.9503041, this._alpha);\n    },\n    rgb: function () {\n      // http://www.easyrgb.com/index.php?X=MATH&H=01#text1\n      var x = this._x,\n          y = this._y,\n          z = this._z,\n          convert = function (channel) {\n        return channel > 0.0031308 ? 1.055 * Math.pow(channel, 1 / 2.4) - 0.055 : 12.92 * channel;\n      }; // Reference white point sRGB D65:\n      // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\n\n      return new color.RGB(convert(x * 3.2404542 + y * -1.5371385 + z * -0.4985314), convert(x * -0.9692660 + y * 1.8760108 + z * 0.0415560), convert(x * 0.0556434 + y * -0.2040259 + z * 1.0572252), this._alpha);\n    },\n    lab: function () {\n      // http://www.easyrgb.com/index.php?X=MATH&H=07#text7\n      var convert = function (channel) {\n        return channel > 0.008856 ? Math.pow(channel, 1 / 3) : 7.787037 * channel + 4 / 29;\n      },\n          x = convert(this._x / 95.047),\n          y = convert(this._y / 100.000),\n          z = convert(this._z / 108.883);\n\n      return new color.LAB(116 * y - 16, 500 * (x - y), 200 * (y - z), this._alpha);\n    }\n  });\n};\n\nvar LAB = function LAB(color) {\n  color.use(XYZ);\n  color.installColorSpace('LAB', ['l', 'a', 'b', 'alpha'], {\n    fromRgb: function () {\n      return this.xyz().lab();\n    },\n    rgb: function () {\n      return this.xyz().rgb();\n    },\n    xyz: function () {\n      // http://www.easyrgb.com/index.php?X=MATH&H=08#text8\n      var convert = function (channel) {\n        var pow = Math.pow(channel, 3);\n        return pow > 0.008856 ? pow : (channel - 16 / 116) / 7.87;\n      },\n          y = (this._l + 16) / 116,\n          x = this._a / 500 + y,\n          z = y - this._b / 200;\n\n      return new color.XYZ(convert(x) * 95.047, convert(y) * 100.000, convert(z) * 108.883, this._alpha);\n    }\n  });\n};\n\nvar HSV = function HSV(color) {\n  color.installColorSpace('HSV', ['hue', 'saturation', 'value', 'alpha'], {\n    rgb: function () {\n      var hue = this._hue,\n          saturation = this._saturation,\n          value = this._value,\n          i = Math.min(5, Math.floor(hue * 6)),\n          f = hue * 6 - i,\n          p = value * (1 - saturation),\n          q = value * (1 - f * saturation),\n          t = value * (1 - (1 - f) * saturation),\n          red,\n          green,\n          blue;\n\n      switch (i) {\n        case 0:\n          red = value;\n          green = t;\n          blue = p;\n          break;\n\n        case 1:\n          red = q;\n          green = value;\n          blue = p;\n          break;\n\n        case 2:\n          red = p;\n          green = value;\n          blue = t;\n          break;\n\n        case 3:\n          red = p;\n          green = q;\n          blue = value;\n          break;\n\n        case 4:\n          red = t;\n          green = p;\n          blue = value;\n          break;\n\n        case 5:\n          red = value;\n          green = p;\n          blue = q;\n          break;\n      }\n\n      return new color.RGB(red, green, blue, this._alpha);\n    },\n    hsl: function () {\n      var l = (2 - this._saturation) * this._value,\n          sv = this._saturation * this._value,\n          svDivisor = l <= 1 ? l : 2 - l,\n          saturation; // Avoid division by zero when lightness approaches zero:\n\n      if (svDivisor < 1e-9) {\n        saturation = 0;\n      } else {\n        saturation = sv / svDivisor;\n      }\n\n      return new color.HSL(this._hue, saturation, l / 2, this._alpha);\n    },\n    fromRgb: function () {\n      // Becomes one.color.RGB.prototype.hsv\n      var red = this._red,\n          green = this._green,\n          blue = this._blue,\n          max = Math.max(red, green, blue),\n          min = Math.min(red, green, blue),\n          delta = max - min,\n          hue,\n          saturation = max === 0 ? 0 : delta / max,\n          value = max;\n\n      if (delta === 0) {\n        hue = 0;\n      } else {\n        switch (max) {\n          case red:\n            hue = (green - blue) / delta / 6 + (green < blue ? 1 : 0);\n            break;\n\n          case green:\n            hue = (blue - red) / delta / 6 + 1 / 3;\n            break;\n\n          case blue:\n            hue = (red - green) / delta / 6 + 2 / 3;\n            break;\n        }\n      }\n\n      return new color.HSV(hue, saturation, value, this._alpha);\n    }\n  });\n};\n\nvar HSL = function HSL(color) {\n  color.use(HSV);\n  color.installColorSpace('HSL', ['hue', 'saturation', 'lightness', 'alpha'], {\n    hsv: function () {\n      // Algorithm adapted from http://wiki.secondlife.com/wiki/Color_conversion_scripts\n      var l = this._lightness * 2,\n          s = this._saturation * (l <= 1 ? l : 2 - l),\n          saturation; // Avoid division by zero when l + s is very small (approaching black):\n\n      if (l + s < 1e-9) {\n        saturation = 0;\n      } else {\n        saturation = 2 * s / (l + s);\n      }\n\n      return new color.HSV(this._hue, saturation, (l + s) / 2, this._alpha);\n    },\n    rgb: function () {\n      return this.hsv().rgb();\n    },\n    fromRgb: function () {\n      // Becomes one.color.RGB.prototype.hsv\n      return this.hsv().hsl();\n    }\n  });\n};\n\nvar CMYK = function CMYK(color) {\n  color.installColorSpace('CMYK', ['cyan', 'magenta', 'yellow', 'black', 'alpha'], {\n    rgb: function () {\n      return new color.RGB(1 - this._cyan * (1 - this._black) - this._black, 1 - this._magenta * (1 - this._black) - this._black, 1 - this._yellow * (1 - this._black) - this._black, this._alpha);\n    },\n    fromRgb: function () {\n      // Becomes one.color.RGB.prototype.cmyk\n      // Adapted from http://www.javascripter.net/faq/rgb2cmyk.htm\n      var red = this._red,\n          green = this._green,\n          blue = this._blue,\n          cyan = 1 - red,\n          magenta = 1 - green,\n          yellow = 1 - blue,\n          black = 1;\n\n      if (red || green || blue) {\n        black = Math.min(cyan, Math.min(magenta, yellow));\n        cyan = (cyan - black) / (1 - black);\n        magenta = (magenta - black) / (1 - black);\n        yellow = (yellow - black) / (1 - black);\n      } else {\n        black = 1;\n      }\n\n      return new color.CMYK(cyan, magenta, yellow, black, this._alpha);\n    }\n  });\n};\n\nvar namedColors = function namedColors(color) {\n  color.namedColors = {\n    aliceblue: 'f0f8ff',\n    antiquewhite: 'faebd7',\n    aqua: '0ff',\n    aquamarine: '7fffd4',\n    azure: 'f0ffff',\n    beige: 'f5f5dc',\n    bisque: 'ffe4c4',\n    black: '000',\n    blanchedalmond: 'ffebcd',\n    blue: '00f',\n    blueviolet: '8a2be2',\n    brown: 'a52a2a',\n    burlywood: 'deb887',\n    cadetblue: '5f9ea0',\n    chartreuse: '7fff00',\n    chocolate: 'd2691e',\n    coral: 'ff7f50',\n    cornflowerblue: '6495ed',\n    cornsilk: 'fff8dc',\n    crimson: 'dc143c',\n    cyan: '0ff',\n    darkblue: '00008b',\n    darkcyan: '008b8b',\n    darkgoldenrod: 'b8860b',\n    darkgray: 'a9a9a9',\n    darkgrey: 'a9a9a9',\n    darkgreen: '006400',\n    darkkhaki: 'bdb76b',\n    darkmagenta: '8b008b',\n    darkolivegreen: '556b2f',\n    darkorange: 'ff8c00',\n    darkorchid: '9932cc',\n    darkred: '8b0000',\n    darksalmon: 'e9967a',\n    darkseagreen: '8fbc8f',\n    darkslateblue: '483d8b',\n    darkslategray: '2f4f4f',\n    darkslategrey: '2f4f4f',\n    darkturquoise: '00ced1',\n    darkviolet: '9400d3',\n    deeppink: 'ff1493',\n    deepskyblue: '00bfff',\n    dimgray: '696969',\n    dimgrey: '696969',\n    dodgerblue: '1e90ff',\n    firebrick: 'b22222',\n    floralwhite: 'fffaf0',\n    forestgreen: '228b22',\n    fuchsia: 'f0f',\n    gainsboro: 'dcdcdc',\n    ghostwhite: 'f8f8ff',\n    gold: 'ffd700',\n    goldenrod: 'daa520',\n    gray: '808080',\n    grey: '808080',\n    green: '008000',\n    greenyellow: 'adff2f',\n    honeydew: 'f0fff0',\n    hotpink: 'ff69b4',\n    indianred: 'cd5c5c',\n    indigo: '4b0082',\n    ivory: 'fffff0',\n    khaki: 'f0e68c',\n    lavender: 'e6e6fa',\n    lavenderblush: 'fff0f5',\n    lawngreen: '7cfc00',\n    lemonchiffon: 'fffacd',\n    lightblue: 'add8e6',\n    lightcoral: 'f08080',\n    lightcyan: 'e0ffff',\n    lightgoldenrodyellow: 'fafad2',\n    lightgray: 'd3d3d3',\n    lightgrey: 'd3d3d3',\n    lightgreen: '90ee90',\n    lightpink: 'ffb6c1',\n    lightsalmon: 'ffa07a',\n    lightseagreen: '20b2aa',\n    lightskyblue: '87cefa',\n    lightslategray: '789',\n    lightslategrey: '789',\n    lightsteelblue: 'b0c4de',\n    lightyellow: 'ffffe0',\n    lime: '0f0',\n    limegreen: '32cd32',\n    linen: 'faf0e6',\n    magenta: 'f0f',\n    maroon: '800000',\n    mediumaquamarine: '66cdaa',\n    mediumblue: '0000cd',\n    mediumorchid: 'ba55d3',\n    mediumpurple: '9370d8',\n    mediumseagreen: '3cb371',\n    mediumslateblue: '7b68ee',\n    mediumspringgreen: '00fa9a',\n    mediumturquoise: '48d1cc',\n    mediumvioletred: 'c71585',\n    midnightblue: '191970',\n    mintcream: 'f5fffa',\n    mistyrose: 'ffe4e1',\n    moccasin: 'ffe4b5',\n    navajowhite: 'ffdead',\n    navy: '000080',\n    oldlace: 'fdf5e6',\n    olive: '808000',\n    olivedrab: '6b8e23',\n    orange: 'ffa500',\n    orangered: 'ff4500',\n    orchid: 'da70d6',\n    palegoldenrod: 'eee8aa',\n    palegreen: '98fb98',\n    paleturquoise: 'afeeee',\n    palevioletred: 'd87093',\n    papayawhip: 'ffefd5',\n    peachpuff: 'ffdab9',\n    peru: 'cd853f',\n    pink: 'ffc0cb',\n    plum: 'dda0dd',\n    powderblue: 'b0e0e6',\n    purple: '800080',\n    rebeccapurple: '639',\n    red: 'f00',\n    rosybrown: 'bc8f8f',\n    royalblue: '4169e1',\n    saddlebrown: '8b4513',\n    salmon: 'fa8072',\n    sandybrown: 'f4a460',\n    seagreen: '2e8b57',\n    seashell: 'fff5ee',\n    sienna: 'a0522d',\n    silver: 'c0c0c0',\n    skyblue: '87ceeb',\n    slateblue: '6a5acd',\n    slategray: '708090',\n    slategrey: '708090',\n    snow: 'fffafa',\n    springgreen: '00ff7f',\n    steelblue: '4682b4',\n    tan: 'd2b48c',\n    teal: '008080',\n    thistle: 'd8bfd8',\n    tomato: 'ff6347',\n    turquoise: '40e0d0',\n    violet: 'ee82ee',\n    wheat: 'f5deb3',\n    white: 'fff',\n    whitesmoke: 'f5f5f5',\n    yellow: 'ff0',\n    yellowgreen: '9acd32'\n  };\n};\n\nvar clearer = function clearer(color) {\n  color.installMethod('clearer', function (amount) {\n    return this.alpha(isNaN(amount) ? -0.1 : -amount, true);\n  });\n};\n\nvar luminance = function luminance(color) {\n  // http://www.w3.org/TR/WCAG20/#relativeluminancedef\n  function channelLuminance(value) {\n    return value <= 0.03928 ? value / 12.92 : Math.pow((value + 0.055) / 1.055, 2.4);\n  }\n\n  color.installMethod('luminance', function () {\n    var rgb = this.rgb();\n    return 0.2126 * channelLuminance(rgb._red) + 0.7152 * channelLuminance(rgb._green) + 0.0722 * channelLuminance(rgb._blue);\n  });\n};\n\nvar contrast = function contrast(color) {\n  // http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n  color.use(luminance);\n  color.installMethod('contrast', function (color2) {\n    var lum1 = this.luminance();\n    var lum2 = color2.luminance();\n\n    if (lum1 > lum2) {\n      return (lum1 + 0.05) / (lum2 + 0.05);\n    }\n\n    return (lum2 + 0.05) / (lum1 + 0.05);\n  });\n};\n\nvar darken = function darken(color) {\n  color.use(HSL);\n  color.installMethod('darken', function (amount) {\n    return this.lightness(isNaN(amount) ? -0.1 : -amount, true);\n  });\n};\n\nvar desaturate = function desaturate(color) {\n  color.use(HSL);\n  color.installMethod('desaturate', function (amount) {\n    return this.saturation(isNaN(amount) ? -0.1 : -amount, true);\n  });\n};\n\nvar grayscale = function grayscale(color) {\n  function gs() {\n    /*jslint strict:false*/\n    var rgb = this.rgb(),\n        val = rgb._red * 0.3 + rgb._green * 0.59 + rgb._blue * 0.11;\n    return new color.RGB(val, val, val, rgb._alpha);\n  }\n\n  color.installMethod('greyscale', gs).installMethod('grayscale', gs);\n};\n\nvar isDark = function isDark(color) {\n  color.installMethod('isDark', function () {\n    var rgb = this.rgb(); // YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\n    var yiq = (rgb._red * 255 * 299 + rgb._green * 255 * 587 + rgb._blue * 255 * 114) / 1000;\n    return yiq < 128;\n  });\n};\n\nvar isLight = function isLight(color) {\n  color.use(isDark);\n  color.installMethod('isLight', function () {\n    return !this.isDark();\n  });\n};\n\nvar lighten = function lighten(color) {\n  color.use(HSL);\n  color.installMethod('lighten', function (amount) {\n    return this.lightness(isNaN(amount) ? 0.1 : amount, true);\n  });\n};\n\nvar mix = function mix(color) {\n  color.installMethod('mix', function (otherColor, weight) {\n    otherColor = color(otherColor).rgb();\n    weight = 1 - (isNaN(weight) ? 0.5 : weight);\n    var w = weight * 2 - 1,\n        a = this._alpha - otherColor._alpha,\n        weight1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2,\n        weight2 = 1 - weight1,\n        rgb = this.rgb();\n    return new color.RGB(rgb._red * weight1 + otherColor._red * weight2, rgb._green * weight1 + otherColor._green * weight2, rgb._blue * weight1 + otherColor._blue * weight2, rgb._alpha * weight + otherColor._alpha * (1 - weight));\n  });\n};\n\nvar negate = function negate(color) {\n  color.installMethod('negate', function () {\n    var rgb = this.rgb();\n    return new color.RGB(1 - rgb._red, 1 - rgb._green, 1 - rgb._blue, this._alpha);\n  });\n};\n\nvar opaquer = function opaquer(color) {\n  color.installMethod('opaquer', function (amount) {\n    return this.alpha(isNaN(amount) ? 0.1 : amount, true);\n  });\n};\n\nvar rotate = function rotate(color) {\n  color.use(HSL);\n  color.installMethod('rotate', function (degrees) {\n    return this.hue((degrees || 0) / 360, true);\n  });\n};\n\nvar saturate = function saturate(color) {\n  color.use(HSL);\n  color.installMethod('saturate', function (amount) {\n    return this.saturation(isNaN(amount) ? 0.1 : amount, true);\n  });\n};\n\n// Adapted from http://gimp.sourcearchive.com/documentation/2.6.6-1ubuntu1/color-to-alpha_8c-source.html\n// toAlpha returns a color where the values of the argument have been converted to alpha\nvar toAlpha = function toAlpha(color) {\n  color.installMethod('toAlpha', function (color) {\n    var me = this.rgb(),\n        other = color(color).rgb(),\n        epsilon = 1e-10,\n        a = new color.RGB(0, 0, 0, me._alpha),\n        channels = ['_red', '_green', '_blue'];\n    channels.forEach(function (channel) {\n      if (me[channel] < epsilon) {\n        a[channel] = me[channel];\n      } else if (me[channel] > other[channel]) {\n        a[channel] = (me[channel] - other[channel]) / (1 - other[channel]);\n      } else if (me[channel] > other[channel]) {\n        a[channel] = (other[channel] - me[channel]) / other[channel];\n      } else {\n        a[channel] = 0;\n      }\n    });\n\n    if (a._red > a._green) {\n      if (a._red > a._blue) {\n        me._alpha = a._red;\n      } else {\n        me._alpha = a._blue;\n      }\n    } else if (a._green > a._blue) {\n      me._alpha = a._green;\n    } else {\n      me._alpha = a._blue;\n    }\n\n    if (me._alpha < epsilon) {\n      return me;\n    }\n\n    channels.forEach(function (channel) {\n      me[channel] = (me[channel] - other[channel]) / me._alpha + other[channel];\n    });\n    me._alpha *= a._alpha;\n    return me;\n  });\n};\n\nvar onecolor = color_1.use(XYZ).use(LAB).use(HSV).use(HSL).use(CMYK) // Convenience functions\n.use(namedColors).use(clearer).use(contrast).use(darken).use(desaturate).use(grayscale).use(isDark).use(isLight).use(lighten).use(luminance).use(mix).use(negate).use(opaquer).use(rotate).use(saturate).use(toAlpha);\n\nfunction getContrastRatio(foreground, background) {\n  var backgroundOnWhite = alphaBlend(background, '#fff');\n  var backgroundOnBlack = alphaBlend(background, '#000');\n  var LWhite = getRelativeLuminance(backgroundOnWhite);\n  var LBlack = getRelativeLuminance(backgroundOnBlack);\n  var LForeground = getRelativeLuminance(foreground);\n\n  if (LWhite < LForeground) {\n    return getContrastRatioOpaque(foreground, backgroundOnWhite);\n  } else if (LBlack > LForeground) {\n    return getContrastRatioOpaque(foreground, backgroundOnBlack);\n  } else {\n    return 1;\n  }\n}\n\nfunction alphaBlend(cssForeground, cssBackground) {\n  var foreground = onecolor(cssForeground);\n  var background = onecolor(cssBackground);\n  var result = onecolor('#fff');\n  var a = foreground.alpha();\n  result._red = foreground._red * a + background._red * (1 - a);\n  result._green = foreground._green * a + background._green * (1 - a);\n  result._blue = foreground._blue * a + background._blue * (1 - a);\n  return result;\n}\n\nfunction getContrastRatioOpaque(foreground, background) {\n  var L1 = getRelativeLuminance(background);\n  var L2 = getRelativeLuminance(alphaBlend(foreground, background)); // https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n\n  return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);\n}\n\nfunction getRelativeLuminance(cssColor) {\n  // https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n  var color = onecolor(cssColor);\n  var R = color._red <= 0.03928 ? color._red / 12.92 : Math.pow((color._red + 0.055) / 1.055, 2.4);\n  var G = color._green <= 0.03928 ? color._green / 12.92 : Math.pow((color._green + 0.055) / 1.055, 2.4);\n  var B = color._blue <= 0.03928 ? color._blue / 12.92 : Math.pow((color._blue + 0.055) / 1.055, 2.4);\n  var L = 0.2126 * R + 0.7152 * G + 0.0722 * B;\n  return L;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getContrastRatio);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29sb3ItY29udHJhc3QvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7O0FBR0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7OztBQUdBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRUFBcUU7O0FBRXJFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGdCQUFnQixFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvZGF2aWRlYmlzY3Vzby9Eb2N1bWVudHMvR2l0SHViL2NvbG9yLXJhbXAvbm9kZV9tb2R1bGVzL2NvbG9yLWNvbnRyYXN0L2Rpc3QvaW5kZXguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpbnN0YWxsZWRDb2xvclNwYWNlcyA9IFtdLFxuICAgIHVuZGVmID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCc7XG59LFxuICAgIGNoYW5uZWxSZWdFeHAgPSAvXFxzKihcXC5cXGQrfFxcZCsoPzpcXC5cXGQrKT8pKCUpP1xccyovLFxuICAgIHBlcmNlbnRhZ2VDaGFubmVsUmVnRXhwID0gL1xccyooXFwuXFxkK3wxMDB8XFxkP1xcZCg/OlxcLlxcZCspPyklXFxzKi8sXG4gICAgYWxwaGFDaGFubmVsUmVnRXhwID0gL1xccyooXFwuXFxkK3xcXGQrKD86XFwuXFxkKyk/KVxccyovLFxuICAgIGNzc0NvbG9yUmVnRXhwID0gbmV3IFJlZ0V4cCgnXihyZ2J8aHNsfGhzdilhPycgKyAnXFxcXCgnICsgY2hhbm5lbFJlZ0V4cC5zb3VyY2UgKyAnLCcgKyBjaGFubmVsUmVnRXhwLnNvdXJjZSArICcsJyArIGNoYW5uZWxSZWdFeHAuc291cmNlICsgJyg/OiwnICsgYWxwaGFDaGFubmVsUmVnRXhwLnNvdXJjZSArICcpPycgKyAnXFxcXCkkJywgJ2knKTtcblxuZnVuY3Rpb24gY29sb3Iob2JqKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBpZiAodHlwZW9mIG9ialswXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGNvbG9yW29ialswXV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFzc3VtZWQgYXJyYXkgZnJvbSAudG9KU09OKClcbiAgICAgIHJldHVybiBuZXcgY29sb3Jbb2JqWzBdXShvYmouc2xpY2UoMSwgb2JqLmxlbmd0aCkpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gNCkge1xuICAgICAgLy8gQXNzdW1lZCA0IGVsZW1lbnQgaW50IFJHQiBhcnJheSBmcm9tIGNhbnZhcyB3aXRoIGFsbCBjaGFubmVscyBbMDsyNTVdXG4gICAgICByZXR1cm4gbmV3IGNvbG9yLlJHQihvYmpbMF0gLyAyNTUsIG9ialsxXSAvIDI1NSwgb2JqWzJdIC8gMjU1LCBvYmpbM10gLyAyNTUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHZhciBsb3dlckNhc2VkID0gb2JqLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoY29sb3IubmFtZWRDb2xvcnNbbG93ZXJDYXNlZF0pIHtcbiAgICAgIG9iaiA9ICcjJyArIGNvbG9yLm5hbWVkQ29sb3JzW2xvd2VyQ2FzZWRdO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICBvYmogPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgfSAvLyBUZXN0IGZvciBDU1MgcmdiKC4uLi4pIHN0cmluZ1xuXG5cbiAgICB2YXIgbWF0Y2hDc3NTeW50YXggPSBvYmoubWF0Y2goY3NzQ29sb3JSZWdFeHApO1xuXG4gICAgaWYgKG1hdGNoQ3NzU3ludGF4KSB7XG4gICAgICB2YXIgY29sb3JTcGFjZU5hbWUgPSBtYXRjaENzc1N5bnRheFsxXS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgIGFscGhhID0gdW5kZWYobWF0Y2hDc3NTeW50YXhbOF0pID8gbWF0Y2hDc3NTeW50YXhbOF0gOiBwYXJzZUZsb2F0KG1hdGNoQ3NzU3ludGF4WzhdKSxcbiAgICAgICAgICBoYXNIdWUgPSBjb2xvclNwYWNlTmFtZVswXSA9PT0gJ0gnLFxuICAgICAgICAgIGZpcnN0Q2hhbm5lbERpdmlzb3IgPSBtYXRjaENzc1N5bnRheFszXSA/IDEwMCA6IGhhc0h1ZSA/IDM2MCA6IDI1NSxcbiAgICAgICAgICBzZWNvbmRDaGFubmVsRGl2aXNvciA9IG1hdGNoQ3NzU3ludGF4WzVdIHx8IGhhc0h1ZSA/IDEwMCA6IDI1NSxcbiAgICAgICAgICB0aGlyZENoYW5uZWxEaXZpc29yID0gbWF0Y2hDc3NTeW50YXhbN10gfHwgaGFzSHVlID8gMTAwIDogMjU1O1xuXG4gICAgICBpZiAodW5kZWYoY29sb3JbY29sb3JTcGFjZU5hbWVdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbG9yLicgKyBjb2xvclNwYWNlTmFtZSArICcgaXMgbm90IGluc3RhbGxlZC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBjb2xvcltjb2xvclNwYWNlTmFtZV0ocGFyc2VGbG9hdChtYXRjaENzc1N5bnRheFsyXSkgLyBmaXJzdENoYW5uZWxEaXZpc29yLCBwYXJzZUZsb2F0KG1hdGNoQ3NzU3ludGF4WzRdKSAvIHNlY29uZENoYW5uZWxEaXZpc29yLCBwYXJzZUZsb2F0KG1hdGNoQ3NzU3ludGF4WzZdKSAvIHRoaXJkQ2hhbm5lbERpdmlzb3IsIGFscGhhKTtcbiAgICB9IC8vIEFzc3VtZSBoZXggc3ludGF4XG5cblxuICAgIGlmIChvYmoubGVuZ3RoIDwgNikge1xuICAgICAgLy8gQWxsb3cgQ1NTIHNob3J0aGFuZFxuICAgICAgb2JqID0gb2JqLnJlcGxhY2UoL14jPyhbMC05YS1mXSkoWzAtOWEtZl0pKFswLTlhLWZdKSQvaSwgJyQxJDEkMiQyJDMkMycpO1xuICAgIH0gLy8gU3BsaXQgb2JqIGludG8gcmVkLCBncmVlbiwgYW5kIGJsdWUgY29tcG9uZW50c1xuXG5cbiAgICB2YXIgaGV4TWF0Y2ggPSBvYmoubWF0Y2goL14jPyhbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXVswLTlhLWZdKSQvaSk7XG5cbiAgICBpZiAoaGV4TWF0Y2gpIHtcbiAgICAgIHJldHVybiBuZXcgY29sb3IuUkdCKHBhcnNlSW50KGhleE1hdGNoWzFdLCAxNikgLyAyNTUsIHBhcnNlSW50KGhleE1hdGNoWzJdLCAxNikgLyAyNTUsIHBhcnNlSW50KGhleE1hdGNoWzNdLCAxNikgLyAyNTUpO1xuICAgIH0gLy8gTm8gbWF0Y2ggc28gZmFyLiBMZXRzIHRyeSB0aGUgbGVzcyBsaWtlbHkgb25lc1xuXG5cbiAgICBpZiAoY29sb3IuQ01ZSykge1xuICAgICAgdmFyIGNteWtNYXRjaCA9IG9iai5tYXRjaChuZXcgUmVnRXhwKCdeY215aycgKyAnXFxcXCgnICsgcGVyY2VudGFnZUNoYW5uZWxSZWdFeHAuc291cmNlICsgJywnICsgcGVyY2VudGFnZUNoYW5uZWxSZWdFeHAuc291cmNlICsgJywnICsgcGVyY2VudGFnZUNoYW5uZWxSZWdFeHAuc291cmNlICsgJywnICsgcGVyY2VudGFnZUNoYW5uZWxSZWdFeHAuc291cmNlICsgJ1xcXFwpJCcsICdpJykpO1xuXG4gICAgICBpZiAoY215a01hdGNoKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29sb3IuQ01ZSyhwYXJzZUZsb2F0KGNteWtNYXRjaFsxXSkgLyAxMDAsIHBhcnNlRmxvYXQoY215a01hdGNoWzJdKSAvIDEwMCwgcGFyc2VGbG9hdChjbXlrTWF0Y2hbM10pIC8gMTAwLCBwYXJzZUZsb2F0KGNteWtNYXRjaFs0XSkgLyAxMDApO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmouaXNDb2xvcikge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbG9yLm5hbWVkQ29sb3JzID0ge307XG5cbmNvbG9yLmluc3RhbGxDb2xvclNwYWNlID0gZnVuY3Rpb24gKGNvbG9yU3BhY2VOYW1lLCBwcm9wZXJ0eU5hbWVzLCBjb25maWcpIHtcbiAgY29sb3JbY29sb3JTcGFjZU5hbWVdID0gZnVuY3Rpb24gKGExKSB7XG4gICAgLy8gLi4uXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5pc0FycmF5KGExKSA/IGExIDogYXJndW1lbnRzO1xuICAgIHByb3BlcnR5TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlOYW1lLCBpKSB7XG4gICAgICB2YXIgcHJvcGVydHlWYWx1ZSA9IGFyZ3NbaV07XG5cbiAgICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICdhbHBoYScpIHtcbiAgICAgICAgdGhpcy5fYWxwaGEgPSBpc05hTihwcm9wZXJ0eVZhbHVlKSB8fCBwcm9wZXJ0eVZhbHVlID4gMSA/IDEgOiBwcm9wZXJ0eVZhbHVlIDwgMCA/IDAgOiBwcm9wZXJ0eVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmFOKHByb3BlcnR5VmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbJyArIGNvbG9yU3BhY2VOYW1lICsgJ106IEludmFsaWQgY29sb3I6ICgnICsgcHJvcGVydHlOYW1lcy5qb2luKCcsJykgKyAnKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSA9PT0gJ2h1ZScpIHtcbiAgICAgICAgICB0aGlzLl9odWUgPSBwcm9wZXJ0eVZhbHVlIDwgMCA/IHByb3BlcnR5VmFsdWUgLSBNYXRoLmZsb29yKHByb3BlcnR5VmFsdWUpIDogcHJvcGVydHlWYWx1ZSAlIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1snXycgKyBwcm9wZXJ0eU5hbWVdID0gcHJvcGVydHlWYWx1ZSA8IDAgPyAwIDogcHJvcGVydHlWYWx1ZSA+IDEgPyAxIDogcHJvcGVydHlWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4gIGNvbG9yW2NvbG9yU3BhY2VOYW1lXS5wcm9wZXJ0eU5hbWVzID0gcHJvcGVydHlOYW1lcztcbiAgdmFyIHByb3RvdHlwZSA9IGNvbG9yW2NvbG9yU3BhY2VOYW1lXS5wcm90b3R5cGU7XG4gIFsndmFsdWVPZicsICdoZXgnLCAnaGV4YScsICdjc3MnLCAnY3NzYSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICBwcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBwcm90b3R5cGVbbWV0aG9kTmFtZV0gfHwgKGNvbG9yU3BhY2VOYW1lID09PSAnUkdCJyA/IHByb3RvdHlwZS5oZXggOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZ2IoKVttZXRob2ROYW1lXSgpO1xuICAgIH0pO1xuICB9KTtcbiAgcHJvdG90eXBlLmlzQ29sb3IgPSB0cnVlO1xuXG4gIHByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXJDb2xvciwgZXBzaWxvbikge1xuICAgIGlmICh1bmRlZihlcHNpbG9uKSkge1xuICAgICAgZXBzaWxvbiA9IDFlLTEwO1xuICAgIH1cblxuICAgIG90aGVyQ29sb3IgPSBvdGhlckNvbG9yW2NvbG9yU3BhY2VOYW1lLnRvTG93ZXJDYXNlKCldKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnR5TmFtZXMubGVuZ3RoOyBpID0gaSArIDEpIHtcbiAgICAgIGlmIChNYXRoLmFicyh0aGlzWydfJyArIHByb3BlcnR5TmFtZXNbaV1dIC0gb3RoZXJDb2xvclsnXycgKyBwcm9wZXJ0eU5hbWVzW2ldXSkgPiBlcHNpbG9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBwcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbY29sb3JTcGFjZU5hbWVdLmNvbmNhdChwcm9wZXJ0eU5hbWVzLm1hcChmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpc1snXycgKyBwcm9wZXJ0eU5hbWVdO1xuICAgIH0sIHRoaXMpKTtcbiAgfTtcblxuICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICB2YXIgbWF0Y2hGcm9tQ29sb3JTcGFjZSA9IHByb3BlcnR5TmFtZS5tYXRjaCgvXmZyb20oLiopJC8pO1xuXG4gICAgICBpZiAobWF0Y2hGcm9tQ29sb3JTcGFjZSkge1xuICAgICAgICBjb2xvclttYXRjaEZyb21Db2xvclNwYWNlWzFdLnRvVXBwZXJDYXNlKCldLnByb3RvdHlwZVtjb2xvclNwYWNlTmFtZS50b0xvd2VyQ2FzZSgpXSA9IGNvbmZpZ1twcm9wZXJ0eU5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdG90eXBlW3Byb3BlcnR5TmFtZV0gPSBjb25maWdbcHJvcGVydHlOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gSXQgaXMgcHJldHR5IGVhc3kgdG8gaW1wbGVtZW50IHRoZSBjb252ZXJzaW9uIHRvIHRoZSBzYW1lIGNvbG9yIHNwYWNlOlxuXG5cbiAgcHJvdG90eXBlW2NvbG9yU3BhY2VOYW1lLnRvTG93ZXJDYXNlKCldID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ1snICsgY29sb3JTcGFjZU5hbWUgKyAnICcgKyBwcm9wZXJ0eU5hbWVzLm1hcChmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpc1snXycgKyBwcm9wZXJ0eU5hbWVdO1xuICAgIH0sIHRoaXMpLmpvaW4oJywgJykgKyAnXSc7XG4gIH07IC8vIEdlbmVyYXRlIGdldHRlcnMgYW5kIHNldHRlcnNcblxuXG4gIHByb3BlcnR5TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgdmFyIHNob3J0TmFtZSA9IHByb3BlcnR5TmFtZSA9PT0gJ2JsYWNrJyA/ICdrJyA6IHByb3BlcnR5TmFtZS5jaGFyQXQoMCk7XG5cbiAgICBwcm90b3R5cGVbcHJvcGVydHlOYW1lXSA9IHByb3RvdHlwZVtzaG9ydE5hbWVdID0gZnVuY3Rpb24gKHZhbHVlLCBpc0RlbHRhKSB7XG4gICAgICAvLyBTaW1wbGUgZ2V0dGVyIG1vZGU6IGNvbG9yLnJlZCgpXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdGhpc1snXycgKyBwcm9wZXJ0eU5hbWVdO1xuICAgICAgfSBlbHNlIGlmIChpc0RlbHRhKSB7XG4gICAgICAgIC8vIEFkanVzdGVyOiBjb2xvci5yZWQoKy4yLCB0cnVlKVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IocHJvcGVydHlOYW1lcy5tYXAoZnVuY3Rpb24gKG90aGVyUHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNbJ18nICsgb3RoZXJQcm9wZXJ0eU5hbWVdICsgKHByb3BlcnR5TmFtZSA9PT0gb3RoZXJQcm9wZXJ0eU5hbWUgPyB2YWx1ZSA6IDApO1xuICAgICAgICB9LCB0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZXR0ZXI6IGNvbG9yLnJlZCguMik7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihwcm9wZXJ0eU5hbWVzLm1hcChmdW5jdGlvbiAob3RoZXJQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcGVydHlOYW1lID09PSBvdGhlclByb3BlcnR5TmFtZSA/IHZhbHVlIDogdGhpc1snXycgKyBvdGhlclByb3BlcnR5TmFtZV07XG4gICAgICAgIH0sIHRoaXMpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBmdW5jdGlvbiBpbnN0YWxsRm9yZWlnbk1ldGhvZHModGFyZ2V0Q29sb3JTcGFjZU5hbWUsIHNvdXJjZUNvbG9yU3BhY2VOYW1lKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuXG4gICAgb2JqW3NvdXJjZUNvbG9yU3BhY2VOYW1lLnRvTG93ZXJDYXNlKCldID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmdiKClbc291cmNlQ29sb3JTcGFjZU5hbWUudG9Mb3dlckNhc2UoKV0oKTtcbiAgICB9O1xuXG4gICAgY29sb3Jbc291cmNlQ29sb3JTcGFjZU5hbWVdLnByb3BlcnR5TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgICB2YXIgc2hvcnROYW1lID0gcHJvcGVydHlOYW1lID09PSAnYmxhY2snID8gJ2snIDogcHJvcGVydHlOYW1lLmNoYXJBdCgwKTtcblxuICAgICAgb2JqW3Byb3BlcnR5TmFtZV0gPSBvYmpbc2hvcnROYW1lXSA9IGZ1bmN0aW9uICh2YWx1ZSwgaXNEZWx0YSkge1xuICAgICAgICByZXR1cm4gdGhpc1tzb3VyY2VDb2xvclNwYWNlTmFtZS50b0xvd2VyQ2FzZSgpXSgpW3Byb3BlcnR5TmFtZV0odmFsdWUsIGlzRGVsdGEpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApICYmIGNvbG9yW3RhcmdldENvbG9yU3BhY2VOYW1lXS5wcm90b3R5cGVbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb2xvclt0YXJnZXRDb2xvclNwYWNlTmFtZV0ucHJvdG90eXBlW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluc3RhbGxlZENvbG9yU3BhY2VzLmZvckVhY2goZnVuY3Rpb24gKG90aGVyQ29sb3JTcGFjZU5hbWUpIHtcbiAgICBpbnN0YWxsRm9yZWlnbk1ldGhvZHMoY29sb3JTcGFjZU5hbWUsIG90aGVyQ29sb3JTcGFjZU5hbWUpO1xuICAgIGluc3RhbGxGb3JlaWduTWV0aG9kcyhvdGhlckNvbG9yU3BhY2VOYW1lLCBjb2xvclNwYWNlTmFtZSk7XG4gIH0pO1xuICBpbnN0YWxsZWRDb2xvclNwYWNlcy5wdXNoKGNvbG9yU3BhY2VOYW1lKTtcbiAgcmV0dXJuIGNvbG9yO1xufTtcblxuY29sb3IucGx1Z2luTGlzdCA9IFtdO1xuXG5jb2xvci51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gIGlmIChjb2xvci5wbHVnaW5MaXN0LmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcbiAgICB0aGlzLnBsdWdpbkxpc3QucHVzaChwbHVnaW4pO1xuICAgIHBsdWdpbihjb2xvcik7XG4gIH1cblxuICByZXR1cm4gY29sb3I7XG59O1xuXG5jb2xvci5pbnN0YWxsTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gIGluc3RhbGxlZENvbG9yU3BhY2VzLmZvckVhY2goZnVuY3Rpb24gKGNvbG9yU3BhY2UpIHtcbiAgICBjb2xvcltjb2xvclNwYWNlXS5wcm90b3R5cGVbbmFtZV0gPSBmbjtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuY29sb3IuaW5zdGFsbENvbG9yU3BhY2UoJ1JHQicsIFsncmVkJywgJ2dyZWVuJywgJ2JsdWUnLCAnYWxwaGEnXSwge1xuICBoZXg6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGV4U3RyaW5nID0gKE1hdGgucm91bmQoMjU1ICogdGhpcy5fcmVkKSAqIDB4MTAwMDAgKyBNYXRoLnJvdW5kKDI1NSAqIHRoaXMuX2dyZWVuKSAqIDB4MTAwICsgTWF0aC5yb3VuZCgyNTUgKiB0aGlzLl9ibHVlKSkudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiAnIycgKyAnMDAwMDAnLnN1YnN0cigwLCA2IC0gaGV4U3RyaW5nLmxlbmd0aCkgKyBoZXhTdHJpbmc7XG4gIH0sXG4gIGhleGE6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWxwaGFTdHJpbmcgPSBNYXRoLnJvdW5kKHRoaXMuX2FscGhhICogMjU1KS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuICcjJyArICcwMCcuc3Vic3RyKDAsIDIgLSBhbHBoYVN0cmluZy5sZW5ndGgpICsgYWxwaGFTdHJpbmcgKyB0aGlzLmhleCgpLnN1YnN0cigxLCA2KTtcbiAgfSxcbiAgY3NzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdyZ2IoJyArIE1hdGgucm91bmQoMjU1ICogdGhpcy5fcmVkKSArICcsJyArIE1hdGgucm91bmQoMjU1ICogdGhpcy5fZ3JlZW4pICsgJywnICsgTWF0aC5yb3VuZCgyNTUgKiB0aGlzLl9ibHVlKSArICcpJztcbiAgfSxcbiAgY3NzYTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAncmdiYSgnICsgTWF0aC5yb3VuZCgyNTUgKiB0aGlzLl9yZWQpICsgJywnICsgTWF0aC5yb3VuZCgyNTUgKiB0aGlzLl9ncmVlbikgKyAnLCcgKyBNYXRoLnJvdW5kKDI1NSAqIHRoaXMuX2JsdWUpICsgJywnICsgdGhpcy5fYWxwaGEgKyAnKSc7XG4gIH1cbn0pO1xudmFyIGNvbG9yXzEgPSBjb2xvcjtcblxudmFyIFhZWiA9IGZ1bmN0aW9uIFhZWihjb2xvcikge1xuICBjb2xvci5pbnN0YWxsQ29sb3JTcGFjZSgnWFlaJywgWyd4JywgJ3knLCAneicsICdhbHBoYSddLCB7XG4gICAgZnJvbVJnYjogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gaHR0cDovL3d3dy5lYXN5cmdiLmNvbS9pbmRleC5waHA/WD1NQVRIJkg9MDIjdGV4dDJcbiAgICAgIHZhciBjb252ZXJ0ID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWwgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKGNoYW5uZWwgKyAwLjA1NSkgLyAxLjA1NSwgMi40KSA6IGNoYW5uZWwgLyAxMi45MjtcbiAgICAgIH0sXG4gICAgICAgICAgciA9IGNvbnZlcnQodGhpcy5fcmVkKSxcbiAgICAgICAgICBnID0gY29udmVydCh0aGlzLl9ncmVlbiksXG4gICAgICAgICAgYiA9IGNvbnZlcnQodGhpcy5fYmx1ZSk7IC8vIFJlZmVyZW5jZSB3aGl0ZSBwb2ludCBzUkdCIEQ2NTpcbiAgICAgIC8vIGh0dHA6Ly93d3cuYnJ1Y2VsaW5kYmxvb20uY29tL2luZGV4Lmh0bWw/RXFuX1JHQl9YWVpfTWF0cml4Lmh0bWxcblxuXG4gICAgICByZXR1cm4gbmV3IGNvbG9yLlhZWihyICogMC40MTI0NTY0ICsgZyAqIDAuMzU3NTc2MSArIGIgKiAwLjE4MDQzNzUsIHIgKiAwLjIxMjY3MjkgKyBnICogMC43MTUxNTIyICsgYiAqIDAuMDcyMTc1MCwgciAqIDAuMDE5MzMzOSArIGcgKiAwLjExOTE5MjAgKyBiICogMC45NTAzMDQxLCB0aGlzLl9hbHBoYSk7XG4gICAgfSxcbiAgICByZ2I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGh0dHA6Ly93d3cuZWFzeXJnYi5jb20vaW5kZXgucGhwP1g9TUFUSCZIPTAxI3RleHQxXG4gICAgICB2YXIgeCA9IHRoaXMuX3gsXG4gICAgICAgICAgeSA9IHRoaXMuX3ksXG4gICAgICAgICAgeiA9IHRoaXMuX3osXG4gICAgICAgICAgY29udmVydCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiBjaGFubmVsID4gMC4wMDMxMzA4ID8gMS4wNTUgKiBNYXRoLnBvdyhjaGFubmVsLCAxIC8gMi40KSAtIDAuMDU1IDogMTIuOTIgKiBjaGFubmVsO1xuICAgICAgfTsgLy8gUmVmZXJlbmNlIHdoaXRlIHBvaW50IHNSR0IgRDY1OlxuICAgICAgLy8gaHR0cDovL3d3dy5icnVjZWxpbmRibG9vbS5jb20vaW5kZXguaHRtbD9FcW5fUkdCX1hZWl9NYXRyaXguaHRtbFxuXG5cbiAgICAgIHJldHVybiBuZXcgY29sb3IuUkdCKGNvbnZlcnQoeCAqIDMuMjQwNDU0MiArIHkgKiAtMS41MzcxMzg1ICsgeiAqIC0wLjQ5ODUzMTQpLCBjb252ZXJ0KHggKiAtMC45NjkyNjYwICsgeSAqIDEuODc2MDEwOCArIHogKiAwLjA0MTU1NjApLCBjb252ZXJ0KHggKiAwLjA1NTY0MzQgKyB5ICogLTAuMjA0MDI1OSArIHogKiAxLjA1NzIyNTIpLCB0aGlzLl9hbHBoYSk7XG4gICAgfSxcbiAgICBsYWI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGh0dHA6Ly93d3cuZWFzeXJnYi5jb20vaW5kZXgucGhwP1g9TUFUSCZIPTA3I3RleHQ3XG4gICAgICB2YXIgY29udmVydCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiBjaGFubmVsID4gMC4wMDg4NTYgPyBNYXRoLnBvdyhjaGFubmVsLCAxIC8gMykgOiA3Ljc4NzAzNyAqIGNoYW5uZWwgKyA0IC8gMjk7XG4gICAgICB9LFxuICAgICAgICAgIHggPSBjb252ZXJ0KHRoaXMuX3ggLyA5NS4wNDcpLFxuICAgICAgICAgIHkgPSBjb252ZXJ0KHRoaXMuX3kgLyAxMDAuMDAwKSxcbiAgICAgICAgICB6ID0gY29udmVydCh0aGlzLl96IC8gMTA4Ljg4Myk7XG5cbiAgICAgIHJldHVybiBuZXcgY29sb3IuTEFCKDExNiAqIHkgLSAxNiwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KSwgdGhpcy5fYWxwaGEpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgTEFCID0gZnVuY3Rpb24gTEFCKGNvbG9yKSB7XG4gIGNvbG9yLnVzZShYWVopO1xuICBjb2xvci5pbnN0YWxsQ29sb3JTcGFjZSgnTEFCJywgWydsJywgJ2EnLCAnYicsICdhbHBoYSddLCB7XG4gICAgZnJvbVJnYjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMueHl6KCkubGFiKCk7XG4gICAgfSxcbiAgICByZ2I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnh5eigpLnJnYigpO1xuICAgIH0sXG4gICAgeHl6OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBodHRwOi8vd3d3LmVhc3lyZ2IuY29tL2luZGV4LnBocD9YPU1BVEgmSD0wOCN0ZXh0OFxuICAgICAgdmFyIGNvbnZlcnQgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICB2YXIgcG93ID0gTWF0aC5wb3coY2hhbm5lbCwgMyk7XG4gICAgICAgIHJldHVybiBwb3cgPiAwLjAwODg1NiA/IHBvdyA6IChjaGFubmVsIC0gMTYgLyAxMTYpIC8gNy44NztcbiAgICAgIH0sXG4gICAgICAgICAgeSA9ICh0aGlzLl9sICsgMTYpIC8gMTE2LFxuICAgICAgICAgIHggPSB0aGlzLl9hIC8gNTAwICsgeSxcbiAgICAgICAgICB6ID0geSAtIHRoaXMuX2IgLyAyMDA7XG5cbiAgICAgIHJldHVybiBuZXcgY29sb3IuWFlaKGNvbnZlcnQoeCkgKiA5NS4wNDcsIGNvbnZlcnQoeSkgKiAxMDAuMDAwLCBjb252ZXJ0KHopICogMTA4Ljg4MywgdGhpcy5fYWxwaGEpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgSFNWID0gZnVuY3Rpb24gSFNWKGNvbG9yKSB7XG4gIGNvbG9yLmluc3RhbGxDb2xvclNwYWNlKCdIU1YnLCBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ3ZhbHVlJywgJ2FscGhhJ10sIHtcbiAgICByZ2I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBodWUgPSB0aGlzLl9odWUsXG4gICAgICAgICAgc2F0dXJhdGlvbiA9IHRoaXMuX3NhdHVyYXRpb24sXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl92YWx1ZSxcbiAgICAgICAgICBpID0gTWF0aC5taW4oNSwgTWF0aC5mbG9vcihodWUgKiA2KSksXG4gICAgICAgICAgZiA9IGh1ZSAqIDYgLSBpLFxuICAgICAgICAgIHAgPSB2YWx1ZSAqICgxIC0gc2F0dXJhdGlvbiksXG4gICAgICAgICAgcSA9IHZhbHVlICogKDEgLSBmICogc2F0dXJhdGlvbiksXG4gICAgICAgICAgdCA9IHZhbHVlICogKDEgLSAoMSAtIGYpICogc2F0dXJhdGlvbiksXG4gICAgICAgICAgcmVkLFxuICAgICAgICAgIGdyZWVuLFxuICAgICAgICAgIGJsdWU7XG5cbiAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmVkID0gdmFsdWU7XG4gICAgICAgICAgZ3JlZW4gPSB0O1xuICAgICAgICAgIGJsdWUgPSBwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZWQgPSBxO1xuICAgICAgICAgIGdyZWVuID0gdmFsdWU7XG4gICAgICAgICAgYmx1ZSA9IHA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJlZCA9IHA7XG4gICAgICAgICAgZ3JlZW4gPSB2YWx1ZTtcbiAgICAgICAgICBibHVlID0gdDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmVkID0gcDtcbiAgICAgICAgICBncmVlbiA9IHE7XG4gICAgICAgICAgYmx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZWQgPSB0O1xuICAgICAgICAgIGdyZWVuID0gcDtcbiAgICAgICAgICBibHVlID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlZCA9IHZhbHVlO1xuICAgICAgICAgIGdyZWVuID0gcDtcbiAgICAgICAgICBibHVlID0gcTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBjb2xvci5SR0IocmVkLCBncmVlbiwgYmx1ZSwgdGhpcy5fYWxwaGEpO1xuICAgIH0sXG4gICAgaHNsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbCA9ICgyIC0gdGhpcy5fc2F0dXJhdGlvbikgKiB0aGlzLl92YWx1ZSxcbiAgICAgICAgICBzdiA9IHRoaXMuX3NhdHVyYXRpb24gKiB0aGlzLl92YWx1ZSxcbiAgICAgICAgICBzdkRpdmlzb3IgPSBsIDw9IDEgPyBsIDogMiAtIGwsXG4gICAgICAgICAgc2F0dXJhdGlvbjsgLy8gQXZvaWQgZGl2aXNpb24gYnkgemVybyB3aGVuIGxpZ2h0bmVzcyBhcHByb2FjaGVzIHplcm86XG5cbiAgICAgIGlmIChzdkRpdmlzb3IgPCAxZS05KSB7XG4gICAgICAgIHNhdHVyYXRpb24gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2F0dXJhdGlvbiA9IHN2IC8gc3ZEaXZpc29yO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IGNvbG9yLkhTTCh0aGlzLl9odWUsIHNhdHVyYXRpb24sIGwgLyAyLCB0aGlzLl9hbHBoYSk7XG4gICAgfSxcbiAgICBmcm9tUmdiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBCZWNvbWVzIG9uZS5jb2xvci5SR0IucHJvdG90eXBlLmhzdlxuICAgICAgdmFyIHJlZCA9IHRoaXMuX3JlZCxcbiAgICAgICAgICBncmVlbiA9IHRoaXMuX2dyZWVuLFxuICAgICAgICAgIGJsdWUgPSB0aGlzLl9ibHVlLFxuICAgICAgICAgIG1heCA9IE1hdGgubWF4KHJlZCwgZ3JlZW4sIGJsdWUpLFxuICAgICAgICAgIG1pbiA9IE1hdGgubWluKHJlZCwgZ3JlZW4sIGJsdWUpLFxuICAgICAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgICAgIGh1ZSxcbiAgICAgICAgICBzYXR1cmF0aW9uID0gbWF4ID09PSAwID8gMCA6IGRlbHRhIC8gbWF4LFxuICAgICAgICAgIHZhbHVlID0gbWF4O1xuXG4gICAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgaHVlID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICAgICAgY2FzZSByZWQ6XG4gICAgICAgICAgICBodWUgPSAoZ3JlZW4gLSBibHVlKSAvIGRlbHRhIC8gNiArIChncmVlbiA8IGJsdWUgPyAxIDogMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgZ3JlZW46XG4gICAgICAgICAgICBodWUgPSAoYmx1ZSAtIHJlZCkgLyBkZWx0YSAvIDYgKyAxIC8gMztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBibHVlOlxuICAgICAgICAgICAgaHVlID0gKHJlZCAtIGdyZWVuKSAvIGRlbHRhIC8gNiArIDIgLyAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBjb2xvci5IU1YoaHVlLCBzYXR1cmF0aW9uLCB2YWx1ZSwgdGhpcy5fYWxwaGEpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgSFNMID0gZnVuY3Rpb24gSFNMKGNvbG9yKSB7XG4gIGNvbG9yLnVzZShIU1YpO1xuICBjb2xvci5pbnN0YWxsQ29sb3JTcGFjZSgnSFNMJywgWydodWUnLCAnc2F0dXJhdGlvbicsICdsaWdodG5lc3MnLCAnYWxwaGEnXSwge1xuICAgIGhzdjogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQWxnb3JpdGhtIGFkYXB0ZWQgZnJvbSBodHRwOi8vd2lraS5zZWNvbmRsaWZlLmNvbS93aWtpL0NvbG9yX2NvbnZlcnNpb25fc2NyaXB0c1xuICAgICAgdmFyIGwgPSB0aGlzLl9saWdodG5lc3MgKiAyLFxuICAgICAgICAgIHMgPSB0aGlzLl9zYXR1cmF0aW9uICogKGwgPD0gMSA/IGwgOiAyIC0gbCksXG4gICAgICAgICAgc2F0dXJhdGlvbjsgLy8gQXZvaWQgZGl2aXNpb24gYnkgemVybyB3aGVuIGwgKyBzIGlzIHZlcnkgc21hbGwgKGFwcHJvYWNoaW5nIGJsYWNrKTpcblxuICAgICAgaWYgKGwgKyBzIDwgMWUtOSkge1xuICAgICAgICBzYXR1cmF0aW9uID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNhdHVyYXRpb24gPSAyICogcyAvIChsICsgcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgY29sb3IuSFNWKHRoaXMuX2h1ZSwgc2F0dXJhdGlvbiwgKGwgKyBzKSAvIDIsIHRoaXMuX2FscGhhKTtcbiAgICB9LFxuICAgIHJnYjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaHN2KCkucmdiKCk7XG4gICAgfSxcbiAgICBmcm9tUmdiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBCZWNvbWVzIG9uZS5jb2xvci5SR0IucHJvdG90eXBlLmhzdlxuICAgICAgcmV0dXJuIHRoaXMuaHN2KCkuaHNsKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBDTVlLID0gZnVuY3Rpb24gQ01ZSyhjb2xvcikge1xuICBjb2xvci5pbnN0YWxsQ29sb3JTcGFjZSgnQ01ZSycsIFsnY3lhbicsICdtYWdlbnRhJywgJ3llbGxvdycsICdibGFjaycsICdhbHBoYSddLCB7XG4gICAgcmdiOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IGNvbG9yLlJHQigxIC0gdGhpcy5fY3lhbiAqICgxIC0gdGhpcy5fYmxhY2spIC0gdGhpcy5fYmxhY2ssIDEgLSB0aGlzLl9tYWdlbnRhICogKDEgLSB0aGlzLl9ibGFjaykgLSB0aGlzLl9ibGFjaywgMSAtIHRoaXMuX3llbGxvdyAqICgxIC0gdGhpcy5fYmxhY2spIC0gdGhpcy5fYmxhY2ssIHRoaXMuX2FscGhhKTtcbiAgICB9LFxuICAgIGZyb21SZ2I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEJlY29tZXMgb25lLmNvbG9yLlJHQi5wcm90b3R5cGUuY215a1xuICAgICAgLy8gQWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cuamF2YXNjcmlwdGVyLm5ldC9mYXEvcmdiMmNteWsuaHRtXG4gICAgICB2YXIgcmVkID0gdGhpcy5fcmVkLFxuICAgICAgICAgIGdyZWVuID0gdGhpcy5fZ3JlZW4sXG4gICAgICAgICAgYmx1ZSA9IHRoaXMuX2JsdWUsXG4gICAgICAgICAgY3lhbiA9IDEgLSByZWQsXG4gICAgICAgICAgbWFnZW50YSA9IDEgLSBncmVlbixcbiAgICAgICAgICB5ZWxsb3cgPSAxIC0gYmx1ZSxcbiAgICAgICAgICBibGFjayA9IDE7XG5cbiAgICAgIGlmIChyZWQgfHwgZ3JlZW4gfHwgYmx1ZSkge1xuICAgICAgICBibGFjayA9IE1hdGgubWluKGN5YW4sIE1hdGgubWluKG1hZ2VudGEsIHllbGxvdykpO1xuICAgICAgICBjeWFuID0gKGN5YW4gLSBibGFjaykgLyAoMSAtIGJsYWNrKTtcbiAgICAgICAgbWFnZW50YSA9IChtYWdlbnRhIC0gYmxhY2spIC8gKDEgLSBibGFjayk7XG4gICAgICAgIHllbGxvdyA9ICh5ZWxsb3cgLSBibGFjaykgLyAoMSAtIGJsYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJsYWNrID0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBjb2xvci5DTVlLKGN5YW4sIG1hZ2VudGEsIHllbGxvdywgYmxhY2ssIHRoaXMuX2FscGhhKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIG5hbWVkQ29sb3JzID0gZnVuY3Rpb24gbmFtZWRDb2xvcnMoY29sb3IpIHtcbiAgY29sb3IubmFtZWRDb2xvcnMgPSB7XG4gICAgYWxpY2VibHVlOiAnZjBmOGZmJyxcbiAgICBhbnRpcXVld2hpdGU6ICdmYWViZDcnLFxuICAgIGFxdWE6ICcwZmYnLFxuICAgIGFxdWFtYXJpbmU6ICc3ZmZmZDQnLFxuICAgIGF6dXJlOiAnZjBmZmZmJyxcbiAgICBiZWlnZTogJ2Y1ZjVkYycsXG4gICAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgICBibGFjazogJzAwMCcsXG4gICAgYmxhbmNoZWRhbG1vbmQ6ICdmZmViY2QnLFxuICAgIGJsdWU6ICcwMGYnLFxuICAgIGJsdWV2aW9sZXQ6ICc4YTJiZTInLFxuICAgIGJyb3duOiAnYTUyYTJhJyxcbiAgICBidXJseXdvb2Q6ICdkZWI4ODcnLFxuICAgIGNhZGV0Ymx1ZTogJzVmOWVhMCcsXG4gICAgY2hhcnRyZXVzZTogJzdmZmYwMCcsXG4gICAgY2hvY29sYXRlOiAnZDI2OTFlJyxcbiAgICBjb3JhbDogJ2ZmN2Y1MCcsXG4gICAgY29ybmZsb3dlcmJsdWU6ICc2NDk1ZWQnLFxuICAgIGNvcm5zaWxrOiAnZmZmOGRjJyxcbiAgICBjcmltc29uOiAnZGMxNDNjJyxcbiAgICBjeWFuOiAnMGZmJyxcbiAgICBkYXJrYmx1ZTogJzAwMDA4YicsXG4gICAgZGFya2N5YW46ICcwMDhiOGInLFxuICAgIGRhcmtnb2xkZW5yb2Q6ICdiODg2MGInLFxuICAgIGRhcmtncmF5OiAnYTlhOWE5JyxcbiAgICBkYXJrZ3JleTogJ2E5YTlhOScsXG4gICAgZGFya2dyZWVuOiAnMDA2NDAwJyxcbiAgICBkYXJra2hha2k6ICdiZGI3NmInLFxuICAgIGRhcmttYWdlbnRhOiAnOGIwMDhiJyxcbiAgICBkYXJrb2xpdmVncmVlbjogJzU1NmIyZicsXG4gICAgZGFya29yYW5nZTogJ2ZmOGMwMCcsXG4gICAgZGFya29yY2hpZDogJzk5MzJjYycsXG4gICAgZGFya3JlZDogJzhiMDAwMCcsXG4gICAgZGFya3NhbG1vbjogJ2U5OTY3YScsXG4gICAgZGFya3NlYWdyZWVuOiAnOGZiYzhmJyxcbiAgICBkYXJrc2xhdGVibHVlOiAnNDgzZDhiJyxcbiAgICBkYXJrc2xhdGVncmF5OiAnMmY0ZjRmJyxcbiAgICBkYXJrc2xhdGVncmV5OiAnMmY0ZjRmJyxcbiAgICBkYXJrdHVycXVvaXNlOiAnMDBjZWQxJyxcbiAgICBkYXJrdmlvbGV0OiAnOTQwMGQzJyxcbiAgICBkZWVwcGluazogJ2ZmMTQ5MycsXG4gICAgZGVlcHNreWJsdWU6ICcwMGJmZmYnLFxuICAgIGRpbWdyYXk6ICc2OTY5NjknLFxuICAgIGRpbWdyZXk6ICc2OTY5NjknLFxuICAgIGRvZGdlcmJsdWU6ICcxZTkwZmYnLFxuICAgIGZpcmVicmljazogJ2IyMjIyMicsXG4gICAgZmxvcmFsd2hpdGU6ICdmZmZhZjAnLFxuICAgIGZvcmVzdGdyZWVuOiAnMjI4YjIyJyxcbiAgICBmdWNoc2lhOiAnZjBmJyxcbiAgICBnYWluc2Jvcm86ICdkY2RjZGMnLFxuICAgIGdob3N0d2hpdGU6ICdmOGY4ZmYnLFxuICAgIGdvbGQ6ICdmZmQ3MDAnLFxuICAgIGdvbGRlbnJvZDogJ2RhYTUyMCcsXG4gICAgZ3JheTogJzgwODA4MCcsXG4gICAgZ3JleTogJzgwODA4MCcsXG4gICAgZ3JlZW46ICcwMDgwMDAnLFxuICAgIGdyZWVueWVsbG93OiAnYWRmZjJmJyxcbiAgICBob25leWRldzogJ2YwZmZmMCcsXG4gICAgaG90cGluazogJ2ZmNjliNCcsXG4gICAgaW5kaWFucmVkOiAnY2Q1YzVjJyxcbiAgICBpbmRpZ286ICc0YjAwODInLFxuICAgIGl2b3J5OiAnZmZmZmYwJyxcbiAgICBraGFraTogJ2YwZTY4YycsXG4gICAgbGF2ZW5kZXI6ICdlNmU2ZmEnLFxuICAgIGxhdmVuZGVyYmx1c2g6ICdmZmYwZjUnLFxuICAgIGxhd25ncmVlbjogJzdjZmMwMCcsXG4gICAgbGVtb25jaGlmZm9uOiAnZmZmYWNkJyxcbiAgICBsaWdodGJsdWU6ICdhZGQ4ZTYnLFxuICAgIGxpZ2h0Y29yYWw6ICdmMDgwODAnLFxuICAgIGxpZ2h0Y3lhbjogJ2UwZmZmZicsXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICdmYWZhZDInLFxuICAgIGxpZ2h0Z3JheTogJ2QzZDNkMycsXG4gICAgbGlnaHRncmV5OiAnZDNkM2QzJyxcbiAgICBsaWdodGdyZWVuOiAnOTBlZTkwJyxcbiAgICBsaWdodHBpbms6ICdmZmI2YzEnLFxuICAgIGxpZ2h0c2FsbW9uOiAnZmZhMDdhJyxcbiAgICBsaWdodHNlYWdyZWVuOiAnMjBiMmFhJyxcbiAgICBsaWdodHNreWJsdWU6ICc4N2NlZmEnLFxuICAgIGxpZ2h0c2xhdGVncmF5OiAnNzg5JyxcbiAgICBsaWdodHNsYXRlZ3JleTogJzc4OScsXG4gICAgbGlnaHRzdGVlbGJsdWU6ICdiMGM0ZGUnLFxuICAgIGxpZ2h0eWVsbG93OiAnZmZmZmUwJyxcbiAgICBsaW1lOiAnMGYwJyxcbiAgICBsaW1lZ3JlZW46ICczMmNkMzInLFxuICAgIGxpbmVuOiAnZmFmMGU2JyxcbiAgICBtYWdlbnRhOiAnZjBmJyxcbiAgICBtYXJvb246ICc4MDAwMDAnLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6ICc2NmNkYWEnLFxuICAgIG1lZGl1bWJsdWU6ICcwMDAwY2QnLFxuICAgIG1lZGl1bW9yY2hpZDogJ2JhNTVkMycsXG4gICAgbWVkaXVtcHVycGxlOiAnOTM3MGQ4JyxcbiAgICBtZWRpdW1zZWFncmVlbjogJzNjYjM3MScsXG4gICAgbWVkaXVtc2xhdGVibHVlOiAnN2I2OGVlJyxcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogJzAwZmE5YScsXG4gICAgbWVkaXVtdHVycXVvaXNlOiAnNDhkMWNjJyxcbiAgICBtZWRpdW12aW9sZXRyZWQ6ICdjNzE1ODUnLFxuICAgIG1pZG5pZ2h0Ymx1ZTogJzE5MTk3MCcsXG4gICAgbWludGNyZWFtOiAnZjVmZmZhJyxcbiAgICBtaXN0eXJvc2U6ICdmZmU0ZTEnLFxuICAgIG1vY2Nhc2luOiAnZmZlNGI1JyxcbiAgICBuYXZham93aGl0ZTogJ2ZmZGVhZCcsXG4gICAgbmF2eTogJzAwMDA4MCcsXG4gICAgb2xkbGFjZTogJ2ZkZjVlNicsXG4gICAgb2xpdmU6ICc4MDgwMDAnLFxuICAgIG9saXZlZHJhYjogJzZiOGUyMycsXG4gICAgb3JhbmdlOiAnZmZhNTAwJyxcbiAgICBvcmFuZ2VyZWQ6ICdmZjQ1MDAnLFxuICAgIG9yY2hpZDogJ2RhNzBkNicsXG4gICAgcGFsZWdvbGRlbnJvZDogJ2VlZThhYScsXG4gICAgcGFsZWdyZWVuOiAnOThmYjk4JyxcbiAgICBwYWxldHVycXVvaXNlOiAnYWZlZWVlJyxcbiAgICBwYWxldmlvbGV0cmVkOiAnZDg3MDkzJyxcbiAgICBwYXBheWF3aGlwOiAnZmZlZmQ1JyxcbiAgICBwZWFjaHB1ZmY6ICdmZmRhYjknLFxuICAgIHBlcnU6ICdjZDg1M2YnLFxuICAgIHBpbms6ICdmZmMwY2InLFxuICAgIHBsdW06ICdkZGEwZGQnLFxuICAgIHBvd2RlcmJsdWU6ICdiMGUwZTYnLFxuICAgIHB1cnBsZTogJzgwMDA4MCcsXG4gICAgcmViZWNjYXB1cnBsZTogJzYzOScsXG4gICAgcmVkOiAnZjAwJyxcbiAgICByb3N5YnJvd246ICdiYzhmOGYnLFxuICAgIHJveWFsYmx1ZTogJzQxNjllMScsXG4gICAgc2FkZGxlYnJvd246ICc4YjQ1MTMnLFxuICAgIHNhbG1vbjogJ2ZhODA3MicsXG4gICAgc2FuZHlicm93bjogJ2Y0YTQ2MCcsXG4gICAgc2VhZ3JlZW46ICcyZThiNTcnLFxuICAgIHNlYXNoZWxsOiAnZmZmNWVlJyxcbiAgICBzaWVubmE6ICdhMDUyMmQnLFxuICAgIHNpbHZlcjogJ2MwYzBjMCcsXG4gICAgc2t5Ymx1ZTogJzg3Y2VlYicsXG4gICAgc2xhdGVibHVlOiAnNmE1YWNkJyxcbiAgICBzbGF0ZWdyYXk6ICc3MDgwOTAnLFxuICAgIHNsYXRlZ3JleTogJzcwODA5MCcsXG4gICAgc25vdzogJ2ZmZmFmYScsXG4gICAgc3ByaW5nZ3JlZW46ICcwMGZmN2YnLFxuICAgIHN0ZWVsYmx1ZTogJzQ2ODJiNCcsXG4gICAgdGFuOiAnZDJiNDhjJyxcbiAgICB0ZWFsOiAnMDA4MDgwJyxcbiAgICB0aGlzdGxlOiAnZDhiZmQ4JyxcbiAgICB0b21hdG86ICdmZjYzNDcnLFxuICAgIHR1cnF1b2lzZTogJzQwZTBkMCcsXG4gICAgdmlvbGV0OiAnZWU4MmVlJyxcbiAgICB3aGVhdDogJ2Y1ZGViMycsXG4gICAgd2hpdGU6ICdmZmYnLFxuICAgIHdoaXRlc21va2U6ICdmNWY1ZjUnLFxuICAgIHllbGxvdzogJ2ZmMCcsXG4gICAgeWVsbG93Z3JlZW46ICc5YWNkMzInXG4gIH07XG59O1xuXG52YXIgY2xlYXJlciA9IGZ1bmN0aW9uIGNsZWFyZXIoY29sb3IpIHtcbiAgY29sb3IuaW5zdGFsbE1ldGhvZCgnY2xlYXJlcicsIGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcy5hbHBoYShpc05hTihhbW91bnQpID8gLTAuMSA6IC1hbW91bnQsIHRydWUpO1xuICB9KTtcbn07XG5cbnZhciBsdW1pbmFuY2UgPSBmdW5jdGlvbiBsdW1pbmFuY2UoY29sb3IpIHtcbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNyZWxhdGl2ZWx1bWluYW5jZWRlZlxuICBmdW5jdGlvbiBjaGFubmVsTHVtaW5hbmNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDw9IDAuMDM5MjggPyB2YWx1ZSAvIDEyLjkyIDogTWF0aC5wb3coKHZhbHVlICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gIH1cblxuICBjb2xvci5pbnN0YWxsTWV0aG9kKCdsdW1pbmFuY2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJnYiA9IHRoaXMucmdiKCk7XG4gICAgcmV0dXJuIDAuMjEyNiAqIGNoYW5uZWxMdW1pbmFuY2UocmdiLl9yZWQpICsgMC43MTUyICogY2hhbm5lbEx1bWluYW5jZShyZ2IuX2dyZWVuKSArIDAuMDcyMiAqIGNoYW5uZWxMdW1pbmFuY2UocmdiLl9ibHVlKTtcbiAgfSk7XG59O1xuXG52YXIgY29udHJhc3QgPSBmdW5jdGlvbiBjb250cmFzdChjb2xvcikge1xuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI2NvbnRyYXN0LXJhdGlvZGVmXG4gIGNvbG9yLnVzZShsdW1pbmFuY2UpO1xuICBjb2xvci5pbnN0YWxsTWV0aG9kKCdjb250cmFzdCcsIGZ1bmN0aW9uIChjb2xvcjIpIHtcbiAgICB2YXIgbHVtMSA9IHRoaXMubHVtaW5hbmNlKCk7XG4gICAgdmFyIGx1bTIgPSBjb2xvcjIubHVtaW5hbmNlKCk7XG5cbiAgICBpZiAobHVtMSA+IGx1bTIpIHtcbiAgICAgIHJldHVybiAobHVtMSArIDAuMDUpIC8gKGx1bTIgKyAwLjA1KTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGx1bTIgKyAwLjA1KSAvIChsdW0xICsgMC4wNSk7XG4gIH0pO1xufTtcblxudmFyIGRhcmtlbiA9IGZ1bmN0aW9uIGRhcmtlbihjb2xvcikge1xuICBjb2xvci51c2UoSFNMKTtcbiAgY29sb3IuaW5zdGFsbE1ldGhvZCgnZGFya2VuJywgZnVuY3Rpb24gKGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzLmxpZ2h0bmVzcyhpc05hTihhbW91bnQpID8gLTAuMSA6IC1hbW91bnQsIHRydWUpO1xuICB9KTtcbn07XG5cbnZhciBkZXNhdHVyYXRlID0gZnVuY3Rpb24gZGVzYXR1cmF0ZShjb2xvcikge1xuICBjb2xvci51c2UoSFNMKTtcbiAgY29sb3IuaW5zdGFsbE1ldGhvZCgnZGVzYXR1cmF0ZScsIGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcy5zYXR1cmF0aW9uKGlzTmFOKGFtb3VudCkgPyAtMC4xIDogLWFtb3VudCwgdHJ1ZSk7XG4gIH0pO1xufTtcblxudmFyIGdyYXlzY2FsZSA9IGZ1bmN0aW9uIGdyYXlzY2FsZShjb2xvcikge1xuICBmdW5jdGlvbiBncygpIHtcbiAgICAvKmpzbGludCBzdHJpY3Q6ZmFsc2UqL1xuICAgIHZhciByZ2IgPSB0aGlzLnJnYigpLFxuICAgICAgICB2YWwgPSByZ2IuX3JlZCAqIDAuMyArIHJnYi5fZ3JlZW4gKiAwLjU5ICsgcmdiLl9ibHVlICogMC4xMTtcbiAgICByZXR1cm4gbmV3IGNvbG9yLlJHQih2YWwsIHZhbCwgdmFsLCByZ2IuX2FscGhhKTtcbiAgfVxuXG4gIGNvbG9yLmluc3RhbGxNZXRob2QoJ2dyZXlzY2FsZScsIGdzKS5pbnN0YWxsTWV0aG9kKCdncmF5c2NhbGUnLCBncyk7XG59O1xuXG52YXIgaXNEYXJrID0gZnVuY3Rpb24gaXNEYXJrKGNvbG9yKSB7XG4gIGNvbG9yLmluc3RhbGxNZXRob2QoJ2lzRGFyaycsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmdiID0gdGhpcy5yZ2IoKTsgLy8gWUlRIGVxdWF0aW9uIGZyb20gaHR0cDovLzI0d2F5cy5vcmcvMjAxMC9jYWxjdWxhdGluZy1jb2xvci1jb250cmFzdFxuXG4gICAgdmFyIHlpcSA9IChyZ2IuX3JlZCAqIDI1NSAqIDI5OSArIHJnYi5fZ3JlZW4gKiAyNTUgKiA1ODcgKyByZ2IuX2JsdWUgKiAyNTUgKiAxMTQpIC8gMTAwMDtcbiAgICByZXR1cm4geWlxIDwgMTI4O1xuICB9KTtcbn07XG5cbnZhciBpc0xpZ2h0ID0gZnVuY3Rpb24gaXNMaWdodChjb2xvcikge1xuICBjb2xvci51c2UoaXNEYXJrKTtcbiAgY29sb3IuaW5zdGFsbE1ldGhvZCgnaXNMaWdodCcsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNEYXJrKCk7XG4gIH0pO1xufTtcblxudmFyIGxpZ2h0ZW4gPSBmdW5jdGlvbiBsaWdodGVuKGNvbG9yKSB7XG4gIGNvbG9yLnVzZShIU0wpO1xuICBjb2xvci5pbnN0YWxsTWV0aG9kKCdsaWdodGVuJywgZnVuY3Rpb24gKGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzLmxpZ2h0bmVzcyhpc05hTihhbW91bnQpID8gMC4xIDogYW1vdW50LCB0cnVlKTtcbiAgfSk7XG59O1xuXG52YXIgbWl4ID0gZnVuY3Rpb24gbWl4KGNvbG9yKSB7XG4gIGNvbG9yLmluc3RhbGxNZXRob2QoJ21peCcsIGZ1bmN0aW9uIChvdGhlckNvbG9yLCB3ZWlnaHQpIHtcbiAgICBvdGhlckNvbG9yID0gY29sb3Iob3RoZXJDb2xvcikucmdiKCk7XG4gICAgd2VpZ2h0ID0gMSAtIChpc05hTih3ZWlnaHQpID8gMC41IDogd2VpZ2h0KTtcbiAgICB2YXIgdyA9IHdlaWdodCAqIDIgLSAxLFxuICAgICAgICBhID0gdGhpcy5fYWxwaGEgLSBvdGhlckNvbG9yLl9hbHBoYSxcbiAgICAgICAgd2VpZ2h0MSA9ICgodyAqIGEgPT09IC0xID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIsXG4gICAgICAgIHdlaWdodDIgPSAxIC0gd2VpZ2h0MSxcbiAgICAgICAgcmdiID0gdGhpcy5yZ2IoKTtcbiAgICByZXR1cm4gbmV3IGNvbG9yLlJHQihyZ2IuX3JlZCAqIHdlaWdodDEgKyBvdGhlckNvbG9yLl9yZWQgKiB3ZWlnaHQyLCByZ2IuX2dyZWVuICogd2VpZ2h0MSArIG90aGVyQ29sb3IuX2dyZWVuICogd2VpZ2h0MiwgcmdiLl9ibHVlICogd2VpZ2h0MSArIG90aGVyQ29sb3IuX2JsdWUgKiB3ZWlnaHQyLCByZ2IuX2FscGhhICogd2VpZ2h0ICsgb3RoZXJDb2xvci5fYWxwaGEgKiAoMSAtIHdlaWdodCkpO1xuICB9KTtcbn07XG5cbnZhciBuZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoY29sb3IpIHtcbiAgY29sb3IuaW5zdGFsbE1ldGhvZCgnbmVnYXRlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciByZ2IgPSB0aGlzLnJnYigpO1xuICAgIHJldHVybiBuZXcgY29sb3IuUkdCKDEgLSByZ2IuX3JlZCwgMSAtIHJnYi5fZ3JlZW4sIDEgLSByZ2IuX2JsdWUsIHRoaXMuX2FscGhhKTtcbiAgfSk7XG59O1xuXG52YXIgb3BhcXVlciA9IGZ1bmN0aW9uIG9wYXF1ZXIoY29sb3IpIHtcbiAgY29sb3IuaW5zdGFsbE1ldGhvZCgnb3BhcXVlcicsIGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcy5hbHBoYShpc05hTihhbW91bnQpID8gMC4xIDogYW1vdW50LCB0cnVlKTtcbiAgfSk7XG59O1xuXG52YXIgcm90YXRlID0gZnVuY3Rpb24gcm90YXRlKGNvbG9yKSB7XG4gIGNvbG9yLnVzZShIU0wpO1xuICBjb2xvci5pbnN0YWxsTWV0aG9kKCdyb3RhdGUnLCBmdW5jdGlvbiAoZGVncmVlcykge1xuICAgIHJldHVybiB0aGlzLmh1ZSgoZGVncmVlcyB8fCAwKSAvIDM2MCwgdHJ1ZSk7XG4gIH0pO1xufTtcblxudmFyIHNhdHVyYXRlID0gZnVuY3Rpb24gc2F0dXJhdGUoY29sb3IpIHtcbiAgY29sb3IudXNlKEhTTCk7XG4gIGNvbG9yLmluc3RhbGxNZXRob2QoJ3NhdHVyYXRlJywgZnVuY3Rpb24gKGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzLnNhdHVyYXRpb24oaXNOYU4oYW1vdW50KSA/IDAuMSA6IGFtb3VudCwgdHJ1ZSk7XG4gIH0pO1xufTtcblxuLy8gQWRhcHRlZCBmcm9tIGh0dHA6Ly9naW1wLnNvdXJjZWFyY2hpdmUuY29tL2RvY3VtZW50YXRpb24vMi42LjYtMXVidW50dTEvY29sb3ItdG8tYWxwaGFfOGMtc291cmNlLmh0bWxcbi8vIHRvQWxwaGEgcmV0dXJucyBhIGNvbG9yIHdoZXJlIHRoZSB2YWx1ZXMgb2YgdGhlIGFyZ3VtZW50IGhhdmUgYmVlbiBjb252ZXJ0ZWQgdG8gYWxwaGFcbnZhciB0b0FscGhhID0gZnVuY3Rpb24gdG9BbHBoYShjb2xvcikge1xuICBjb2xvci5pbnN0YWxsTWV0aG9kKCd0b0FscGhhJywgZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgdmFyIG1lID0gdGhpcy5yZ2IoKSxcbiAgICAgICAgb3RoZXIgPSBjb2xvcihjb2xvcikucmdiKCksXG4gICAgICAgIGVwc2lsb24gPSAxZS0xMCxcbiAgICAgICAgYSA9IG5ldyBjb2xvci5SR0IoMCwgMCwgMCwgbWUuX2FscGhhKSxcbiAgICAgICAgY2hhbm5lbHMgPSBbJ19yZWQnLCAnX2dyZWVuJywgJ19ibHVlJ107XG4gICAgY2hhbm5lbHMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgaWYgKG1lW2NoYW5uZWxdIDwgZXBzaWxvbikge1xuICAgICAgICBhW2NoYW5uZWxdID0gbWVbY2hhbm5lbF07XG4gICAgICB9IGVsc2UgaWYgKG1lW2NoYW5uZWxdID4gb3RoZXJbY2hhbm5lbF0pIHtcbiAgICAgICAgYVtjaGFubmVsXSA9IChtZVtjaGFubmVsXSAtIG90aGVyW2NoYW5uZWxdKSAvICgxIC0gb3RoZXJbY2hhbm5lbF0pO1xuICAgICAgfSBlbHNlIGlmIChtZVtjaGFubmVsXSA+IG90aGVyW2NoYW5uZWxdKSB7XG4gICAgICAgIGFbY2hhbm5lbF0gPSAob3RoZXJbY2hhbm5lbF0gLSBtZVtjaGFubmVsXSkgLyBvdGhlcltjaGFubmVsXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFbY2hhbm5lbF0gPSAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGEuX3JlZCA+IGEuX2dyZWVuKSB7XG4gICAgICBpZiAoYS5fcmVkID4gYS5fYmx1ZSkge1xuICAgICAgICBtZS5fYWxwaGEgPSBhLl9yZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZS5fYWxwaGEgPSBhLl9ibHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYS5fZ3JlZW4gPiBhLl9ibHVlKSB7XG4gICAgICBtZS5fYWxwaGEgPSBhLl9ncmVlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbWUuX2FscGhhID0gYS5fYmx1ZTtcbiAgICB9XG5cbiAgICBpZiAobWUuX2FscGhhIDwgZXBzaWxvbikge1xuICAgICAgcmV0dXJuIG1lO1xuICAgIH1cblxuICAgIGNoYW5uZWxzLmZvckVhY2goZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgIG1lW2NoYW5uZWxdID0gKG1lW2NoYW5uZWxdIC0gb3RoZXJbY2hhbm5lbF0pIC8gbWUuX2FscGhhICsgb3RoZXJbY2hhbm5lbF07XG4gICAgfSk7XG4gICAgbWUuX2FscGhhICo9IGEuX2FscGhhO1xuICAgIHJldHVybiBtZTtcbiAgfSk7XG59O1xuXG52YXIgb25lY29sb3IgPSBjb2xvcl8xLnVzZShYWVopLnVzZShMQUIpLnVzZShIU1YpLnVzZShIU0wpLnVzZShDTVlLKSAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbnNcbi51c2UobmFtZWRDb2xvcnMpLnVzZShjbGVhcmVyKS51c2UoY29udHJhc3QpLnVzZShkYXJrZW4pLnVzZShkZXNhdHVyYXRlKS51c2UoZ3JheXNjYWxlKS51c2UoaXNEYXJrKS51c2UoaXNMaWdodCkudXNlKGxpZ2h0ZW4pLnVzZShsdW1pbmFuY2UpLnVzZShtaXgpLnVzZShuZWdhdGUpLnVzZShvcGFxdWVyKS51c2Uocm90YXRlKS51c2Uoc2F0dXJhdGUpLnVzZSh0b0FscGhhKTtcblxuZnVuY3Rpb24gZ2V0Q29udHJhc3RSYXRpbyhmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKSB7XG4gIHZhciBiYWNrZ3JvdW5kT25XaGl0ZSA9IGFscGhhQmxlbmQoYmFja2dyb3VuZCwgJyNmZmYnKTtcbiAgdmFyIGJhY2tncm91bmRPbkJsYWNrID0gYWxwaGFCbGVuZChiYWNrZ3JvdW5kLCAnIzAwMCcpO1xuICB2YXIgTFdoaXRlID0gZ2V0UmVsYXRpdmVMdW1pbmFuY2UoYmFja2dyb3VuZE9uV2hpdGUpO1xuICB2YXIgTEJsYWNrID0gZ2V0UmVsYXRpdmVMdW1pbmFuY2UoYmFja2dyb3VuZE9uQmxhY2spO1xuICB2YXIgTEZvcmVncm91bmQgPSBnZXRSZWxhdGl2ZUx1bWluYW5jZShmb3JlZ3JvdW5kKTtcblxuICBpZiAoTFdoaXRlIDwgTEZvcmVncm91bmQpIHtcbiAgICByZXR1cm4gZ2V0Q29udHJhc3RSYXRpb09wYXF1ZShmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kT25XaGl0ZSk7XG4gIH0gZWxzZSBpZiAoTEJsYWNrID4gTEZvcmVncm91bmQpIHtcbiAgICByZXR1cm4gZ2V0Q29udHJhc3RSYXRpb09wYXF1ZShmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kT25CbGFjayk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWxwaGFCbGVuZChjc3NGb3JlZ3JvdW5kLCBjc3NCYWNrZ3JvdW5kKSB7XG4gIHZhciBmb3JlZ3JvdW5kID0gb25lY29sb3IoY3NzRm9yZWdyb3VuZCk7XG4gIHZhciBiYWNrZ3JvdW5kID0gb25lY29sb3IoY3NzQmFja2dyb3VuZCk7XG4gIHZhciByZXN1bHQgPSBvbmVjb2xvcignI2ZmZicpO1xuICB2YXIgYSA9IGZvcmVncm91bmQuYWxwaGEoKTtcbiAgcmVzdWx0Ll9yZWQgPSBmb3JlZ3JvdW5kLl9yZWQgKiBhICsgYmFja2dyb3VuZC5fcmVkICogKDEgLSBhKTtcbiAgcmVzdWx0Ll9ncmVlbiA9IGZvcmVncm91bmQuX2dyZWVuICogYSArIGJhY2tncm91bmQuX2dyZWVuICogKDEgLSBhKTtcbiAgcmVzdWx0Ll9ibHVlID0gZm9yZWdyb3VuZC5fYmx1ZSAqIGEgKyBiYWNrZ3JvdW5kLl9ibHVlICogKDEgLSBhKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udHJhc3RSYXRpb09wYXF1ZShmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKSB7XG4gIHZhciBMMSA9IGdldFJlbGF0aXZlTHVtaW5hbmNlKGJhY2tncm91bmQpO1xuICB2YXIgTDIgPSBnZXRSZWxhdGl2ZUx1bWluYW5jZShhbHBoYUJsZW5kKGZvcmVncm91bmQsIGJhY2tncm91bmQpKTsgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDgvUkVDLVdDQUcyMC0yMDA4MTIxMS8jY29udHJhc3QtcmF0aW9kZWZcblxuICByZXR1cm4gKE1hdGgubWF4KEwxLCBMMikgKyAwLjA1KSAvIChNYXRoLm1pbihMMSwgTDIpICsgMC4wNSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlbGF0aXZlTHVtaW5hbmNlKGNzc0NvbG9yKSB7XG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI3JlbGF0aXZlbHVtaW5hbmNlZGVmXG4gIHZhciBjb2xvciA9IG9uZWNvbG9yKGNzc0NvbG9yKTtcbiAgdmFyIFIgPSBjb2xvci5fcmVkIDw9IDAuMDM5MjggPyBjb2xvci5fcmVkIC8gMTIuOTIgOiBNYXRoLnBvdygoY29sb3IuX3JlZCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICB2YXIgRyA9IGNvbG9yLl9ncmVlbiA8PSAwLjAzOTI4ID8gY29sb3IuX2dyZWVuIC8gMTIuOTIgOiBNYXRoLnBvdygoY29sb3IuX2dyZWVuICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gIHZhciBCID0gY29sb3IuX2JsdWUgPD0gMC4wMzkyOCA/IGNvbG9yLl9ibHVlIC8gMTIuOTIgOiBNYXRoLnBvdygoY29sb3IuX2JsdWUgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgdmFyIEwgPSAwLjIxMjYgKiBSICsgMC43MTUyICogRyArIDAuMDcyMiAqIEI7XG4gIHJldHVybiBMO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRDb250cmFzdFJhdGlvO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/color-contrast/dist/index.esm.js\n");

/***/ })

};
;