"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@k-vyn";
exports.ids = ["vendor-chunks/@k-vyn"];
exports.modules = {

/***/ "(ssr)/./node_modules/@k-vyn/coloralgorithm/dist/bundle.js":
/*!***********************************************************!*\
  !*** ./node_modules/@k-vyn/coloralgorithm/dist/bundle.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generate: () => (/* binding */ generate)\n/* harmony export */ });\n// Originally from https://github.com/koenbok/Framer/blob/master/framer/Utils.coffee\n// Translated to Typescript\nfunction distribute({ value, rangeA, rangeB, limit, }) {\n    if (limit === undefined) {\n        limit = false;\n    }\n    const [fromLow, fromHigh] = Array.from(rangeA);\n    const [toLow, toHigh] = Array.from(rangeB);\n    const result = toLow + ((value - fromLow) / (fromHigh - fromLow)) * (toHigh - toLow);\n    if (limit === true) {\n        if (toLow < toHigh) {\n            if (result < toLow) {\n                return toLow;\n            }\n            if (result > toHigh) {\n                return toHigh;\n            }\n        }\n        else {\n            if (result > toLow) {\n                return toLow;\n            }\n            if (result < toHigh) {\n                return toHigh;\n            }\n        }\n    }\n    return result;\n}\n\nconst bezier$2 = __webpack_require__(/*! bezier-easing */ \"(ssr)/./node_modules/bezier-easing/src/index.js\");\nfunction generateNumberOfSteps({ curve, steps, }) {\n    const arrayOfSteps = Array.from(Array(steps).keys());\n    var array = [];\n    for (const step in arrayOfSteps) {\n        const stepNumber = parseInt(step, 10);\n        const easing = bezier$2(...curve);\n        const value = easing(stepNumber / (steps - 1));\n        array.push(value);\n    }\n    return array;\n}\n\nconst defaultCurves = {\n    linear: {\n        name: \"linear\",\n        formatted_name: \"Linear\",\n        value: [0.5, 0.5, 0.5, 0.5],\n    },\n    easeInCubic: {\n        name: \"easeInCubic\",\n        formatted_name: \"Cubic - EaseIn\",\n        value: [0.55, 0.055, 0.675, 0.19],\n    },\n    easeOutCubic: {\n        name: \"easeOutCubic\",\n        formatted_name: \"Cubic - EaseOut\",\n        value: [0.215, 0.61, 0.355, 1],\n    },\n    easeInOutCubic: {\n        name: \"easeInOutCubic\",\n        formatted_name: \"Cubic - EaseInOut\",\n        value: [0.645, 0.045, 0.355, 1],\n    },\n    easeInSine: {\n        name: \"easeInSine\",\n        formatted_name: \"Sine - EaseIn\",\n        value: [0.47, 0, 0.745, 0.715],\n    },\n    easeOutSine: {\n        name: \"easeOutSine\",\n        formatted_name: \"Sine - EaseOut\",\n        value: [0.39, 0.575, 0.565, 1],\n    },\n    easeInOutSine: {\n        name: \"easeInOutSine\",\n        formatted_name: \"Sine - EaseInOut\",\n        value: [0.445, 0.05, 0.55, 0.95],\n    },\n    easeInQuad: {\n        name: \"easeInQuad\",\n        formatted_name: \"Quad - EaseIn\",\n        value: [0.55, 0.085, 0.68, 0.53],\n    },\n    easeOutQuad: {\n        name: \"easeOutQuad\",\n        formatted_name: \"Quad - EaseOut\",\n        value: [0.25, 0.46, 0.45, 0.94],\n    },\n    easeInOutQuad: {\n        name: \"easeInOutQuad\",\n        formatted_name: \"Quad - EaseInOut\",\n        value: [0.455, 0.03, 0.515, 0.955],\n    },\n    easeInQuart: {\n        name: \"easeInQuart\",\n        formatted_name: \"Quart - EaseIn\",\n        value: [0.895, 0.03, 0.685, 0.22],\n    },\n    easeOutQuart: {\n        name: \"easeOutQuart\",\n        formatted_name: \"Quart - EaseOut\",\n        value: [0.165, 0.84, 0.44, 1],\n    },\n    easeInOutQuart: {\n        name: \"easeInOutQuart\",\n        formatted_name: \"Quart - EaseInOut\",\n        value: [0.77, 0, 0.175, 1],\n    },\n    easeInQuint: {\n        name: \"easeInQuint\",\n        formatted_name: \"Quint - EaseIn\",\n        value: [0.755, 0.05, 0.855, 0.06],\n    },\n    easeOutQuint: {\n        name: \"easeOutQuint\",\n        formatted_name: \"Quint - EaseOut\",\n        value: [0.23, 1, 0.32, 1],\n    },\n    easeInOutQuint: {\n        name: \"easeInOutQuint\",\n        formatted_name: \"Quint - EaseInOut\",\n        value: [0.86, 0, 0.07, 1],\n    },\n    easeInCirc: {\n        name: \"easeInCirc\",\n        formatted_name: \"Circ - EaseIn\",\n        value: [0.6, 0.04, 0.98, 0.335],\n    },\n    easeOutCirc: {\n        name: \"easeOutCirc\",\n        formatted_name: \"Circ - EaseOut\",\n        value: [0.075, 0.82, 0.165, 1],\n    },\n    easeInOutCirc: {\n        name: \"easeInOutCirc\",\n        formatted_name: \"Circ - EaseInOut\",\n        value: [0.785, 0.135, 0.15, 0.86],\n    },\n    easeInExpo: {\n        name: \"easeInExpo\",\n        formatted_name: \"Expo - EaseIn\",\n        value: [0.95, 0.05, 0.795, 0.035],\n    },\n    easeOutExpo: {\n        name: \"easeOutExpo\",\n        formatted_name: \"Expo - EaseOut\",\n        value: [0.19, 1, 0.22, 1],\n    },\n    easeInOutExpo: {\n        name: \"easeInOutExpo\",\n        formatted_name: \"Expo - EaseInOut\",\n        value: [1, 0, 0, 1],\n    },\n    easeInBack: {\n        name: \"easeInBack\",\n        formatted_name: \"Back - EaseIn\",\n        value: [0.6, -0.28, 0.735, 0.045],\n    },\n    easeOutBack: {\n        name: \"easeOutBack\",\n        formatted_name: \"Back - EaseOut\",\n        value: [0.175, 0.885, 0.32, 1.275],\n    },\n    easeInOutBack: {\n        name: \"easeInOutBack\",\n        formatted_name: \"Back - EaseInOut\",\n        value: [0.68, -0.55, 0.265, 1.55],\n    },\n};\n\nfunction getCoordinates(curve, invert) {\n    if (typeof curve === \"string\") {\n        const coordinates = defaultCurves[curve];\n        if (coordinates) {\n            return invert === true\n                ? coordinates.value.slice().reverse()\n                : coordinates.value;\n        }\n        else {\n            throw Error(\"provided incorrect curve\");\n        }\n    }\n    if (typeof curve === \"object\") {\n        if (curve.length === 4) {\n            if (!curve.some(isNaN)) {\n                return curve;\n            }\n            else {\n                throw Error(\"incompatible curve\");\n            }\n        }\n        else {\n            throw Error(\"curve is neither a string or a compatible array\");\n        }\n    }\n    throw Error(\"curve was neither a string or an object\");\n}\n\nfunction generateColors(props, options, invert) {\n    const { steps, hue, saturation, brightness } = props;\n    const { minorSteps } = options;\n    // default rotation is clockwise\n    const rotation = options.rotation === \"counterclockwise\" || options.rotation === \"ccw\"\n        ? \"ccw\"\n        : \"cw\";\n    // generate steps 0 to 1 based on curve\n    const hueSteps = generateNumberOfSteps({\n        curve: getCoordinates(hue.curve, invert),\n        steps,\n    });\n    const saturationSteps = generateNumberOfSteps({\n        curve: getCoordinates(saturation.curve, invert),\n        steps,\n    });\n    const brightnessSteps = generateNumberOfSteps({\n        curve: getCoordinates(brightness.curve, invert),\n        steps,\n    });\n    // adjust hue start/end to get the intended rotation\n    if (rotation === \"cw\") {\n        if (hue.start > hue.end) {\n            hue.start -= 360;\n        }\n    }\n    else if (rotation === \"ccw\") {\n        if (hue.end > hue.start) {\n            hue.end -= 360;\n        }\n    }\n    // Distribute the generated steps between hue, saturation, brightness ranges\n    const hueValues = hueSteps.map(function (s) {\n        return distribute({\n            value: s,\n            rangeA: [0, 1],\n            rangeB: [\n                invert === true ? hue.end : hue.start,\n                invert === true ? hue.start : hue.end,\n            ],\n            limit: true,\n        });\n    });\n    const saturationValues = saturationSteps.map(function (s) {\n        const value = distribute({\n            value: s,\n            rangeA: [0, 1],\n            rangeB: [\n                invert === true ? saturation.end : saturation.start,\n                invert === true ? saturation.start : saturation.end,\n            ],\n            limit: true,\n        });\n        const valueWithRate = value * saturation.rate;\n        return valueWithRate < 1 ? valueWithRate : 1; // prevent too much satuartion saturation\n    });\n    const brightnessValues = brightnessSteps.map(function (s) {\n        return distribute({\n            value: s,\n            rangeA: [0, 1],\n            rangeB: [\n                invert === true ? brightness.end : brightness.start,\n                invert === true ? brightness.start : brightness.end,\n            ],\n        });\n    });\n    // Merge values into color steps\n    const colorSteps = hueValues.map(function (hue, i) {\n        const step = {\n            hue: {\n                step: hueSteps[i],\n                value: hueValues[i],\n            },\n            saturation: {\n                step: saturationSteps[i],\n                value: saturationValues[i],\n            },\n            brightness: {\n                step: brightnessSteps[i],\n                value: brightnessValues[i],\n            },\n            step: i,\n            isMajor: true,\n            isLocked: false,\n        };\n        return step;\n    });\n    // generate minor steps\n    if (minorSteps) {\n        minorSteps.forEach(function (o, i) {\n            const defaultStep = {\n                hue: {\n                    step: 0,\n                    value: 0,\n                },\n                saturation: {\n                    step: 0,\n                    value: 0,\n                },\n                brightness: {\n                    step: 0,\n                    value: 0,\n                },\n                isMajor: true,\n                isLocked: false,\n                step: 0,\n            };\n            let insertPreviousStep = defaultStep;\n            let insertNextStep = defaultStep;\n            let insertAtIndex = 0;\n            colorSteps.forEach(function (p, j) {\n                if (o === p.step) {\n                    insertAtIndex = j + 1;\n                    insertPreviousStep = p;\n                    insertNextStep = colorSteps[j + 1];\n                }\n            });\n            const hueStep = (insertPreviousStep.hue.step + insertNextStep.hue.step) / 2;\n            const hueValue = distribute({\n                value: hueStep,\n                rangeA: [0, 1],\n                rangeB: [\n                    invert === true ? hue.end : hue.start,\n                    invert === true ? hue.start : hue.end,\n                ],\n            });\n            const saturationStep = (insertPreviousStep.saturation.step + insertNextStep.saturation.step) /\n                2;\n            let saturationValue = distribute({\n                value: saturationStep,\n                rangeA: [0, 1],\n                rangeB: [\n                    invert === true ? saturation.end : saturation.start,\n                    invert === true ? saturation.start : saturation.end,\n                ],\n            }) * saturation.rate;\n            saturationValue = saturationValue < 1 ? saturationValue : 1;\n            const brightnessStep = (insertPreviousStep.brightness.step + insertNextStep.brightness.step) /\n                2;\n            const brightnessValue = distribute({\n                value: brightnessStep,\n                rangeA: [0, 1],\n                rangeB: [\n                    invert === true ? brightness.end : brightness.start,\n                    invert === true ? brightness.start : brightness.end,\n                ],\n            });\n            if (insertAtIndex !== undefined) {\n                const insertItem = {\n                    hue: {\n                        step: hueStep,\n                        value: hueValue,\n                    },\n                    saturation: {\n                        step: saturationStep,\n                        value: saturationValue,\n                    },\n                    brightness: {\n                        step: brightnessStep,\n                        value: brightnessValue,\n                    },\n                    isLocked: false,\n                    isMajor: false,\n                    step: (insertPreviousStep.step + insertNextStep.step) / 2,\n                };\n                colorSteps.splice(insertAtIndex, 0, insertItem);\n            }\n        });\n    }\n    return colorSteps;\n}\n\nconst chroma$1 = __webpack_require__(/*! chroma-js */ \"(ssr)/./node_modules/chroma-js/dist/chroma.cjs\");\nfunction convertToColors(props, options, algorithmResult) {\n    const results = algorithmResult.map(function (set, i) {\n        const colors = set.map(function ({ hue, saturation, brightness, isMajor, isLocked, step, }) {\n            const color = chroma$1.hsv(hue.value, saturation.value, brightness.value);\n            function replaceNaN(array) {\n                // fixes a NaN for 0 values in ChromaJS\n                array[0] = 0;\n                return array;\n            }\n            const convertedColor = {\n                step,\n                hue: hue.value,\n                saturation: saturation.value,\n                brightness: brightness.value,\n                isMajor,\n                isLocked,\n                hex: color.hex(),\n                hsl: isNaN(color.hsl()[0]) ? replaceNaN(color.hsl()) : color.hsl(),\n                hsv: isNaN(color.hsv()[0]) ? replaceNaN(color.hsv()) : color.hsv(),\n                lab: isNaN(color.lab()[0]) ? replaceNaN(color.lab()) : color.lab(),\n                rgbString: color.rgb().join(),\n                rgbArray: color.rgb(),\n                rgbaString: color.rgba().join(),\n                rgbaArray: color.rgba(),\n            };\n            return convertedColor;\n        });\n        return {\n            inverted: i > 0 ? true : false,\n            colors: colors,\n            name: options.name,\n        };\n    });\n    return results;\n}\n\nvar limit = (x, low = 0, high = 1) => {\n    return min$3(max$3(low, x), high);\n};\n\nvar clip_rgb = (rgb) => {\n    rgb._clipped = false;\n    rgb._unclipped = rgb.slice(0);\n    for (let i = 0; i <= 3; i++) {\n        if (i < 3) {\n            if (rgb[i] < 0 || rgb[i] > 255) rgb._clipped = true;\n            rgb[i] = limit(rgb[i], 0, 255);\n        } else if (i === 3) {\n            rgb[i] = limit(rgb[i], 0, 1);\n        }\n    }\n    return rgb;\n};\n\n// ported from jQuery's $.type\nconst classToType = {};\nfor (let name of [\n    'Boolean',\n    'Number',\n    'String',\n    'Function',\n    'Array',\n    'Date',\n    'RegExp',\n    'Undefined',\n    'Null'\n]) {\n    classToType[`[object ${name}]`] = name.toLowerCase();\n}\nfunction type (obj) {\n    return classToType[Object.prototype.toString.call(obj)] || 'object';\n}\n\nvar unpack = (args, keyOrder = null) => {\n    // if called with more than 3 arguments, we return the arguments\n    if (args.length >= 3) return Array.prototype.slice.call(args);\n    // with less than 3 args we check if first arg is object\n    // and use the keyOrder string to extract and sort properties\n    if (type(args[0]) == 'object' && keyOrder) {\n        return keyOrder\n            .split('')\n            .filter((k) => args[0][k] !== undefined)\n            .map((k) => args[0][k]);\n    }\n    // otherwise we just return the first argument\n    // (which we suppose is an array of args)\n    return args[0].slice(0);\n};\n\nvar last = (args) => {\n    if (args.length < 2) return null;\n    const l = args.length - 1;\n    if (type(args[l]) == 'string') return args[l].toLowerCase();\n    return null;\n};\n\nconst { PI: PI$2, min: min$3, max: max$3 } = Math;\n\nconst rnd2 = (a) => Math.round(a * 100) / 100;\nconst rnd3 = (a) => Math.round(a * 100) / 100;\n\nconst TWOPI = PI$2 * 2;\nconst PITHIRD = PI$2 / 3;\nconst DEG2RAD = PI$2 / 180;\nconst RAD2DEG = 180 / PI$2;\n\nvar input = {\n    format: {},\n    autodetect: []\n};\n\nclass Color {\n    constructor(...args) {\n        const me = this;\n        if (\n            type(args[0]) === 'object' &&\n            args[0].constructor &&\n            args[0].constructor === this.constructor\n        ) {\n            // the argument is already a Color instance\n            return args[0];\n        }\n        // last argument could be the mode\n        let mode = last(args);\n        let autodetect = false;\n        if (!mode) {\n            autodetect = true;\n\n            if (!input.sorted) {\n                input.autodetect = input.autodetect.sort((a, b) => b.p - a.p);\n                input.sorted = true;\n            }\n\n            // auto-detect format\n            for (let chk of input.autodetect) {\n                mode = chk.test(...args);\n                if (mode) break;\n            }\n        }\n        if (input.format[mode]) {\n            const rgb = input.format[mode].apply(\n                null,\n                autodetect ? args : args.slice(0, -1)\n            );\n            me._rgb = clip_rgb(rgb);\n        } else {\n            throw new Error('unknown format: ' + args);\n        }\n        // add alpha channel\n        if (me._rgb.length === 3) me._rgb.push(1);\n    }\n    toString() {\n        if (type(this.hex) == 'function') return this.hex();\n        return `[${this._rgb.join(',')}]`;\n    }\n}\n\n// this gets updated automatically\nconst version = '3.0.0';\n\nconst chroma = (...args) => {\n    return new Color(...args);\n};\n\nchroma.version = version;\n\n/**\n\tX11 color names\n\n\thttp://www.w3.org/TR/css3-color/#svg-color\n*/\n\nconst w3cx11 = {\n    aliceblue: '#f0f8ff',\n    antiquewhite: '#faebd7',\n    aqua: '#00ffff',\n    aquamarine: '#7fffd4',\n    azure: '#f0ffff',\n    beige: '#f5f5dc',\n    bisque: '#ffe4c4',\n    black: '#000000',\n    blanchedalmond: '#ffebcd',\n    blue: '#0000ff',\n    blueviolet: '#8a2be2',\n    brown: '#a52a2a',\n    burlywood: '#deb887',\n    cadetblue: '#5f9ea0',\n    chartreuse: '#7fff00',\n    chocolate: '#d2691e',\n    coral: '#ff7f50',\n    cornflowerblue: '#6495ed',\n    cornsilk: '#fff8dc',\n    crimson: '#dc143c',\n    cyan: '#00ffff',\n    darkblue: '#00008b',\n    darkcyan: '#008b8b',\n    darkgoldenrod: '#b8860b',\n    darkgray: '#a9a9a9',\n    darkgreen: '#006400',\n    darkgrey: '#a9a9a9',\n    darkkhaki: '#bdb76b',\n    darkmagenta: '#8b008b',\n    darkolivegreen: '#556b2f',\n    darkorange: '#ff8c00',\n    darkorchid: '#9932cc',\n    darkred: '#8b0000',\n    darksalmon: '#e9967a',\n    darkseagreen: '#8fbc8f',\n    darkslateblue: '#483d8b',\n    darkslategray: '#2f4f4f',\n    darkslategrey: '#2f4f4f',\n    darkturquoise: '#00ced1',\n    darkviolet: '#9400d3',\n    deeppink: '#ff1493',\n    deepskyblue: '#00bfff',\n    dimgray: '#696969',\n    dimgrey: '#696969',\n    dodgerblue: '#1e90ff',\n    firebrick: '#b22222',\n    floralwhite: '#fffaf0',\n    forestgreen: '#228b22',\n    fuchsia: '#ff00ff',\n    gainsboro: '#dcdcdc',\n    ghostwhite: '#f8f8ff',\n    gold: '#ffd700',\n    goldenrod: '#daa520',\n    gray: '#808080',\n    green: '#008000',\n    greenyellow: '#adff2f',\n    grey: '#808080',\n    honeydew: '#f0fff0',\n    hotpink: '#ff69b4',\n    indianred: '#cd5c5c',\n    indigo: '#4b0082',\n    ivory: '#fffff0',\n    khaki: '#f0e68c',\n    laserlemon: '#ffff54',\n    lavender: '#e6e6fa',\n    lavenderblush: '#fff0f5',\n    lawngreen: '#7cfc00',\n    lemonchiffon: '#fffacd',\n    lightblue: '#add8e6',\n    lightcoral: '#f08080',\n    lightcyan: '#e0ffff',\n    lightgoldenrod: '#fafad2',\n    lightgoldenrodyellow: '#fafad2',\n    lightgray: '#d3d3d3',\n    lightgreen: '#90ee90',\n    lightgrey: '#d3d3d3',\n    lightpink: '#ffb6c1',\n    lightsalmon: '#ffa07a',\n    lightseagreen: '#20b2aa',\n    lightskyblue: '#87cefa',\n    lightslategray: '#778899',\n    lightslategrey: '#778899',\n    lightsteelblue: '#b0c4de',\n    lightyellow: '#ffffe0',\n    lime: '#00ff00',\n    limegreen: '#32cd32',\n    linen: '#faf0e6',\n    magenta: '#ff00ff',\n    maroon: '#800000',\n    maroon2: '#7f0000',\n    maroon3: '#b03060',\n    mediumaquamarine: '#66cdaa',\n    mediumblue: '#0000cd',\n    mediumorchid: '#ba55d3',\n    mediumpurple: '#9370db',\n    mediumseagreen: '#3cb371',\n    mediumslateblue: '#7b68ee',\n    mediumspringgreen: '#00fa9a',\n    mediumturquoise: '#48d1cc',\n    mediumvioletred: '#c71585',\n    midnightblue: '#191970',\n    mintcream: '#f5fffa',\n    mistyrose: '#ffe4e1',\n    moccasin: '#ffe4b5',\n    navajowhite: '#ffdead',\n    navy: '#000080',\n    oldlace: '#fdf5e6',\n    olive: '#808000',\n    olivedrab: '#6b8e23',\n    orange: '#ffa500',\n    orangered: '#ff4500',\n    orchid: '#da70d6',\n    palegoldenrod: '#eee8aa',\n    palegreen: '#98fb98',\n    paleturquoise: '#afeeee',\n    palevioletred: '#db7093',\n    papayawhip: '#ffefd5',\n    peachpuff: '#ffdab9',\n    peru: '#cd853f',\n    pink: '#ffc0cb',\n    plum: '#dda0dd',\n    powderblue: '#b0e0e6',\n    purple: '#800080',\n    purple2: '#7f007f',\n    purple3: '#a020f0',\n    rebeccapurple: '#663399',\n    red: '#ff0000',\n    rosybrown: '#bc8f8f',\n    royalblue: '#4169e1',\n    saddlebrown: '#8b4513',\n    salmon: '#fa8072',\n    sandybrown: '#f4a460',\n    seagreen: '#2e8b57',\n    seashell: '#fff5ee',\n    sienna: '#a0522d',\n    silver: '#c0c0c0',\n    skyblue: '#87ceeb',\n    slateblue: '#6a5acd',\n    slategray: '#708090',\n    slategrey: '#708090',\n    snow: '#fffafa',\n    springgreen: '#00ff7f',\n    steelblue: '#4682b4',\n    tan: '#d2b48c',\n    teal: '#008080',\n    thistle: '#d8bfd8',\n    tomato: '#ff6347',\n    turquoise: '#40e0d0',\n    violet: '#ee82ee',\n    wheat: '#f5deb3',\n    white: '#ffffff',\n    whitesmoke: '#f5f5f5',\n    yellow: '#ffff00',\n    yellowgreen: '#9acd32'\n};\n\nconst RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;\nconst RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;\n\nconst hex2rgb = (hex) => {\n    if (hex.match(RE_HEX)) {\n        // remove optional leading #\n        if (hex.length === 4 || hex.length === 7) {\n            hex = hex.substr(1);\n        }\n        // expand short-notation to full six-digit\n        if (hex.length === 3) {\n            hex = hex.split('');\n            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n        }\n        const u = parseInt(hex, 16);\n        const r = u >> 16;\n        const g = (u >> 8) & 0xff;\n        const b = u & 0xff;\n        return [r, g, b, 1];\n    }\n\n    // match rgba hex format, eg #FF000077\n    if (hex.match(RE_HEXA)) {\n        if (hex.length === 5 || hex.length === 9) {\n            // remove optional leading #\n            hex = hex.substr(1);\n        }\n        // expand short-notation to full eight-digit\n        if (hex.length === 4) {\n            hex = hex.split('');\n            hex =\n                hex[0] +\n                hex[0] +\n                hex[1] +\n                hex[1] +\n                hex[2] +\n                hex[2] +\n                hex[3] +\n                hex[3];\n        }\n        const u = parseInt(hex, 16);\n        const r = (u >> 24) & 0xff;\n        const g = (u >> 16) & 0xff;\n        const b = (u >> 8) & 0xff;\n        const a = Math.round(((u & 0xff) / 0xff) * 100) / 100;\n        return [r, g, b, a];\n    }\n\n    // we used to check for css colors here\n    // if _input.css? and rgb = _input.css hex\n    //     return rgb\n\n    throw new Error(`unknown hex color: ${hex}`);\n};\n\nconst { round: round$5 } = Math;\n\nconst rgb2hex = (...args) => {\n    let [r, g, b, a] = unpack(args, 'rgba');\n    let mode = last(args) || 'auto';\n    if (a === undefined) a = 1;\n    if (mode === 'auto') {\n        mode = a < 1 ? 'rgba' : 'rgb';\n    }\n    r = round$5(r);\n    g = round$5(g);\n    b = round$5(b);\n    const u = (r << 16) | (g << 8) | b;\n    let str = '000000' + u.toString(16); //#.toUpperCase();\n    str = str.substr(str.length - 6);\n    let hxa = '0' + round$5(a * 255).toString(16);\n    hxa = hxa.substr(hxa.length - 2);\n    switch (mode.toLowerCase()) {\n        case 'rgba':\n            return `#${str}${hxa}`;\n        case 'argb':\n            return `#${hxa}${str}`;\n        default:\n            return `#${str}`;\n    }\n};\n\nColor.prototype.name = function () {\n    const hex = rgb2hex(this._rgb, 'rgb');\n    for (let n of Object.keys(w3cx11)) {\n        if (w3cx11[n] === hex) return n.toLowerCase();\n    }\n    return hex;\n};\n\ninput.format.named = (name) => {\n    name = name.toLowerCase();\n    if (w3cx11[name]) return hex2rgb(w3cx11[name]);\n    throw new Error('unknown color name: ' + name);\n};\n\ninput.autodetect.push({\n    p: 5,\n    test: (h, ...rest) => {\n        if (!rest.length && type(h) === 'string' && w3cx11[h.toLowerCase()]) {\n            return 'named';\n        }\n    }\n});\n\nColor.prototype.alpha = function (a, mutate = false) {\n    if (a !== undefined && type(a) === 'number') {\n        if (mutate) {\n            this._rgb[3] = a;\n            return this;\n        }\n        return new Color([this._rgb[0], this._rgb[1], this._rgb[2], a], 'rgb');\n    }\n    return this._rgb[3];\n};\n\nColor.prototype.clipped = function () {\n    return this._rgb._clipped || false;\n};\n\nconst labConstants = {\n    // Corresponds roughly to RGB brighter/darker\n    Kn: 18,\n\n    // D65 standard referent\n    labWhitePoint: 'd65',\n    Xn: 0.95047,\n    Yn: 1,\n    Zn: 1.08883,\n\n    t0: 0.137931034, // 4 / 29\n    t1: 0.206896552, // 6 / 29\n    t2: 0.12841855, // 3 * t1 * t1\n    t3: 0.008856452, // t1 * t1 * t1,\n\n    kE: 216.0 / 24389.0,\n    kKE: 8.0,\n    kK: 24389.0 / 27.0,\n\n    RefWhiteRGB: {\n        // sRGB\n        X: 0.95047,\n        Y: 1,\n        Z: 1.08883\n    },\n\n    MtxRGB2XYZ: {\n        m00: 0.4124564390896922,\n        m01: 0.21267285140562253,\n        m02: 0.0193338955823293,\n        m10: 0.357576077643909,\n        m11: 0.715152155287818,\n        m12: 0.11919202588130297,\n        m20: 0.18043748326639894,\n        m21: 0.07217499330655958,\n        m22: 0.9503040785363679\n    },\n\n    MtxXYZ2RGB: {\n        m00: 3.2404541621141045,\n        m01: -0.9692660305051868,\n        m02: 0.055643430959114726,\n        m10: -1.5371385127977166,\n        m11: 1.8760108454466942,\n        m12: -0.2040259135167538,\n        m20: -0.498531409556016,\n        m21: 0.041556017530349834,\n        m22: 1.0572251882231791\n    },\n\n    // used in rgb2xyz\n    As: 0.9414285350000001,\n    Bs: 1.040417467,\n    Cs: 1.089532651,\n\n    MtxAdaptMa: {\n        m00: 0.8951,\n        m01: -0.7502,\n        m02: 0.0389,\n        m10: 0.2664,\n        m11: 1.7135,\n        m12: -0.0685,\n        m20: -0.1614,\n        m21: 0.0367,\n        m22: 1.0296\n    },\n\n    MtxAdaptMaI: {\n        m00: 0.9869929054667123,\n        m01: 0.43230526972339456,\n        m02: -0.008528664575177328,\n        m10: -0.14705425642099013,\n        m11: 0.5183602715367776,\n        m12: 0.04004282165408487,\n        m20: 0.15996265166373125,\n        m21: 0.0492912282128556,\n        m22: 0.9684866957875502\n    }\n};\n\n// taken from https://de.mathworks.com/help/images/ref/whitepoint.html\nconst ILLUMINANTS = new Map([\n    // ASTM E308-01\n    ['a', [1.0985, 0.35585]],\n    // Wyszecki & Stiles, p. 769\n    ['b', [1.0985, 0.35585]],\n    // C ASTM E308-01\n    ['c', [0.98074, 1.18232]],\n    // D50 (ASTM E308-01)\n    ['d50', [0.96422, 0.82521]],\n    // D55 (ASTM E308-01)\n    ['d55', [0.95682, 0.92149]],\n    // D65 (ASTM E308-01)\n    ['d65', [0.95047, 1.08883]],\n    // E (ASTM E308-01)\n    ['e', [1, 1, 1]],\n    // F2 (ASTM E308-01)\n    ['f2', [0.99186, 0.67393]],\n    // F7 (ASTM E308-01)\n    ['f7', [0.95041, 1.08747]],\n    // F11 (ASTM E308-01)\n    ['f11', [1.00962, 0.6435]],\n    ['icc', [0.96422, 0.82521]]\n]);\n\nfunction setLabWhitePoint(name) {\n    const ill = ILLUMINANTS.get(String(name).toLowerCase());\n    if (!ill) {\n        throw new Error('unknown Lab illuminant ' + name);\n    }\n    labConstants.labWhitePoint = name;\n    labConstants.Xn = ill[0];\n    labConstants.Zn = ill[1];\n}\n\nfunction getLabWhitePoint() {\n    return labConstants.labWhitePoint;\n}\n\n/*\n * L* [0..100]\n * a [-100..100]\n * b [-100..100]\n */\nconst lab2rgb = (...args) => {\n    args = unpack(args, 'lab');\n    const [L, a, b] = args;\n    const [x, y, z] = lab2xyz(L, a, b);\n    const [r, g, b_] = xyz2rgb(x, y, z);\n    return [r, g, b_, args.length > 3 ? args[3] : 1];\n};\n\nconst lab2xyz = (L, a, b) => {\n    const { kE, kK, kKE, Xn, Yn, Zn } = labConstants;\n\n    const fy = (L + 16.0) / 116.0;\n    const fx = 0.002 * a + fy;\n    const fz = fy - 0.005 * b;\n\n    const fx3 = fx * fx * fx;\n    const fz3 = fz * fz * fz;\n\n    const xr = fx3 > kE ? fx3 : (116.0 * fx - 16.0) / kK;\n    const yr = L > kKE ? Math.pow((L + 16.0) / 116.0, 3.0) : L / kK;\n    const zr = fz3 > kE ? fz3 : (116.0 * fz - 16.0) / kK;\n\n    const x = xr * Xn;\n    const y = yr * Yn;\n    const z = zr * Zn;\n\n    return [x, y, z];\n};\n\nconst compand = (linear) => {\n    /* sRGB */\n    const sign = Math.sign(linear);\n    linear = Math.abs(linear);\n    return (\n        (linear <= 0.0031308\n            ? linear * 12.92\n            : 1.055 * Math.pow(linear, 1.0 / 2.4) - 0.055) * sign\n    );\n};\n\nconst xyz2rgb = (x, y, z) => {\n    const { MtxAdaptMa, MtxAdaptMaI, MtxXYZ2RGB, RefWhiteRGB, Xn, Yn, Zn } =\n        labConstants;\n\n    const As = Xn * MtxAdaptMa.m00 + Yn * MtxAdaptMa.m10 + Zn * MtxAdaptMa.m20;\n    const Bs = Xn * MtxAdaptMa.m01 + Yn * MtxAdaptMa.m11 + Zn * MtxAdaptMa.m21;\n    const Cs = Xn * MtxAdaptMa.m02 + Yn * MtxAdaptMa.m12 + Zn * MtxAdaptMa.m22;\n\n    const Ad =\n        RefWhiteRGB.X * MtxAdaptMa.m00 +\n        RefWhiteRGB.Y * MtxAdaptMa.m10 +\n        RefWhiteRGB.Z * MtxAdaptMa.m20;\n    const Bd =\n        RefWhiteRGB.X * MtxAdaptMa.m01 +\n        RefWhiteRGB.Y * MtxAdaptMa.m11 +\n        RefWhiteRGB.Z * MtxAdaptMa.m21;\n    const Cd =\n        RefWhiteRGB.X * MtxAdaptMa.m02 +\n        RefWhiteRGB.Y * MtxAdaptMa.m12 +\n        RefWhiteRGB.Z * MtxAdaptMa.m22;\n\n    const X1 =\n        (x * MtxAdaptMa.m00 + y * MtxAdaptMa.m10 + z * MtxAdaptMa.m20) *\n        (Ad / As);\n    const Y1 =\n        (x * MtxAdaptMa.m01 + y * MtxAdaptMa.m11 + z * MtxAdaptMa.m21) *\n        (Bd / Bs);\n    const Z1 =\n        (x * MtxAdaptMa.m02 + y * MtxAdaptMa.m12 + z * MtxAdaptMa.m22) *\n        (Cd / Cs);\n\n    const X2 =\n        X1 * MtxAdaptMaI.m00 + Y1 * MtxAdaptMaI.m10 + Z1 * MtxAdaptMaI.m20;\n    const Y2 =\n        X1 * MtxAdaptMaI.m01 + Y1 * MtxAdaptMaI.m11 + Z1 * MtxAdaptMaI.m21;\n    const Z2 =\n        X1 * MtxAdaptMaI.m02 + Y1 * MtxAdaptMaI.m12 + Z1 * MtxAdaptMaI.m22;\n\n    const r = compand(\n        X2 * MtxXYZ2RGB.m00 + Y2 * MtxXYZ2RGB.m10 + Z2 * MtxXYZ2RGB.m20\n    );\n    const g = compand(\n        X2 * MtxXYZ2RGB.m01 + Y2 * MtxXYZ2RGB.m11 + Z2 * MtxXYZ2RGB.m21\n    );\n    const b = compand(\n        X2 * MtxXYZ2RGB.m02 + Y2 * MtxXYZ2RGB.m12 + Z2 * MtxXYZ2RGB.m22\n    );\n\n    return [r * 255, g * 255, b * 255];\n};\n\nconst rgb2lab = (...args) => {\n    const [r, g, b, ...rest] = unpack(args, 'rgb');\n    const [x, y, z] = rgb2xyz(r, g, b);\n    const [L, a, b_] = xyz2lab(x, y, z);\n    return [L, a, b_, ...(rest.length > 0 && rest[0] < 1 ? [rest[0]] : [])];\n};\n\nfunction xyz2lab(x, y, z) {\n    const { Xn, Yn, Zn, kE, kK } = labConstants;\n    const xr = x / Xn;\n    const yr = y / Yn;\n    const zr = z / Zn;\n\n    const fx = xr > kE ? Math.pow(xr, 1.0 / 3.0) : (kK * xr + 16.0) / 116.0;\n    const fy = yr > kE ? Math.pow(yr, 1.0 / 3.0) : (kK * yr + 16.0) / 116.0;\n    const fz = zr > kE ? Math.pow(zr, 1.0 / 3.0) : (kK * zr + 16.0) / 116.0;\n\n    return [116.0 * fy - 16.0, 500.0 * (fx - fy), 200.0 * (fy - fz)];\n}\n\nfunction gammaAdjustSRGB(companded) {\n    const sign = Math.sign(companded);\n    companded = Math.abs(companded);\n    const linear =\n        companded <= 0.04045\n            ? companded / 12.92\n            : Math.pow((companded + 0.055) / 1.055, 2.4);\n    return linear * sign;\n}\n\nconst rgb2xyz = (r, g, b) => {\n    // normalize and gamma adjust\n    r = gammaAdjustSRGB(r / 255);\n    g = gammaAdjustSRGB(g / 255);\n    b = gammaAdjustSRGB(b / 255);\n\n    const { MtxRGB2XYZ, MtxAdaptMa, MtxAdaptMaI, Xn, Yn, Zn, As, Bs, Cs } =\n        labConstants;\n\n    let x = r * MtxRGB2XYZ.m00 + g * MtxRGB2XYZ.m10 + b * MtxRGB2XYZ.m20;\n    let y = r * MtxRGB2XYZ.m01 + g * MtxRGB2XYZ.m11 + b * MtxRGB2XYZ.m21;\n    let z = r * MtxRGB2XYZ.m02 + g * MtxRGB2XYZ.m12 + b * MtxRGB2XYZ.m22;\n\n    const Ad = Xn * MtxAdaptMa.m00 + Yn * MtxAdaptMa.m10 + Zn * MtxAdaptMa.m20;\n    const Bd = Xn * MtxAdaptMa.m01 + Yn * MtxAdaptMa.m11 + Zn * MtxAdaptMa.m21;\n    const Cd = Xn * MtxAdaptMa.m02 + Yn * MtxAdaptMa.m12 + Zn * MtxAdaptMa.m22;\n\n    let X = x * MtxAdaptMa.m00 + y * MtxAdaptMa.m10 + z * MtxAdaptMa.m20;\n    let Y = x * MtxAdaptMa.m01 + y * MtxAdaptMa.m11 + z * MtxAdaptMa.m21;\n    let Z = x * MtxAdaptMa.m02 + y * MtxAdaptMa.m12 + z * MtxAdaptMa.m22;\n\n    X *= Ad / As;\n    Y *= Bd / Bs;\n    Z *= Cd / Cs;\n\n    x = X * MtxAdaptMaI.m00 + Y * MtxAdaptMaI.m10 + Z * MtxAdaptMaI.m20;\n    y = X * MtxAdaptMaI.m01 + Y * MtxAdaptMaI.m11 + Z * MtxAdaptMaI.m21;\n    z = X * MtxAdaptMaI.m02 + Y * MtxAdaptMaI.m12 + Z * MtxAdaptMaI.m22;\n\n    return [x, y, z];\n};\n\nColor.prototype.lab = function () {\n    return rgb2lab(this._rgb);\n};\n\nconst lab$1 = (...args) => new Color(...args, 'lab');\nObject.assign(chroma, { lab: lab$1, getLabWhitePoint, setLabWhitePoint });\n\ninput.format.lab = lab2rgb;\n\ninput.autodetect.push({\n    p: 2,\n    test: (...args) => {\n        args = unpack(args, 'lab');\n        if (type(args) === 'array' && args.length === 3) {\n            return 'lab';\n        }\n    }\n});\n\nColor.prototype.darken = function (amount = 1) {\n    const me = this;\n    const lab = me.lab();\n    lab[0] -= labConstants.Kn * amount;\n    return new Color(lab, 'lab').alpha(me.alpha(), true);\n};\n\nColor.prototype.brighten = function (amount = 1) {\n    return this.darken(-amount);\n};\n\nColor.prototype.darker = Color.prototype.darken;\nColor.prototype.brighter = Color.prototype.brighten;\n\nColor.prototype.get = function (mc) {\n    const [mode, channel] = mc.split('.');\n    const src = this[mode]();\n    if (channel) {\n        const i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);\n        if (i > -1) return src[i];\n        throw new Error(`unknown channel ${channel} in mode ${mode}`);\n    } else {\n        return src;\n    }\n};\n\nconst { pow: pow$6 } = Math;\n\nconst EPS = 1e-7;\nconst MAX_ITER = 20;\n\nColor.prototype.luminance = function (lum, mode = 'rgb') {\n    if (lum !== undefined && type(lum) === 'number') {\n        if (lum === 0) {\n            // return pure black\n            return new Color([0, 0, 0, this._rgb[3]], 'rgb');\n        }\n        if (lum === 1) {\n            // return pure white\n            return new Color([255, 255, 255, this._rgb[3]], 'rgb');\n        }\n        // compute new color using...\n        let cur_lum = this.luminance();\n        let max_iter = MAX_ITER;\n\n        const test = (low, high) => {\n            const mid = low.interpolate(high, 0.5, mode);\n            const lm = mid.luminance();\n            if (Math.abs(lum - lm) < EPS || !max_iter--) {\n                // close enough\n                return mid;\n            }\n            return lm > lum ? test(low, mid) : test(mid, high);\n        };\n\n        const rgb = (\n            cur_lum > lum\n                ? test(new Color([0, 0, 0]), this)\n                : test(this, new Color([255, 255, 255]))\n        ).rgb();\n        return new Color([...rgb, this._rgb[3]]);\n    }\n    return rgb2luminance(...this._rgb.slice(0, 3));\n};\n\nconst rgb2luminance = (r, g, b) => {\n    // relative luminance\n    // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n    r = luminance_x(r);\n    g = luminance_x(g);\n    b = luminance_x(b);\n    return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n};\n\nconst luminance_x = (x) => {\n    x /= 255;\n    return x <= 0.03928 ? x / 12.92 : pow$6((x + 0.055) / 1.055, 2.4);\n};\n\nvar index = {};\n\nvar mix = (col1, col2, f = 0.5, ...rest) => {\n    let mode = rest[0] || 'lrgb';\n    if (!index[mode] && !rest.length) {\n        // fall back to the first supported mode\n        mode = Object.keys(index)[0];\n    }\n    if (!index[mode]) {\n        throw new Error(`interpolation mode ${mode} is not defined`);\n    }\n    if (type(col1) !== 'object') col1 = new Color(col1);\n    if (type(col2) !== 'object') col2 = new Color(col2);\n    return index[mode](col1, col2, f).alpha(\n        col1.alpha() + f * (col2.alpha() - col1.alpha())\n    );\n};\n\nColor.prototype.mix = Color.prototype.interpolate = function (\n    col2,\n    f = 0.5,\n    ...rest\n) {\n    return mix(this, col2, f, ...rest);\n};\n\nColor.prototype.premultiply = function (mutate = false) {\n    const rgb = this._rgb;\n    const a = rgb[3];\n    if (mutate) {\n        this._rgb = [rgb[0] * a, rgb[1] * a, rgb[2] * a, a];\n        return this;\n    } else {\n        return new Color([rgb[0] * a, rgb[1] * a, rgb[2] * a, a], 'rgb');\n    }\n};\n\nconst { sin: sin$3, cos: cos$4 } = Math;\n\nconst lch2lab = (...args) => {\n    /*\n    Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.\n    These formulas were invented by David Dalrymple to obtain maximum contrast without going\n    out of gamut if the parameters are in the range 0-1.\n\n    A saturation multiplier was added by Gregor Aisch\n    */\n    let [l, c, h] = unpack(args, 'lch');\n    if (isNaN(h)) h = 0;\n    h = h * DEG2RAD;\n    return [l, cos$4(h) * c, sin$3(h) * c];\n};\n\nconst lch2rgb = (...args) => {\n    args = unpack(args, 'lch');\n    const [l, c, h] = args;\n    const [L, a, b_] = lch2lab(l, c, h);\n    const [r, g, b] = lab2rgb(L, a, b_);\n    return [r, g, b, args.length > 3 ? args[3] : 1];\n};\n\nconst hcl2rgb = (...args) => {\n    const hcl = unpack(args, 'hcl').reverse();\n    return lch2rgb(...hcl);\n};\n\nconst { sqrt: sqrt$4, atan2: atan2$2, round: round$4 } = Math;\n\nconst lab2lch = (...args) => {\n    const [l, a, b] = unpack(args, 'lab');\n    const c = sqrt$4(a * a + b * b);\n    let h = (atan2$2(b, a) * RAD2DEG + 360) % 360;\n    if (round$4(c * 10000) === 0) h = Number.NaN;\n    return [l, c, h];\n};\n\nconst rgb2lch = (...args) => {\n    const [r, g, b, ...rest] = unpack(args, 'rgb');\n    const [l, a, b_] = rgb2lab(r, g, b);\n    const [L, c, h] = lab2lch(l, a, b_);\n    return [L, c, h, ...(rest.length > 0 && rest[0] < 1 ? [rest[0]] : [])];\n};\n\nColor.prototype.lch = function () {\n    return rgb2lch(this._rgb);\n};\nColor.prototype.hcl = function () {\n    return rgb2lch(this._rgb).reverse();\n};\n\nconst lch$1 = (...args) => new Color(...args, 'lch');\nconst hcl = (...args) => new Color(...args, 'hcl');\n\nObject.assign(chroma, { lch: lch$1, hcl });\n\ninput.format.lch = lch2rgb;\ninput.format.hcl = hcl2rgb;\n['lch', 'hcl'].forEach((m) =>\n    input.autodetect.push({\n        p: 2,\n        test: (...args) => {\n            args = unpack(args, m);\n            if (type(args) === 'array' && args.length === 3) {\n                return m;\n            }\n        }\n    })\n);\n\nColor.prototype.saturate = function (amount = 1) {\n    const me = this;\n    const lch = me.lch();\n    lch[1] += labConstants.Kn * amount;\n    if (lch[1] < 0) lch[1] = 0;\n    return new Color(lch, 'lch').alpha(me.alpha(), true);\n};\n\nColor.prototype.desaturate = function (amount = 1) {\n    return this.saturate(-amount);\n};\n\nColor.prototype.set = function (mc, value, mutate = false) {\n    const [mode, channel] = mc.split('.');\n    const src = this[mode]();\n    if (channel) {\n        const i = mode.indexOf(channel) - (mode.substr(0, 2) === 'ok' ? 2 : 0);\n        if (i > -1) {\n            if (type(value) == 'string') {\n                switch (value.charAt(0)) {\n                    case '+':\n                        src[i] += +value;\n                        break;\n                    case '-':\n                        src[i] += +value;\n                        break;\n                    case '*':\n                        src[i] *= +value.substr(1);\n                        break;\n                    case '/':\n                        src[i] /= +value.substr(1);\n                        break;\n                    default:\n                        src[i] = +value;\n                }\n            } else if (type(value) === 'number') {\n                src[i] = value;\n            } else {\n                throw new Error(`unsupported value for Color.set`);\n            }\n            const out = new Color(src, mode);\n            if (mutate) {\n                this._rgb = out._rgb;\n                return this;\n            }\n            return out;\n        }\n        throw new Error(`unknown channel ${channel} in mode ${mode}`);\n    } else {\n        return src;\n    }\n};\n\nColor.prototype.tint = function (f = 0.5, ...rest) {\n    return mix(this, 'white', f, ...rest);\n};\n\nColor.prototype.shade = function (f = 0.5, ...rest) {\n    return mix(this, 'black', f, ...rest);\n};\n\nconst rgb$1 = (col1, col2, f) => {\n    const xyz0 = col1._rgb;\n    const xyz1 = col2._rgb;\n    return new Color(\n        xyz0[0] + f * (xyz1[0] - xyz0[0]),\n        xyz0[1] + f * (xyz1[1] - xyz0[1]),\n        xyz0[2] + f * (xyz1[2] - xyz0[2]),\n        'rgb'\n    );\n};\n\n// register interpolator\nindex.rgb = rgb$1;\n\nconst { sqrt: sqrt$3, pow: pow$5 } = Math;\n\nconst lrgb = (col1, col2, f) => {\n    const [x1, y1, z1] = col1._rgb;\n    const [x2, y2, z2] = col2._rgb;\n    return new Color(\n        sqrt$3(pow$5(x1, 2) * (1 - f) + pow$5(x2, 2) * f),\n        sqrt$3(pow$5(y1, 2) * (1 - f) + pow$5(y2, 2) * f),\n        sqrt$3(pow$5(z1, 2) * (1 - f) + pow$5(z2, 2) * f),\n        'rgb'\n    );\n};\n\n// register interpolator\nindex.lrgb = lrgb;\n\nconst lab = (col1, col2, f) => {\n    const xyz0 = col1.lab();\n    const xyz1 = col2.lab();\n    return new Color(\n        xyz0[0] + f * (xyz1[0] - xyz0[0]),\n        xyz0[1] + f * (xyz1[1] - xyz0[1]),\n        xyz0[2] + f * (xyz1[2] - xyz0[2]),\n        'lab'\n    );\n};\n\n// register interpolator\nindex.lab = lab;\n\nvar interpolate_hsx = (col1, col2, f, m) => {\n    let xyz0, xyz1;\n    if (m === 'hsl') {\n        xyz0 = col1.hsl();\n        xyz1 = col2.hsl();\n    } else if (m === 'hsv') {\n        xyz0 = col1.hsv();\n        xyz1 = col2.hsv();\n    } else if (m === 'hcg') {\n        xyz0 = col1.hcg();\n        xyz1 = col2.hcg();\n    } else if (m === 'hsi') {\n        xyz0 = col1.hsi();\n        xyz1 = col2.hsi();\n    } else if (m === 'lch' || m === 'hcl') {\n        m = 'hcl';\n        xyz0 = col1.hcl();\n        xyz1 = col2.hcl();\n    } else if (m === 'oklch') {\n        xyz0 = col1.oklch().reverse();\n        xyz1 = col2.oklch().reverse();\n    }\n\n    let hue0, hue1, sat0, sat1, lbv0, lbv1;\n    if (m.substr(0, 1) === 'h' || m === 'oklch') {\n        [hue0, sat0, lbv0] = xyz0;\n        [hue1, sat1, lbv1] = xyz1;\n    }\n\n    let sat, hue, lbv, dh;\n\n    if (!isNaN(hue0) && !isNaN(hue1)) {\n        // both colors have hue\n        if (hue1 > hue0 && hue1 - hue0 > 180) {\n            dh = hue1 - (hue0 + 360);\n        } else if (hue1 < hue0 && hue0 - hue1 > 180) {\n            dh = hue1 + 360 - hue0;\n        } else {\n            dh = hue1 - hue0;\n        }\n        hue = hue0 + f * dh;\n    } else if (!isNaN(hue0)) {\n        hue = hue0;\n        if ((lbv1 == 1 || lbv1 == 0) && m != 'hsv') sat = sat0;\n    } else if (!isNaN(hue1)) {\n        hue = hue1;\n        if ((lbv0 == 1 || lbv0 == 0) && m != 'hsv') sat = sat1;\n    } else {\n        hue = Number.NaN;\n    }\n\n    if (sat === undefined) sat = sat0 + f * (sat1 - sat0);\n    lbv = lbv0 + f * (lbv1 - lbv0);\n    return m === 'oklch'\n        ? new Color([lbv, sat, hue], m)\n        : new Color([hue, sat, lbv], m);\n};\n\nconst lch = (col1, col2, f) => {\n    return interpolate_hsx(col1, col2, f, 'lch');\n};\n\n// register interpolator\nindex.lch = lch;\nindex.hcl = lch;\n\nconst num2rgb = (num) => {\n    if (type(num) == 'number' && num >= 0 && num <= 0xffffff) {\n        const r = num >> 16;\n        const g = (num >> 8) & 0xff;\n        const b = num & 0xff;\n        return [r, g, b, 1];\n    }\n    throw new Error('unknown num color: ' + num);\n};\n\nconst rgb2num = (...args) => {\n    const [r, g, b] = unpack(args, 'rgb');\n    return (r << 16) + (g << 8) + b;\n};\n\nColor.prototype.num = function () {\n    return rgb2num(this._rgb);\n};\n\nconst num$1 = (...args) => new Color(...args, 'num');\n\nObject.assign(chroma, { num: num$1 });\n\ninput.format.num = num2rgb;\n\ninput.autodetect.push({\n    p: 5,\n    test: (...args) => {\n        if (\n            args.length === 1 &&\n            type(args[0]) === 'number' &&\n            args[0] >= 0 &&\n            args[0] <= 0xffffff\n        ) {\n            return 'num';\n        }\n    }\n});\n\nconst num = (col1, col2, f) => {\n    const c1 = col1.num();\n    const c2 = col2.num();\n    return new Color(c1 + f * (c2 - c1), 'num');\n};\n\n// register interpolator\nindex.num = num;\n\nconst { floor: floor$3 } = Math;\n\n/*\n * this is basically just HSV with some minor tweaks\n *\n * hue.. [0..360]\n * chroma .. [0..1]\n * grayness .. [0..1]\n */\n\nconst hcg2rgb = (...args) => {\n    args = unpack(args, 'hcg');\n    let [h, c, _g] = args;\n    let r, g, b;\n    _g = _g * 255;\n    const _c = c * 255;\n    if (c === 0) {\n        r = g = b = _g;\n    } else {\n        if (h === 360) h = 0;\n        if (h > 360) h -= 360;\n        if (h < 0) h += 360;\n        h /= 60;\n        const i = floor$3(h);\n        const f = h - i;\n        const p = _g * (1 - c);\n        const q = p + _c * (1 - f);\n        const t = p + _c * f;\n        const v = p + _c;\n        switch (i) {\n            case 0:\n                [r, g, b] = [v, t, p];\n                break;\n            case 1:\n                [r, g, b] = [q, v, p];\n                break;\n            case 2:\n                [r, g, b] = [p, v, t];\n                break;\n            case 3:\n                [r, g, b] = [p, q, v];\n                break;\n            case 4:\n                [r, g, b] = [t, p, v];\n                break;\n            case 5:\n                [r, g, b] = [v, p, q];\n                break;\n        }\n    }\n    return [r, g, b, args.length > 3 ? args[3] : 1];\n};\n\nconst rgb2hcg = (...args) => {\n    const [r, g, b] = unpack(args, 'rgb');\n    const minRgb = min$3(r, g, b);\n    const maxRgb = max$3(r, g, b);\n    const delta = maxRgb - minRgb;\n    const c = (delta * 100) / 255;\n    const _g = (minRgb / (255 - delta)) * 100;\n    let h;\n    if (delta === 0) {\n        h = Number.NaN;\n    } else {\n        if (r === maxRgb) h = (g - b) / delta;\n        if (g === maxRgb) h = 2 + (b - r) / delta;\n        if (b === maxRgb) h = 4 + (r - g) / delta;\n        h *= 60;\n        if (h < 0) h += 360;\n    }\n    return [h, c, _g];\n};\n\nColor.prototype.hcg = function () {\n    return rgb2hcg(this._rgb);\n};\n\nconst hcg$1 = (...args) => new Color(...args, 'hcg');\nchroma.hcg = hcg$1;\n\ninput.format.hcg = hcg2rgb;\n\ninput.autodetect.push({\n    p: 1,\n    test: (...args) => {\n        args = unpack(args, 'hcg');\n        if (type(args) === 'array' && args.length === 3) {\n            return 'hcg';\n        }\n    }\n});\n\nconst hcg = (col1, col2, f) => {\n    return interpolate_hsx(col1, col2, f, 'hcg');\n};\n\n// register interpolator\nindex.hcg = hcg;\n\nconst { cos: cos$3 } = Math;\n\n/*\n * hue [0..360]\n * saturation [0..1]\n * intensity [0..1]\n */\nconst hsi2rgb = (...args) => {\n    /*\n    borrowed from here:\n    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp\n    */\n    args = unpack(args, 'hsi');\n    let [h, s, i] = args;\n    let r, g, b;\n\n    if (isNaN(h)) h = 0;\n    if (isNaN(s)) s = 0;\n    // normalize hue\n    if (h > 360) h -= 360;\n    if (h < 0) h += 360;\n    h /= 360;\n    if (h < 1 / 3) {\n        b = (1 - s) / 3;\n        r = (1 + (s * cos$3(TWOPI * h)) / cos$3(PITHIRD - TWOPI * h)) / 3;\n        g = 1 - (b + r);\n    } else if (h < 2 / 3) {\n        h -= 1 / 3;\n        r = (1 - s) / 3;\n        g = (1 + (s * cos$3(TWOPI * h)) / cos$3(PITHIRD - TWOPI * h)) / 3;\n        b = 1 - (r + g);\n    } else {\n        h -= 2 / 3;\n        g = (1 - s) / 3;\n        b = (1 + (s * cos$3(TWOPI * h)) / cos$3(PITHIRD - TWOPI * h)) / 3;\n        r = 1 - (g + b);\n    }\n    r = limit(i * r * 3);\n    g = limit(i * g * 3);\n    b = limit(i * b * 3);\n    return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];\n};\n\nconst { min: min$2, sqrt: sqrt$2, acos } = Math;\n\nconst rgb2hsi = (...args) => {\n    /*\n    borrowed from here:\n    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp\n    */\n    let [r, g, b] = unpack(args, 'rgb');\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    let h;\n    const min_ = min$2(r, g, b);\n    const i = (r + g + b) / 3;\n    const s = i > 0 ? 1 - min_ / i : 0;\n    if (s === 0) {\n        h = NaN;\n    } else {\n        h = (r - g + (r - b)) / 2;\n        h /= sqrt$2((r - g) * (r - g) + (r - b) * (g - b));\n        h = acos(h);\n        if (b > g) {\n            h = TWOPI - h;\n        }\n        h /= TWOPI;\n    }\n    return [h * 360, s, i];\n};\n\nColor.prototype.hsi = function () {\n    return rgb2hsi(this._rgb);\n};\n\nconst hsi$1 = (...args) => new Color(...args, 'hsi');\nchroma.hsi = hsi$1;\n\ninput.format.hsi = hsi2rgb;\n\ninput.autodetect.push({\n    p: 2,\n    test: (...args) => {\n        args = unpack(args, 'hsi');\n        if (type(args) === 'array' && args.length === 3) {\n            return 'hsi';\n        }\n    }\n});\n\nconst hsi = (col1, col2, f) => {\n    return interpolate_hsx(col1, col2, f, 'hsi');\n};\n\n// register interpolator\nindex.hsi = hsi;\n\nconst hsl2rgb = (...args) => {\n    args = unpack(args, 'hsl');\n    const [h, s, l] = args;\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l * 255;\n    } else {\n        const t3 = [0, 0, 0];\n        const c = [0, 0, 0];\n        const t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const t1 = 2 * l - t2;\n        const h_ = h / 360;\n        t3[0] = h_ + 1 / 3;\n        t3[1] = h_;\n        t3[2] = h_ - 1 / 3;\n        for (let i = 0; i < 3; i++) {\n            if (t3[i] < 0) t3[i] += 1;\n            if (t3[i] > 1) t3[i] -= 1;\n            if (6 * t3[i] < 1) c[i] = t1 + (t2 - t1) * 6 * t3[i];\n            else if (2 * t3[i] < 1) c[i] = t2;\n            else if (3 * t3[i] < 2) c[i] = t1 + (t2 - t1) * (2 / 3 - t3[i]) * 6;\n            else c[i] = t1;\n        }\n        [r, g, b] = [c[0] * 255, c[1] * 255, c[2] * 255];\n    }\n    if (args.length > 3) {\n        // keep alpha channel\n        return [r, g, b, args[3]];\n    }\n    return [r, g, b, 1];\n};\n\n/*\n * supported arguments:\n * - rgb2hsl(r,g,b)\n * - rgb2hsl(r,g,b,a)\n * - rgb2hsl([r,g,b])\n * - rgb2hsl([r,g,b,a])\n * - rgb2hsl({r,g,b,a})\n */\nconst rgb2hsl$1 = (...args) => {\n    args = unpack(args, 'rgba');\n    let [r, g, b] = args;\n\n    r /= 255;\n    g /= 255;\n    b /= 255;\n\n    const minRgb = min$3(r, g, b);\n    const maxRgb = max$3(r, g, b);\n\n    const l = (maxRgb + minRgb) / 2;\n    let s, h;\n\n    if (maxRgb === minRgb) {\n        s = 0;\n        h = Number.NaN;\n    } else {\n        s =\n            l < 0.5\n                ? (maxRgb - minRgb) / (maxRgb + minRgb)\n                : (maxRgb - minRgb) / (2 - maxRgb - minRgb);\n    }\n\n    if (r == maxRgb) h = (g - b) / (maxRgb - minRgb);\n    else if (g == maxRgb) h = 2 + (b - r) / (maxRgb - minRgb);\n    else if (b == maxRgb) h = 4 + (r - g) / (maxRgb - minRgb);\n\n    h *= 60;\n    if (h < 0) h += 360;\n    if (args.length > 3 && args[3] !== undefined) return [h, s, l, args[3]];\n    return [h, s, l];\n};\n\nColor.prototype.hsl = function () {\n    return rgb2hsl$1(this._rgb);\n};\n\nconst hsl$1 = (...args) => new Color(...args, 'hsl');\nchroma.hsl = hsl$1;\n\ninput.format.hsl = hsl2rgb;\n\ninput.autodetect.push({\n    p: 2,\n    test: (...args) => {\n        args = unpack(args, 'hsl');\n        if (type(args) === 'array' && args.length === 3) {\n            return 'hsl';\n        }\n    }\n});\n\nconst hsl = (col1, col2, f) => {\n    return interpolate_hsx(col1, col2, f, 'hsl');\n};\n\n// register interpolator\nindex.hsl = hsl;\n\nconst { floor: floor$2 } = Math;\n\nconst hsv2rgb = (...args) => {\n    args = unpack(args, 'hsv');\n    let [h, s, v] = args;\n    let r, g, b;\n    v *= 255;\n    if (s === 0) {\n        r = g = b = v;\n    } else {\n        if (h === 360) h = 0;\n        if (h > 360) h -= 360;\n        if (h < 0) h += 360;\n        h /= 60;\n\n        const i = floor$2(h);\n        const f = h - i;\n        const p = v * (1 - s);\n        const q = v * (1 - s * f);\n        const t = v * (1 - s * (1 - f));\n\n        switch (i) {\n            case 0:\n                [r, g, b] = [v, t, p];\n                break;\n            case 1:\n                [r, g, b] = [q, v, p];\n                break;\n            case 2:\n                [r, g, b] = [p, v, t];\n                break;\n            case 3:\n                [r, g, b] = [p, q, v];\n                break;\n            case 4:\n                [r, g, b] = [t, p, v];\n                break;\n            case 5:\n                [r, g, b] = [v, p, q];\n                break;\n        }\n    }\n    return [r, g, b, args.length > 3 ? args[3] : 1];\n};\n\nconst { min: min$1, max: max$2 } = Math;\n\n/*\n * supported arguments:\n * - rgb2hsv(r,g,b)\n * - rgb2hsv([r,g,b])\n * - rgb2hsv({r,g,b})\n */\nconst rgb2hsl = (...args) => {\n    args = unpack(args, 'rgb');\n    let [r, g, b] = args;\n    const min_ = min$1(r, g, b);\n    const max_ = max$2(r, g, b);\n    const delta = max_ - min_;\n    let h, s, v;\n    v = max_ / 255.0;\n    if (max_ === 0) {\n        h = Number.NaN;\n        s = 0;\n    } else {\n        s = delta / max_;\n        if (r === max_) h = (g - b) / delta;\n        if (g === max_) h = 2 + (b - r) / delta;\n        if (b === max_) h = 4 + (r - g) / delta;\n        h *= 60;\n        if (h < 0) h += 360;\n    }\n    return [h, s, v];\n};\n\nColor.prototype.hsv = function () {\n    return rgb2hsl(this._rgb);\n};\n\nconst hsv$1 = (...args) => new Color(...args, 'hsv');\nchroma.hsv = hsv$1;\n\ninput.format.hsv = hsv2rgb;\n\ninput.autodetect.push({\n    p: 2,\n    test: (...args) => {\n        args = unpack(args, 'hsv');\n        if (type(args) === 'array' && args.length === 3) {\n            return 'hsv';\n        }\n    }\n});\n\nconst hsv = (col1, col2, f) => {\n    return interpolate_hsx(col1, col2, f, 'hsv');\n};\n\n// register interpolator\nindex.hsv = hsv;\n\n// from https://www.w3.org/TR/css-color-4/multiply-matrices.js\nfunction multiplyMatrices(A, B) {\n    let m = A.length;\n\n    if (!Array.isArray(A[0])) {\n        // A is vector, convert to [[a, b, c, ...]]\n        A = [A];\n    }\n\n    if (!Array.isArray(B[0])) {\n        // B is vector, convert to [[a], [b], [c], ...]]\n        B = B.map((x) => [x]);\n    }\n\n    let p = B[0].length;\n    let B_cols = B[0].map((_, i) => B.map((x) => x[i])); // transpose B\n    let product = A.map((row) =>\n        B_cols.map((col) => {\n            if (!Array.isArray(row)) {\n                return col.reduce((a, c) => a + c * row, 0);\n            }\n\n            return row.reduce((a, c, i) => a + c * (col[i] || 0), 0);\n        })\n    );\n\n    if (m === 1) {\n        product = product[0]; // Avoid [[a, b, c, ...]]\n    }\n\n    if (p === 1) {\n        return product.map((x) => x[0]); // Avoid [[a], [b], [c], ...]]\n    }\n\n    return product;\n}\n\nconst oklab2rgb = (...args) => {\n    args = unpack(args, 'lab');\n    const [L, a, b, ...rest] = args;\n    const [X, Y, Z] = OKLab_to_XYZ([L, a, b]);\n    const [r, g, b_] = xyz2rgb(X, Y, Z);\n    return [r, g, b_, ...(rest.length > 0 && rest[0] < 1 ? [rest[0]] : [])];\n};\n\n// from https://www.w3.org/TR/css-color-4/#color-conversion-code\nfunction OKLab_to_XYZ(OKLab) {\n    // Given OKLab, convert to XYZ relative to D65\n    var LMStoXYZ = [\n        [1.2268798758459243, -0.5578149944602171, 0.2813910456659647],\n        [-0.0405757452148008, 1.112286803280317, -0.0717110580655164],\n        [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]\n    ];\n    var OKLabtoLMS = [\n        [1.0, 0.3963377773761749, 0.2158037573099136],\n        [1.0, -0.1055613458156586, -0.0638541728258133],\n        [1.0, -0.0894841775298119, -1.2914855480194092]\n    ];\n\n    var LMSnl = multiplyMatrices(OKLabtoLMS, OKLab);\n    return multiplyMatrices(\n        LMStoXYZ,\n        LMSnl.map((c) => c ** 3)\n    );\n}\n\nconst rgb2oklab = (...args) => {\n    const [r, g, b, ...rest] = unpack(args, 'rgb');\n    const xyz = rgb2xyz(r, g, b);\n    const oklab = XYZ_to_OKLab(xyz);\n    return [...oklab, ...(rest.length > 0 && rest[0] < 1 ? [rest[0]] : [])];\n};\n\n// from https://www.w3.org/TR/css-color-4/#color-conversion-code\nfunction XYZ_to_OKLab(XYZ) {\n    // Given XYZ relative to D65, convert to OKLab\n    const XYZtoLMS = [\n        [0.819022437996703, 0.3619062600528904, -0.1288737815209879],\n        [0.0329836539323885, 0.9292868615863434, 0.0361446663506424],\n        [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]\n    ];\n    const LMStoOKLab = [\n        [0.210454268309314, 0.7936177747023054, -0.0040720430116193],\n        [1.9779985324311684, -2.4285922420485799, 0.450593709617411],\n        [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]\n    ];\n\n    const LMS = multiplyMatrices(XYZtoLMS, XYZ);\n    // JavaScript Math.cbrt returns a sign-matched cube root\n    // beware if porting to other languages\n    // especially if tempted to use a general power function\n    return multiplyMatrices(\n        LMStoOKLab,\n        LMS.map((c) => Math.cbrt(c))\n    );\n    // L in range [0,1]. For use in CSS, multiply by 100 and add a percent\n}\n\nColor.prototype.oklab = function () {\n    return rgb2oklab(this._rgb);\n};\n\nconst oklab$1 = (...args) => new Color(...args, 'oklab');\nObject.assign(chroma, { oklab: oklab$1 });\n\ninput.format.oklab = oklab2rgb;\n\ninput.autodetect.push({\n    p: 2,\n    test: (...args) => {\n        args = unpack(args, 'oklab');\n        if (type(args) === 'array' && args.length === 3) {\n            return 'oklab';\n        }\n    }\n});\n\nconst oklab = (col1, col2, f) => {\n    const xyz0 = col1.oklab();\n    const xyz1 = col2.oklab();\n    return new Color(\n        xyz0[0] + f * (xyz1[0] - xyz0[0]),\n        xyz0[1] + f * (xyz1[1] - xyz0[1]),\n        xyz0[2] + f * (xyz1[2] - xyz0[2]),\n        'oklab'\n    );\n};\n\n// register interpolator\nindex.oklab = oklab;\n\nconst oklch$1 = (col1, col2, f) => {\n    return interpolate_hsx(col1, col2, f, 'oklch');\n};\n\n// register interpolator\nindex.oklch = oklch$1;\n\nconst { pow: pow$4, sqrt: sqrt$1, PI: PI$1, cos: cos$2, sin: sin$2, atan2: atan2$1 } = Math;\n\nvar average = (colors, mode = 'lrgb', weights = null) => {\n    const l = colors.length;\n    if (!weights) weights = Array.from(new Array(l)).map(() => 1);\n    // normalize weights\n    const k =\n        l /\n        weights.reduce(function (a, b) {\n            return a + b;\n        });\n    weights.forEach((w, i) => {\n        weights[i] *= k;\n    });\n    // convert colors to Color objects\n    colors = colors.map((c) => new Color(c));\n    if (mode === 'lrgb') {\n        return _average_lrgb(colors, weights);\n    }\n    const first = colors.shift();\n    const xyz = first.get(mode);\n    const cnt = [];\n    let dx = 0;\n    let dy = 0;\n    // initial color\n    for (let i = 0; i < xyz.length; i++) {\n        xyz[i] = (xyz[i] || 0) * weights[0];\n        cnt.push(isNaN(xyz[i]) ? 0 : weights[0]);\n        if (mode.charAt(i) === 'h' && !isNaN(xyz[i])) {\n            const A = (xyz[i] / 180) * PI$1;\n            dx += cos$2(A) * weights[0];\n            dy += sin$2(A) * weights[0];\n        }\n    }\n\n    let alpha = first.alpha() * weights[0];\n    colors.forEach((c, ci) => {\n        const xyz2 = c.get(mode);\n        alpha += c.alpha() * weights[ci + 1];\n        for (let i = 0; i < xyz.length; i++) {\n            if (!isNaN(xyz2[i])) {\n                cnt[i] += weights[ci + 1];\n                if (mode.charAt(i) === 'h') {\n                    const A = (xyz2[i] / 180) * PI$1;\n                    dx += cos$2(A) * weights[ci + 1];\n                    dy += sin$2(A) * weights[ci + 1];\n                } else {\n                    xyz[i] += xyz2[i] * weights[ci + 1];\n                }\n            }\n        }\n    });\n\n    for (let i = 0; i < xyz.length; i++) {\n        if (mode.charAt(i) === 'h') {\n            let A = (atan2$1(dy / cnt[i], dx / cnt[i]) / PI$1) * 180;\n            while (A < 0) A += 360;\n            while (A >= 360) A -= 360;\n            xyz[i] = A;\n        } else {\n            xyz[i] = xyz[i] / cnt[i];\n        }\n    }\n    alpha /= l;\n    return new Color(xyz, mode).alpha(alpha > 0.99999 ? 1 : alpha, true);\n};\n\nconst _average_lrgb = (colors, weights) => {\n    const l = colors.length;\n    const xyz = [0, 0, 0, 0];\n    for (let i = 0; i < colors.length; i++) {\n        const col = colors[i];\n        const f = weights[i] / l;\n        const rgb = col._rgb;\n        xyz[0] += pow$4(rgb[0], 2) * f;\n        xyz[1] += pow$4(rgb[1], 2) * f;\n        xyz[2] += pow$4(rgb[2], 2) * f;\n        xyz[3] += rgb[3] * f;\n    }\n    xyz[0] = sqrt$1(xyz[0]);\n    xyz[1] = sqrt$1(xyz[1]);\n    xyz[2] = sqrt$1(xyz[2]);\n    if (xyz[3] > 0.9999999) xyz[3] = 1;\n    return new Color(clip_rgb(xyz));\n};\n\n// minimal multi-purpose interface\n\n\nconst { pow: pow$3 } = Math;\n\nfunction scale (colors) {\n    // constructor\n    let _mode = 'rgb';\n    let _nacol = chroma('#ccc');\n    let _spread = 0;\n    // const _fixed = false;\n    let _domain = [0, 1];\n    let _pos = [];\n    let _padding = [0, 0];\n    let _classes = false;\n    let _colors = [];\n    let _out = false;\n    let _min = 0;\n    let _max = 1;\n    let _correctLightness = false;\n    let _colorCache = {};\n    let _useCache = true;\n    let _gamma = 1;\n\n    // private methods\n\n    const setColors = function (colors) {\n        colors = colors || ['#fff', '#000'];\n        if (\n            colors &&\n            type(colors) === 'string' &&\n            chroma.brewer &&\n            chroma.brewer[colors.toLowerCase()]\n        ) {\n            colors = chroma.brewer[colors.toLowerCase()];\n        }\n        if (type(colors) === 'array') {\n            // handle single color\n            if (colors.length === 1) {\n                colors = [colors[0], colors[0]];\n            }\n            // make a copy of the colors\n            colors = colors.slice(0);\n            // convert to chroma classes\n            for (let c = 0; c < colors.length; c++) {\n                colors[c] = chroma(colors[c]);\n            }\n            // auto-fill color position\n            _pos.length = 0;\n            for (let c = 0; c < colors.length; c++) {\n                _pos.push(c / (colors.length - 1));\n            }\n        }\n        resetCache();\n        return (_colors = colors);\n    };\n\n    const getClass = function (value) {\n        if (_classes != null) {\n            const n = _classes.length - 1;\n            let i = 0;\n            while (i < n && value >= _classes[i]) {\n                i++;\n            }\n            return i - 1;\n        }\n        return 0;\n    };\n\n    let tMapLightness = (t) => t;\n    let tMapDomain = (t) => t;\n\n    // const classifyValue = function(value) {\n    //     let val = value;\n    //     if (_classes.length > 2) {\n    //         const n = _classes.length-1;\n    //         const i = getClass(value);\n    //         const minc = _classes[0] + ((_classes[1]-_classes[0]) * (0 + (_spread * 0.5)));  // center of 1st class\n    //         const maxc = _classes[n-1] + ((_classes[n]-_classes[n-1]) * (1 - (_spread * 0.5)));  // center of last class\n    //         val = _min + ((((_classes[i] + ((_classes[i+1] - _classes[i]) * 0.5)) - minc) / (maxc-minc)) * (_max - _min));\n    //     }\n    //     return val;\n    // };\n\n    const getColor = function (val, bypassMap) {\n        let col, t;\n        if (bypassMap == null) {\n            bypassMap = false;\n        }\n        if (isNaN(val) || val === null) {\n            return _nacol;\n        }\n        if (!bypassMap) {\n            if (_classes && _classes.length > 2) {\n                // find the class\n                const c = getClass(val);\n                t = c / (_classes.length - 2);\n            } else if (_max !== _min) {\n                // just interpolate between min/max\n                t = (val - _min) / (_max - _min);\n            } else {\n                t = 1;\n            }\n        } else {\n            t = val;\n        }\n\n        // domain map\n        t = tMapDomain(t);\n\n        if (!bypassMap) {\n            t = tMapLightness(t); // lightness correction\n        }\n\n        if (_gamma !== 1) {\n            t = pow$3(t, _gamma);\n        }\n\n        t = _padding[0] + t * (1 - _padding[0] - _padding[1]);\n\n        t = limit(t, 0, 1);\n\n        const k = Math.floor(t * 10000);\n\n        if (_useCache && _colorCache[k]) {\n            col = _colorCache[k];\n        } else {\n            if (type(_colors) === 'array') {\n                //for i in [0.._pos.length-1]\n                for (let i = 0; i < _pos.length; i++) {\n                    const p = _pos[i];\n                    if (t <= p) {\n                        col = _colors[i];\n                        break;\n                    }\n                    if (t >= p && i === _pos.length - 1) {\n                        col = _colors[i];\n                        break;\n                    }\n                    if (t > p && t < _pos[i + 1]) {\n                        t = (t - p) / (_pos[i + 1] - p);\n                        col = chroma.interpolate(\n                            _colors[i],\n                            _colors[i + 1],\n                            t,\n                            _mode\n                        );\n                        break;\n                    }\n                }\n            } else if (type(_colors) === 'function') {\n                col = _colors(t);\n            }\n            if (_useCache) {\n                _colorCache[k] = col;\n            }\n        }\n        return col;\n    };\n\n    var resetCache = () => (_colorCache = {});\n\n    setColors(colors);\n\n    // public interface\n\n    const f = function (v) {\n        const c = chroma(getColor(v));\n        if (_out && c[_out]) {\n            return c[_out]();\n        } else {\n            return c;\n        }\n    };\n\n    f.classes = function (classes) {\n        if (classes != null) {\n            if (type(classes) === 'array') {\n                _classes = classes;\n                _domain = [classes[0], classes[classes.length - 1]];\n            } else {\n                const d = chroma.analyze(_domain);\n                if (classes === 0) {\n                    _classes = [d.min, d.max];\n                } else {\n                    _classes = chroma.limits(d, 'e', classes);\n                }\n            }\n            return f;\n        }\n        return _classes;\n    };\n\n    f.domain = function (domain) {\n        if (!arguments.length) {\n            return _domain;\n        }\n        _min = domain[0];\n        _max = domain[domain.length - 1];\n        _pos = [];\n        const k = _colors.length;\n        if (domain.length === k && _min !== _max) {\n            // update positions\n            for (let d of Array.from(domain)) {\n                _pos.push((d - _min) / (_max - _min));\n            }\n        } else {\n            for (let c = 0; c < k; c++) {\n                _pos.push(c / (k - 1));\n            }\n            if (domain.length > 2) {\n                // set domain map\n                const tOut = domain.map((d, i) => i / (domain.length - 1));\n                const tBreaks = domain.map((d) => (d - _min) / (_max - _min));\n                if (!tBreaks.every((val, i) => tOut[i] === val)) {\n                    tMapDomain = (t) => {\n                        if (t <= 0 || t >= 1) return t;\n                        let i = 0;\n                        while (t >= tBreaks[i + 1]) i++;\n                        const f =\n                            (t - tBreaks[i]) / (tBreaks[i + 1] - tBreaks[i]);\n                        const out = tOut[i] + f * (tOut[i + 1] - tOut[i]);\n                        return out;\n                    };\n                }\n            }\n        }\n        _domain = [_min, _max];\n        return f;\n    };\n\n    f.mode = function (_m) {\n        if (!arguments.length) {\n            return _mode;\n        }\n        _mode = _m;\n        resetCache();\n        return f;\n    };\n\n    f.range = function (colors, _pos) {\n        setColors(colors);\n        return f;\n    };\n\n    f.out = function (_o) {\n        _out = _o;\n        return f;\n    };\n\n    f.spread = function (val) {\n        if (!arguments.length) {\n            return _spread;\n        }\n        _spread = val;\n        return f;\n    };\n\n    f.correctLightness = function (v) {\n        if (v == null) {\n            v = true;\n        }\n        _correctLightness = v;\n        resetCache();\n        if (_correctLightness) {\n            tMapLightness = function (t) {\n                const L0 = getColor(0, true).lab()[0];\n                const L1 = getColor(1, true).lab()[0];\n                const pol = L0 > L1;\n                let L_actual = getColor(t, true).lab()[0];\n                const L_ideal = L0 + (L1 - L0) * t;\n                let L_diff = L_actual - L_ideal;\n                let t0 = 0;\n                let t1 = 1;\n                let max_iter = 20;\n                while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {\n                    (function () {\n                        if (pol) {\n                            L_diff *= -1;\n                        }\n                        if (L_diff < 0) {\n                            t0 = t;\n                            t += (t1 - t) * 0.5;\n                        } else {\n                            t1 = t;\n                            t += (t0 - t) * 0.5;\n                        }\n                        L_actual = getColor(t, true).lab()[0];\n                        return (L_diff = L_actual - L_ideal);\n                    })();\n                }\n                return t;\n            };\n        } else {\n            tMapLightness = (t) => t;\n        }\n        return f;\n    };\n\n    f.padding = function (p) {\n        if (p != null) {\n            if (type(p) === 'number') {\n                p = [p, p];\n            }\n            _padding = p;\n            return f;\n        } else {\n            return _padding;\n        }\n    };\n\n    f.colors = function (numColors, out) {\n        // If no arguments are given, return the original colors that were provided\n        if (arguments.length < 2) {\n            out = 'hex';\n        }\n        let result = [];\n\n        if (arguments.length === 0) {\n            result = _colors.slice(0);\n        } else if (numColors === 1) {\n            result = [f(0.5)];\n        } else if (numColors > 1) {\n            const dm = _domain[0];\n            const dd = _domain[1] - dm;\n            result = __range__(0, numColors).map((i) =>\n                f(dm + (i / (numColors - 1)) * dd)\n            );\n        } else {\n            // returns all colors based on the defined classes\n            colors = [];\n            let samples = [];\n            if (_classes && _classes.length > 2) {\n                for (\n                    let i = 1, end = _classes.length, asc = 1 <= end;\n                    asc ? i < end : i > end;\n                    asc ? i++ : i--\n                ) {\n                    samples.push((_classes[i - 1] + _classes[i]) * 0.5);\n                }\n            } else {\n                samples = _domain;\n            }\n            result = samples.map((v) => f(v));\n        }\n\n        if (chroma[out]) {\n            result = result.map((c) => c[out]());\n        }\n        return result;\n    };\n\n    f.cache = function (c) {\n        if (c != null) {\n            _useCache = c;\n            return f;\n        } else {\n            return _useCache;\n        }\n    };\n\n    f.gamma = function (g) {\n        if (g != null) {\n            _gamma = g;\n            return f;\n        } else {\n            return _gamma;\n        }\n    };\n\n    f.nodata = function (d) {\n        if (d != null) {\n            _nacol = chroma(d);\n            return f;\n        } else {\n            return _nacol;\n        }\n    };\n\n    return f;\n}\n\nfunction __range__(left, right, inclusive) {\n    let range = [];\n    let ascending = left < right;\n    let end = right ;\n    for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n        range.push(i);\n    }\n    return range;\n}\n\n//\n// interpolates between a set of colors uzing a bezier spline\n//\n\n\n// nth row of the pascal triangle\nconst binom_row = function (n) {\n    let row = [1, 1];\n    for (let i = 1; i < n; i++) {\n        let newrow = [1];\n        for (let j = 1; j <= row.length; j++) {\n            newrow[j] = (row[j] || 0) + row[j - 1];\n        }\n        row = newrow;\n    }\n    return row;\n};\n\nconst bezier = function (colors) {\n    let I, lab0, lab1, lab2;\n    colors = colors.map((c) => new Color(c));\n    if (colors.length === 2) {\n        // linear interpolation\n        [lab0, lab1] = colors.map((c) => c.lab());\n        I = function (t) {\n            const lab = [0, 1, 2].map((i) => lab0[i] + t * (lab1[i] - lab0[i]));\n            return new Color(lab, 'lab');\n        };\n    } else if (colors.length === 3) {\n        // quadratic bezier interpolation\n        [lab0, lab1, lab2] = colors.map((c) => c.lab());\n        I = function (t) {\n            const lab = [0, 1, 2].map(\n                (i) =>\n                    (1 - t) * (1 - t) * lab0[i] +\n                    2 * (1 - t) * t * lab1[i] +\n                    t * t * lab2[i]\n            );\n            return new Color(lab, 'lab');\n        };\n    } else if (colors.length === 4) {\n        // cubic bezier interpolation\n        let lab3;\n        [lab0, lab1, lab2, lab3] = colors.map((c) => c.lab());\n        I = function (t) {\n            const lab = [0, 1, 2].map(\n                (i) =>\n                    (1 - t) * (1 - t) * (1 - t) * lab0[i] +\n                    3 * (1 - t) * (1 - t) * t * lab1[i] +\n                    3 * (1 - t) * t * t * lab2[i] +\n                    t * t * t * lab3[i]\n            );\n            return new Color(lab, 'lab');\n        };\n    } else if (colors.length >= 5) {\n        // general case (degree n bezier)\n        let labs, row, n;\n        labs = colors.map((c) => c.lab());\n        n = colors.length - 1;\n        row = binom_row(n);\n        I = function (t) {\n            const u = 1 - t;\n            const lab = [0, 1, 2].map((i) =>\n                labs.reduce(\n                    (sum, el, j) =>\n                        sum + row[j] * u ** (n - j) * t ** j * el[i],\n                    0\n                )\n            );\n            return new Color(lab, 'lab');\n        };\n    } else {\n        throw new RangeError('No point in running bezier with only one color.');\n    }\n    return I;\n};\n\nvar bezier$1 = (colors) => {\n    const f = bezier(colors);\n    f.scale = () => scale(f);\n    return f;\n};\n\nconst { round: round$3 } = Math;\n\nColor.prototype.rgb = function (rnd = true) {\n    if (rnd === false) return this._rgb.slice(0, 3);\n    return this._rgb.slice(0, 3).map(round$3);\n};\n\nColor.prototype.rgba = function (rnd = true) {\n    return this._rgb.slice(0, 4).map((v, i) => {\n        return i < 3 ? (rnd === false ? v : round$3(v)) : v;\n    });\n};\n\nconst rgb = (...args) => new Color(...args, 'rgb');\nObject.assign(chroma, { rgb });\n\ninput.format.rgb = (...args) => {\n    const rgba = unpack(args, 'rgba');\n    if (rgba[3] === undefined) rgba[3] = 1;\n    return rgba;\n};\n\ninput.autodetect.push({\n    p: 3,\n    test: (...args) => {\n        args = unpack(args, 'rgba');\n        if (\n            type(args) === 'array' &&\n            (args.length === 3 ||\n                (args.length === 4 &&\n                    type(args[3]) == 'number' &&\n                    args[3] >= 0 &&\n                    args[3] <= 1))\n        ) {\n            return 'rgb';\n        }\n    }\n});\n\n/*\n * interpolates between a set of colors uzing a bezier spline\n * blend mode formulas taken from https://web.archive.org/web/20180110014946/http://www.venture-ware.com/kevin/coding/lets-learn-math-photoshop-blend-modes/\n */\n\n\nconst blend = (bottom, top, mode) => {\n    if (!blend[mode]) {\n        throw new Error('unknown blend mode ' + mode);\n    }\n    return blend[mode](bottom, top);\n};\n\nconst blend_f = (f) => (bottom, top) => {\n    const c0 = chroma(top).rgb();\n    const c1 = chroma(bottom).rgb();\n    return chroma.rgb(f(c0, c1));\n};\n\nconst each = (f) => (c0, c1) => {\n    const out = [];\n    out[0] = f(c0[0], c1[0]);\n    out[1] = f(c0[1], c1[1]);\n    out[2] = f(c0[2], c1[2]);\n    return out;\n};\n\nconst normal = (a) => a;\nconst multiply = (a, b) => (a * b) / 255;\nconst darken = (a, b) => (a > b ? b : a);\nconst lighten = (a, b) => (a > b ? a : b);\nconst screen = (a, b) => 255 * (1 - (1 - a / 255) * (1 - b / 255));\nconst overlay = (a, b) =>\n    b < 128 ? (2 * a * b) / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));\nconst burn = (a, b) => 255 * (1 - (1 - b / 255) / (a / 255));\nconst dodge = (a, b) => {\n    if (a === 255) return 255;\n    a = (255 * (b / 255)) / (1 - a / 255);\n    return a > 255 ? 255 : a;\n};\n\n// # add = (a,b) ->\n// #     if (a + b > 255) then 255 else a + b\n\nblend.normal = blend_f(each(normal));\nblend.multiply = blend_f(each(multiply));\nblend.screen = blend_f(each(screen));\nblend.overlay = blend_f(each(overlay));\nblend.darken = blend_f(each(darken));\nblend.lighten = blend_f(each(lighten));\nblend.dodge = blend_f(each(dodge));\nblend.burn = blend_f(each(burn));\n\n// cubehelix interpolation\n// based on D.A. Green \"A colour scheme for the display of astronomical intensity images\"\n// http://astron-soc.in/bulletin/11June/289392011.pdf\nconst { pow: pow$2, sin: sin$1, cos: cos$1 } = Math;\n\nfunction cubehelix (\n    start = 300,\n    rotations = -1.5,\n    hue = 1,\n    gamma = 1,\n    lightness = [0, 1]\n) {\n    let dh = 0,\n        dl;\n    if (type(lightness) === 'array') {\n        dl = lightness[1] - lightness[0];\n    } else {\n        dl = 0;\n        lightness = [lightness, lightness];\n    }\n    const f = function (fract) {\n        const a = TWOPI * ((start + 120) / 360 + rotations * fract);\n        const l = pow$2(lightness[0] + dl * fract, gamma);\n        const h = dh !== 0 ? hue[0] + fract * dh : hue;\n        const amp = (h * l * (1 - l)) / 2;\n        const cos_a = cos$1(a);\n        const sin_a = sin$1(a);\n        const r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);\n        const g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);\n        const b = l + amp * (+1.97294 * cos_a);\n        return chroma(clip_rgb([r * 255, g * 255, b * 255, 1]));\n    };\n    f.start = function (s) {\n        if (s == null) {\n            return start;\n        }\n        start = s;\n        return f;\n    };\n    f.rotations = function (r) {\n        if (r == null) {\n            return rotations;\n        }\n        rotations = r;\n        return f;\n    };\n    f.gamma = function (g) {\n        if (g == null) {\n            return gamma;\n        }\n        gamma = g;\n        return f;\n    };\n    f.hue = function (h) {\n        if (h == null) {\n            return hue;\n        }\n        hue = h;\n        if (type(hue) === 'array') {\n            dh = hue[1] - hue[0];\n            if (dh === 0) {\n                hue = hue[1];\n            }\n        } else {\n            dh = 0;\n        }\n        return f;\n    };\n    f.lightness = function (h) {\n        if (h == null) {\n            return lightness;\n        }\n        if (type(h) === 'array') {\n            lightness = h;\n            dl = h[1] - h[0];\n        } else {\n            lightness = [h, h];\n            dl = 0;\n        }\n        return f;\n    };\n    f.scale = () => chroma.scale(f);\n    f.hue(hue);\n    return f;\n}\n\nconst digits = '0123456789abcdef';\n\nconst { floor: floor$1, random } = Math;\n\nvar random$1 = () => {\n    let code = '#';\n    for (let i = 0; i < 6; i++) {\n        code += digits.charAt(floor$1(random() * 16));\n    }\n    return new Color(code, 'hex');\n};\n\nconst { log: log$1, pow: pow$1, floor, abs: abs$1 } = Math;\n\nfunction analyze(data, key = null) {\n    const r = {\n        min: Number.MAX_VALUE,\n        max: Number.MAX_VALUE * -1,\n        sum: 0,\n        values: [],\n        count: 0\n    };\n    if (type(data) === 'object') {\n        data = Object.values(data);\n    }\n    data.forEach((val) => {\n        if (key && type(val) === 'object') val = val[key];\n        if (val !== undefined && val !== null && !isNaN(val)) {\n            r.values.push(val);\n            r.sum += val;\n            if (val < r.min) r.min = val;\n            if (val > r.max) r.max = val;\n            r.count += 1;\n        }\n    });\n\n    r.domain = [r.min, r.max];\n\n    r.limits = (mode, num) => limits(r, mode, num);\n\n    return r;\n}\n\nfunction limits(data, mode = 'equal', num = 7) {\n    if (type(data) == 'array') {\n        data = analyze(data);\n    }\n    const { min, max } = data;\n    const values = data.values.sort((a, b) => a - b);\n\n    if (num === 1) {\n        return [min, max];\n    }\n\n    const limits = [];\n\n    if (mode.substr(0, 1) === 'c') {\n        // continuous\n        limits.push(min);\n        limits.push(max);\n    }\n\n    if (mode.substr(0, 1) === 'e') {\n        // equal interval\n        limits.push(min);\n        for (let i = 1; i < num; i++) {\n            limits.push(min + (i / num) * (max - min));\n        }\n        limits.push(max);\n    } else if (mode.substr(0, 1) === 'l') {\n        // log scale\n        if (min <= 0) {\n            throw new Error(\n                'Logarithmic scales are only possible for values > 0'\n            );\n        }\n        const min_log = Math.LOG10E * log$1(min);\n        const max_log = Math.LOG10E * log$1(max);\n        limits.push(min);\n        for (let i = 1; i < num; i++) {\n            limits.push(pow$1(10, min_log + (i / num) * (max_log - min_log)));\n        }\n        limits.push(max);\n    } else if (mode.substr(0, 1) === 'q') {\n        // quantile scale\n        limits.push(min);\n        for (let i = 1; i < num; i++) {\n            const p = ((values.length - 1) * i) / num;\n            const pb = floor(p);\n            if (pb === p) {\n                limits.push(values[pb]);\n            } else {\n                // p > pb\n                const pr = p - pb;\n                limits.push(values[pb] * (1 - pr) + values[pb + 1] * pr);\n            }\n        }\n        limits.push(max);\n    } else if (mode.substr(0, 1) === 'k') {\n        // k-means clustering\n        /*\n        implementation based on\n        http://code.google.com/p/figue/source/browse/trunk/figue.js#336\n        simplified for 1-d input values\n        */\n        let cluster;\n        const n = values.length;\n        const assignments = new Array(n);\n        const clusterSizes = new Array(num);\n        let repeat = true;\n        let nb_iters = 0;\n        let centroids = null;\n\n        // get seed values\n        centroids = [];\n        centroids.push(min);\n        for (let i = 1; i < num; i++) {\n            centroids.push(min + (i / num) * (max - min));\n        }\n        centroids.push(max);\n\n        while (repeat) {\n            // assignment step\n            for (let j = 0; j < num; j++) {\n                clusterSizes[j] = 0;\n            }\n            for (let i = 0; i < n; i++) {\n                const value = values[i];\n                let mindist = Number.MAX_VALUE;\n                let best;\n                for (let j = 0; j < num; j++) {\n                    const dist = abs$1(centroids[j] - value);\n                    if (dist < mindist) {\n                        mindist = dist;\n                        best = j;\n                    }\n                    clusterSizes[best]++;\n                    assignments[i] = best;\n                }\n            }\n\n            // update centroids step\n            const newCentroids = new Array(num);\n            for (let j = 0; j < num; j++) {\n                newCentroids[j] = null;\n            }\n            for (let i = 0; i < n; i++) {\n                cluster = assignments[i];\n                if (newCentroids[cluster] === null) {\n                    newCentroids[cluster] = values[i];\n                } else {\n                    newCentroids[cluster] += values[i];\n                }\n            }\n            for (let j = 0; j < num; j++) {\n                newCentroids[j] *= 1 / clusterSizes[j];\n            }\n\n            // check convergence\n            repeat = false;\n            for (let j = 0; j < num; j++) {\n                if (newCentroids[j] !== centroids[j]) {\n                    repeat = true;\n                    break;\n                }\n            }\n\n            centroids = newCentroids;\n            nb_iters++;\n\n            if (nb_iters > 200) {\n                repeat = false;\n            }\n        }\n\n        // finished k-means clustering\n        // the next part is borrowed from gabrielflor.it\n        const kClusters = {};\n        for (let j = 0; j < num; j++) {\n            kClusters[j] = [];\n        }\n        for (let i = 0; i < n; i++) {\n            cluster = assignments[i];\n            kClusters[cluster].push(values[i]);\n        }\n        let tmpKMeansBreaks = [];\n        for (let j = 0; j < num; j++) {\n            tmpKMeansBreaks.push(kClusters[j][0]);\n            tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);\n        }\n        tmpKMeansBreaks = tmpKMeansBreaks.sort((a, b) => a - b);\n        limits.push(tmpKMeansBreaks[0]);\n        for (let i = 1; i < tmpKMeansBreaks.length; i += 2) {\n            const v = tmpKMeansBreaks[i];\n            if (!isNaN(v) && limits.indexOf(v) === -1) {\n                limits.push(v);\n            }\n        }\n    }\n    return limits;\n}\n\nvar contrast = (a, b) => {\n    // WCAG contrast ratio\n    // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n    a = new Color(a);\n    b = new Color(b);\n    const l1 = a.luminance();\n    const l2 = b.luminance();\n    return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);\n};\n\nconst { sqrt, pow, min, max: max$1, atan2, abs, cos, sin, exp, PI } = Math;\n\nfunction deltaE (a, b, Kl = 1, Kc = 1, Kh = 1) {\n    // Delta E (CIE 2000)\n    // see http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE2000.html\n    var rad2deg = function (rad) {\n        return (360 * rad) / (2 * PI);\n    };\n    var deg2rad = function (deg) {\n        return (2 * PI * deg) / 360;\n    };\n    a = new Color(a);\n    b = new Color(b);\n    const [L1, a1, b1] = Array.from(a.lab());\n    const [L2, a2, b2] = Array.from(b.lab());\n    const avgL = (L1 + L2) / 2;\n    const C1 = sqrt(pow(a1, 2) + pow(b1, 2));\n    const C2 = sqrt(pow(a2, 2) + pow(b2, 2));\n    const avgC = (C1 + C2) / 2;\n    const G = 0.5 * (1 - sqrt(pow(avgC, 7) / (pow(avgC, 7) + pow(25, 7))));\n    const a1p = a1 * (1 + G);\n    const a2p = a2 * (1 + G);\n    const C1p = sqrt(pow(a1p, 2) + pow(b1, 2));\n    const C2p = sqrt(pow(a2p, 2) + pow(b2, 2));\n    const avgCp = (C1p + C2p) / 2;\n    const arctan1 = rad2deg(atan2(b1, a1p));\n    const arctan2 = rad2deg(atan2(b2, a2p));\n    const h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;\n    const h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;\n    const avgHp =\n        abs(h1p - h2p) > 180 ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;\n    const T =\n        1 -\n        0.17 * cos(deg2rad(avgHp - 30)) +\n        0.24 * cos(deg2rad(2 * avgHp)) +\n        0.32 * cos(deg2rad(3 * avgHp + 6)) -\n        0.2 * cos(deg2rad(4 * avgHp - 63));\n    let deltaHp = h2p - h1p;\n    deltaHp =\n        abs(deltaHp) <= 180\n            ? deltaHp\n            : h2p <= h1p\n              ? deltaHp + 360\n              : deltaHp - 360;\n    deltaHp = 2 * sqrt(C1p * C2p) * sin(deg2rad(deltaHp) / 2);\n    const deltaL = L2 - L1;\n    const deltaCp = C2p - C1p;\n    const sl = 1 + (0.015 * pow(avgL - 50, 2)) / sqrt(20 + pow(avgL - 50, 2));\n    const sc = 1 + 0.045 * avgCp;\n    const sh = 1 + 0.015 * avgCp * T;\n    const deltaTheta = 30 * exp(-pow((avgHp - 275) / 25, 2));\n    const Rc = 2 * sqrt(pow(avgCp, 7) / (pow(avgCp, 7) + pow(25, 7)));\n    const Rt = -Rc * sin(2 * deg2rad(deltaTheta));\n    const result = sqrt(\n        pow(deltaL / (Kl * sl), 2) +\n            pow(deltaCp / (Kc * sc), 2) +\n            pow(deltaHp / (Kh * sh), 2) +\n            Rt * (deltaCp / (Kc * sc)) * (deltaHp / (Kh * sh))\n    );\n    return max$1(0, min(100, result));\n}\n\n// simple Euclidean distance\nfunction distance (a, b, mode = 'lab') {\n    // Delta E (CIE 1976)\n    // see http://www.brucelindbloom.com/index.html?Equations.html\n    a = new Color(a);\n    b = new Color(b);\n    const l1 = a.get(mode);\n    const l2 = b.get(mode);\n    let sum_sq = 0;\n    for (let i in l1) {\n        const d = (l1[i] || 0) - (l2[i] || 0);\n        sum_sq += d * d;\n    }\n    return Math.sqrt(sum_sq);\n}\n\nvar valid = (...args) => {\n    try {\n        new Color(...args);\n        return true;\n        // eslint-disable-next-line\n    } catch (e) {\n        return false;\n    }\n};\n\n// some pre-defined color scales:\n\nvar scales = {\n    cool() {\n        return scale([chroma.hsl(180, 1, 0.9), chroma.hsl(250, 0.7, 0.4)]);\n    },\n    hot() {\n        return scale(['#000', '#f00', '#ff0', '#fff']).mode(\n            'rgb'\n        );\n    }\n};\n\n/**\n    ColorBrewer colors for chroma.js\n\n    Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The\n    Pennsylvania State University.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software distributed\n    under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n    CONDITIONS OF ANY KIND, either express or implied. See the License for the\n    specific language governing permissions and limitations under the License.\n*/\n\nconst colorbrewer = {\n    // sequential\n    OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],\n    PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],\n    BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],\n    Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],\n    BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],\n    YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],\n    YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],\n    Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],\n    RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],\n    Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],\n    YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],\n    Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],\n    GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],\n    Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],\n    YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],\n    PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],\n    Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],\n    PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],\n    Viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],\n\n    // diverging\n    Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],\n    RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],\n    RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],\n    PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],\n    PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],\n    RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],\n    BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],\n    RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],\n    PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],\n\n    // qualitative\n    Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],\n    Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],\n    Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],\n    Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],\n    Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],\n    Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],\n    Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],\n    Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2']\n};\n\n// add lowercase aliases for case-insensitive matches\nfor (let key of Object.keys(colorbrewer)) {\n    colorbrewer[key.toLowerCase()] = colorbrewer[key];\n}\n\nconst cmyk2rgb = (...args) => {\n    args = unpack(args, 'cmyk');\n    const [c, m, y, k] = args;\n    const alpha = args.length > 4 ? args[4] : 1;\n    if (k === 1) return [0, 0, 0, alpha];\n    return [\n        c >= 1 ? 0 : 255 * (1 - c) * (1 - k), // r\n        m >= 1 ? 0 : 255 * (1 - m) * (1 - k), // g\n        y >= 1 ? 0 : 255 * (1 - y) * (1 - k), // b\n        alpha\n    ];\n};\n\nconst { max } = Math;\n\nconst rgb2cmyk = (...args) => {\n    let [r, g, b] = unpack(args, 'rgb');\n    r = r / 255;\n    g = g / 255;\n    b = b / 255;\n    const k = 1 - max(r, max(g, b));\n    const f = k < 1 ? 1 / (1 - k) : 0;\n    const c = (1 - r - k) * f;\n    const m = (1 - g - k) * f;\n    const y = (1 - b - k) * f;\n    return [c, m, y, k];\n};\n\nColor.prototype.cmyk = function () {\n    return rgb2cmyk(this._rgb);\n};\n\nconst cmyk = (...args) => new Color(...args, 'cmyk');\nObject.assign(chroma, { cmyk });\n\ninput.format.cmyk = cmyk2rgb;\n\ninput.autodetect.push({\n    p: 2,\n    test: (...args) => {\n        args = unpack(args, 'cmyk');\n        if (type(args) === 'array' && args.length === 4) {\n            return 'cmyk';\n        }\n    }\n});\n\n/*\n * supported arguments:\n * - hsl2css(h,s,l)\n * - hsl2css(h,s,l,a)\n * - hsl2css([h,s,l], mode)\n * - hsl2css([h,s,l,a], mode)\n * - hsl2css({h,s,l,a}, mode)\n */\nconst hsl2css = (...args) => {\n    const hsla = unpack(args, 'hsla');\n    let mode = last(args) || 'lsa';\n    hsla[0] = rnd2(hsla[0] || 0) + 'deg';\n    hsla[1] = rnd2(hsla[1] * 100) + '%';\n    hsla[2] = rnd2(hsla[2] * 100) + '%';\n    if (mode === 'hsla' || (hsla.length > 3 && hsla[3] < 1)) {\n        hsla[3] = '/ ' + (hsla.length > 3 ? hsla[3] : 1);\n        mode = 'hsla';\n    } else {\n        hsla.length = 3;\n    }\n    return `${mode.substr(0, 3)}(${hsla.join(' ')})`;\n};\n\n/*\n * supported arguments:\n * - lab2css(l,a,b)\n * - lab2css(l,a,b,alpha)\n * - lab2css([l,a,b], mode)\n * - lab2css([l,a,b,alpha], mode)\n */\nconst lab2css = (...args) => {\n    const laba = unpack(args, 'lab');\n    let mode = last(args) || 'lab';\n    laba[0] = rnd2(laba[0]) + '%';\n    laba[1] = rnd2(laba[1]);\n    laba[2] = rnd2(laba[2]);\n    if (mode === 'laba' || (laba.length > 3 && laba[3] < 1)) {\n        laba[3] = '/ ' + (laba.length > 3 ? laba[3] : 1);\n    } else {\n        laba.length = 3;\n    }\n    return `lab(${laba.join(' ')})`;\n};\n\n/*\n * supported arguments:\n * - lab2css(l,a,b)\n * - lab2css(l,a,b,alpha)\n * - lab2css([l,a,b], mode)\n * - lab2css([l,a,b,alpha], mode)\n */\nconst lch2css = (...args) => {\n    const lcha = unpack(args, 'lch');\n    let mode = last(args) || 'lab';\n    lcha[0] = rnd2(lcha[0]) + '%';\n    lcha[1] = rnd2(lcha[1]);\n    lcha[2] = rnd2(lcha[2]) + 'deg'; // add deg unit to hue\n    if (mode === 'lcha' || (lcha.length > 3 && lcha[3] < 1)) {\n        lcha[3] = '/ ' + (lcha.length > 3 ? lcha[3] : 1);\n    } else {\n        lcha.length = 3;\n    }\n    return `lch(${lcha.join(' ')})`;\n};\n\nconst oklab2css$1 = (...args) => {\n    const laba = unpack(args, 'lab');\n    laba[0] = rnd2(laba[0] * 100) + '%';\n    laba[1] = rnd3(laba[1]);\n    laba[2] = rnd3(laba[2]);\n    if (laba.length > 3 && laba[3] < 1) {\n        laba[3] = '/ ' + (laba.length > 3 ? laba[3] : 1);\n    } else {\n        laba.length = 3;\n    }\n    return `oklab(${laba.join(' ')})`;\n};\n\nconst rgb2oklch = (...args) => {\n    const [r, g, b, ...rest] = unpack(args, 'rgb');\n    const [l, a, b_] = rgb2oklab(r, g, b);\n    const [L, c, h] = lab2lch(l, a, b_);\n    return [L, c, h, ...(rest.length > 0 && rest[0] < 1 ? [rest[0]] : [])];\n};\n\nconst oklab2css = (...args) => {\n    const laba = unpack(args, 'lab');\n    laba[0] = rnd2(laba[0] * 100) + '%';\n    laba[1] = rnd3(laba[1]);\n    laba[2] = rnd2(laba[2]) + 'deg';\n    if (laba.length > 3 && laba[3] < 1) {\n        laba[3] = '/ ' + (laba.length > 3 ? laba[3] : 1);\n    } else {\n        laba.length = 3;\n    }\n    return `oklch(${laba.join(' ')})`;\n};\n\nconst { round: round$2 } = Math;\n\n/*\n * supported arguments:\n * - rgb2css(r,g,b)\n * - rgb2css(r,g,b,a)\n * - rgb2css([r,g,b], mode)\n * - rgb2css([r,g,b,a], mode)\n * - rgb2css({r,g,b,a}, mode)\n */\nconst rgb2css = (...args) => {\n    const rgba = unpack(args, 'rgba');\n    let mode = last(args) || 'rgb';\n    if (mode.substr(0, 3) === 'hsl') {\n        return hsl2css(rgb2hsl$1(rgba), mode);\n    }\n    if (mode.substr(0, 3) === 'lab') {\n        // change to D50 lab whitepoint since this is what W3C is using for CSS Lab colors\n        const prevWhitePoint = getLabWhitePoint();\n        setLabWhitePoint('d50');\n        const cssColor = lab2css(rgb2lab(rgba), mode);\n        setLabWhitePoint(prevWhitePoint);\n        return cssColor;\n    }\n    if (mode.substr(0, 3) === 'lch') {\n        // change to D50 lab whitepoint since this is what W3C is using for CSS Lab colors\n        const prevWhitePoint = getLabWhitePoint();\n        setLabWhitePoint('d50');\n        const cssColor = lch2css(rgb2lch(rgba), mode);\n        setLabWhitePoint(prevWhitePoint);\n        return cssColor;\n    }\n    if (mode.substr(0, 5) === 'oklab') {\n        return oklab2css$1(rgb2oklab(rgba));\n    }\n    if (mode.substr(0, 5) === 'oklch') {\n        return oklab2css(rgb2oklch(rgba));\n    }\n    rgba[0] = round$2(rgba[0]);\n    rgba[1] = round$2(rgba[1]);\n    rgba[2] = round$2(rgba[2]);\n    if (mode === 'rgba' || (rgba.length > 3 && rgba[3] < 1)) {\n        rgba[3] = '/ ' + (rgba.length > 3 ? rgba[3] : 1);\n        mode = 'rgba';\n    }\n    return `${mode.substr(0, 3)}(${rgba.slice(0, mode === 'rgb' ? 3 : 4).join(' ')})`;\n};\n\nconst oklch2rgb = (...args) => {\n    args = unpack(args, 'lch');\n    const [l, c, h, ...rest] = args;\n    const [L, a, b_] = lch2lab(l, c, h);\n    const [r, g, b] = oklab2rgb(L, a, b_);\n    return [r, g, b, ...(rest.length > 0 && rest[0] < 1 ? [rest[0]] : [])];\n};\n\nconst RE_RGB = /^rgb\\(\\s*(-?\\d+) \\s*(-?\\d+)\\s* \\s*(-?\\d+)\\s*\\)$/;\nconst RE_RGB_LEGACY = /^rgb\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*\\)$/;\n\nconst RE_RGBA =\n    /^rgba?\\(\\s*(-?\\d+) \\s*(-?\\d+)\\s* \\s*(-?\\d+)\\s*\\/\\s*([01]|[01]?\\.\\d+)\\)$/;\nconst RE_RGBA_LEGACY =\n    /^rgba\\(\\s*(-?\\d+),\\s*(-?\\d+)\\s*,\\s*(-?\\d+)\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n\nconst RE_RGB_PCT =\n    /^rgb\\(\\s*(-?\\d+(?:\\.\\d+)?)% \\s*(-?\\d+(?:\\.\\d+)?)%\\s* \\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\nconst RE_RGB_PCT_LEGACY =\n    /^rgb\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n\nconst RE_RGBA_PCT =\n    /^rgba?\\(\\s*(-?\\d+(?:\\.\\d+)?)% \\s*(-?\\d+(?:\\.\\d+)?)%\\s* \\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\/\\s*([01]|[01]?\\.\\d+)\\)$/;\nconst RE_RGBA_PCT_LEGACY =\n    /^rgba\\(\\s*(-?\\d+(?:\\.\\d+)?)%,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n\nconst RE_HSL =\n    /^hsl\\(\\s*(-?\\d+(?:\\.\\d+)?)deg \\s*(-?\\d+(?:\\.\\d+)?)%\\s* \\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\nconst RE_HSL_LEGACY =\n    /^hsl\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n\nconst RE_HSLA =\n    /^hsla?\\(\\s*(-?\\d+(?:\\.\\d+)?)deg \\s*(-?\\d+(?:\\.\\d+)?)%\\s* \\s*(-?\\d+(?:\\.\\d+)?)%\\s*\\/\\s*([01]|[01]?\\.\\d+)\\)$/;\nconst RE_HSLA_LEGACY =\n    /^hsla\\(\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*(-?\\d+(?:\\.\\d+)?)%\\s*,\\s*([01]|[01]?\\.\\d+)\\)$/;\n\nconst RE_LAB =\n    /^lab\\(\\s*(-?\\d+(?:\\.\\d+)?%?) \\s*(-?\\d+(?:\\.\\d+)?%?) \\s*(-?\\d+(?:\\.\\d+)?%?)\\s*(?:\\/\\s*(\\d+(?:\\.\\d+)?))?\\)?$/;\nconst RE_LCH =\n    /^lch\\(\\s*(-?\\d+(?:\\.\\d+)?%?) \\s*((?:-?\\d+(?:\\.\\d+)?%?)|none) \\s*(-?\\d+(?:\\.\\d+)?(?:deg)?|none)\\s*(?:\\/\\s*(\\d+(?:\\.\\d+)?))?\\)?$/;\nconst RE_OKLAB =\n    /^oklab\\(\\s*(-?\\d+(?:\\.\\d+)?%?) \\s*(-?\\d+(?:\\.\\d+)?%?) \\s*(-?\\d+(?:\\.\\d+)?%?)\\s*(?:\\/\\s*(\\d+(?:\\.\\d+)?))?\\)?$/;\nconst RE_OKLCH =\n    /^oklch\\(\\s*(-?\\d+(?:\\.\\d+)?%?) \\s*(?:(-?\\d+(?:\\.\\d+)?%?)|none) \\s*(-?\\d+(?:\\.\\d+)?(?:deg)?|none)\\s*(?:\\/\\s*(\\d+(?:\\.\\d+)?))?\\)?$/;\n\nconst { round: round$1 } = Math;\n\nconst roundRGB = (rgb) => {\n    return rgb.map((v, i) => (i <= 2 ? limit(round$1(v), 0, 255) : v));\n};\n\nconst percentToAbsolute = (pct, min = 0, max = 100, signed = false) => {\n    if (typeof pct === 'string' && pct.endsWith('%')) {\n        pct = parseFloat(pct.substring(0, pct.length - 1)) / 100;\n        if (signed) {\n            // signed percentages are in the range -100% to 100%\n            pct = min + (pct + 1) * 0.5 * (max - min);\n        } else {\n            pct = min + pct * (max - min);\n        }\n    }\n    return +pct;\n};\n\nconst noneToValue = (v, noneValue) => {\n    return v === 'none' ? noneValue : v;\n};\n\nconst css2rgb = (css) => {\n    css = css.toLowerCase().trim();\n    let m;\n\n    if (input.format.named) {\n        try {\n            return input.format.named(css);\n            // eslint-disable-next-line\n        } catch (e) {}\n    }\n\n    // rgb(250 20 0) or rgb(250,20,0)\n    if ((m = css.match(RE_RGB)) || (m = css.match(RE_RGB_LEGACY))) {\n        const rgb = m.slice(1, 4);\n        for (let i = 0; i < 3; i++) {\n            rgb[i] = +rgb[i];\n        }\n        rgb[3] = 1; // default alpha\n        return rgb;\n    }\n\n    // rgba(250,20,0,0.4)\n    if ((m = css.match(RE_RGBA)) || (m = css.match(RE_RGBA_LEGACY))) {\n        const rgb = m.slice(1, 5);\n        for (let i = 0; i < 4; i++) {\n            rgb[i] = +rgb[i];\n        }\n        return rgb;\n    }\n\n    // rgb(100%,0%,0%)\n    if ((m = css.match(RE_RGB_PCT)) || (m = css.match(RE_RGB_PCT_LEGACY))) {\n        const rgb = m.slice(1, 4);\n        for (let i = 0; i < 3; i++) {\n            rgb[i] = round$1(rgb[i] * 2.55);\n        }\n        rgb[3] = 1; // default alpha\n        return rgb;\n    }\n\n    // rgba(100%,0%,0%,0.4)\n    if ((m = css.match(RE_RGBA_PCT)) || (m = css.match(RE_RGBA_PCT_LEGACY))) {\n        const rgb = m.slice(1, 5);\n        for (let i = 0; i < 3; i++) {\n            rgb[i] = round$1(rgb[i] * 2.55);\n        }\n        rgb[3] = +rgb[3];\n        return rgb;\n    }\n\n    // hsl(0,100%,50%)\n    if ((m = css.match(RE_HSL)) || (m = css.match(RE_HSL_LEGACY))) {\n        const hsl = m.slice(1, 4);\n        hsl[1] *= 0.01;\n        hsl[2] *= 0.01;\n        const rgb = hsl2rgb(hsl);\n        for (let i = 0; i < 3; i++) {\n            rgb[i] = round$1(rgb[i]);\n        }\n        rgb[3] = 1;\n        return rgb;\n    }\n\n    // hsla(0,100%,50%,0.5)\n    if ((m = css.match(RE_HSLA)) || (m = css.match(RE_HSLA_LEGACY))) {\n        const hsl = m.slice(1, 4);\n        hsl[1] *= 0.01;\n        hsl[2] *= 0.01;\n        const rgb = hsl2rgb(hsl);\n        for (let i = 0; i < 3; i++) {\n            rgb[i] = round$1(rgb[i]);\n        }\n        rgb[3] = +m[4]; // default alpha = 1\n        return rgb;\n    }\n\n    if ((m = css.match(RE_LAB))) {\n        const lab = m.slice(1, 4);\n        lab[0] = percentToAbsolute(lab[0], 0, 100);\n        lab[1] = percentToAbsolute(lab[1], -125, 125, true);\n        lab[2] = percentToAbsolute(lab[2], -125, 125, true);\n        // convert to D50 Lab whitepoint\n        const wp = getLabWhitePoint();\n        setLabWhitePoint('d50');\n        const rgb = roundRGB(lab2rgb(lab));\n        // convert back to original Lab whitepoint\n        setLabWhitePoint(wp);\n        rgb[3] = m[4] !== undefined ? +m[4] : 1;\n        return rgb;\n    }\n\n    if ((m = css.match(RE_LCH))) {\n        const lch = m.slice(1, 4);\n        lch[0] = percentToAbsolute(lch[0], 0, 100);\n        lch[1] = percentToAbsolute(noneToValue(lch[1], 0), 0, 150, false);\n        lch[2] = +noneToValue(lch[2].replace('deg', ''), 0);\n        // convert to D50 Lab whitepoint\n        const wp = getLabWhitePoint();\n        setLabWhitePoint('d50');\n        const rgb = roundRGB(lch2rgb(lch));\n        // convert back to original Lab whitepoint\n        setLabWhitePoint(wp);\n        rgb[3] = m[4] !== undefined ? +m[4] : 1;\n        return rgb;\n    }\n\n    if ((m = css.match(RE_OKLAB))) {\n        const oklab = m.slice(1, 4);\n        oklab[0] = percentToAbsolute(oklab[0], 0, 1);\n        oklab[1] = percentToAbsolute(oklab[1], -0.4, 0.4, true);\n        oklab[2] = percentToAbsolute(oklab[2], -0.4, 0.4, true);\n        const rgb = roundRGB(oklab2rgb(oklab));\n        rgb[3] = m[4] !== undefined ? +m[4] : 1;\n        return rgb;\n    }\n\n    if ((m = css.match(RE_OKLCH))) {\n        const oklch = m.slice(1, 4);\n        oklch[0] = percentToAbsolute(oklch[0], 0, 1);\n        oklch[1] = percentToAbsolute(noneToValue(oklch[1], 0), 0, 0.4, false);\n        oklch[2] = +noneToValue(oklch[2].replace('deg', ''), 0);\n        const rgb = roundRGB(oklch2rgb(oklch));\n        rgb[3] = m[4] !== undefined ? +m[4] : 1;\n        return rgb;\n    }\n};\n\ncss2rgb.test = (s) => {\n    return (\n        // modern\n        RE_RGB.test(s) ||\n        RE_RGBA.test(s) ||\n        RE_RGB_PCT.test(s) ||\n        RE_RGBA_PCT.test(s) ||\n        RE_HSL.test(s) ||\n        RE_HSLA.test(s) ||\n        RE_LAB.test(s) ||\n        RE_LCH.test(s) ||\n        RE_OKLAB.test(s) ||\n        RE_OKLCH.test(s) ||\n        // legacy\n        RE_RGB_LEGACY.test(s) ||\n        RE_RGBA_LEGACY.test(s) ||\n        RE_RGB_PCT_LEGACY.test(s) ||\n        RE_RGBA_PCT_LEGACY.test(s) ||\n        RE_HSL_LEGACY.test(s) ||\n        RE_HSLA_LEGACY.test(s)\n    );\n};\n\nColor.prototype.css = function (mode) {\n    return rgb2css(this._rgb, mode);\n};\n\nconst css = (...args) => new Color(...args, 'css');\nchroma.css = css;\n\ninput.format.css = css2rgb;\n\ninput.autodetect.push({\n    p: 5,\n    test: (h, ...rest) => {\n        if (!rest.length && type(h) === 'string' && css2rgb.test(h)) {\n            return 'css';\n        }\n    }\n});\n\ninput.format.gl = (...args) => {\n    const rgb = unpack(args, 'rgba');\n    rgb[0] *= 255;\n    rgb[1] *= 255;\n    rgb[2] *= 255;\n    return rgb;\n};\n\nconst gl = (...args) => new Color(...args, 'gl');\nchroma.gl = gl;\n\nColor.prototype.gl = function () {\n    const rgb = this._rgb;\n    return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, rgb[3]];\n};\n\nColor.prototype.hex = function (mode) {\n    return rgb2hex(this._rgb, mode);\n};\n\nconst hex = (...args) => new Color(...args, 'hex');\nchroma.hex = hex;\n\ninput.format.hex = hex2rgb;\ninput.autodetect.push({\n    p: 4,\n    test: (h, ...rest) => {\n        if (\n            !rest.length &&\n            type(h) === 'string' &&\n            [3, 4, 5, 6, 7, 8, 9].indexOf(h.length) >= 0\n        ) {\n            return 'hex';\n        }\n    }\n});\n\n/*\n * Based on implementation by Neil Bartlett\n * https://github.com/neilbartlett/color-temperature\n */\n\nconst { log } = Math;\n\nconst temperature2rgb = (kelvin) => {\n    const temp = kelvin / 100;\n    let r, g, b;\n    if (temp < 66) {\n        r = 255;\n        g =\n            temp < 6\n                ? 0\n                : -155.25485562709179 -\n                  0.44596950469579133 * (g = temp - 2) +\n                  104.49216199393888 * log(g);\n        b =\n            temp < 20\n                ? 0\n                : -254.76935184120902 +\n                  0.8274096064007395 * (b = temp - 10) +\n                  115.67994401066147 * log(b);\n    } else {\n        r =\n            351.97690566805693 +\n            0.114206453784165 * (r = temp - 55) -\n            40.25366309332127 * log(r);\n        g =\n            325.4494125711974 +\n            0.07943456536662342 * (g = temp - 50) -\n            28.0852963507957 * log(g);\n        b = 255;\n    }\n    return [r, g, b, 1];\n};\n\n/*\n * Based on implementation by Neil Bartlett\n * https://github.com/neilbartlett/color-temperature\n **/\n\nconst { round } = Math;\n\nconst rgb2temperature = (...args) => {\n    const rgb = unpack(args, 'rgb');\n    const r = rgb[0],\n        b = rgb[2];\n    let minTemp = 1000;\n    let maxTemp = 40000;\n    const eps = 0.4;\n    let temp;\n    while (maxTemp - minTemp > eps) {\n        temp = (maxTemp + minTemp) * 0.5;\n        const rgb = temperature2rgb(temp);\n        if (rgb[2] / rgb[0] >= b / r) {\n            maxTemp = temp;\n        } else {\n            minTemp = temp;\n        }\n    }\n    return round(temp);\n};\n\nColor.prototype.temp =\n    Color.prototype.kelvin =\n    Color.prototype.temperature =\n        function () {\n            return rgb2temperature(this._rgb);\n        };\n\nconst temp = (...args) => new Color(...args, 'temp');\nObject.assign(chroma, { temp, kelvin: temp, temperature: temp });\n\ninput.format.temp =\n    input.format.kelvin =\n    input.format.temperature =\n        temperature2rgb;\n\nColor.prototype.oklch = function () {\n    return rgb2oklch(this._rgb);\n};\n\nconst oklch = (...args) => new Color(...args, 'oklch');\nObject.assign(chroma, { oklch });\n\ninput.format.oklch = oklch2rgb;\n\ninput.autodetect.push({\n    p: 2,\n    test: (...args) => {\n        args = unpack(args, 'oklch');\n        if (type(args) === 'array' && args.length === 3) {\n            return 'oklch';\n        }\n    }\n});\n\n// feel free to comment out anything to rollup\n// a smaller chroma.js bundle\n\nObject.assign(chroma, {\n    analyze,\n    average,\n    bezier: bezier$1,\n    blend,\n    brewer: colorbrewer,\n    Color,\n    colors: w3cx11,\n    contrast,\n    cubehelix,\n    deltaE,\n    distance,\n    input,\n    interpolate: mix,\n    limits,\n    mix,\n    random: random$1,\n    scale,\n    scales,\n    valid\n});\n\nfunction replaceNaN(array) {\n    // fixes a NaN for 0 values in ChromaJS\n    array[0] = 0;\n    return array;\n}\nfunction convertToNamedObject(hsv) {\n    return {\n        hue: hsv[0],\n        saturation: hsv[1],\n        brightness: hsv[2],\n    };\n}\nfunction generateColorsWithLock(props, options, results) {\n    const lockHSV = isNaN(chroma.hex(`${options.lockHex}`).hsv()[0])\n        ? convertToNamedObject(replaceNaN(chroma.hex(`${options.lockHex}`).hsv()))\n        : convertToNamedObject(chroma.hex(`${options.lockHex}`).hsv());\n    let shortestDistance = 999999;\n    let lockedColor = {\n        hue: { step: 0, value: 0 },\n        saturation: { step: 0, value: 0 },\n        brightness: { step: 0, value: 0 },\n        step: 0,\n        isMajor: false,\n        isLocked: false\n    };\n    let lockedIndex;\n    const lastColor = results[results.length - 1];\n    results.forEach(function (color, index) {\n        const { hue, saturation, brightness } = color;\n        const hex = chroma.hsv(hue.value, saturation.value, brightness.value);\n        if (options.lockHex !== undefined) {\n            const distance = chroma.distance(hex, options.lockHex);\n            if (shortestDistance > distance) {\n                shortestDistance = distance;\n                lockedColor = color;\n                lockedIndex = index;\n            }\n        }\n    });\n    const difference = {\n        hue: lockHSV.hue - lockedColor.hue.value,\n        saturation: lockHSV.saturation - lockedColor.saturation.value,\n        brightness: lockHSV.brightness - lockedColor.brightness.value,\n    };\n    const adjustedColorSet = results.map(function (color, index) {\n        var _a, _b, _c;\n        if (index < lockedIndex) {\n            const hueDifference = distribute({\n                value: index,\n                rangeA: [0, lockedIndex],\n                rangeB: [0, difference.hue],\n            });\n            const saturationDifference = distribute({\n                value: index,\n                rangeA: [0, lockedIndex],\n                rangeB: [0, difference.saturation],\n            });\n            const brightnessDifference = distribute({\n                value: index,\n                rangeA: [0, lockedIndex],\n                rangeB: [0, difference.brightness],\n            });\n            return {\n                hue: {\n                    step: color.hue.step,\n                    value: color.hue.value + hueDifference > 0\n                        ? color.hue.value + hueDifference\n                        : 0,\n                },\n                saturation: {\n                    step: color.saturation.step,\n                    value: color.saturation.value + saturationDifference > 0\n                        ? color.saturation.value + saturationDifference\n                        : 0,\n                },\n                brightness: {\n                    step: color.brightness.step,\n                    value: color.brightness.value + brightnessDifference > 0\n                        ? color.brightness.value + brightnessDifference\n                        : 0,\n                },\n                step: color.step,\n                isMajor: color.isMajor,\n                isLocked: false,\n            };\n        }\n        else if (index === lockedIndex) {\n            return {\n                hue: { step: color.hue.step, value: lockHSV.hue },\n                saturation: { step: color.saturation.step, value: lockHSV.saturation },\n                brightness: { step: color.brightness.step, value: lockHSV.brightness },\n                step: color.step,\n                isMajor: color.isMajor,\n                isLocked: true,\n            };\n        }\n        else {\n            const hueDifference = distribute({\n                value: index,\n                rangeA: [lockedIndex, lastColor.step + (((_a = options === null || options === void 0 ? void 0 : options.minorSteps) === null || _a === void 0 ? void 0 : _a.length) || 0)],\n                rangeB: [difference.hue, 0],\n            });\n            const saturationDifference = distribute({\n                value: index,\n                rangeA: [lockedIndex, lastColor.step + (((_b = options === null || options === void 0 ? void 0 : options.minorSteps) === null || _b === void 0 ? void 0 : _b.length) || 0)],\n                rangeB: [difference.saturation, 0],\n            });\n            const brightnessDifference = distribute({\n                value: index,\n                rangeA: [lockedIndex, lastColor.step + (((_c = options === null || options === void 0 ? void 0 : options.minorSteps) === null || _c === void 0 ? void 0 : _c.length) || 0)],\n                rangeB: [difference.brightness, 0],\n            });\n            return {\n                hue: {\n                    step: color.hue.step,\n                    value: color.hue.value + hueDifference > 0 ||\n                        color.hue.value + hueDifference < 360\n                        ? color.hue.value + hueDifference\n                        : 0,\n                },\n                saturation: {\n                    step: color.saturation.step,\n                    value: color.saturation.value + saturationDifference < 1\n                        ? color.saturation.value + saturationDifference\n                        : 1,\n                },\n                brightness: {\n                    step: color.brightness.step,\n                    value: color.brightness.value + brightnessDifference < 1\n                        ? color.brightness.value + brightnessDifference\n                        : 1,\n                },\n                step: color.step,\n                isMajor: color.isMajor,\n                isLocked: false,\n            };\n        }\n    });\n    return adjustedColorSet;\n}\n\nfunction generate(props, options) {\n    if (options === undefined) {\n        options = {};\n    }\n    const { lockHex, lockHexInverted, provideInverted } = options;\n    const algorithmResult = [];\n    const generated = generateColors(props, options);\n    if (lockHex) {\n        algorithmResult.push(generateColorsWithLock(props, options, generated));\n    }\n    else {\n        algorithmResult.push(generated);\n    }\n    if (provideInverted) {\n        const generatedInverted = generateColors(props, options, true);\n        lockHexInverted === undefined\n            ? algorithmResult.push(generatedInverted)\n            : algorithmResult.push(generateColorsWithLock(props, options, generatedInverted));\n    }\n    return convertToColors(props, options, algorithmResult);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGstdnluL2NvbG9yYWxnb3JpdGhtL2Rpc3QvYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFlO0FBQ3hDLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNEQUFzRDtBQUN0RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLGlFQUFXO0FBQ3BDO0FBQ0E7QUFDQSwyQ0FBMkMsdURBQXVEO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxtQ0FBbUM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsRUFBRSxhQUFhLEVBQUU7QUFDakQsaUNBQWlDLEVBQUUsYUFBYSxFQUFFOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxJQUFJO0FBQzlDOztBQUVBLFFBQVEsaUJBQWlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsSUFBSSxFQUFFLElBQUk7QUFDakM7QUFDQSx1QkFBdUIsSUFBSSxFQUFFLElBQUk7QUFDakM7QUFDQSx1QkFBdUIsSUFBSTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksMEJBQTBCOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLCtEQUErRDtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksOERBQThEO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZ0RBQWdEOztBQUV4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsVUFBVSxLQUFLO0FBQ25FLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxhQUFhOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsUUFBUSx5QkFBeUI7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSwrQ0FBK0M7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsaUJBQWlCOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTLFVBQVUsS0FBSztBQUNuRSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxRQUFRLDJCQUEyQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixZQUFZOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxRQUFRLGlCQUFpQjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxRQUFRLGFBQWE7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsaUNBQWlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsUUFBUSxpQkFBaUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHlCQUF5Qjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGdCQUFnQjs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxRQUFRLDZFQUE2RTs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLFFBQVEsYUFBYTs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRyxvR0FBb0c7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDOztBQUU1Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGlCQUFpQjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0Esd0JBQXdCLEtBQUs7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUNBQXFDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFFBQVEseUJBQXlCOztBQUVqQztBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSw0Q0FBNEM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSw0REFBNEQ7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE1BQU07O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixNQUFNOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGNBQWMsa0JBQWtCLEdBQUcsZUFBZTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQzs7QUFFQSxRQUFRLGlCQUFpQjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCLEdBQUcsZ0RBQWdEO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGlCQUFpQjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE1BQU07O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxRQUFROztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qix1Q0FBdUM7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixPQUFPOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RCx3REFBd0QsZ0JBQWdCO0FBQ3hFLDZDQUE2QyxnQkFBZ0I7QUFDN0Q7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLHNCQUFzQixtQkFBbUI7QUFDekMsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUEwQztBQUNqRSw4QkFBOEIsd0RBQXdEO0FBQ3RGLDhCQUE4Qix3REFBd0Q7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQTRDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQiIsInNvdXJjZXMiOlsiL1VzZXJzL2RhdmlkZWJpc2N1c28vRG9jdW1lbnRzL0dpdEh1Yi9jb2xvci1yYW1wL25vZGVfbW9kdWxlcy9Aay12eW4vY29sb3JhbGdvcml0aG0vZGlzdC9idW5kbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gT3JpZ2luYWxseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rb2VuYm9rL0ZyYW1lci9ibG9iL21hc3Rlci9mcmFtZXIvVXRpbHMuY29mZmVlXG4vLyBUcmFuc2xhdGVkIHRvIFR5cGVzY3JpcHRcbmZ1bmN0aW9uIGRpc3RyaWJ1dGUoeyB2YWx1ZSwgcmFuZ2VBLCByYW5nZUIsIGxpbWl0LCB9KSB7XG4gICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGltaXQgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgW2Zyb21Mb3csIGZyb21IaWdoXSA9IEFycmF5LmZyb20ocmFuZ2VBKTtcbiAgICBjb25zdCBbdG9Mb3csIHRvSGlnaF0gPSBBcnJheS5mcm9tKHJhbmdlQik7XG4gICAgY29uc3QgcmVzdWx0ID0gdG9Mb3cgKyAoKHZhbHVlIC0gZnJvbUxvdykgLyAoZnJvbUhpZ2ggLSBmcm9tTG93KSkgKiAodG9IaWdoIC0gdG9Mb3cpO1xuICAgIGlmIChsaW1pdCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodG9Mb3cgPCB0b0hpZ2gpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPCB0b0xvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0xvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPiB0b0hpZ2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9IaWdoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA+IHRvTG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvTG93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA8IHRvSGlnaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0hpZ2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgYmV6aWVyJDIgPSByZXF1aXJlKFwiYmV6aWVyLWVhc2luZ1wiKTtcbmZ1bmN0aW9uIGdlbmVyYXRlTnVtYmVyT2ZTdGVwcyh7IGN1cnZlLCBzdGVwcywgfSkge1xuICAgIGNvbnN0IGFycmF5T2ZTdGVwcyA9IEFycmF5LmZyb20oQXJyYXkoc3RlcHMpLmtleXMoKSk7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yIChjb25zdCBzdGVwIGluIGFycmF5T2ZTdGVwcykge1xuICAgICAgICBjb25zdCBzdGVwTnVtYmVyID0gcGFyc2VJbnQoc3RlcCwgMTApO1xuICAgICAgICBjb25zdCBlYXNpbmcgPSBiZXppZXIkMiguLi5jdXJ2ZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZWFzaW5nKHN0ZXBOdW1iZXIgLyAoc3RlcHMgLSAxKSk7XG4gICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmNvbnN0IGRlZmF1bHRDdXJ2ZXMgPSB7XG4gICAgbGluZWFyOiB7XG4gICAgICAgIG5hbWU6IFwibGluZWFyXCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIkxpbmVhclwiLFxuICAgICAgICB2YWx1ZTogWzAuNSwgMC41LCAwLjUsIDAuNV0sXG4gICAgfSxcbiAgICBlYXNlSW5DdWJpYzoge1xuICAgICAgICBuYW1lOiBcImVhc2VJbkN1YmljXCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIkN1YmljIC0gRWFzZUluXCIsXG4gICAgICAgIHZhbHVlOiBbMC41NSwgMC4wNTUsIDAuNjc1LCAwLjE5XSxcbiAgICB9LFxuICAgIGVhc2VPdXRDdWJpYzoge1xuICAgICAgICBuYW1lOiBcImVhc2VPdXRDdWJpY1wiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJDdWJpYyAtIEVhc2VPdXRcIixcbiAgICAgICAgdmFsdWU6IFswLjIxNSwgMC42MSwgMC4zNTUsIDFdLFxuICAgIH0sXG4gICAgZWFzZUluT3V0Q3ViaWM6IHtcbiAgICAgICAgbmFtZTogXCJlYXNlSW5PdXRDdWJpY1wiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJDdWJpYyAtIEVhc2VJbk91dFwiLFxuICAgICAgICB2YWx1ZTogWzAuNjQ1LCAwLjA0NSwgMC4zNTUsIDFdLFxuICAgIH0sXG4gICAgZWFzZUluU2luZToge1xuICAgICAgICBuYW1lOiBcImVhc2VJblNpbmVcIixcbiAgICAgICAgZm9ybWF0dGVkX25hbWU6IFwiU2luZSAtIEVhc2VJblwiLFxuICAgICAgICB2YWx1ZTogWzAuNDcsIDAsIDAuNzQ1LCAwLjcxNV0sXG4gICAgfSxcbiAgICBlYXNlT3V0U2luZToge1xuICAgICAgICBuYW1lOiBcImVhc2VPdXRTaW5lXCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIlNpbmUgLSBFYXNlT3V0XCIsXG4gICAgICAgIHZhbHVlOiBbMC4zOSwgMC41NzUsIDAuNTY1LCAxXSxcbiAgICB9LFxuICAgIGVhc2VJbk91dFNpbmU6IHtcbiAgICAgICAgbmFtZTogXCJlYXNlSW5PdXRTaW5lXCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIlNpbmUgLSBFYXNlSW5PdXRcIixcbiAgICAgICAgdmFsdWU6IFswLjQ0NSwgMC4wNSwgMC41NSwgMC45NV0sXG4gICAgfSxcbiAgICBlYXNlSW5RdWFkOiB7XG4gICAgICAgIG5hbWU6IFwiZWFzZUluUXVhZFwiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJRdWFkIC0gRWFzZUluXCIsXG4gICAgICAgIHZhbHVlOiBbMC41NSwgMC4wODUsIDAuNjgsIDAuNTNdLFxuICAgIH0sXG4gICAgZWFzZU91dFF1YWQ6IHtcbiAgICAgICAgbmFtZTogXCJlYXNlT3V0UXVhZFwiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJRdWFkIC0gRWFzZU91dFwiLFxuICAgICAgICB2YWx1ZTogWzAuMjUsIDAuNDYsIDAuNDUsIDAuOTRdLFxuICAgIH0sXG4gICAgZWFzZUluT3V0UXVhZDoge1xuICAgICAgICBuYW1lOiBcImVhc2VJbk91dFF1YWRcIixcbiAgICAgICAgZm9ybWF0dGVkX25hbWU6IFwiUXVhZCAtIEVhc2VJbk91dFwiLFxuICAgICAgICB2YWx1ZTogWzAuNDU1LCAwLjAzLCAwLjUxNSwgMC45NTVdLFxuICAgIH0sXG4gICAgZWFzZUluUXVhcnQ6IHtcbiAgICAgICAgbmFtZTogXCJlYXNlSW5RdWFydFwiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJRdWFydCAtIEVhc2VJblwiLFxuICAgICAgICB2YWx1ZTogWzAuODk1LCAwLjAzLCAwLjY4NSwgMC4yMl0sXG4gICAgfSxcbiAgICBlYXNlT3V0UXVhcnQ6IHtcbiAgICAgICAgbmFtZTogXCJlYXNlT3V0UXVhcnRcIixcbiAgICAgICAgZm9ybWF0dGVkX25hbWU6IFwiUXVhcnQgLSBFYXNlT3V0XCIsXG4gICAgICAgIHZhbHVlOiBbMC4xNjUsIDAuODQsIDAuNDQsIDFdLFxuICAgIH0sXG4gICAgZWFzZUluT3V0UXVhcnQ6IHtcbiAgICAgICAgbmFtZTogXCJlYXNlSW5PdXRRdWFydFwiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJRdWFydCAtIEVhc2VJbk91dFwiLFxuICAgICAgICB2YWx1ZTogWzAuNzcsIDAsIDAuMTc1LCAxXSxcbiAgICB9LFxuICAgIGVhc2VJblF1aW50OiB7XG4gICAgICAgIG5hbWU6IFwiZWFzZUluUXVpbnRcIixcbiAgICAgICAgZm9ybWF0dGVkX25hbWU6IFwiUXVpbnQgLSBFYXNlSW5cIixcbiAgICAgICAgdmFsdWU6IFswLjc1NSwgMC4wNSwgMC44NTUsIDAuMDZdLFxuICAgIH0sXG4gICAgZWFzZU91dFF1aW50OiB7XG4gICAgICAgIG5hbWU6IFwiZWFzZU91dFF1aW50XCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIlF1aW50IC0gRWFzZU91dFwiLFxuICAgICAgICB2YWx1ZTogWzAuMjMsIDEsIDAuMzIsIDFdLFxuICAgIH0sXG4gICAgZWFzZUluT3V0UXVpbnQ6IHtcbiAgICAgICAgbmFtZTogXCJlYXNlSW5PdXRRdWludFwiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJRdWludCAtIEVhc2VJbk91dFwiLFxuICAgICAgICB2YWx1ZTogWzAuODYsIDAsIDAuMDcsIDFdLFxuICAgIH0sXG4gICAgZWFzZUluQ2lyYzoge1xuICAgICAgICBuYW1lOiBcImVhc2VJbkNpcmNcIixcbiAgICAgICAgZm9ybWF0dGVkX25hbWU6IFwiQ2lyYyAtIEVhc2VJblwiLFxuICAgICAgICB2YWx1ZTogWzAuNiwgMC4wNCwgMC45OCwgMC4zMzVdLFxuICAgIH0sXG4gICAgZWFzZU91dENpcmM6IHtcbiAgICAgICAgbmFtZTogXCJlYXNlT3V0Q2lyY1wiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJDaXJjIC0gRWFzZU91dFwiLFxuICAgICAgICB2YWx1ZTogWzAuMDc1LCAwLjgyLCAwLjE2NSwgMV0sXG4gICAgfSxcbiAgICBlYXNlSW5PdXRDaXJjOiB7XG4gICAgICAgIG5hbWU6IFwiZWFzZUluT3V0Q2lyY1wiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJDaXJjIC0gRWFzZUluT3V0XCIsXG4gICAgICAgIHZhbHVlOiBbMC43ODUsIDAuMTM1LCAwLjE1LCAwLjg2XSxcbiAgICB9LFxuICAgIGVhc2VJbkV4cG86IHtcbiAgICAgICAgbmFtZTogXCJlYXNlSW5FeHBvXCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIkV4cG8gLSBFYXNlSW5cIixcbiAgICAgICAgdmFsdWU6IFswLjk1LCAwLjA1LCAwLjc5NSwgMC4wMzVdLFxuICAgIH0sXG4gICAgZWFzZU91dEV4cG86IHtcbiAgICAgICAgbmFtZTogXCJlYXNlT3V0RXhwb1wiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJFeHBvIC0gRWFzZU91dFwiLFxuICAgICAgICB2YWx1ZTogWzAuMTksIDEsIDAuMjIsIDFdLFxuICAgIH0sXG4gICAgZWFzZUluT3V0RXhwbzoge1xuICAgICAgICBuYW1lOiBcImVhc2VJbk91dEV4cG9cIixcbiAgICAgICAgZm9ybWF0dGVkX25hbWU6IFwiRXhwbyAtIEVhc2VJbk91dFwiLFxuICAgICAgICB2YWx1ZTogWzEsIDAsIDAsIDFdLFxuICAgIH0sXG4gICAgZWFzZUluQmFjazoge1xuICAgICAgICBuYW1lOiBcImVhc2VJbkJhY2tcIixcbiAgICAgICAgZm9ybWF0dGVkX25hbWU6IFwiQmFjayAtIEVhc2VJblwiLFxuICAgICAgICB2YWx1ZTogWzAuNiwgLTAuMjgsIDAuNzM1LCAwLjA0NV0sXG4gICAgfSxcbiAgICBlYXNlT3V0QmFjazoge1xuICAgICAgICBuYW1lOiBcImVhc2VPdXRCYWNrXCIsXG4gICAgICAgIGZvcm1hdHRlZF9uYW1lOiBcIkJhY2sgLSBFYXNlT3V0XCIsXG4gICAgICAgIHZhbHVlOiBbMC4xNzUsIDAuODg1LCAwLjMyLCAxLjI3NV0sXG4gICAgfSxcbiAgICBlYXNlSW5PdXRCYWNrOiB7XG4gICAgICAgIG5hbWU6IFwiZWFzZUluT3V0QmFja1wiLFxuICAgICAgICBmb3JtYXR0ZWRfbmFtZTogXCJCYWNrIC0gRWFzZUluT3V0XCIsXG4gICAgICAgIHZhbHVlOiBbMC42OCwgLTAuNTUsIDAuMjY1LCAxLjU1XSxcbiAgICB9LFxufTtcblxuZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMoY3VydmUsIGludmVydCkge1xuICAgIGlmICh0eXBlb2YgY3VydmUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBkZWZhdWx0Q3VydmVzW2N1cnZlXTtcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gaW52ZXJ0ID09PSB0cnVlXG4gICAgICAgICAgICAgICAgPyBjb29yZGluYXRlcy52YWx1ZS5zbGljZSgpLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgIDogY29vcmRpbmF0ZXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcInByb3ZpZGVkIGluY29ycmVjdCBjdXJ2ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGN1cnZlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChjdXJ2ZS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIGlmICghY3VydmUuc29tZShpc05hTikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VydmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImluY29tcGF0aWJsZSBjdXJ2ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiY3VydmUgaXMgbmVpdGhlciBhIHN0cmluZyBvciBhIGNvbXBhdGlibGUgYXJyYXlcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJjdXJ2ZSB3YXMgbmVpdGhlciBhIHN0cmluZyBvciBhbiBvYmplY3RcIik7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29sb3JzKHByb3BzLCBvcHRpb25zLCBpbnZlcnQpIHtcbiAgICBjb25zdCB7IHN0ZXBzLCBodWUsIHNhdHVyYXRpb24sIGJyaWdodG5lc3MgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgbWlub3JTdGVwcyB9ID0gb3B0aW9ucztcbiAgICAvLyBkZWZhdWx0IHJvdGF0aW9uIGlzIGNsb2Nrd2lzZVxuICAgIGNvbnN0IHJvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvbiA9PT0gXCJjb3VudGVyY2xvY2t3aXNlXCIgfHwgb3B0aW9ucy5yb3RhdGlvbiA9PT0gXCJjY3dcIlxuICAgICAgICA/IFwiY2N3XCJcbiAgICAgICAgOiBcImN3XCI7XG4gICAgLy8gZ2VuZXJhdGUgc3RlcHMgMCB0byAxIGJhc2VkIG9uIGN1cnZlXG4gICAgY29uc3QgaHVlU3RlcHMgPSBnZW5lcmF0ZU51bWJlck9mU3RlcHMoe1xuICAgICAgICBjdXJ2ZTogZ2V0Q29vcmRpbmF0ZXMoaHVlLmN1cnZlLCBpbnZlcnQpLFxuICAgICAgICBzdGVwcyxcbiAgICB9KTtcbiAgICBjb25zdCBzYXR1cmF0aW9uU3RlcHMgPSBnZW5lcmF0ZU51bWJlck9mU3RlcHMoe1xuICAgICAgICBjdXJ2ZTogZ2V0Q29vcmRpbmF0ZXMoc2F0dXJhdGlvbi5jdXJ2ZSwgaW52ZXJ0KSxcbiAgICAgICAgc3RlcHMsXG4gICAgfSk7XG4gICAgY29uc3QgYnJpZ2h0bmVzc1N0ZXBzID0gZ2VuZXJhdGVOdW1iZXJPZlN0ZXBzKHtcbiAgICAgICAgY3VydmU6IGdldENvb3JkaW5hdGVzKGJyaWdodG5lc3MuY3VydmUsIGludmVydCksXG4gICAgICAgIHN0ZXBzLFxuICAgIH0pO1xuICAgIC8vIGFkanVzdCBodWUgc3RhcnQvZW5kIHRvIGdldCB0aGUgaW50ZW5kZWQgcm90YXRpb25cbiAgICBpZiAocm90YXRpb24gPT09IFwiY3dcIikge1xuICAgICAgICBpZiAoaHVlLnN0YXJ0ID4gaHVlLmVuZCkge1xuICAgICAgICAgICAgaHVlLnN0YXJ0IC09IDM2MDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyb3RhdGlvbiA9PT0gXCJjY3dcIikge1xuICAgICAgICBpZiAoaHVlLmVuZCA+IGh1ZS5zdGFydCkge1xuICAgICAgICAgICAgaHVlLmVuZCAtPSAzNjA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRGlzdHJpYnV0ZSB0aGUgZ2VuZXJhdGVkIHN0ZXBzIGJldHdlZW4gaHVlLCBzYXR1cmF0aW9uLCBicmlnaHRuZXNzIHJhbmdlc1xuICAgIGNvbnN0IGh1ZVZhbHVlcyA9IGh1ZVN0ZXBzLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gZGlzdHJpYnV0ZSh7XG4gICAgICAgICAgICB2YWx1ZTogcyxcbiAgICAgICAgICAgIHJhbmdlQTogWzAsIDFdLFxuICAgICAgICAgICAgcmFuZ2VCOiBbXG4gICAgICAgICAgICAgICAgaW52ZXJ0ID09PSB0cnVlID8gaHVlLmVuZCA6IGh1ZS5zdGFydCxcbiAgICAgICAgICAgICAgICBpbnZlcnQgPT09IHRydWUgPyBodWUuc3RhcnQgOiBodWUuZW5kLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGxpbWl0OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBzYXR1cmF0aW9uVmFsdWVzID0gc2F0dXJhdGlvblN0ZXBzLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRpc3RyaWJ1dGUoe1xuICAgICAgICAgICAgdmFsdWU6IHMsXG4gICAgICAgICAgICByYW5nZUE6IFswLCAxXSxcbiAgICAgICAgICAgIHJhbmdlQjogW1xuICAgICAgICAgICAgICAgIGludmVydCA9PT0gdHJ1ZSA/IHNhdHVyYXRpb24uZW5kIDogc2F0dXJhdGlvbi5zdGFydCxcbiAgICAgICAgICAgICAgICBpbnZlcnQgPT09IHRydWUgPyBzYXR1cmF0aW9uLnN0YXJ0IDogc2F0dXJhdGlvbi5lbmQsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbGltaXQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB2YWx1ZVdpdGhSYXRlID0gdmFsdWUgKiBzYXR1cmF0aW9uLnJhdGU7XG4gICAgICAgIHJldHVybiB2YWx1ZVdpdGhSYXRlIDwgMSA/IHZhbHVlV2l0aFJhdGUgOiAxOyAvLyBwcmV2ZW50IHRvbyBtdWNoIHNhdHVhcnRpb24gc2F0dXJhdGlvblxuICAgIH0pO1xuICAgIGNvbnN0IGJyaWdodG5lc3NWYWx1ZXMgPSBicmlnaHRuZXNzU3RlcHMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBkaXN0cmlidXRlKHtcbiAgICAgICAgICAgIHZhbHVlOiBzLFxuICAgICAgICAgICAgcmFuZ2VBOiBbMCwgMV0sXG4gICAgICAgICAgICByYW5nZUI6IFtcbiAgICAgICAgICAgICAgICBpbnZlcnQgPT09IHRydWUgPyBicmlnaHRuZXNzLmVuZCA6IGJyaWdodG5lc3Muc3RhcnQsXG4gICAgICAgICAgICAgICAgaW52ZXJ0ID09PSB0cnVlID8gYnJpZ2h0bmVzcy5zdGFydCA6IGJyaWdodG5lc3MuZW5kLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gTWVyZ2UgdmFsdWVzIGludG8gY29sb3Igc3RlcHNcbiAgICBjb25zdCBjb2xvclN0ZXBzID0gaHVlVmFsdWVzLm1hcChmdW5jdGlvbiAoaHVlLCBpKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB7XG4gICAgICAgICAgICBodWU6IHtcbiAgICAgICAgICAgICAgICBzdGVwOiBodWVTdGVwc1tpXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaHVlVmFsdWVzW2ldLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhdHVyYXRpb246IHtcbiAgICAgICAgICAgICAgICBzdGVwOiBzYXR1cmF0aW9uU3RlcHNbaV0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHNhdHVyYXRpb25WYWx1ZXNbaV0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnJpZ2h0bmVzczoge1xuICAgICAgICAgICAgICAgIHN0ZXA6IGJyaWdodG5lc3NTdGVwc1tpXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYnJpZ2h0bmVzc1ZhbHVlc1tpXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGVwOiBpLFxuICAgICAgICAgICAgaXNNYWpvcjogdHJ1ZSxcbiAgICAgICAgICAgIGlzTG9ja2VkOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfSk7XG4gICAgLy8gZ2VuZXJhdGUgbWlub3Igc3RlcHNcbiAgICBpZiAobWlub3JTdGVwcykge1xuICAgICAgICBtaW5vclN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKG8sIGkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRTdGVwID0ge1xuICAgICAgICAgICAgICAgIGh1ZToge1xuICAgICAgICAgICAgICAgICAgICBzdGVwOiAwLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNhdHVyYXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogMCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBicmlnaHRuZXNzOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IDAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNNYWpvcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0xvY2tlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3RlcDogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgaW5zZXJ0UHJldmlvdXNTdGVwID0gZGVmYXVsdFN0ZXA7XG4gICAgICAgICAgICBsZXQgaW5zZXJ0TmV4dFN0ZXAgPSBkZWZhdWx0U3RlcDtcbiAgICAgICAgICAgIGxldCBpbnNlcnRBdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGNvbG9yU3RlcHMuZm9yRWFjaChmdW5jdGlvbiAocCwgaikge1xuICAgICAgICAgICAgICAgIGlmIChvID09PSBwLnN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QXRJbmRleCA9IGogKyAxO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRQcmV2aW91c1N0ZXAgPSBwO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnROZXh0U3RlcCA9IGNvbG9yU3RlcHNbaiArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaHVlU3RlcCA9IChpbnNlcnRQcmV2aW91c1N0ZXAuaHVlLnN0ZXAgKyBpbnNlcnROZXh0U3RlcC5odWUuc3RlcCkgLyAyO1xuICAgICAgICAgICAgY29uc3QgaHVlVmFsdWUgPSBkaXN0cmlidXRlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaHVlU3RlcCxcbiAgICAgICAgICAgICAgICByYW5nZUE6IFswLCAxXSxcbiAgICAgICAgICAgICAgICByYW5nZUI6IFtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJ0ID09PSB0cnVlID8gaHVlLmVuZCA6IGh1ZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJ0ID09PSB0cnVlID8gaHVlLnN0YXJ0IDogaHVlLmVuZCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzYXR1cmF0aW9uU3RlcCA9IChpbnNlcnRQcmV2aW91c1N0ZXAuc2F0dXJhdGlvbi5zdGVwICsgaW5zZXJ0TmV4dFN0ZXAuc2F0dXJhdGlvbi5zdGVwKSAvXG4gICAgICAgICAgICAgICAgMjtcbiAgICAgICAgICAgIGxldCBzYXR1cmF0aW9uVmFsdWUgPSBkaXN0cmlidXRlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2F0dXJhdGlvblN0ZXAsXG4gICAgICAgICAgICAgICAgcmFuZ2VBOiBbMCwgMV0sXG4gICAgICAgICAgICAgICAgcmFuZ2VCOiBbXG4gICAgICAgICAgICAgICAgICAgIGludmVydCA9PT0gdHJ1ZSA/IHNhdHVyYXRpb24uZW5kIDogc2F0dXJhdGlvbi5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJ0ID09PSB0cnVlID8gc2F0dXJhdGlvbi5zdGFydCA6IHNhdHVyYXRpb24uZW5kLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KSAqIHNhdHVyYXRpb24ucmF0ZTtcbiAgICAgICAgICAgIHNhdHVyYXRpb25WYWx1ZSA9IHNhdHVyYXRpb25WYWx1ZSA8IDEgPyBzYXR1cmF0aW9uVmFsdWUgOiAxO1xuICAgICAgICAgICAgY29uc3QgYnJpZ2h0bmVzc1N0ZXAgPSAoaW5zZXJ0UHJldmlvdXNTdGVwLmJyaWdodG5lc3Muc3RlcCArIGluc2VydE5leHRTdGVwLmJyaWdodG5lc3Muc3RlcCkgL1xuICAgICAgICAgICAgICAgIDI7XG4gICAgICAgICAgICBjb25zdCBicmlnaHRuZXNzVmFsdWUgPSBkaXN0cmlidXRlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogYnJpZ2h0bmVzc1N0ZXAsXG4gICAgICAgICAgICAgICAgcmFuZ2VBOiBbMCwgMV0sXG4gICAgICAgICAgICAgICAgcmFuZ2VCOiBbXG4gICAgICAgICAgICAgICAgICAgIGludmVydCA9PT0gdHJ1ZSA/IGJyaWdodG5lc3MuZW5kIDogYnJpZ2h0bmVzcy5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJ0ID09PSB0cnVlID8gYnJpZ2h0bmVzcy5zdGFydCA6IGJyaWdodG5lc3MuZW5kLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbnNlcnRBdEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICBodWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IGh1ZVN0ZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaHVlVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNhdHVyYXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IHNhdHVyYXRpb25TdGVwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNhdHVyYXRpb25WYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYnJpZ2h0bmVzczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogYnJpZ2h0bmVzc1N0ZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYnJpZ2h0bmVzc1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpc0xvY2tlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGlzTWFqb3I6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzdGVwOiAoaW5zZXJ0UHJldmlvdXNTdGVwLnN0ZXAgKyBpbnNlcnROZXh0U3RlcC5zdGVwKSAvIDIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb2xvclN0ZXBzLnNwbGljZShpbnNlcnRBdEluZGV4LCAwLCBpbnNlcnRJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb2xvclN0ZXBzO1xufVxuXG5jb25zdCBjaHJvbWEkMSA9IHJlcXVpcmUoXCJjaHJvbWEtanNcIik7XG5mdW5jdGlvbiBjb252ZXJ0VG9Db2xvcnMocHJvcHMsIG9wdGlvbnMsIGFsZ29yaXRobVJlc3VsdCkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhbGdvcml0aG1SZXN1bHQubWFwKGZ1bmN0aW9uIChzZXQsIGkpIHtcbiAgICAgICAgY29uc3QgY29sb3JzID0gc2V0Lm1hcChmdW5jdGlvbiAoeyBodWUsIHNhdHVyYXRpb24sIGJyaWdodG5lc3MsIGlzTWFqb3IsIGlzTG9ja2VkLCBzdGVwLCB9KSB7XG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IGNocm9tYSQxLmhzdihodWUudmFsdWUsIHNhdHVyYXRpb24udmFsdWUsIGJyaWdodG5lc3MudmFsdWUpO1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVwbGFjZU5hTihhcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIGZpeGVzIGEgTmFOIGZvciAwIHZhbHVlcyBpbiBDaHJvbWFKU1xuICAgICAgICAgICAgICAgIGFycmF5WzBdID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRDb2xvciA9IHtcbiAgICAgICAgICAgICAgICBzdGVwLFxuICAgICAgICAgICAgICAgIGh1ZTogaHVlLnZhbHVlLFxuICAgICAgICAgICAgICAgIHNhdHVyYXRpb246IHNhdHVyYXRpb24udmFsdWUsXG4gICAgICAgICAgICAgICAgYnJpZ2h0bmVzczogYnJpZ2h0bmVzcy52YWx1ZSxcbiAgICAgICAgICAgICAgICBpc01ham9yLFxuICAgICAgICAgICAgICAgIGlzTG9ja2VkLFxuICAgICAgICAgICAgICAgIGhleDogY29sb3IuaGV4KCksXG4gICAgICAgICAgICAgICAgaHNsOiBpc05hTihjb2xvci5oc2woKVswXSkgPyByZXBsYWNlTmFOKGNvbG9yLmhzbCgpKSA6IGNvbG9yLmhzbCgpLFxuICAgICAgICAgICAgICAgIGhzdjogaXNOYU4oY29sb3IuaHN2KClbMF0pID8gcmVwbGFjZU5hTihjb2xvci5oc3YoKSkgOiBjb2xvci5oc3YoKSxcbiAgICAgICAgICAgICAgICBsYWI6IGlzTmFOKGNvbG9yLmxhYigpWzBdKSA/IHJlcGxhY2VOYU4oY29sb3IubGFiKCkpIDogY29sb3IubGFiKCksXG4gICAgICAgICAgICAgICAgcmdiU3RyaW5nOiBjb2xvci5yZ2IoKS5qb2luKCksXG4gICAgICAgICAgICAgICAgcmdiQXJyYXk6IGNvbG9yLnJnYigpLFxuICAgICAgICAgICAgICAgIHJnYmFTdHJpbmc6IGNvbG9yLnJnYmEoKS5qb2luKCksXG4gICAgICAgICAgICAgICAgcmdiYUFycmF5OiBjb2xvci5yZ2JhKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRlZENvbG9yO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludmVydGVkOiBpID4gMCA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbG9yczogY29sb3JzLFxuICAgICAgICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG52YXIgbGltaXQgPSAoeCwgbG93ID0gMCwgaGlnaCA9IDEpID0+IHtcbiAgICByZXR1cm4gbWluJDMobWF4JDMobG93LCB4KSwgaGlnaCk7XG59O1xuXG52YXIgY2xpcF9yZ2IgPSAocmdiKSA9PiB7XG4gICAgcmdiLl9jbGlwcGVkID0gZmFsc2U7XG4gICAgcmdiLl91bmNsaXBwZWQgPSByZ2Iuc2xpY2UoMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMzsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgMykge1xuICAgICAgICAgICAgaWYgKHJnYltpXSA8IDAgfHwgcmdiW2ldID4gMjU1KSByZ2IuX2NsaXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmdiW2ldID0gbGltaXQocmdiW2ldLCAwLCAyNTUpO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDMpIHtcbiAgICAgICAgICAgIHJnYltpXSA9IGxpbWl0KHJnYltpXSwgMCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJnYjtcbn07XG5cbi8vIHBvcnRlZCBmcm9tIGpRdWVyeSdzICQudHlwZVxuY29uc3QgY2xhc3NUb1R5cGUgPSB7fTtcbmZvciAobGV0IG5hbWUgb2YgW1xuICAgICdCb29sZWFuJyxcbiAgICAnTnVtYmVyJyxcbiAgICAnU3RyaW5nJyxcbiAgICAnRnVuY3Rpb24nLFxuICAgICdBcnJheScsXG4gICAgJ0RhdGUnLFxuICAgICdSZWdFeHAnLFxuICAgICdVbmRlZmluZWQnLFxuICAgICdOdWxsJ1xuXSkge1xuICAgIGNsYXNzVG9UeXBlW2Bbb2JqZWN0ICR7bmFtZX1dYF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiB0eXBlIChvYmopIHtcbiAgICByZXR1cm4gY2xhc3NUb1R5cGVbT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaildIHx8ICdvYmplY3QnO1xufVxuXG52YXIgdW5wYWNrID0gKGFyZ3MsIGtleU9yZGVyID0gbnVsbCkgPT4ge1xuICAgIC8vIGlmIGNhbGxlZCB3aXRoIG1vcmUgdGhhbiAzIGFyZ3VtZW50cywgd2UgcmV0dXJuIHRoZSBhcmd1bWVudHNcbiAgICBpZiAoYXJncy5sZW5ndGggPj0gMykgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuICAgIC8vIHdpdGggbGVzcyB0aGFuIDMgYXJncyB3ZSBjaGVjayBpZiBmaXJzdCBhcmcgaXMgb2JqZWN0XG4gICAgLy8gYW5kIHVzZSB0aGUga2V5T3JkZXIgc3RyaW5nIHRvIGV4dHJhY3QgYW5kIHNvcnQgcHJvcGVydGllc1xuICAgIGlmICh0eXBlKGFyZ3NbMF0pID09ICdvYmplY3QnICYmIGtleU9yZGVyKSB7XG4gICAgICAgIHJldHVybiBrZXlPcmRlclxuICAgICAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAgICAgLmZpbHRlcigoaykgPT4gYXJnc1swXVtrXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgLm1hcCgoaykgPT4gYXJnc1swXVtrXSk7XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSB3ZSBqdXN0IHJldHVybiB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAvLyAod2hpY2ggd2Ugc3VwcG9zZSBpcyBhbiBhcnJheSBvZiBhcmdzKVxuICAgIHJldHVybiBhcmdzWzBdLnNsaWNlKDApO1xufTtcblxudmFyIGxhc3QgPSAoYXJncykgPT4ge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGwgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgaWYgKHR5cGUoYXJnc1tsXSkgPT0gJ3N0cmluZycpIHJldHVybiBhcmdzW2xdLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCB7IFBJOiBQSSQyLCBtaW46IG1pbiQzLCBtYXg6IG1heCQzIH0gPSBNYXRoO1xuXG5jb25zdCBybmQyID0gKGEpID0+IE1hdGgucm91bmQoYSAqIDEwMCkgLyAxMDA7XG5jb25zdCBybmQzID0gKGEpID0+IE1hdGgucm91bmQoYSAqIDEwMCkgLyAxMDA7XG5cbmNvbnN0IFRXT1BJID0gUEkkMiAqIDI7XG5jb25zdCBQSVRISVJEID0gUEkkMiAvIDM7XG5jb25zdCBERUcyUkFEID0gUEkkMiAvIDE4MDtcbmNvbnN0IFJBRDJERUcgPSAxODAgLyBQSSQyO1xuXG52YXIgaW5wdXQgPSB7XG4gICAgZm9ybWF0OiB7fSxcbiAgICBhdXRvZGV0ZWN0OiBbXVxufTtcblxuY2xhc3MgQ29sb3Ige1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlKGFyZ3NbMF0pID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgYXJnc1swXS5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgYXJnc1swXS5jb25zdHJ1Y3RvciA9PT0gdGhpcy5jb25zdHJ1Y3RvclxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIHRoZSBhcmd1bWVudCBpcyBhbHJlYWR5IGEgQ29sb3IgaW5zdGFuY2VcbiAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxhc3QgYXJndW1lbnQgY291bGQgYmUgdGhlIG1vZGVcbiAgICAgICAgbGV0IG1vZGUgPSBsYXN0KGFyZ3MpO1xuICAgICAgICBsZXQgYXV0b2RldGVjdCA9IGZhbHNlO1xuICAgICAgICBpZiAoIW1vZGUpIHtcbiAgICAgICAgICAgIGF1dG9kZXRlY3QgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIWlucHV0LnNvcnRlZCkge1xuICAgICAgICAgICAgICAgIGlucHV0LmF1dG9kZXRlY3QgPSBpbnB1dC5hdXRvZGV0ZWN0LnNvcnQoKGEsIGIpID0+IGIucCAtIGEucCk7XG4gICAgICAgICAgICAgICAgaW5wdXQuc29ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYXV0by1kZXRlY3QgZm9ybWF0XG4gICAgICAgICAgICBmb3IgKGxldCBjaGsgb2YgaW5wdXQuYXV0b2RldGVjdCkge1xuICAgICAgICAgICAgICAgIG1vZGUgPSBjaGsudGVzdCguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LmZvcm1hdFttb2RlXSkge1xuICAgICAgICAgICAgY29uc3QgcmdiID0gaW5wdXQuZm9ybWF0W21vZGVdLmFwcGx5KFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgYXV0b2RldGVjdCA/IGFyZ3MgOiBhcmdzLnNsaWNlKDAsIC0xKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1lLl9yZ2IgPSBjbGlwX3JnYihyZ2IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGZvcm1hdDogJyArIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBhbHBoYSBjaGFubmVsXG4gICAgICAgIGlmIChtZS5fcmdiLmxlbmd0aCA9PT0gMykgbWUuX3JnYi5wdXNoKDEpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHR5cGUodGhpcy5oZXgpID09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmhleCgpO1xuICAgICAgICByZXR1cm4gYFske3RoaXMuX3JnYi5qb2luKCcsJyl9XWA7XG4gICAgfVxufVxuXG4vLyB0aGlzIGdldHMgdXBkYXRlZCBhdXRvbWF0aWNhbGx5XG5jb25zdCB2ZXJzaW9uID0gJzMuMC4wJztcblxuY29uc3QgY2hyb21hID0gKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gbmV3IENvbG9yKC4uLmFyZ3MpO1xufTtcblxuY2hyb21hLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4vKipcblx0WDExIGNvbG9yIG5hbWVzXG5cblx0aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jc3ZnLWNvbG9yXG4qL1xuXG5jb25zdCB3M2N4MTEgPSB7XG4gICAgYWxpY2VibHVlOiAnI2YwZjhmZicsXG4gICAgYW50aXF1ZXdoaXRlOiAnI2ZhZWJkNycsXG4gICAgYXF1YTogJyMwMGZmZmYnLFxuICAgIGFxdWFtYXJpbmU6ICcjN2ZmZmQ0JyxcbiAgICBhenVyZTogJyNmMGZmZmYnLFxuICAgIGJlaWdlOiAnI2Y1ZjVkYycsXG4gICAgYmlzcXVlOiAnI2ZmZTRjNCcsXG4gICAgYmxhY2s6ICcjMDAwMDAwJyxcbiAgICBibGFuY2hlZGFsbW9uZDogJyNmZmViY2QnLFxuICAgIGJsdWU6ICcjMDAwMGZmJyxcbiAgICBibHVldmlvbGV0OiAnIzhhMmJlMicsXG4gICAgYnJvd246ICcjYTUyYTJhJyxcbiAgICBidXJseXdvb2Q6ICcjZGViODg3JyxcbiAgICBjYWRldGJsdWU6ICcjNWY5ZWEwJyxcbiAgICBjaGFydHJldXNlOiAnIzdmZmYwMCcsXG4gICAgY2hvY29sYXRlOiAnI2QyNjkxZScsXG4gICAgY29yYWw6ICcjZmY3ZjUwJyxcbiAgICBjb3JuZmxvd2VyYmx1ZTogJyM2NDk1ZWQnLFxuICAgIGNvcm5zaWxrOiAnI2ZmZjhkYycsXG4gICAgY3JpbXNvbjogJyNkYzE0M2MnLFxuICAgIGN5YW46ICcjMDBmZmZmJyxcbiAgICBkYXJrYmx1ZTogJyMwMDAwOGInLFxuICAgIGRhcmtjeWFuOiAnIzAwOGI4YicsXG4gICAgZGFya2dvbGRlbnJvZDogJyNiODg2MGInLFxuICAgIGRhcmtncmF5OiAnI2E5YTlhOScsXG4gICAgZGFya2dyZWVuOiAnIzAwNjQwMCcsXG4gICAgZGFya2dyZXk6ICcjYTlhOWE5JyxcbiAgICBkYXJra2hha2k6ICcjYmRiNzZiJyxcbiAgICBkYXJrbWFnZW50YTogJyM4YjAwOGInLFxuICAgIGRhcmtvbGl2ZWdyZWVuOiAnIzU1NmIyZicsXG4gICAgZGFya29yYW5nZTogJyNmZjhjMDAnLFxuICAgIGRhcmtvcmNoaWQ6ICcjOTkzMmNjJyxcbiAgICBkYXJrcmVkOiAnIzhiMDAwMCcsXG4gICAgZGFya3NhbG1vbjogJyNlOTk2N2EnLFxuICAgIGRhcmtzZWFncmVlbjogJyM4ZmJjOGYnLFxuICAgIGRhcmtzbGF0ZWJsdWU6ICcjNDgzZDhiJyxcbiAgICBkYXJrc2xhdGVncmF5OiAnIzJmNGY0ZicsXG4gICAgZGFya3NsYXRlZ3JleTogJyMyZjRmNGYnLFxuICAgIGRhcmt0dXJxdW9pc2U6ICcjMDBjZWQxJyxcbiAgICBkYXJrdmlvbGV0OiAnIzk0MDBkMycsXG4gICAgZGVlcHBpbms6ICcjZmYxNDkzJyxcbiAgICBkZWVwc2t5Ymx1ZTogJyMwMGJmZmYnLFxuICAgIGRpbWdyYXk6ICcjNjk2OTY5JyxcbiAgICBkaW1ncmV5OiAnIzY5Njk2OScsXG4gICAgZG9kZ2VyYmx1ZTogJyMxZTkwZmYnLFxuICAgIGZpcmVicmljazogJyNiMjIyMjInLFxuICAgIGZsb3JhbHdoaXRlOiAnI2ZmZmFmMCcsXG4gICAgZm9yZXN0Z3JlZW46ICcjMjI4YjIyJyxcbiAgICBmdWNoc2lhOiAnI2ZmMDBmZicsXG4gICAgZ2FpbnNib3JvOiAnI2RjZGNkYycsXG4gICAgZ2hvc3R3aGl0ZTogJyNmOGY4ZmYnLFxuICAgIGdvbGQ6ICcjZmZkNzAwJyxcbiAgICBnb2xkZW5yb2Q6ICcjZGFhNTIwJyxcbiAgICBncmF5OiAnIzgwODA4MCcsXG4gICAgZ3JlZW46ICcjMDA4MDAwJyxcbiAgICBncmVlbnllbGxvdzogJyNhZGZmMmYnLFxuICAgIGdyZXk6ICcjODA4MDgwJyxcbiAgICBob25leWRldzogJyNmMGZmZjAnLFxuICAgIGhvdHBpbms6ICcjZmY2OWI0JyxcbiAgICBpbmRpYW5yZWQ6ICcjY2Q1YzVjJyxcbiAgICBpbmRpZ286ICcjNGIwMDgyJyxcbiAgICBpdm9yeTogJyNmZmZmZjAnLFxuICAgIGtoYWtpOiAnI2YwZTY4YycsXG4gICAgbGFzZXJsZW1vbjogJyNmZmZmNTQnLFxuICAgIGxhdmVuZGVyOiAnI2U2ZTZmYScsXG4gICAgbGF2ZW5kZXJibHVzaDogJyNmZmYwZjUnLFxuICAgIGxhd25ncmVlbjogJyM3Y2ZjMDAnLFxuICAgIGxlbW9uY2hpZmZvbjogJyNmZmZhY2QnLFxuICAgIGxpZ2h0Ymx1ZTogJyNhZGQ4ZTYnLFxuICAgIGxpZ2h0Y29yYWw6ICcjZjA4MDgwJyxcbiAgICBsaWdodGN5YW46ICcjZTBmZmZmJyxcbiAgICBsaWdodGdvbGRlbnJvZDogJyNmYWZhZDInLFxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnI2ZhZmFkMicsXG4gICAgbGlnaHRncmF5OiAnI2QzZDNkMycsXG4gICAgbGlnaHRncmVlbjogJyM5MGVlOTAnLFxuICAgIGxpZ2h0Z3JleTogJyNkM2QzZDMnLFxuICAgIGxpZ2h0cGluazogJyNmZmI2YzEnLFxuICAgIGxpZ2h0c2FsbW9uOiAnI2ZmYTA3YScsXG4gICAgbGlnaHRzZWFncmVlbjogJyMyMGIyYWEnLFxuICAgIGxpZ2h0c2t5Ymx1ZTogJyM4N2NlZmEnLFxuICAgIGxpZ2h0c2xhdGVncmF5OiAnIzc3ODg5OScsXG4gICAgbGlnaHRzbGF0ZWdyZXk6ICcjNzc4ODk5JyxcbiAgICBsaWdodHN0ZWVsYmx1ZTogJyNiMGM0ZGUnLFxuICAgIGxpZ2h0eWVsbG93OiAnI2ZmZmZlMCcsXG4gICAgbGltZTogJyMwMGZmMDAnLFxuICAgIGxpbWVncmVlbjogJyMzMmNkMzInLFxuICAgIGxpbmVuOiAnI2ZhZjBlNicsXG4gICAgbWFnZW50YTogJyNmZjAwZmYnLFxuICAgIG1hcm9vbjogJyM4MDAwMDAnLFxuICAgIG1hcm9vbjI6ICcjN2YwMDAwJyxcbiAgICBtYXJvb24zOiAnI2IwMzA2MCcsXG4gICAgbWVkaXVtYXF1YW1hcmluZTogJyM2NmNkYWEnLFxuICAgIG1lZGl1bWJsdWU6ICcjMDAwMGNkJyxcbiAgICBtZWRpdW1vcmNoaWQ6ICcjYmE1NWQzJyxcbiAgICBtZWRpdW1wdXJwbGU6ICcjOTM3MGRiJyxcbiAgICBtZWRpdW1zZWFncmVlbjogJyMzY2IzNzEnLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogJyM3YjY4ZWUnLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAnIzAwZmE5YScsXG4gICAgbWVkaXVtdHVycXVvaXNlOiAnIzQ4ZDFjYycsXG4gICAgbWVkaXVtdmlvbGV0cmVkOiAnI2M3MTU4NScsXG4gICAgbWlkbmlnaHRibHVlOiAnIzE5MTk3MCcsXG4gICAgbWludGNyZWFtOiAnI2Y1ZmZmYScsXG4gICAgbWlzdHlyb3NlOiAnI2ZmZTRlMScsXG4gICAgbW9jY2FzaW46ICcjZmZlNGI1JyxcbiAgICBuYXZham93aGl0ZTogJyNmZmRlYWQnLFxuICAgIG5hdnk6ICcjMDAwMDgwJyxcbiAgICBvbGRsYWNlOiAnI2ZkZjVlNicsXG4gICAgb2xpdmU6ICcjODA4MDAwJyxcbiAgICBvbGl2ZWRyYWI6ICcjNmI4ZTIzJyxcbiAgICBvcmFuZ2U6ICcjZmZhNTAwJyxcbiAgICBvcmFuZ2VyZWQ6ICcjZmY0NTAwJyxcbiAgICBvcmNoaWQ6ICcjZGE3MGQ2JyxcbiAgICBwYWxlZ29sZGVucm9kOiAnI2VlZThhYScsXG4gICAgcGFsZWdyZWVuOiAnIzk4ZmI5OCcsXG4gICAgcGFsZXR1cnF1b2lzZTogJyNhZmVlZWUnLFxuICAgIHBhbGV2aW9sZXRyZWQ6ICcjZGI3MDkzJyxcbiAgICBwYXBheWF3aGlwOiAnI2ZmZWZkNScsXG4gICAgcGVhY2hwdWZmOiAnI2ZmZGFiOScsXG4gICAgcGVydTogJyNjZDg1M2YnLFxuICAgIHBpbms6ICcjZmZjMGNiJyxcbiAgICBwbHVtOiAnI2RkYTBkZCcsXG4gICAgcG93ZGVyYmx1ZTogJyNiMGUwZTYnLFxuICAgIHB1cnBsZTogJyM4MDAwODAnLFxuICAgIHB1cnBsZTI6ICcjN2YwMDdmJyxcbiAgICBwdXJwbGUzOiAnI2EwMjBmMCcsXG4gICAgcmViZWNjYXB1cnBsZTogJyM2NjMzOTknLFxuICAgIHJlZDogJyNmZjAwMDAnLFxuICAgIHJvc3licm93bjogJyNiYzhmOGYnLFxuICAgIHJveWFsYmx1ZTogJyM0MTY5ZTEnLFxuICAgIHNhZGRsZWJyb3duOiAnIzhiNDUxMycsXG4gICAgc2FsbW9uOiAnI2ZhODA3MicsXG4gICAgc2FuZHlicm93bjogJyNmNGE0NjAnLFxuICAgIHNlYWdyZWVuOiAnIzJlOGI1NycsXG4gICAgc2Vhc2hlbGw6ICcjZmZmNWVlJyxcbiAgICBzaWVubmE6ICcjYTA1MjJkJyxcbiAgICBzaWx2ZXI6ICcjYzBjMGMwJyxcbiAgICBza3libHVlOiAnIzg3Y2VlYicsXG4gICAgc2xhdGVibHVlOiAnIzZhNWFjZCcsXG4gICAgc2xhdGVncmF5OiAnIzcwODA5MCcsXG4gICAgc2xhdGVncmV5OiAnIzcwODA5MCcsXG4gICAgc25vdzogJyNmZmZhZmEnLFxuICAgIHNwcmluZ2dyZWVuOiAnIzAwZmY3ZicsXG4gICAgc3RlZWxibHVlOiAnIzQ2ODJiNCcsXG4gICAgdGFuOiAnI2QyYjQ4YycsXG4gICAgdGVhbDogJyMwMDgwODAnLFxuICAgIHRoaXN0bGU6ICcjZDhiZmQ4JyxcbiAgICB0b21hdG86ICcjZmY2MzQ3JyxcbiAgICB0dXJxdW9pc2U6ICcjNDBlMGQwJyxcbiAgICB2aW9sZXQ6ICcjZWU4MmVlJyxcbiAgICB3aGVhdDogJyNmNWRlYjMnLFxuICAgIHdoaXRlOiAnI2ZmZmZmZicsXG4gICAgd2hpdGVzbW9rZTogJyNmNWY1ZjUnLFxuICAgIHllbGxvdzogJyNmZmZmMDAnLFxuICAgIHllbGxvd2dyZWVuOiAnIzlhY2QzMidcbn07XG5cbmNvbnN0IFJFX0hFWCA9IC9eIz8oW0EtRmEtZjAtOV17Nn18W0EtRmEtZjAtOV17M30pJC87XG5jb25zdCBSRV9IRVhBID0gL14jPyhbQS1GYS1mMC05XXs4fXxbQS1GYS1mMC05XXs0fSkkLztcblxuY29uc3QgaGV4MnJnYiA9IChoZXgpID0+IHtcbiAgICBpZiAoaGV4Lm1hdGNoKFJFX0hFWCkpIHtcbiAgICAgICAgLy8gcmVtb3ZlIG9wdGlvbmFsIGxlYWRpbmcgI1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gNCB8fCBoZXgubGVuZ3RoID09PSA3KSB7XG4gICAgICAgICAgICBoZXggPSBoZXguc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4cGFuZCBzaG9ydC1ub3RhdGlvbiB0byBmdWxsIHNpeC1kaWdpdFxuICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgaGV4ID0gaGV4LnNwbGl0KCcnKTtcbiAgICAgICAgICAgIGhleCA9IGhleFswXSArIGhleFswXSArIGhleFsxXSArIGhleFsxXSArIGhleFsyXSArIGhleFsyXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1ID0gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgICAgIGNvbnN0IHIgPSB1ID4+IDE2O1xuICAgICAgICBjb25zdCBnID0gKHUgPj4gOCkgJiAweGZmO1xuICAgICAgICBjb25zdCBiID0gdSAmIDB4ZmY7XG4gICAgICAgIHJldHVybiBbciwgZywgYiwgMV07XG4gICAgfVxuXG4gICAgLy8gbWF0Y2ggcmdiYSBoZXggZm9ybWF0LCBlZyAjRkYwMDAwNzdcbiAgICBpZiAoaGV4Lm1hdGNoKFJFX0hFWEEpKSB7XG4gICAgICAgIGlmIChoZXgubGVuZ3RoID09PSA1IHx8IGhleC5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvcHRpb25hbCBsZWFkaW5nICNcbiAgICAgICAgICAgIGhleCA9IGhleC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhwYW5kIHNob3J0LW5vdGF0aW9uIHRvIGZ1bGwgZWlnaHQtZGlnaXRcbiAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIGhleCA9IGhleC5zcGxpdCgnJyk7XG4gICAgICAgICAgICBoZXggPVxuICAgICAgICAgICAgICAgIGhleFswXSArXG4gICAgICAgICAgICAgICAgaGV4WzBdICtcbiAgICAgICAgICAgICAgICBoZXhbMV0gK1xuICAgICAgICAgICAgICAgIGhleFsxXSArXG4gICAgICAgICAgICAgICAgaGV4WzJdICtcbiAgICAgICAgICAgICAgICBoZXhbMl0gK1xuICAgICAgICAgICAgICAgIGhleFszXSArXG4gICAgICAgICAgICAgICAgaGV4WzNdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHUgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgICAgY29uc3QgciA9ICh1ID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIGNvbnN0IGcgPSAodSA+PiAxNikgJiAweGZmO1xuICAgICAgICBjb25zdCBiID0gKHUgPj4gOCkgJiAweGZmO1xuICAgICAgICBjb25zdCBhID0gTWF0aC5yb3VuZCgoKHUgJiAweGZmKSAvIDB4ZmYpICogMTAwKSAvIDEwMDtcbiAgICAgICAgcmV0dXJuIFtyLCBnLCBiLCBhXTtcbiAgICB9XG5cbiAgICAvLyB3ZSB1c2VkIHRvIGNoZWNrIGZvciBjc3MgY29sb3JzIGhlcmVcbiAgICAvLyBpZiBfaW5wdXQuY3NzPyBhbmQgcmdiID0gX2lucHV0LmNzcyBoZXhcbiAgICAvLyAgICAgcmV0dXJuIHJnYlxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGhleCBjb2xvcjogJHtoZXh9YCk7XG59O1xuXG5jb25zdCB7IHJvdW5kOiByb3VuZCQ1IH0gPSBNYXRoO1xuXG5jb25zdCByZ2IyaGV4ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBsZXQgW3IsIGcsIGIsIGFdID0gdW5wYWNrKGFyZ3MsICdyZ2JhJyk7XG4gICAgbGV0IG1vZGUgPSBsYXN0KGFyZ3MpIHx8ICdhdXRvJztcbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSBhID0gMTtcbiAgICBpZiAobW9kZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIG1vZGUgPSBhIDwgMSA/ICdyZ2JhJyA6ICdyZ2InO1xuICAgIH1cbiAgICByID0gcm91bmQkNShyKTtcbiAgICBnID0gcm91bmQkNShnKTtcbiAgICBiID0gcm91bmQkNShiKTtcbiAgICBjb25zdCB1ID0gKHIgPDwgMTYpIHwgKGcgPDwgOCkgfCBiO1xuICAgIGxldCBzdHIgPSAnMDAwMDAwJyArIHUudG9TdHJpbmcoMTYpOyAvLyMudG9VcHBlckNhc2UoKTtcbiAgICBzdHIgPSBzdHIuc3Vic3RyKHN0ci5sZW5ndGggLSA2KTtcbiAgICBsZXQgaHhhID0gJzAnICsgcm91bmQkNShhICogMjU1KS50b1N0cmluZygxNik7XG4gICAgaHhhID0gaHhhLnN1YnN0cihoeGEubGVuZ3RoIC0gMik7XG4gICAgc3dpdGNoIChtb2RlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgICAgICByZXR1cm4gYCMke3N0cn0ke2h4YX1gO1xuICAgICAgICBjYXNlICdhcmdiJzpcbiAgICAgICAgICAgIHJldHVybiBgIyR7aHhhfSR7c3RyfWA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gYCMke3N0cn1gO1xuICAgIH1cbn07XG5cbkNvbG9yLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGhleCA9IHJnYjJoZXgodGhpcy5fcmdiLCAncmdiJyk7XG4gICAgZm9yIChsZXQgbiBvZiBPYmplY3Qua2V5cyh3M2N4MTEpKSB7XG4gICAgICAgIGlmICh3M2N4MTFbbl0gPT09IGhleCkgcmV0dXJuIG4udG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn07XG5cbmlucHV0LmZvcm1hdC5uYW1lZCA9IChuYW1lKSA9PiB7XG4gICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodzNjeDExW25hbWVdKSByZXR1cm4gaGV4MnJnYih3M2N4MTFbbmFtZV0pO1xuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjb2xvciBuYW1lOiAnICsgbmFtZSk7XG59O1xuXG5pbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDUsXG4gICAgdGVzdDogKGgsIC4uLnJlc3QpID0+IHtcbiAgICAgICAgaWYgKCFyZXN0Lmxlbmd0aCAmJiB0eXBlKGgpID09PSAnc3RyaW5nJyAmJiB3M2N4MTFbaC50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICAgICAgcmV0dXJuICduYW1lZCc7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuQ29sb3IucHJvdG90eXBlLmFscGhhID0gZnVuY3Rpb24gKGEsIG11dGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKGEgIT09IHVuZGVmaW5lZCAmJiB0eXBlKGEpID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAobXV0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZ2JbM10gPSBhO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihbdGhpcy5fcmdiWzBdLCB0aGlzLl9yZ2JbMV0sIHRoaXMuX3JnYlsyXSwgYV0sICdyZ2InKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JnYlszXTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5jbGlwcGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZ2IuX2NsaXBwZWQgfHwgZmFsc2U7XG59O1xuXG5jb25zdCBsYWJDb25zdGFudHMgPSB7XG4gICAgLy8gQ29ycmVzcG9uZHMgcm91Z2hseSB0byBSR0IgYnJpZ2h0ZXIvZGFya2VyXG4gICAgS246IDE4LFxuXG4gICAgLy8gRDY1IHN0YW5kYXJkIHJlZmVyZW50XG4gICAgbGFiV2hpdGVQb2ludDogJ2Q2NScsXG4gICAgWG46IDAuOTUwNDcsXG4gICAgWW46IDEsXG4gICAgWm46IDEuMDg4ODMsXG5cbiAgICB0MDogMC4xMzc5MzEwMzQsIC8vIDQgLyAyOVxuICAgIHQxOiAwLjIwNjg5NjU1MiwgLy8gNiAvIDI5XG4gICAgdDI6IDAuMTI4NDE4NTUsIC8vIDMgKiB0MSAqIHQxXG4gICAgdDM6IDAuMDA4ODU2NDUyLCAvLyB0MSAqIHQxICogdDEsXG5cbiAgICBrRTogMjE2LjAgLyAyNDM4OS4wLFxuICAgIGtLRTogOC4wLFxuICAgIGtLOiAyNDM4OS4wIC8gMjcuMCxcblxuICAgIFJlZldoaXRlUkdCOiB7XG4gICAgICAgIC8vIHNSR0JcbiAgICAgICAgWDogMC45NTA0NyxcbiAgICAgICAgWTogMSxcbiAgICAgICAgWjogMS4wODg4M1xuICAgIH0sXG5cbiAgICBNdHhSR0IyWFlaOiB7XG4gICAgICAgIG0wMDogMC40MTI0NTY0MzkwODk2OTIyLFxuICAgICAgICBtMDE6IDAuMjEyNjcyODUxNDA1NjIyNTMsXG4gICAgICAgIG0wMjogMC4wMTkzMzM4OTU1ODIzMjkzLFxuICAgICAgICBtMTA6IDAuMzU3NTc2MDc3NjQzOTA5LFxuICAgICAgICBtMTE6IDAuNzE1MTUyMTU1Mjg3ODE4LFxuICAgICAgICBtMTI6IDAuMTE5MTkyMDI1ODgxMzAyOTcsXG4gICAgICAgIG0yMDogMC4xODA0Mzc0ODMyNjYzOTg5NCxcbiAgICAgICAgbTIxOiAwLjA3MjE3NDk5MzMwNjU1OTU4LFxuICAgICAgICBtMjI6IDAuOTUwMzA0MDc4NTM2MzY3OVxuICAgIH0sXG5cbiAgICBNdHhYWVoyUkdCOiB7XG4gICAgICAgIG0wMDogMy4yNDA0NTQxNjIxMTQxMDQ1LFxuICAgICAgICBtMDE6IC0wLjk2OTI2NjAzMDUwNTE4NjgsXG4gICAgICAgIG0wMjogMC4wNTU2NDM0MzA5NTkxMTQ3MjYsXG4gICAgICAgIG0xMDogLTEuNTM3MTM4NTEyNzk3NzE2NixcbiAgICAgICAgbTExOiAxLjg3NjAxMDg0NTQ0NjY5NDIsXG4gICAgICAgIG0xMjogLTAuMjA0MDI1OTEzNTE2NzUzOCxcbiAgICAgICAgbTIwOiAtMC40OTg1MzE0MDk1NTYwMTYsXG4gICAgICAgIG0yMTogMC4wNDE1NTYwMTc1MzAzNDk4MzQsXG4gICAgICAgIG0yMjogMS4wNTcyMjUxODgyMjMxNzkxXG4gICAgfSxcblxuICAgIC8vIHVzZWQgaW4gcmdiMnh5elxuICAgIEFzOiAwLjk0MTQyODUzNTAwMDAwMDEsXG4gICAgQnM6IDEuMDQwNDE3NDY3LFxuICAgIENzOiAxLjA4OTUzMjY1MSxcblxuICAgIE10eEFkYXB0TWE6IHtcbiAgICAgICAgbTAwOiAwLjg5NTEsXG4gICAgICAgIG0wMTogLTAuNzUwMixcbiAgICAgICAgbTAyOiAwLjAzODksXG4gICAgICAgIG0xMDogMC4yNjY0LFxuICAgICAgICBtMTE6IDEuNzEzNSxcbiAgICAgICAgbTEyOiAtMC4wNjg1LFxuICAgICAgICBtMjA6IC0wLjE2MTQsXG4gICAgICAgIG0yMTogMC4wMzY3LFxuICAgICAgICBtMjI6IDEuMDI5NlxuICAgIH0sXG5cbiAgICBNdHhBZGFwdE1hSToge1xuICAgICAgICBtMDA6IDAuOTg2OTkyOTA1NDY2NzEyMyxcbiAgICAgICAgbTAxOiAwLjQzMjMwNTI2OTcyMzM5NDU2LFxuICAgICAgICBtMDI6IC0wLjAwODUyODY2NDU3NTE3NzMyOCxcbiAgICAgICAgbTEwOiAtMC4xNDcwNTQyNTY0MjA5OTAxMyxcbiAgICAgICAgbTExOiAwLjUxODM2MDI3MTUzNjc3NzYsXG4gICAgICAgIG0xMjogMC4wNDAwNDI4MjE2NTQwODQ4NyxcbiAgICAgICAgbTIwOiAwLjE1OTk2MjY1MTY2MzczMTI1LFxuICAgICAgICBtMjE6IDAuMDQ5MjkxMjI4MjEyODU1NixcbiAgICAgICAgbTIyOiAwLjk2ODQ4NjY5NTc4NzU1MDJcbiAgICB9XG59O1xuXG4vLyB0YWtlbiBmcm9tIGh0dHBzOi8vZGUubWF0aHdvcmtzLmNvbS9oZWxwL2ltYWdlcy9yZWYvd2hpdGVwb2ludC5odG1sXG5jb25zdCBJTExVTUlOQU5UUyA9IG5ldyBNYXAoW1xuICAgIC8vIEFTVE0gRTMwOC0wMVxuICAgIFsnYScsIFsxLjA5ODUsIDAuMzU1ODVdXSxcbiAgICAvLyBXeXN6ZWNraSAmIFN0aWxlcywgcC4gNzY5XG4gICAgWydiJywgWzEuMDk4NSwgMC4zNTU4NV1dLFxuICAgIC8vIEMgQVNUTSBFMzA4LTAxXG4gICAgWydjJywgWzAuOTgwNzQsIDEuMTgyMzJdXSxcbiAgICAvLyBENTAgKEFTVE0gRTMwOC0wMSlcbiAgICBbJ2Q1MCcsIFswLjk2NDIyLCAwLjgyNTIxXV0sXG4gICAgLy8gRDU1IChBU1RNIEUzMDgtMDEpXG4gICAgWydkNTUnLCBbMC45NTY4MiwgMC45MjE0OV1dLFxuICAgIC8vIEQ2NSAoQVNUTSBFMzA4LTAxKVxuICAgIFsnZDY1JywgWzAuOTUwNDcsIDEuMDg4ODNdXSxcbiAgICAvLyBFIChBU1RNIEUzMDgtMDEpXG4gICAgWydlJywgWzEsIDEsIDFdXSxcbiAgICAvLyBGMiAoQVNUTSBFMzA4LTAxKVxuICAgIFsnZjInLCBbMC45OTE4NiwgMC42NzM5M11dLFxuICAgIC8vIEY3IChBU1RNIEUzMDgtMDEpXG4gICAgWydmNycsIFswLjk1MDQxLCAxLjA4NzQ3XV0sXG4gICAgLy8gRjExIChBU1RNIEUzMDgtMDEpXG4gICAgWydmMTEnLCBbMS4wMDk2MiwgMC42NDM1XV0sXG4gICAgWydpY2MnLCBbMC45NjQyMiwgMC44MjUyMV1dXG5dKTtcblxuZnVuY3Rpb24gc2V0TGFiV2hpdGVQb2ludChuYW1lKSB7XG4gICAgY29uc3QgaWxsID0gSUxMVU1JTkFOVFMuZ2V0KFN0cmluZyhuYW1lKS50b0xvd2VyQ2FzZSgpKTtcbiAgICBpZiAoIWlsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gTGFiIGlsbHVtaW5hbnQgJyArIG5hbWUpO1xuICAgIH1cbiAgICBsYWJDb25zdGFudHMubGFiV2hpdGVQb2ludCA9IG5hbWU7XG4gICAgbGFiQ29uc3RhbnRzLlhuID0gaWxsWzBdO1xuICAgIGxhYkNvbnN0YW50cy5abiA9IGlsbFsxXTtcbn1cblxuZnVuY3Rpb24gZ2V0TGFiV2hpdGVQb2ludCgpIHtcbiAgICByZXR1cm4gbGFiQ29uc3RhbnRzLmxhYldoaXRlUG9pbnQ7XG59XG5cbi8qXG4gKiBMKiBbMC4uMTAwXVxuICogYSBbLTEwMC4uMTAwXVxuICogYiBbLTEwMC4uMTAwXVxuICovXG5jb25zdCBsYWIycmdiID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdsYWInKTtcbiAgICBjb25zdCBbTCwgYSwgYl0gPSBhcmdzO1xuICAgIGNvbnN0IFt4LCB5LCB6XSA9IGxhYjJ4eXooTCwgYSwgYik7XG4gICAgY29uc3QgW3IsIGcsIGJfXSA9IHh5ejJyZ2IoeCwgeSwgeik7XG4gICAgcmV0dXJuIFtyLCBnLCBiXywgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xufTtcblxuY29uc3QgbGFiMnh5eiA9IChMLCBhLCBiKSA9PiB7XG4gICAgY29uc3QgeyBrRSwga0ssIGtLRSwgWG4sIFluLCBabiB9ID0gbGFiQ29uc3RhbnRzO1xuXG4gICAgY29uc3QgZnkgPSAoTCArIDE2LjApIC8gMTE2LjA7XG4gICAgY29uc3QgZnggPSAwLjAwMiAqIGEgKyBmeTtcbiAgICBjb25zdCBmeiA9IGZ5IC0gMC4wMDUgKiBiO1xuXG4gICAgY29uc3QgZngzID0gZnggKiBmeCAqIGZ4O1xuICAgIGNvbnN0IGZ6MyA9IGZ6ICogZnogKiBmejtcblxuICAgIGNvbnN0IHhyID0gZngzID4ga0UgPyBmeDMgOiAoMTE2LjAgKiBmeCAtIDE2LjApIC8ga0s7XG4gICAgY29uc3QgeXIgPSBMID4ga0tFID8gTWF0aC5wb3coKEwgKyAxNi4wKSAvIDExNi4wLCAzLjApIDogTCAvIGtLO1xuICAgIGNvbnN0IHpyID0gZnozID4ga0UgPyBmejMgOiAoMTE2LjAgKiBmeiAtIDE2LjApIC8ga0s7XG5cbiAgICBjb25zdCB4ID0geHIgKiBYbjtcbiAgICBjb25zdCB5ID0geXIgKiBZbjtcbiAgICBjb25zdCB6ID0genIgKiBabjtcblxuICAgIHJldHVybiBbeCwgeSwgel07XG59O1xuXG5jb25zdCBjb21wYW5kID0gKGxpbmVhcikgPT4ge1xuICAgIC8qIHNSR0IgKi9cbiAgICBjb25zdCBzaWduID0gTWF0aC5zaWduKGxpbmVhcik7XG4gICAgbGluZWFyID0gTWF0aC5hYnMobGluZWFyKTtcbiAgICByZXR1cm4gKFxuICAgICAgICAobGluZWFyIDw9IDAuMDAzMTMwOFxuICAgICAgICAgICAgPyBsaW5lYXIgKiAxMi45MlxuICAgICAgICAgICAgOiAxLjA1NSAqIE1hdGgucG93KGxpbmVhciwgMS4wIC8gMi40KSAtIDAuMDU1KSAqIHNpZ25cbiAgICApO1xufTtcblxuY29uc3QgeHl6MnJnYiA9ICh4LCB5LCB6KSA9PiB7XG4gICAgY29uc3QgeyBNdHhBZGFwdE1hLCBNdHhBZGFwdE1hSSwgTXR4WFlaMlJHQiwgUmVmV2hpdGVSR0IsIFhuLCBZbiwgWm4gfSA9XG4gICAgICAgIGxhYkNvbnN0YW50cztcblxuICAgIGNvbnN0IEFzID0gWG4gKiBNdHhBZGFwdE1hLm0wMCArIFluICogTXR4QWRhcHRNYS5tMTAgKyBabiAqIE10eEFkYXB0TWEubTIwO1xuICAgIGNvbnN0IEJzID0gWG4gKiBNdHhBZGFwdE1hLm0wMSArIFluICogTXR4QWRhcHRNYS5tMTEgKyBabiAqIE10eEFkYXB0TWEubTIxO1xuICAgIGNvbnN0IENzID0gWG4gKiBNdHhBZGFwdE1hLm0wMiArIFluICogTXR4QWRhcHRNYS5tMTIgKyBabiAqIE10eEFkYXB0TWEubTIyO1xuXG4gICAgY29uc3QgQWQgPVxuICAgICAgICBSZWZXaGl0ZVJHQi5YICogTXR4QWRhcHRNYS5tMDAgK1xuICAgICAgICBSZWZXaGl0ZVJHQi5ZICogTXR4QWRhcHRNYS5tMTAgK1xuICAgICAgICBSZWZXaGl0ZVJHQi5aICogTXR4QWRhcHRNYS5tMjA7XG4gICAgY29uc3QgQmQgPVxuICAgICAgICBSZWZXaGl0ZVJHQi5YICogTXR4QWRhcHRNYS5tMDEgK1xuICAgICAgICBSZWZXaGl0ZVJHQi5ZICogTXR4QWRhcHRNYS5tMTEgK1xuICAgICAgICBSZWZXaGl0ZVJHQi5aICogTXR4QWRhcHRNYS5tMjE7XG4gICAgY29uc3QgQ2QgPVxuICAgICAgICBSZWZXaGl0ZVJHQi5YICogTXR4QWRhcHRNYS5tMDIgK1xuICAgICAgICBSZWZXaGl0ZVJHQi5ZICogTXR4QWRhcHRNYS5tMTIgK1xuICAgICAgICBSZWZXaGl0ZVJHQi5aICogTXR4QWRhcHRNYS5tMjI7XG5cbiAgICBjb25zdCBYMSA9XG4gICAgICAgICh4ICogTXR4QWRhcHRNYS5tMDAgKyB5ICogTXR4QWRhcHRNYS5tMTAgKyB6ICogTXR4QWRhcHRNYS5tMjApICpcbiAgICAgICAgKEFkIC8gQXMpO1xuICAgIGNvbnN0IFkxID1cbiAgICAgICAgKHggKiBNdHhBZGFwdE1hLm0wMSArIHkgKiBNdHhBZGFwdE1hLm0xMSArIHogKiBNdHhBZGFwdE1hLm0yMSkgKlxuICAgICAgICAoQmQgLyBCcyk7XG4gICAgY29uc3QgWjEgPVxuICAgICAgICAoeCAqIE10eEFkYXB0TWEubTAyICsgeSAqIE10eEFkYXB0TWEubTEyICsgeiAqIE10eEFkYXB0TWEubTIyKSAqXG4gICAgICAgIChDZCAvIENzKTtcblxuICAgIGNvbnN0IFgyID1cbiAgICAgICAgWDEgKiBNdHhBZGFwdE1hSS5tMDAgKyBZMSAqIE10eEFkYXB0TWFJLm0xMCArIFoxICogTXR4QWRhcHRNYUkubTIwO1xuICAgIGNvbnN0IFkyID1cbiAgICAgICAgWDEgKiBNdHhBZGFwdE1hSS5tMDEgKyBZMSAqIE10eEFkYXB0TWFJLm0xMSArIFoxICogTXR4QWRhcHRNYUkubTIxO1xuICAgIGNvbnN0IFoyID1cbiAgICAgICAgWDEgKiBNdHhBZGFwdE1hSS5tMDIgKyBZMSAqIE10eEFkYXB0TWFJLm0xMiArIFoxICogTXR4QWRhcHRNYUkubTIyO1xuXG4gICAgY29uc3QgciA9IGNvbXBhbmQoXG4gICAgICAgIFgyICogTXR4WFlaMlJHQi5tMDAgKyBZMiAqIE10eFhZWjJSR0IubTEwICsgWjIgKiBNdHhYWVoyUkdCLm0yMFxuICAgICk7XG4gICAgY29uc3QgZyA9IGNvbXBhbmQoXG4gICAgICAgIFgyICogTXR4WFlaMlJHQi5tMDEgKyBZMiAqIE10eFhZWjJSR0IubTExICsgWjIgKiBNdHhYWVoyUkdCLm0yMVxuICAgICk7XG4gICAgY29uc3QgYiA9IGNvbXBhbmQoXG4gICAgICAgIFgyICogTXR4WFlaMlJHQi5tMDIgKyBZMiAqIE10eFhZWjJSR0IubTEyICsgWjIgKiBNdHhYWVoyUkdCLm0yMlxuICAgICk7XG5cbiAgICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufTtcblxuY29uc3QgcmdiMmxhYiA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgW3IsIGcsIGIsIC4uLnJlc3RdID0gdW5wYWNrKGFyZ3MsICdyZ2InKTtcbiAgICBjb25zdCBbeCwgeSwgel0gPSByZ2IyeHl6KHIsIGcsIGIpO1xuICAgIGNvbnN0IFtMLCBhLCBiX10gPSB4eXoybGFiKHgsIHksIHopO1xuICAgIHJldHVybiBbTCwgYSwgYl8sIC4uLihyZXN0Lmxlbmd0aCA+IDAgJiYgcmVzdFswXSA8IDEgPyBbcmVzdFswXV0gOiBbXSldO1xufTtcblxuZnVuY3Rpb24geHl6MmxhYih4LCB5LCB6KSB7XG4gICAgY29uc3QgeyBYbiwgWW4sIFpuLCBrRSwga0sgfSA9IGxhYkNvbnN0YW50cztcbiAgICBjb25zdCB4ciA9IHggLyBYbjtcbiAgICBjb25zdCB5ciA9IHkgLyBZbjtcbiAgICBjb25zdCB6ciA9IHogLyBabjtcblxuICAgIGNvbnN0IGZ4ID0geHIgPiBrRSA/IE1hdGgucG93KHhyLCAxLjAgLyAzLjApIDogKGtLICogeHIgKyAxNi4wKSAvIDExNi4wO1xuICAgIGNvbnN0IGZ5ID0geXIgPiBrRSA/IE1hdGgucG93KHlyLCAxLjAgLyAzLjApIDogKGtLICogeXIgKyAxNi4wKSAvIDExNi4wO1xuICAgIGNvbnN0IGZ6ID0genIgPiBrRSA/IE1hdGgucG93KHpyLCAxLjAgLyAzLjApIDogKGtLICogenIgKyAxNi4wKSAvIDExNi4wO1xuXG4gICAgcmV0dXJuIFsxMTYuMCAqIGZ5IC0gMTYuMCwgNTAwLjAgKiAoZnggLSBmeSksIDIwMC4wICogKGZ5IC0gZnopXTtcbn1cblxuZnVuY3Rpb24gZ2FtbWFBZGp1c3RTUkdCKGNvbXBhbmRlZCkge1xuICAgIGNvbnN0IHNpZ24gPSBNYXRoLnNpZ24oY29tcGFuZGVkKTtcbiAgICBjb21wYW5kZWQgPSBNYXRoLmFicyhjb21wYW5kZWQpO1xuICAgIGNvbnN0IGxpbmVhciA9XG4gICAgICAgIGNvbXBhbmRlZCA8PSAwLjA0MDQ1XG4gICAgICAgICAgICA/IGNvbXBhbmRlZCAvIDEyLjkyXG4gICAgICAgICAgICA6IE1hdGgucG93KChjb21wYW5kZWQgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgICByZXR1cm4gbGluZWFyICogc2lnbjtcbn1cblxuY29uc3QgcmdiMnh5eiA9IChyLCBnLCBiKSA9PiB7XG4gICAgLy8gbm9ybWFsaXplIGFuZCBnYW1tYSBhZGp1c3RcbiAgICByID0gZ2FtbWFBZGp1c3RTUkdCKHIgLyAyNTUpO1xuICAgIGcgPSBnYW1tYUFkanVzdFNSR0IoZyAvIDI1NSk7XG4gICAgYiA9IGdhbW1hQWRqdXN0U1JHQihiIC8gMjU1KTtcblxuICAgIGNvbnN0IHsgTXR4UkdCMlhZWiwgTXR4QWRhcHRNYSwgTXR4QWRhcHRNYUksIFhuLCBZbiwgWm4sIEFzLCBCcywgQ3MgfSA9XG4gICAgICAgIGxhYkNvbnN0YW50cztcblxuICAgIGxldCB4ID0gciAqIE10eFJHQjJYWVoubTAwICsgZyAqIE10eFJHQjJYWVoubTEwICsgYiAqIE10eFJHQjJYWVoubTIwO1xuICAgIGxldCB5ID0gciAqIE10eFJHQjJYWVoubTAxICsgZyAqIE10eFJHQjJYWVoubTExICsgYiAqIE10eFJHQjJYWVoubTIxO1xuICAgIGxldCB6ID0gciAqIE10eFJHQjJYWVoubTAyICsgZyAqIE10eFJHQjJYWVoubTEyICsgYiAqIE10eFJHQjJYWVoubTIyO1xuXG4gICAgY29uc3QgQWQgPSBYbiAqIE10eEFkYXB0TWEubTAwICsgWW4gKiBNdHhBZGFwdE1hLm0xMCArIFpuICogTXR4QWRhcHRNYS5tMjA7XG4gICAgY29uc3QgQmQgPSBYbiAqIE10eEFkYXB0TWEubTAxICsgWW4gKiBNdHhBZGFwdE1hLm0xMSArIFpuICogTXR4QWRhcHRNYS5tMjE7XG4gICAgY29uc3QgQ2QgPSBYbiAqIE10eEFkYXB0TWEubTAyICsgWW4gKiBNdHhBZGFwdE1hLm0xMiArIFpuICogTXR4QWRhcHRNYS5tMjI7XG5cbiAgICBsZXQgWCA9IHggKiBNdHhBZGFwdE1hLm0wMCArIHkgKiBNdHhBZGFwdE1hLm0xMCArIHogKiBNdHhBZGFwdE1hLm0yMDtcbiAgICBsZXQgWSA9IHggKiBNdHhBZGFwdE1hLm0wMSArIHkgKiBNdHhBZGFwdE1hLm0xMSArIHogKiBNdHhBZGFwdE1hLm0yMTtcbiAgICBsZXQgWiA9IHggKiBNdHhBZGFwdE1hLm0wMiArIHkgKiBNdHhBZGFwdE1hLm0xMiArIHogKiBNdHhBZGFwdE1hLm0yMjtcblxuICAgIFggKj0gQWQgLyBBcztcbiAgICBZICo9IEJkIC8gQnM7XG4gICAgWiAqPSBDZCAvIENzO1xuXG4gICAgeCA9IFggKiBNdHhBZGFwdE1hSS5tMDAgKyBZICogTXR4QWRhcHRNYUkubTEwICsgWiAqIE10eEFkYXB0TWFJLm0yMDtcbiAgICB5ID0gWCAqIE10eEFkYXB0TWFJLm0wMSArIFkgKiBNdHhBZGFwdE1hSS5tMTEgKyBaICogTXR4QWRhcHRNYUkubTIxO1xuICAgIHogPSBYICogTXR4QWRhcHRNYUkubTAyICsgWSAqIE10eEFkYXB0TWFJLm0xMiArIFogKiBNdHhBZGFwdE1hSS5tMjI7XG5cbiAgICByZXR1cm4gW3gsIHksIHpdO1xufTtcblxuQ29sb3IucHJvdG90eXBlLmxhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmxhYih0aGlzLl9yZ2IpO1xufTtcblxuY29uc3QgbGFiJDEgPSAoLi4uYXJncykgPT4gbmV3IENvbG9yKC4uLmFyZ3MsICdsYWInKTtcbk9iamVjdC5hc3NpZ24oY2hyb21hLCB7IGxhYjogbGFiJDEsIGdldExhYldoaXRlUG9pbnQsIHNldExhYldoaXRlUG9pbnQgfSk7XG5cbmlucHV0LmZvcm1hdC5sYWIgPSBsYWIycmdiO1xuXG5pbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDIsXG4gICAgdGVzdDogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgYXJncyA9IHVucGFjayhhcmdzLCAnbGFiJyk7XG4gICAgICAgIGlmICh0eXBlKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2xhYic7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuQ29sb3IucHJvdG90eXBlLmRhcmtlbiA9IGZ1bmN0aW9uIChhbW91bnQgPSAxKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IGxhYiA9IG1lLmxhYigpO1xuICAgIGxhYlswXSAtPSBsYWJDb25zdGFudHMuS24gKiBhbW91bnQ7XG4gICAgcmV0dXJuIG5ldyBDb2xvcihsYWIsICdsYWInKS5hbHBoYShtZS5hbHBoYSgpLCB0cnVlKTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5icmlnaHRlbiA9IGZ1bmN0aW9uIChhbW91bnQgPSAxKSB7XG4gICAgcmV0dXJuIHRoaXMuZGFya2VuKC1hbW91bnQpO1xufTtcblxuQ29sb3IucHJvdG90eXBlLmRhcmtlciA9IENvbG9yLnByb3RvdHlwZS5kYXJrZW47XG5Db2xvci5wcm90b3R5cGUuYnJpZ2h0ZXIgPSBDb2xvci5wcm90b3R5cGUuYnJpZ2h0ZW47XG5cbkNvbG9yLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobWMpIHtcbiAgICBjb25zdCBbbW9kZSwgY2hhbm5lbF0gPSBtYy5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHNyYyA9IHRoaXNbbW9kZV0oKTtcbiAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICBjb25zdCBpID0gbW9kZS5pbmRleE9mKGNoYW5uZWwpIC0gKG1vZGUuc3Vic3RyKDAsIDIpID09PSAnb2snID8gMiA6IDApO1xuICAgICAgICBpZiAoaSA+IC0xKSByZXR1cm4gc3JjW2ldO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gY2hhbm5lbCAke2NoYW5uZWx9IGluIG1vZGUgJHttb2RlfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxufTtcblxuY29uc3QgeyBwb3c6IHBvdyQ2IH0gPSBNYXRoO1xuXG5jb25zdCBFUFMgPSAxZS03O1xuY29uc3QgTUFYX0lURVIgPSAyMDtcblxuQ29sb3IucHJvdG90eXBlLmx1bWluYW5jZSA9IGZ1bmN0aW9uIChsdW0sIG1vZGUgPSAncmdiJykge1xuICAgIGlmIChsdW0gIT09IHVuZGVmaW5lZCAmJiB0eXBlKGx1bSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChsdW0gPT09IDApIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBwdXJlIGJsYWNrXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKFswLCAwLCAwLCB0aGlzLl9yZ2JbM11dLCAncmdiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGx1bSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIHB1cmUgd2hpdGVcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IoWzI1NSwgMjU1LCAyNTUsIHRoaXMuX3JnYlszXV0sICdyZ2InKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wdXRlIG5ldyBjb2xvciB1c2luZy4uLlxuICAgICAgICBsZXQgY3VyX2x1bSA9IHRoaXMubHVtaW5hbmNlKCk7XG4gICAgICAgIGxldCBtYXhfaXRlciA9IE1BWF9JVEVSO1xuXG4gICAgICAgIGNvbnN0IHRlc3QgPSAobG93LCBoaWdoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtaWQgPSBsb3cuaW50ZXJwb2xhdGUoaGlnaCwgMC41LCBtb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGxtID0gbWlkLmx1bWluYW5jZSgpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGx1bSAtIGxtKSA8IEVQUyB8fCAhbWF4X2l0ZXItLSkge1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlIGVub3VnaFxuICAgICAgICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG0gPiBsdW0gPyB0ZXN0KGxvdywgbWlkKSA6IHRlc3QobWlkLCBoaWdoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCByZ2IgPSAoXG4gICAgICAgICAgICBjdXJfbHVtID4gbHVtXG4gICAgICAgICAgICAgICAgPyB0ZXN0KG5ldyBDb2xvcihbMCwgMCwgMF0pLCB0aGlzKVxuICAgICAgICAgICAgICAgIDogdGVzdCh0aGlzLCBuZXcgQ29sb3IoWzI1NSwgMjU1LCAyNTVdKSlcbiAgICAgICAgKS5yZ2IoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihbLi4ucmdiLCB0aGlzLl9yZ2JbM11dKTtcbiAgICB9XG4gICAgcmV0dXJuIHJnYjJsdW1pbmFuY2UoLi4udGhpcy5fcmdiLnNsaWNlKDAsIDMpKTtcbn07XG5cbmNvbnN0IHJnYjJsdW1pbmFuY2UgPSAociwgZywgYikgPT4ge1xuICAgIC8vIHJlbGF0aXZlIGx1bWluYW5jZVxuICAgIC8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI3JlbGF0aXZlbHVtaW5hbmNlZGVmXG4gICAgciA9IGx1bWluYW5jZV94KHIpO1xuICAgIGcgPSBsdW1pbmFuY2VfeChnKTtcbiAgICBiID0gbHVtaW5hbmNlX3goYik7XG4gICAgcmV0dXJuIDAuMjEyNiAqIHIgKyAwLjcxNTIgKiBnICsgMC4wNzIyICogYjtcbn07XG5cbmNvbnN0IGx1bWluYW5jZV94ID0gKHgpID0+IHtcbiAgICB4IC89IDI1NTtcbiAgICByZXR1cm4geCA8PSAwLjAzOTI4ID8geCAvIDEyLjkyIDogcG93JDYoKHggKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbn07XG5cbnZhciBpbmRleCA9IHt9O1xuXG52YXIgbWl4ID0gKGNvbDEsIGNvbDIsIGYgPSAwLjUsIC4uLnJlc3QpID0+IHtcbiAgICBsZXQgbW9kZSA9IHJlc3RbMF0gfHwgJ2xyZ2InO1xuICAgIGlmICghaW5kZXhbbW9kZV0gJiYgIXJlc3QubGVuZ3RoKSB7XG4gICAgICAgIC8vIGZhbGwgYmFjayB0byB0aGUgZmlyc3Qgc3VwcG9ydGVkIG1vZGVcbiAgICAgICAgbW9kZSA9IE9iamVjdC5rZXlzKGluZGV4KVswXTtcbiAgICB9XG4gICAgaWYgKCFpbmRleFttb2RlXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludGVycG9sYXRpb24gbW9kZSAke21vZGV9IGlzIG5vdCBkZWZpbmVkYCk7XG4gICAgfVxuICAgIGlmICh0eXBlKGNvbDEpICE9PSAnb2JqZWN0JykgY29sMSA9IG5ldyBDb2xvcihjb2wxKTtcbiAgICBpZiAodHlwZShjb2wyKSAhPT0gJ29iamVjdCcpIGNvbDIgPSBuZXcgQ29sb3IoY29sMik7XG4gICAgcmV0dXJuIGluZGV4W21vZGVdKGNvbDEsIGNvbDIsIGYpLmFscGhhKFxuICAgICAgICBjb2wxLmFscGhhKCkgKyBmICogKGNvbDIuYWxwaGEoKSAtIGNvbDEuYWxwaGEoKSlcbiAgICApO1xufTtcblxuQ29sb3IucHJvdG90eXBlLm1peCA9IENvbG9yLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChcbiAgICBjb2wyLFxuICAgIGYgPSAwLjUsXG4gICAgLi4ucmVzdFxuKSB7XG4gICAgcmV0dXJuIG1peCh0aGlzLCBjb2wyLCBmLCAuLi5yZXN0KTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5wcmVtdWx0aXBseSA9IGZ1bmN0aW9uIChtdXRhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICBjb25zdCBhID0gcmdiWzNdO1xuICAgIGlmIChtdXRhdGUpIHtcbiAgICAgICAgdGhpcy5fcmdiID0gW3JnYlswXSAqIGEsIHJnYlsxXSAqIGEsIHJnYlsyXSAqIGEsIGFdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yKFtyZ2JbMF0gKiBhLCByZ2JbMV0gKiBhLCByZ2JbMl0gKiBhLCBhXSwgJ3JnYicpO1xuICAgIH1cbn07XG5cbmNvbnN0IHsgc2luOiBzaW4kMywgY29zOiBjb3MkNCB9ID0gTWF0aDtcblxuY29uc3QgbGNoMmxhYiA9ICguLi5hcmdzKSA9PiB7XG4gICAgLypcbiAgICBDb252ZXJ0IGZyb20gYSBxdWFsaXRhdGl2ZSBwYXJhbWV0ZXIgaCBhbmQgYSBxdWFudGl0YXRpdmUgcGFyYW1ldGVyIGwgdG8gYSAyNC1iaXQgcGl4ZWwuXG4gICAgVGhlc2UgZm9ybXVsYXMgd2VyZSBpbnZlbnRlZCBieSBEYXZpZCBEYWxyeW1wbGUgdG8gb2J0YWluIG1heGltdW0gY29udHJhc3Qgd2l0aG91dCBnb2luZ1xuICAgIG91dCBvZiBnYW11dCBpZiB0aGUgcGFyYW1ldGVycyBhcmUgaW4gdGhlIHJhbmdlIDAtMS5cblxuICAgIEEgc2F0dXJhdGlvbiBtdWx0aXBsaWVyIHdhcyBhZGRlZCBieSBHcmVnb3IgQWlzY2hcbiAgICAqL1xuICAgIGxldCBbbCwgYywgaF0gPSB1bnBhY2soYXJncywgJ2xjaCcpO1xuICAgIGlmIChpc05hTihoKSkgaCA9IDA7XG4gICAgaCA9IGggKiBERUcyUkFEO1xuICAgIHJldHVybiBbbCwgY29zJDQoaCkgKiBjLCBzaW4kMyhoKSAqIGNdO1xufTtcblxuY29uc3QgbGNoMnJnYiA9ICguLi5hcmdzKSA9PiB7XG4gICAgYXJncyA9IHVucGFjayhhcmdzLCAnbGNoJyk7XG4gICAgY29uc3QgW2wsIGMsIGhdID0gYXJncztcbiAgICBjb25zdCBbTCwgYSwgYl9dID0gbGNoMmxhYihsLCBjLCBoKTtcbiAgICBjb25zdCBbciwgZywgYl0gPSBsYWIycmdiKEwsIGEsIGJfKTtcbiAgICByZXR1cm4gW3IsIGcsIGIsIGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3NbM10gOiAxXTtcbn07XG5cbmNvbnN0IGhjbDJyZ2IgPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGhjbCA9IHVucGFjayhhcmdzLCAnaGNsJykucmV2ZXJzZSgpO1xuICAgIHJldHVybiBsY2gycmdiKC4uLmhjbCk7XG59O1xuXG5jb25zdCB7IHNxcnQ6IHNxcnQkNCwgYXRhbjI6IGF0YW4yJDIsIHJvdW5kOiByb3VuZCQ0IH0gPSBNYXRoO1xuXG5jb25zdCBsYWIybGNoID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBbbCwgYSwgYl0gPSB1bnBhY2soYXJncywgJ2xhYicpO1xuICAgIGNvbnN0IGMgPSBzcXJ0JDQoYSAqIGEgKyBiICogYik7XG4gICAgbGV0IGggPSAoYXRhbjIkMihiLCBhKSAqIFJBRDJERUcgKyAzNjApICUgMzYwO1xuICAgIGlmIChyb3VuZCQ0KGMgKiAxMDAwMCkgPT09IDApIGggPSBOdW1iZXIuTmFOO1xuICAgIHJldHVybiBbbCwgYywgaF07XG59O1xuXG5jb25zdCByZ2IybGNoID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBbciwgZywgYiwgLi4ucmVzdF0gPSB1bnBhY2soYXJncywgJ3JnYicpO1xuICAgIGNvbnN0IFtsLCBhLCBiX10gPSByZ2IybGFiKHIsIGcsIGIpO1xuICAgIGNvbnN0IFtMLCBjLCBoXSA9IGxhYjJsY2gobCwgYSwgYl8pO1xuICAgIHJldHVybiBbTCwgYywgaCwgLi4uKHJlc3QubGVuZ3RoID4gMCAmJiByZXN0WzBdIDwgMSA/IFtyZXN0WzBdXSA6IFtdKV07XG59O1xuXG5Db2xvci5wcm90b3R5cGUubGNoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IybGNoKHRoaXMuX3JnYik7XG59O1xuQ29sb3IucHJvdG90eXBlLmhjbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmxjaCh0aGlzLl9yZ2IpLnJldmVyc2UoKTtcbn07XG5cbmNvbnN0IGxjaCQxID0gKC4uLmFyZ3MpID0+IG5ldyBDb2xvciguLi5hcmdzLCAnbGNoJyk7XG5jb25zdCBoY2wgPSAoLi4uYXJncykgPT4gbmV3IENvbG9yKC4uLmFyZ3MsICdoY2wnKTtcblxuT2JqZWN0LmFzc2lnbihjaHJvbWEsIHsgbGNoOiBsY2gkMSwgaGNsIH0pO1xuXG5pbnB1dC5mb3JtYXQubGNoID0gbGNoMnJnYjtcbmlucHV0LmZvcm1hdC5oY2wgPSBoY2wycmdiO1xuWydsY2gnLCAnaGNsJ10uZm9yRWFjaCgobSkgPT5cbiAgICBpbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgICAgICBwOiAyLFxuICAgICAgICB0ZXN0OiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgYXJncyA9IHVucGFjayhhcmdzLCBtKTtcbiAgICAgICAgICAgIGlmICh0eXBlKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuKTtcblxuQ29sb3IucHJvdG90eXBlLnNhdHVyYXRlID0gZnVuY3Rpb24gKGFtb3VudCA9IDEpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgbGNoID0gbWUubGNoKCk7XG4gICAgbGNoWzFdICs9IGxhYkNvbnN0YW50cy5LbiAqIGFtb3VudDtcbiAgICBpZiAobGNoWzFdIDwgMCkgbGNoWzFdID0gMDtcbiAgICByZXR1cm4gbmV3IENvbG9yKGxjaCwgJ2xjaCcpLmFscGhhKG1lLmFscGhhKCksIHRydWUpO1xufTtcblxuQ29sb3IucHJvdG90eXBlLmRlc2F0dXJhdGUgPSBmdW5jdGlvbiAoYW1vdW50ID0gMSkge1xuICAgIHJldHVybiB0aGlzLnNhdHVyYXRlKC1hbW91bnQpO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChtYywgdmFsdWUsIG11dGF0ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgW21vZGUsIGNoYW5uZWxdID0gbWMuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBzcmMgPSB0aGlzW21vZGVdKCk7XG4gICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgY29uc3QgaSA9IG1vZGUuaW5kZXhPZihjaGFubmVsKSAtIChtb2RlLnN1YnN0cigwLCAyKSA9PT0gJ29rJyA/IDIgOiAwKTtcbiAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgaWYgKHR5cGUodmFsdWUpID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZS5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNbaV0gKz0gK3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjW2ldICs9ICt2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tpXSAqPSArdmFsdWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjW2ldIC89ICt2YWx1ZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tpXSA9ICt2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUodmFsdWUpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHNyY1tpXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHZhbHVlIGZvciBDb2xvci5zZXRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG91dCA9IG5ldyBDb2xvcihzcmMsIG1vZGUpO1xuICAgICAgICAgICAgaWYgKG11dGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JnYiA9IG91dC5fcmdiO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gY2hhbm5lbCAke2NoYW5uZWx9IGluIG1vZGUgJHttb2RlfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxufTtcblxuQ29sb3IucHJvdG90eXBlLnRpbnQgPSBmdW5jdGlvbiAoZiA9IDAuNSwgLi4ucmVzdCkge1xuICAgIHJldHVybiBtaXgodGhpcywgJ3doaXRlJywgZiwgLi4ucmVzdCk7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc2hhZGUgPSBmdW5jdGlvbiAoZiA9IDAuNSwgLi4ucmVzdCkge1xuICAgIHJldHVybiBtaXgodGhpcywgJ2JsYWNrJywgZiwgLi4ucmVzdCk7XG59O1xuXG5jb25zdCByZ2IkMSA9IChjb2wxLCBjb2wyLCBmKSA9PiB7XG4gICAgY29uc3QgeHl6MCA9IGNvbDEuX3JnYjtcbiAgICBjb25zdCB4eXoxID0gY29sMi5fcmdiO1xuICAgIHJldHVybiBuZXcgQ29sb3IoXG4gICAgICAgIHh5ejBbMF0gKyBmICogKHh5ejFbMF0gLSB4eXowWzBdKSxcbiAgICAgICAgeHl6MFsxXSArIGYgKiAoeHl6MVsxXSAtIHh5ejBbMV0pLFxuICAgICAgICB4eXowWzJdICsgZiAqICh4eXoxWzJdIC0geHl6MFsyXSksXG4gICAgICAgICdyZ2InXG4gICAgKTtcbn07XG5cbi8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuaW5kZXgucmdiID0gcmdiJDE7XG5cbmNvbnN0IHsgc3FydDogc3FydCQzLCBwb3c6IHBvdyQ1IH0gPSBNYXRoO1xuXG5jb25zdCBscmdiID0gKGNvbDEsIGNvbDIsIGYpID0+IHtcbiAgICBjb25zdCBbeDEsIHkxLCB6MV0gPSBjb2wxLl9yZ2I7XG4gICAgY29uc3QgW3gyLCB5MiwgejJdID0gY29sMi5fcmdiO1xuICAgIHJldHVybiBuZXcgQ29sb3IoXG4gICAgICAgIHNxcnQkMyhwb3ckNSh4MSwgMikgKiAoMSAtIGYpICsgcG93JDUoeDIsIDIpICogZiksXG4gICAgICAgIHNxcnQkMyhwb3ckNSh5MSwgMikgKiAoMSAtIGYpICsgcG93JDUoeTIsIDIpICogZiksXG4gICAgICAgIHNxcnQkMyhwb3ckNSh6MSwgMikgKiAoMSAtIGYpICsgcG93JDUoejIsIDIpICogZiksXG4gICAgICAgICdyZ2InXG4gICAgKTtcbn07XG5cbi8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuaW5kZXgubHJnYiA9IGxyZ2I7XG5cbmNvbnN0IGxhYiA9IChjb2wxLCBjb2wyLCBmKSA9PiB7XG4gICAgY29uc3QgeHl6MCA9IGNvbDEubGFiKCk7XG4gICAgY29uc3QgeHl6MSA9IGNvbDIubGFiKCk7XG4gICAgcmV0dXJuIG5ldyBDb2xvcihcbiAgICAgICAgeHl6MFswXSArIGYgKiAoeHl6MVswXSAtIHh5ejBbMF0pLFxuICAgICAgICB4eXowWzFdICsgZiAqICh4eXoxWzFdIC0geHl6MFsxXSksXG4gICAgICAgIHh5ejBbMl0gKyBmICogKHh5ejFbMl0gLSB4eXowWzJdKSxcbiAgICAgICAgJ2xhYidcbiAgICApO1xufTtcblxuLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5pbmRleC5sYWIgPSBsYWI7XG5cbnZhciBpbnRlcnBvbGF0ZV9oc3ggPSAoY29sMSwgY29sMiwgZiwgbSkgPT4ge1xuICAgIGxldCB4eXowLCB4eXoxO1xuICAgIGlmIChtID09PSAnaHNsJykge1xuICAgICAgICB4eXowID0gY29sMS5oc2woKTtcbiAgICAgICAgeHl6MSA9IGNvbDIuaHNsKCk7XG4gICAgfSBlbHNlIGlmIChtID09PSAnaHN2Jykge1xuICAgICAgICB4eXowID0gY29sMS5oc3YoKTtcbiAgICAgICAgeHl6MSA9IGNvbDIuaHN2KCk7XG4gICAgfSBlbHNlIGlmIChtID09PSAnaGNnJykge1xuICAgICAgICB4eXowID0gY29sMS5oY2coKTtcbiAgICAgICAgeHl6MSA9IGNvbDIuaGNnKCk7XG4gICAgfSBlbHNlIGlmIChtID09PSAnaHNpJykge1xuICAgICAgICB4eXowID0gY29sMS5oc2koKTtcbiAgICAgICAgeHl6MSA9IGNvbDIuaHNpKCk7XG4gICAgfSBlbHNlIGlmIChtID09PSAnbGNoJyB8fCBtID09PSAnaGNsJykge1xuICAgICAgICBtID0gJ2hjbCc7XG4gICAgICAgIHh5ejAgPSBjb2wxLmhjbCgpO1xuICAgICAgICB4eXoxID0gY29sMi5oY2woKTtcbiAgICB9IGVsc2UgaWYgKG0gPT09ICdva2xjaCcpIHtcbiAgICAgICAgeHl6MCA9IGNvbDEub2tsY2goKS5yZXZlcnNlKCk7XG4gICAgICAgIHh5ejEgPSBjb2wyLm9rbGNoKCkucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIGxldCBodWUwLCBodWUxLCBzYXQwLCBzYXQxLCBsYnYwLCBsYnYxO1xuICAgIGlmIChtLnN1YnN0cigwLCAxKSA9PT0gJ2gnIHx8IG0gPT09ICdva2xjaCcpIHtcbiAgICAgICAgW2h1ZTAsIHNhdDAsIGxidjBdID0geHl6MDtcbiAgICAgICAgW2h1ZTEsIHNhdDEsIGxidjFdID0geHl6MTtcbiAgICB9XG5cbiAgICBsZXQgc2F0LCBodWUsIGxidiwgZGg7XG5cbiAgICBpZiAoIWlzTmFOKGh1ZTApICYmICFpc05hTihodWUxKSkge1xuICAgICAgICAvLyBib3RoIGNvbG9ycyBoYXZlIGh1ZVxuICAgICAgICBpZiAoaHVlMSA+IGh1ZTAgJiYgaHVlMSAtIGh1ZTAgPiAxODApIHtcbiAgICAgICAgICAgIGRoID0gaHVlMSAtIChodWUwICsgMzYwKTtcbiAgICAgICAgfSBlbHNlIGlmIChodWUxIDwgaHVlMCAmJiBodWUwIC0gaHVlMSA+IDE4MCkge1xuICAgICAgICAgICAgZGggPSBodWUxICsgMzYwIC0gaHVlMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRoID0gaHVlMSAtIGh1ZTA7XG4gICAgICAgIH1cbiAgICAgICAgaHVlID0gaHVlMCArIGYgKiBkaDtcbiAgICB9IGVsc2UgaWYgKCFpc05hTihodWUwKSkge1xuICAgICAgICBodWUgPSBodWUwO1xuICAgICAgICBpZiAoKGxidjEgPT0gMSB8fCBsYnYxID09IDApICYmIG0gIT0gJ2hzdicpIHNhdCA9IHNhdDA7XG4gICAgfSBlbHNlIGlmICghaXNOYU4oaHVlMSkpIHtcbiAgICAgICAgaHVlID0gaHVlMTtcbiAgICAgICAgaWYgKChsYnYwID09IDEgfHwgbGJ2MCA9PSAwKSAmJiBtICE9ICdoc3YnKSBzYXQgPSBzYXQxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGh1ZSA9IE51bWJlci5OYU47XG4gICAgfVxuXG4gICAgaWYgKHNhdCA9PT0gdW5kZWZpbmVkKSBzYXQgPSBzYXQwICsgZiAqIChzYXQxIC0gc2F0MCk7XG4gICAgbGJ2ID0gbGJ2MCArIGYgKiAobGJ2MSAtIGxidjApO1xuICAgIHJldHVybiBtID09PSAnb2tsY2gnXG4gICAgICAgID8gbmV3IENvbG9yKFtsYnYsIHNhdCwgaHVlXSwgbSlcbiAgICAgICAgOiBuZXcgQ29sb3IoW2h1ZSwgc2F0LCBsYnZdLCBtKTtcbn07XG5cbmNvbnN0IGxjaCA9IChjb2wxLCBjb2wyLCBmKSA9PiB7XG4gICAgcmV0dXJuIGludGVycG9sYXRlX2hzeChjb2wxLCBjb2wyLCBmLCAnbGNoJyk7XG59O1xuXG4vLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbmluZGV4LmxjaCA9IGxjaDtcbmluZGV4LmhjbCA9IGxjaDtcblxuY29uc3QgbnVtMnJnYiA9IChudW0pID0+IHtcbiAgICBpZiAodHlwZShudW0pID09ICdudW1iZXInICYmIG51bSA+PSAwICYmIG51bSA8PSAweGZmZmZmZikge1xuICAgICAgICBjb25zdCByID0gbnVtID4+IDE2O1xuICAgICAgICBjb25zdCBnID0gKG51bSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGNvbnN0IGIgPSBudW0gJiAweGZmO1xuICAgICAgICByZXR1cm4gW3IsIGcsIGIsIDFdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gbnVtIGNvbG9yOiAnICsgbnVtKTtcbn07XG5cbmNvbnN0IHJnYjJudW0gPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHVucGFjayhhcmdzLCAncmdiJyk7XG4gICAgcmV0dXJuIChyIDw8IDE2KSArIChnIDw8IDgpICsgYjtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5udW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJnYjJudW0odGhpcy5fcmdiKTtcbn07XG5cbmNvbnN0IG51bSQxID0gKC4uLmFyZ3MpID0+IG5ldyBDb2xvciguLi5hcmdzLCAnbnVtJyk7XG5cbk9iamVjdC5hc3NpZ24oY2hyb21hLCB7IG51bTogbnVtJDEgfSk7XG5cbmlucHV0LmZvcm1hdC5udW0gPSBudW0ycmdiO1xuXG5pbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDUsXG4gICAgdGVzdDogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgYXJncy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIHR5cGUoYXJnc1swXSkgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICBhcmdzWzBdID49IDAgJiZcbiAgICAgICAgICAgIGFyZ3NbMF0gPD0gMHhmZmZmZmZcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gJ251bSc7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3QgbnVtID0gKGNvbDEsIGNvbDIsIGYpID0+IHtcbiAgICBjb25zdCBjMSA9IGNvbDEubnVtKCk7XG4gICAgY29uc3QgYzIgPSBjb2wyLm51bSgpO1xuICAgIHJldHVybiBuZXcgQ29sb3IoYzEgKyBmICogKGMyIC0gYzEpLCAnbnVtJyk7XG59O1xuXG4vLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbmluZGV4Lm51bSA9IG51bTtcblxuY29uc3QgeyBmbG9vcjogZmxvb3IkMyB9ID0gTWF0aDtcblxuLypcbiAqIHRoaXMgaXMgYmFzaWNhbGx5IGp1c3QgSFNWIHdpdGggc29tZSBtaW5vciB0d2Vha3NcbiAqXG4gKiBodWUuLiBbMC4uMzYwXVxuICogY2hyb21hIC4uIFswLi4xXVxuICogZ3JheW5lc3MgLi4gWzAuLjFdXG4gKi9cblxuY29uc3QgaGNnMnJnYiA9ICguLi5hcmdzKSA9PiB7XG4gICAgYXJncyA9IHVucGFjayhhcmdzLCAnaGNnJyk7XG4gICAgbGV0IFtoLCBjLCBfZ10gPSBhcmdzO1xuICAgIGxldCByLCBnLCBiO1xuICAgIF9nID0gX2cgKiAyNTU7XG4gICAgY29uc3QgX2MgPSBjICogMjU1O1xuICAgIGlmIChjID09PSAwKSB7XG4gICAgICAgIHIgPSBnID0gYiA9IF9nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChoID09PSAzNjApIGggPSAwO1xuICAgICAgICBpZiAoaCA+IDM2MCkgaCAtPSAzNjA7XG4gICAgICAgIGlmIChoIDwgMCkgaCArPSAzNjA7XG4gICAgICAgIGggLz0gNjA7XG4gICAgICAgIGNvbnN0IGkgPSBmbG9vciQzKGgpO1xuICAgICAgICBjb25zdCBmID0gaCAtIGk7XG4gICAgICAgIGNvbnN0IHAgPSBfZyAqICgxIC0gYyk7XG4gICAgICAgIGNvbnN0IHEgPSBwICsgX2MgKiAoMSAtIGYpO1xuICAgICAgICBjb25zdCB0ID0gcCArIF9jICogZjtcbiAgICAgICAgY29uc3QgdiA9IHAgKyBfYztcbiAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgW3IsIGcsIGJdID0gW3YsIHQsIHBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIFtyLCBnLCBiXSA9IFtxLCB2LCBwXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBbciwgZywgYl0gPSBbcCwgdiwgdF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgW3IsIGcsIGJdID0gW3AsIHEsIHZdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIFtyLCBnLCBiXSA9IFt0LCBwLCB2XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBbciwgZywgYl0gPSBbdiwgcCwgcV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtyLCBnLCBiLCBhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMV07XG59O1xuXG5jb25zdCByZ2IyaGNnID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBbciwgZywgYl0gPSB1bnBhY2soYXJncywgJ3JnYicpO1xuICAgIGNvbnN0IG1pblJnYiA9IG1pbiQzKHIsIGcsIGIpO1xuICAgIGNvbnN0IG1heFJnYiA9IG1heCQzKHIsIGcsIGIpO1xuICAgIGNvbnN0IGRlbHRhID0gbWF4UmdiIC0gbWluUmdiO1xuICAgIGNvbnN0IGMgPSAoZGVsdGEgKiAxMDApIC8gMjU1O1xuICAgIGNvbnN0IF9nID0gKG1pblJnYiAvICgyNTUgLSBkZWx0YSkpICogMTAwO1xuICAgIGxldCBoO1xuICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgICBoID0gTnVtYmVyLk5hTjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAociA9PT0gbWF4UmdiKSBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgICBpZiAoZyA9PT0gbWF4UmdiKSBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgICAgICAgaWYgKGIgPT09IG1heFJnYikgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG4gICAgICAgIGggKj0gNjA7XG4gICAgICAgIGlmIChoIDwgMCkgaCArPSAzNjA7XG4gICAgfVxuICAgIHJldHVybiBbaCwgYywgX2ddO1xufTtcblxuQ29sb3IucHJvdG90eXBlLmhjZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmhjZyh0aGlzLl9yZ2IpO1xufTtcblxuY29uc3QgaGNnJDEgPSAoLi4uYXJncykgPT4gbmV3IENvbG9yKC4uLmFyZ3MsICdoY2cnKTtcbmNocm9tYS5oY2cgPSBoY2ckMTtcblxuaW5wdXQuZm9ybWF0LmhjZyA9IGhjZzJyZ2I7XG5cbmlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMSxcbiAgICB0ZXN0OiAoLi4uYXJncykgPT4ge1xuICAgICAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdoY2cnKTtcbiAgICAgICAgaWYgKHR5cGUoYXJncykgPT09ICdhcnJheScgJiYgYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiAnaGNnJztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb25zdCBoY2cgPSAoY29sMSwgY29sMiwgZikgPT4ge1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZV9oc3goY29sMSwgY29sMiwgZiwgJ2hjZycpO1xufTtcblxuLy8gcmVnaXN0ZXIgaW50ZXJwb2xhdG9yXG5pbmRleC5oY2cgPSBoY2c7XG5cbmNvbnN0IHsgY29zOiBjb3MkMyB9ID0gTWF0aDtcblxuLypcbiAqIGh1ZSBbMC4uMzYwXVxuICogc2F0dXJhdGlvbiBbMC4uMV1cbiAqIGludGVuc2l0eSBbMC4uMV1cbiAqL1xuY29uc3QgaHNpMnJnYiA9ICguLi5hcmdzKSA9PiB7XG4gICAgLypcbiAgICBib3Jyb3dlZCBmcm9tIGhlcmU6XG4gICAgaHR0cDovL2h1bW1lci5zdGFuZm9yZC5lZHUvbXVzZWluZm8vZG9jL2V4YW1wbGVzL2h1bWRydW0va2V5c2NhcGUyL2hzaTJyZ2IuY3BwXG4gICAgKi9cbiAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdoc2knKTtcbiAgICBsZXQgW2gsIHMsIGldID0gYXJncztcbiAgICBsZXQgciwgZywgYjtcblxuICAgIGlmIChpc05hTihoKSkgaCA9IDA7XG4gICAgaWYgKGlzTmFOKHMpKSBzID0gMDtcbiAgICAvLyBub3JtYWxpemUgaHVlXG4gICAgaWYgKGggPiAzNjApIGggLT0gMzYwO1xuICAgIGlmIChoIDwgMCkgaCArPSAzNjA7XG4gICAgaCAvPSAzNjA7XG4gICAgaWYgKGggPCAxIC8gMykge1xuICAgICAgICBiID0gKDEgLSBzKSAvIDM7XG4gICAgICAgIHIgPSAoMSArIChzICogY29zJDMoVFdPUEkgKiBoKSkgLyBjb3MkMyhQSVRISVJEIC0gVFdPUEkgKiBoKSkgLyAzO1xuICAgICAgICBnID0gMSAtIChiICsgcik7XG4gICAgfSBlbHNlIGlmIChoIDwgMiAvIDMpIHtcbiAgICAgICAgaCAtPSAxIC8gMztcbiAgICAgICAgciA9ICgxIC0gcykgLyAzO1xuICAgICAgICBnID0gKDEgKyAocyAqIGNvcyQzKFRXT1BJICogaCkpIC8gY29zJDMoUElUSElSRCAtIFRXT1BJICogaCkpIC8gMztcbiAgICAgICAgYiA9IDEgLSAociArIGcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGggLT0gMiAvIDM7XG4gICAgICAgIGcgPSAoMSAtIHMpIC8gMztcbiAgICAgICAgYiA9ICgxICsgKHMgKiBjb3MkMyhUV09QSSAqIGgpKSAvIGNvcyQzKFBJVEhJUkQgLSBUV09QSSAqIGgpKSAvIDM7XG4gICAgICAgIHIgPSAxIC0gKGcgKyBiKTtcbiAgICB9XG4gICAgciA9IGxpbWl0KGkgKiByICogMyk7XG4gICAgZyA9IGxpbWl0KGkgKiBnICogMyk7XG4gICAgYiA9IGxpbWl0KGkgKiBiICogMyk7XG4gICAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1LCBhcmdzLmxlbmd0aCA+IDMgPyBhcmdzWzNdIDogMV07XG59O1xuXG5jb25zdCB7IG1pbjogbWluJDIsIHNxcnQ6IHNxcnQkMiwgYWNvcyB9ID0gTWF0aDtcblxuY29uc3QgcmdiMmhzaSA9ICguLi5hcmdzKSA9PiB7XG4gICAgLypcbiAgICBib3Jyb3dlZCBmcm9tIGhlcmU6XG4gICAgaHR0cDovL2h1bW1lci5zdGFuZm9yZC5lZHUvbXVzZWluZm8vZG9jL2V4YW1wbGVzL2h1bWRydW0va2V5c2NhcGUyL3JnYjJoc2kuY3BwXG4gICAgKi9cbiAgICBsZXQgW3IsIGcsIGJdID0gdW5wYWNrKGFyZ3MsICdyZ2InKTtcbiAgICByIC89IDI1NTtcbiAgICBnIC89IDI1NTtcbiAgICBiIC89IDI1NTtcbiAgICBsZXQgaDtcbiAgICBjb25zdCBtaW5fID0gbWluJDIociwgZywgYik7XG4gICAgY29uc3QgaSA9IChyICsgZyArIGIpIC8gMztcbiAgICBjb25zdCBzID0gaSA+IDAgPyAxIC0gbWluXyAvIGkgOiAwO1xuICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgIGggPSBOYU47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaCA9IChyIC0gZyArIChyIC0gYikpIC8gMjtcbiAgICAgICAgaCAvPSBzcXJ0JDIoKHIgLSBnKSAqIChyIC0gZykgKyAociAtIGIpICogKGcgLSBiKSk7XG4gICAgICAgIGggPSBhY29zKGgpO1xuICAgICAgICBpZiAoYiA+IGcpIHtcbiAgICAgICAgICAgIGggPSBUV09QSSAtIGg7XG4gICAgICAgIH1cbiAgICAgICAgaCAvPSBUV09QSTtcbiAgICB9XG4gICAgcmV0dXJuIFtoICogMzYwLCBzLCBpXTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5oc2kgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJnYjJoc2kodGhpcy5fcmdiKTtcbn07XG5cbmNvbnN0IGhzaSQxID0gKC4uLmFyZ3MpID0+IG5ldyBDb2xvciguLi5hcmdzLCAnaHNpJyk7XG5jaHJvbWEuaHNpID0gaHNpJDE7XG5cbmlucHV0LmZvcm1hdC5oc2kgPSBoc2kycmdiO1xuXG5pbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDIsXG4gICAgdGVzdDogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgYXJncyA9IHVucGFjayhhcmdzLCAnaHNpJyk7XG4gICAgICAgIGlmICh0eXBlKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2hzaSc7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3QgaHNpID0gKGNvbDEsIGNvbDIsIGYpID0+IHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGVfaHN4KGNvbDEsIGNvbDIsIGYsICdoc2knKTtcbn07XG5cbi8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuaW5kZXguaHNpID0gaHNpO1xuXG5jb25zdCBoc2wycmdiID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdoc2wnKTtcbiAgICBjb25zdCBbaCwgcywgbF0gPSBhcmdzO1xuICAgIGxldCByLCBnLCBiO1xuICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgIHIgPSBnID0gYiA9IGwgKiAyNTU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdDMgPSBbMCwgMCwgMF07XG4gICAgICAgIGNvbnN0IGMgPSBbMCwgMCwgMF07XG4gICAgICAgIGNvbnN0IHQyID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgY29uc3QgdDEgPSAyICogbCAtIHQyO1xuICAgICAgICBjb25zdCBoXyA9IGggLyAzNjA7XG4gICAgICAgIHQzWzBdID0gaF8gKyAxIC8gMztcbiAgICAgICAgdDNbMV0gPSBoXztcbiAgICAgICAgdDNbMl0gPSBoXyAtIDEgLyAzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgaWYgKHQzW2ldIDwgMCkgdDNbaV0gKz0gMTtcbiAgICAgICAgICAgIGlmICh0M1tpXSA+IDEpIHQzW2ldIC09IDE7XG4gICAgICAgICAgICBpZiAoNiAqIHQzW2ldIDwgMSkgY1tpXSA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzW2ldO1xuICAgICAgICAgICAgZWxzZSBpZiAoMiAqIHQzW2ldIDwgMSkgY1tpXSA9IHQyO1xuICAgICAgICAgICAgZWxzZSBpZiAoMyAqIHQzW2ldIDwgMikgY1tpXSA9IHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDNbaV0pICogNjtcbiAgICAgICAgICAgIGVsc2UgY1tpXSA9IHQxO1xuICAgICAgICB9XG4gICAgICAgIFtyLCBnLCBiXSA9IFtjWzBdICogMjU1LCBjWzFdICogMjU1LCBjWzJdICogMjU1XTtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMykge1xuICAgICAgICAvLyBrZWVwIGFscGhhIGNoYW5uZWxcbiAgICAgICAgcmV0dXJuIFtyLCBnLCBiLCBhcmdzWzNdXTtcbiAgICB9XG4gICAgcmV0dXJuIFtyLCBnLCBiLCAxXTtcbn07XG5cbi8qXG4gKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICogLSByZ2IyaHNsKHIsZyxiKVxuICogLSByZ2IyaHNsKHIsZyxiLGEpXG4gKiAtIHJnYjJoc2woW3IsZyxiXSlcbiAqIC0gcmdiMmhzbChbcixnLGIsYV0pXG4gKiAtIHJnYjJoc2woe3IsZyxiLGF9KVxuICovXG5jb25zdCByZ2IyaHNsJDEgPSAoLi4uYXJncykgPT4ge1xuICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ3JnYmEnKTtcbiAgICBsZXQgW3IsIGcsIGJdID0gYXJncztcblxuICAgIHIgLz0gMjU1O1xuICAgIGcgLz0gMjU1O1xuICAgIGIgLz0gMjU1O1xuXG4gICAgY29uc3QgbWluUmdiID0gbWluJDMociwgZywgYik7XG4gICAgY29uc3QgbWF4UmdiID0gbWF4JDMociwgZywgYik7XG5cbiAgICBjb25zdCBsID0gKG1heFJnYiArIG1pblJnYikgLyAyO1xuICAgIGxldCBzLCBoO1xuXG4gICAgaWYgKG1heFJnYiA9PT0gbWluUmdiKSB7XG4gICAgICAgIHMgPSAwO1xuICAgICAgICBoID0gTnVtYmVyLk5hTjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzID1cbiAgICAgICAgICAgIGwgPCAwLjVcbiAgICAgICAgICAgICAgICA/IChtYXhSZ2IgLSBtaW5SZ2IpIC8gKG1heFJnYiArIG1pblJnYilcbiAgICAgICAgICAgICAgICA6IChtYXhSZ2IgLSBtaW5SZ2IpIC8gKDIgLSBtYXhSZ2IgLSBtaW5SZ2IpO1xuICAgIH1cblxuICAgIGlmIChyID09IG1heFJnYikgaCA9IChnIC0gYikgLyAobWF4UmdiIC0gbWluUmdiKTtcbiAgICBlbHNlIGlmIChnID09IG1heFJnYikgaCA9IDIgKyAoYiAtIHIpIC8gKG1heFJnYiAtIG1pblJnYik7XG4gICAgZWxzZSBpZiAoYiA9PSBtYXhSZ2IpIGggPSA0ICsgKHIgLSBnKSAvIChtYXhSZ2IgLSBtaW5SZ2IpO1xuXG4gICAgaCAqPSA2MDtcbiAgICBpZiAoaCA8IDApIGggKz0gMzYwO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDMgJiYgYXJnc1szXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gW2gsIHMsIGwsIGFyZ3NbM11dO1xuICAgIHJldHVybiBbaCwgcywgbF07XG59O1xuXG5Db2xvci5wcm90b3R5cGUuaHNsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IyaHNsJDEodGhpcy5fcmdiKTtcbn07XG5cbmNvbnN0IGhzbCQxID0gKC4uLmFyZ3MpID0+IG5ldyBDb2xvciguLi5hcmdzLCAnaHNsJyk7XG5jaHJvbWEuaHNsID0gaHNsJDE7XG5cbmlucHV0LmZvcm1hdC5oc2wgPSBoc2wycmdiO1xuXG5pbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDIsXG4gICAgdGVzdDogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgYXJncyA9IHVucGFjayhhcmdzLCAnaHNsJyk7XG4gICAgICAgIGlmICh0eXBlKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2hzbCc7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3QgaHNsID0gKGNvbDEsIGNvbDIsIGYpID0+IHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGVfaHN4KGNvbDEsIGNvbDIsIGYsICdoc2wnKTtcbn07XG5cbi8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuaW5kZXguaHNsID0gaHNsO1xuXG5jb25zdCB7IGZsb29yOiBmbG9vciQyIH0gPSBNYXRoO1xuXG5jb25zdCBoc3YycmdiID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdoc3YnKTtcbiAgICBsZXQgW2gsIHMsIHZdID0gYXJncztcbiAgICBsZXQgciwgZywgYjtcbiAgICB2ICo9IDI1NTtcbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICByID0gZyA9IGIgPSB2O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChoID09PSAzNjApIGggPSAwO1xuICAgICAgICBpZiAoaCA+IDM2MCkgaCAtPSAzNjA7XG4gICAgICAgIGlmIChoIDwgMCkgaCArPSAzNjA7XG4gICAgICAgIGggLz0gNjA7XG5cbiAgICAgICAgY29uc3QgaSA9IGZsb29yJDIoaCk7XG4gICAgICAgIGNvbnN0IGYgPSBoIC0gaTtcbiAgICAgICAgY29uc3QgcCA9IHYgKiAoMSAtIHMpO1xuICAgICAgICBjb25zdCBxID0gdiAqICgxIC0gcyAqIGYpO1xuICAgICAgICBjb25zdCB0ID0gdiAqICgxIC0gcyAqICgxIC0gZikpO1xuXG4gICAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIFtyLCBnLCBiXSA9IFt2LCB0LCBwXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBbciwgZywgYl0gPSBbcSwgdiwgcF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgW3IsIGcsIGJdID0gW3AsIHYsIHRdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIFtyLCBnLCBiXSA9IFtwLCBxLCB2XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBbciwgZywgYl0gPSBbdCwgcCwgdl07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgW3IsIGcsIGJdID0gW3YsIHAsIHFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbciwgZywgYiwgYXJncy5sZW5ndGggPiAzID8gYXJnc1szXSA6IDFdO1xufTtcblxuY29uc3QgeyBtaW46IG1pbiQxLCBtYXg6IG1heCQyIH0gPSBNYXRoO1xuXG4vKlxuICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAqIC0gcmdiMmhzdihyLGcsYilcbiAqIC0gcmdiMmhzdihbcixnLGJdKVxuICogLSByZ2IyaHN2KHtyLGcsYn0pXG4gKi9cbmNvbnN0IHJnYjJoc2wgPSAoLi4uYXJncykgPT4ge1xuICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ3JnYicpO1xuICAgIGxldCBbciwgZywgYl0gPSBhcmdzO1xuICAgIGNvbnN0IG1pbl8gPSBtaW4kMShyLCBnLCBiKTtcbiAgICBjb25zdCBtYXhfID0gbWF4JDIociwgZywgYik7XG4gICAgY29uc3QgZGVsdGEgPSBtYXhfIC0gbWluXztcbiAgICBsZXQgaCwgcywgdjtcbiAgICB2ID0gbWF4XyAvIDI1NS4wO1xuICAgIGlmIChtYXhfID09PSAwKSB7XG4gICAgICAgIGggPSBOdW1iZXIuTmFOO1xuICAgICAgICBzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzID0gZGVsdGEgLyBtYXhfO1xuICAgICAgICBpZiAociA9PT0gbWF4XykgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgICAgICAgaWYgKGcgPT09IG1heF8pIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgICAgICBpZiAoYiA9PT0gbWF4XykgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG4gICAgICAgIGggKj0gNjA7XG4gICAgICAgIGlmIChoIDwgMCkgaCArPSAzNjA7XG4gICAgfVxuICAgIHJldHVybiBbaCwgcywgdl07XG59O1xuXG5Db2xvci5wcm90b3R5cGUuaHN2ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZ2IyaHNsKHRoaXMuX3JnYik7XG59O1xuXG5jb25zdCBoc3YkMSA9ICguLi5hcmdzKSA9PiBuZXcgQ29sb3IoLi4uYXJncywgJ2hzdicpO1xuY2hyb21hLmhzdiA9IGhzdiQxO1xuXG5pbnB1dC5mb3JtYXQuaHN2ID0gaHN2MnJnYjtcblxuaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICBwOiAyLFxuICAgIHRlc3Q6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2hzdicpO1xuICAgICAgICBpZiAodHlwZShhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuICdoc3YnO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmNvbnN0IGhzdiA9IChjb2wxLCBjb2wyLCBmKSA9PiB7XG4gICAgcmV0dXJuIGludGVycG9sYXRlX2hzeChjb2wxLCBjb2wyLCBmLCAnaHN2Jyk7XG59O1xuXG4vLyByZWdpc3RlciBpbnRlcnBvbGF0b3JcbmluZGV4LmhzdiA9IGhzdjtcblxuLy8gZnJvbSBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTQvbXVsdGlwbHktbWF0cmljZXMuanNcbmZ1bmN0aW9uIG11bHRpcGx5TWF0cmljZXMoQSwgQikge1xuICAgIGxldCBtID0gQS5sZW5ndGg7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoQVswXSkpIHtcbiAgICAgICAgLy8gQSBpcyB2ZWN0b3IsIGNvbnZlcnQgdG8gW1thLCBiLCBjLCAuLi5dXVxuICAgICAgICBBID0gW0FdO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShCWzBdKSkge1xuICAgICAgICAvLyBCIGlzIHZlY3RvciwgY29udmVydCB0byBbW2FdLCBbYl0sIFtjXSwgLi4uXV1cbiAgICAgICAgQiA9IEIubWFwKCh4KSA9PiBbeF0pO1xuICAgIH1cblxuICAgIGxldCBwID0gQlswXS5sZW5ndGg7XG4gICAgbGV0IEJfY29scyA9IEJbMF0ubWFwKChfLCBpKSA9PiBCLm1hcCgoeCkgPT4geFtpXSkpOyAvLyB0cmFuc3Bvc2UgQlxuICAgIGxldCBwcm9kdWN0ID0gQS5tYXAoKHJvdykgPT5cbiAgICAgICAgQl9jb2xzLm1hcCgoY29sKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocm93KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2wucmVkdWNlKChhLCBjKSA9PiBhICsgYyAqIHJvdywgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByb3cucmVkdWNlKChhLCBjLCBpKSA9PiBhICsgYyAqIChjb2xbaV0gfHwgMCksIDApO1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgICBpZiAobSA9PT0gMSkge1xuICAgICAgICBwcm9kdWN0ID0gcHJvZHVjdFswXTsgLy8gQXZvaWQgW1thLCBiLCBjLCAuLi5dXVxuICAgIH1cblxuICAgIGlmIChwID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwcm9kdWN0Lm1hcCgoeCkgPT4geFswXSk7IC8vIEF2b2lkIFtbYV0sIFtiXSwgW2NdLCAuLi5dXVxuICAgIH1cblxuICAgIHJldHVybiBwcm9kdWN0O1xufVxuXG5jb25zdCBva2xhYjJyZ2IgPSAoLi4uYXJncykgPT4ge1xuICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ2xhYicpO1xuICAgIGNvbnN0IFtMLCBhLCBiLCAuLi5yZXN0XSA9IGFyZ3M7XG4gICAgY29uc3QgW1gsIFksIFpdID0gT0tMYWJfdG9fWFlaKFtMLCBhLCBiXSk7XG4gICAgY29uc3QgW3IsIGcsIGJfXSA9IHh5ejJyZ2IoWCwgWSwgWik7XG4gICAgcmV0dXJuIFtyLCBnLCBiXywgLi4uKHJlc3QubGVuZ3RoID4gMCAmJiByZXN0WzBdIDwgMSA/IFtyZXN0WzBdXSA6IFtdKV07XG59O1xuXG4vLyBmcm9tIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItNC8jY29sb3ItY29udmVyc2lvbi1jb2RlXG5mdW5jdGlvbiBPS0xhYl90b19YWVooT0tMYWIpIHtcbiAgICAvLyBHaXZlbiBPS0xhYiwgY29udmVydCB0byBYWVogcmVsYXRpdmUgdG8gRDY1XG4gICAgdmFyIExNU3RvWFlaID0gW1xuICAgICAgICBbMS4yMjY4Nzk4NzU4NDU5MjQzLCAtMC41NTc4MTQ5OTQ0NjAyMTcxLCAwLjI4MTM5MTA0NTY2NTk2NDddLFxuICAgICAgICBbLTAuMDQwNTc1NzQ1MjE0ODAwOCwgMS4xMTIyODY4MDMyODAzMTcsIC0wLjA3MTcxMTA1ODA2NTUxNjRdLFxuICAgICAgICBbLTAuMDc2MzcyOTM2Njc0NjYwMSwgLTAuNDIxNDkzMzMyNDAyMjQzMiwgMS41ODY5MjQwMTk4MzY3ODE2XVxuICAgIF07XG4gICAgdmFyIE9LTGFidG9MTVMgPSBbXG4gICAgICAgIFsxLjAsIDAuMzk2MzM3Nzc3Mzc2MTc0OSwgMC4yMTU4MDM3NTczMDk5MTM2XSxcbiAgICAgICAgWzEuMCwgLTAuMTA1NTYxMzQ1ODE1NjU4NiwgLTAuMDYzODU0MTcyODI1ODEzM10sXG4gICAgICAgIFsxLjAsIC0wLjA4OTQ4NDE3NzUyOTgxMTksIC0xLjI5MTQ4NTU0ODAxOTQwOTJdXG4gICAgXTtcblxuICAgIHZhciBMTVNubCA9IG11bHRpcGx5TWF0cmljZXMoT0tMYWJ0b0xNUywgT0tMYWIpO1xuICAgIHJldHVybiBtdWx0aXBseU1hdHJpY2VzKFxuICAgICAgICBMTVN0b1hZWixcbiAgICAgICAgTE1TbmwubWFwKChjKSA9PiBjICoqIDMpXG4gICAgKTtcbn1cblxuY29uc3QgcmdiMm9rbGFiID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBbciwgZywgYiwgLi4ucmVzdF0gPSB1bnBhY2soYXJncywgJ3JnYicpO1xuICAgIGNvbnN0IHh5eiA9IHJnYjJ4eXoociwgZywgYik7XG4gICAgY29uc3Qgb2tsYWIgPSBYWVpfdG9fT0tMYWIoeHl6KTtcbiAgICByZXR1cm4gWy4uLm9rbGFiLCAuLi4ocmVzdC5sZW5ndGggPiAwICYmIHJlc3RbMF0gPCAxID8gW3Jlc3RbMF1dIDogW10pXTtcbn07XG5cbi8vIGZyb20gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci00LyNjb2xvci1jb252ZXJzaW9uLWNvZGVcbmZ1bmN0aW9uIFhZWl90b19PS0xhYihYWVopIHtcbiAgICAvLyBHaXZlbiBYWVogcmVsYXRpdmUgdG8gRDY1LCBjb252ZXJ0IHRvIE9LTGFiXG4gICAgY29uc3QgWFladG9MTVMgPSBbXG4gICAgICAgIFswLjgxOTAyMjQzNzk5NjcwMywgMC4zNjE5MDYyNjAwNTI4OTA0LCAtMC4xMjg4NzM3ODE1MjA5ODc5XSxcbiAgICAgICAgWzAuMDMyOTgzNjUzOTMyMzg4NSwgMC45MjkyODY4NjE1ODYzNDM0LCAwLjAzNjE0NDY2NjM1MDY0MjRdLFxuICAgICAgICBbMC4wNDgxNzcxODkzNTk2MjQyLCAwLjI2NDIzOTUzMTc1MjczMDgsIDAuNjMzNTQ3ODI4NDY5NDMwOV1cbiAgICBdO1xuICAgIGNvbnN0IExNU3RvT0tMYWIgPSBbXG4gICAgICAgIFswLjIxMDQ1NDI2ODMwOTMxNCwgMC43OTM2MTc3NzQ3MDIzMDU0LCAtMC4wMDQwNzIwNDMwMTE2MTkzXSxcbiAgICAgICAgWzEuOTc3OTk4NTMyNDMxMTY4NCwgLTIuNDI4NTkyMjQyMDQ4NTc5OSwgMC40NTA1OTM3MDk2MTc0MTFdLFxuICAgICAgICBbMC4wMjU5MDQwNDI0NjU1NDc4LCAwLjc4Mjc3MTcxMjQ1NzUyOTYsIC0wLjgwODY3NTc1NDkyMzA3NzRdXG4gICAgXTtcblxuICAgIGNvbnN0IExNUyA9IG11bHRpcGx5TWF0cmljZXMoWFladG9MTVMsIFhZWik7XG4gICAgLy8gSmF2YVNjcmlwdCBNYXRoLmNicnQgcmV0dXJucyBhIHNpZ24tbWF0Y2hlZCBjdWJlIHJvb3RcbiAgICAvLyBiZXdhcmUgaWYgcG9ydGluZyB0byBvdGhlciBsYW5ndWFnZXNcbiAgICAvLyBlc3BlY2lhbGx5IGlmIHRlbXB0ZWQgdG8gdXNlIGEgZ2VuZXJhbCBwb3dlciBmdW5jdGlvblxuICAgIHJldHVybiBtdWx0aXBseU1hdHJpY2VzKFxuICAgICAgICBMTVN0b09LTGFiLFxuICAgICAgICBMTVMubWFwKChjKSA9PiBNYXRoLmNicnQoYykpXG4gICAgKTtcbiAgICAvLyBMIGluIHJhbmdlIFswLDFdLiBGb3IgdXNlIGluIENTUywgbXVsdGlwbHkgYnkgMTAwIGFuZCBhZGQgYSBwZXJjZW50XG59XG5cbkNvbG9yLnByb3RvdHlwZS5va2xhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMm9rbGFiKHRoaXMuX3JnYik7XG59O1xuXG5jb25zdCBva2xhYiQxID0gKC4uLmFyZ3MpID0+IG5ldyBDb2xvciguLi5hcmdzLCAnb2tsYWInKTtcbk9iamVjdC5hc3NpZ24oY2hyb21hLCB7IG9rbGFiOiBva2xhYiQxIH0pO1xuXG5pbnB1dC5mb3JtYXQub2tsYWIgPSBva2xhYjJyZ2I7XG5cbmlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMixcbiAgICB0ZXN0OiAoLi4uYXJncykgPT4ge1xuICAgICAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdva2xhYicpO1xuICAgICAgICBpZiAodHlwZShhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuICdva2xhYic7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3Qgb2tsYWIgPSAoY29sMSwgY29sMiwgZikgPT4ge1xuICAgIGNvbnN0IHh5ejAgPSBjb2wxLm9rbGFiKCk7XG4gICAgY29uc3QgeHl6MSA9IGNvbDIub2tsYWIoKTtcbiAgICByZXR1cm4gbmV3IENvbG9yKFxuICAgICAgICB4eXowWzBdICsgZiAqICh4eXoxWzBdIC0geHl6MFswXSksXG4gICAgICAgIHh5ejBbMV0gKyBmICogKHh5ejFbMV0gLSB4eXowWzFdKSxcbiAgICAgICAgeHl6MFsyXSArIGYgKiAoeHl6MVsyXSAtIHh5ejBbMl0pLFxuICAgICAgICAnb2tsYWInXG4gICAgKTtcbn07XG5cbi8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuaW5kZXgub2tsYWIgPSBva2xhYjtcblxuY29uc3Qgb2tsY2gkMSA9IChjb2wxLCBjb2wyLCBmKSA9PiB7XG4gICAgcmV0dXJuIGludGVycG9sYXRlX2hzeChjb2wxLCBjb2wyLCBmLCAnb2tsY2gnKTtcbn07XG5cbi8vIHJlZ2lzdGVyIGludGVycG9sYXRvclxuaW5kZXgub2tsY2ggPSBva2xjaCQxO1xuXG5jb25zdCB7IHBvdzogcG93JDQsIHNxcnQ6IHNxcnQkMSwgUEk6IFBJJDEsIGNvczogY29zJDIsIHNpbjogc2luJDIsIGF0YW4yOiBhdGFuMiQxIH0gPSBNYXRoO1xuXG52YXIgYXZlcmFnZSA9IChjb2xvcnMsIG1vZGUgPSAnbHJnYicsIHdlaWdodHMgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgbCA9IGNvbG9ycy5sZW5ndGg7XG4gICAgaWYgKCF3ZWlnaHRzKSB3ZWlnaHRzID0gQXJyYXkuZnJvbShuZXcgQXJyYXkobCkpLm1hcCgoKSA9PiAxKTtcbiAgICAvLyBub3JtYWxpemUgd2VpZ2h0c1xuICAgIGNvbnN0IGsgPVxuICAgICAgICBsIC9cbiAgICAgICAgd2VpZ2h0cy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhICsgYjtcbiAgICAgICAgfSk7XG4gICAgd2VpZ2h0cy5mb3JFYWNoKCh3LCBpKSA9PiB7XG4gICAgICAgIHdlaWdodHNbaV0gKj0gaztcbiAgICB9KTtcbiAgICAvLyBjb252ZXJ0IGNvbG9ycyB0byBDb2xvciBvYmplY3RzXG4gICAgY29sb3JzID0gY29sb3JzLm1hcCgoYykgPT4gbmV3IENvbG9yKGMpKTtcbiAgICBpZiAobW9kZSA9PT0gJ2xyZ2InKSB7XG4gICAgICAgIHJldHVybiBfYXZlcmFnZV9scmdiKGNvbG9ycywgd2VpZ2h0cyk7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0ID0gY29sb3JzLnNoaWZ0KCk7XG4gICAgY29uc3QgeHl6ID0gZmlyc3QuZ2V0KG1vZGUpO1xuICAgIGNvbnN0IGNudCA9IFtdO1xuICAgIGxldCBkeCA9IDA7XG4gICAgbGV0IGR5ID0gMDtcbiAgICAvLyBpbml0aWFsIGNvbG9yXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4eXoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeHl6W2ldID0gKHh5eltpXSB8fCAwKSAqIHdlaWdodHNbMF07XG4gICAgICAgIGNudC5wdXNoKGlzTmFOKHh5eltpXSkgPyAwIDogd2VpZ2h0c1swXSk7XG4gICAgICAgIGlmIChtb2RlLmNoYXJBdChpKSA9PT0gJ2gnICYmICFpc05hTih4eXpbaV0pKSB7XG4gICAgICAgICAgICBjb25zdCBBID0gKHh5eltpXSAvIDE4MCkgKiBQSSQxO1xuICAgICAgICAgICAgZHggKz0gY29zJDIoQSkgKiB3ZWlnaHRzWzBdO1xuICAgICAgICAgICAgZHkgKz0gc2luJDIoQSkgKiB3ZWlnaHRzWzBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGFscGhhID0gZmlyc3QuYWxwaGEoKSAqIHdlaWdodHNbMF07XG4gICAgY29sb3JzLmZvckVhY2goKGMsIGNpKSA9PiB7XG4gICAgICAgIGNvbnN0IHh5ejIgPSBjLmdldChtb2RlKTtcbiAgICAgICAgYWxwaGEgKz0gYy5hbHBoYSgpICogd2VpZ2h0c1tjaSArIDFdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHh5ei5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFpc05hTih4eXoyW2ldKSkge1xuICAgICAgICAgICAgICAgIGNudFtpXSArPSB3ZWlnaHRzW2NpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUuY2hhckF0KGkpID09PSAnaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQSA9ICh4eXoyW2ldIC8gMTgwKSAqIFBJJDE7XG4gICAgICAgICAgICAgICAgICAgIGR4ICs9IGNvcyQyKEEpICogd2VpZ2h0c1tjaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBkeSArPSBzaW4kMihBKSAqIHdlaWdodHNbY2kgKyAxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4eXpbaV0gKz0geHl6MltpXSAqIHdlaWdodHNbY2kgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeHl6Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChtb2RlLmNoYXJBdChpKSA9PT0gJ2gnKSB7XG4gICAgICAgICAgICBsZXQgQSA9IChhdGFuMiQxKGR5IC8gY250W2ldLCBkeCAvIGNudFtpXSkgLyBQSSQxKSAqIDE4MDtcbiAgICAgICAgICAgIHdoaWxlIChBIDwgMCkgQSArPSAzNjA7XG4gICAgICAgICAgICB3aGlsZSAoQSA+PSAzNjApIEEgLT0gMzYwO1xuICAgICAgICAgICAgeHl6W2ldID0gQTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHh5eltpXSA9IHh5eltpXSAvIGNudFtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhbHBoYSAvPSBsO1xuICAgIHJldHVybiBuZXcgQ29sb3IoeHl6LCBtb2RlKS5hbHBoYShhbHBoYSA+IDAuOTk5OTkgPyAxIDogYWxwaGEsIHRydWUpO1xufTtcblxuY29uc3QgX2F2ZXJhZ2VfbHJnYiA9IChjb2xvcnMsIHdlaWdodHMpID0+IHtcbiAgICBjb25zdCBsID0gY29sb3JzLmxlbmd0aDtcbiAgICBjb25zdCB4eXogPSBbMCwgMCwgMCwgMF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29sID0gY29sb3JzW2ldO1xuICAgICAgICBjb25zdCBmID0gd2VpZ2h0c1tpXSAvIGw7XG4gICAgICAgIGNvbnN0IHJnYiA9IGNvbC5fcmdiO1xuICAgICAgICB4eXpbMF0gKz0gcG93JDQocmdiWzBdLCAyKSAqIGY7XG4gICAgICAgIHh5elsxXSArPSBwb3ckNChyZ2JbMV0sIDIpICogZjtcbiAgICAgICAgeHl6WzJdICs9IHBvdyQ0KHJnYlsyXSwgMikgKiBmO1xuICAgICAgICB4eXpbM10gKz0gcmdiWzNdICogZjtcbiAgICB9XG4gICAgeHl6WzBdID0gc3FydCQxKHh5elswXSk7XG4gICAgeHl6WzFdID0gc3FydCQxKHh5elsxXSk7XG4gICAgeHl6WzJdID0gc3FydCQxKHh5elsyXSk7XG4gICAgaWYgKHh5elszXSA+IDAuOTk5OTk5OSkgeHl6WzNdID0gMTtcbiAgICByZXR1cm4gbmV3IENvbG9yKGNsaXBfcmdiKHh5eikpO1xufTtcblxuLy8gbWluaW1hbCBtdWx0aS1wdXJwb3NlIGludGVyZmFjZVxuXG5cbmNvbnN0IHsgcG93OiBwb3ckMyB9ID0gTWF0aDtcblxuZnVuY3Rpb24gc2NhbGUgKGNvbG9ycykge1xuICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgbGV0IF9tb2RlID0gJ3JnYic7XG4gICAgbGV0IF9uYWNvbCA9IGNocm9tYSgnI2NjYycpO1xuICAgIGxldCBfc3ByZWFkID0gMDtcbiAgICAvLyBjb25zdCBfZml4ZWQgPSBmYWxzZTtcbiAgICBsZXQgX2RvbWFpbiA9IFswLCAxXTtcbiAgICBsZXQgX3BvcyA9IFtdO1xuICAgIGxldCBfcGFkZGluZyA9IFswLCAwXTtcbiAgICBsZXQgX2NsYXNzZXMgPSBmYWxzZTtcbiAgICBsZXQgX2NvbG9ycyA9IFtdO1xuICAgIGxldCBfb3V0ID0gZmFsc2U7XG4gICAgbGV0IF9taW4gPSAwO1xuICAgIGxldCBfbWF4ID0gMTtcbiAgICBsZXQgX2NvcnJlY3RMaWdodG5lc3MgPSBmYWxzZTtcbiAgICBsZXQgX2NvbG9yQ2FjaGUgPSB7fTtcbiAgICBsZXQgX3VzZUNhY2hlID0gdHJ1ZTtcbiAgICBsZXQgX2dhbW1hID0gMTtcblxuICAgIC8vIHByaXZhdGUgbWV0aG9kc1xuXG4gICAgY29uc3Qgc2V0Q29sb3JzID0gZnVuY3Rpb24gKGNvbG9ycykge1xuICAgICAgICBjb2xvcnMgPSBjb2xvcnMgfHwgWycjZmZmJywgJyMwMDAnXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29sb3JzICYmXG4gICAgICAgICAgICB0eXBlKGNvbG9ycykgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBjaHJvbWEuYnJld2VyICYmXG4gICAgICAgICAgICBjaHJvbWEuYnJld2VyW2NvbG9ycy50b0xvd2VyQ2FzZSgpXVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbG9ycyA9IGNocm9tYS5icmV3ZXJbY29sb3JzLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlKGNvbG9ycykgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBzaW5nbGUgY29sb3JcbiAgICAgICAgICAgIGlmIChjb2xvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY29sb3JzID0gW2NvbG9yc1swXSwgY29sb3JzWzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBjb2xvcnNcbiAgICAgICAgICAgIGNvbG9ycyA9IGNvbG9ycy5zbGljZSgwKTtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gY2hyb21hIGNsYXNzZXNcbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY29sb3JzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgY29sb3JzW2NdID0gY2hyb21hKGNvbG9yc1tjXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhdXRvLWZpbGwgY29sb3IgcG9zaXRpb25cbiAgICAgICAgICAgIF9wb3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY29sb3JzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgX3Bvcy5wdXNoKGMgLyAoY29sb3JzLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXNldENhY2hlKCk7XG4gICAgICAgIHJldHVybiAoX2NvbG9ycyA9IGNvbG9ycyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldENsYXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChfY2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gX2NsYXNzZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbiAmJiB2YWx1ZSA+PSBfY2xhc3Nlc1tpXSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG4gICAgbGV0IHRNYXBMaWdodG5lc3MgPSAodCkgPT4gdDtcbiAgICBsZXQgdE1hcERvbWFpbiA9ICh0KSA9PiB0O1xuXG4gICAgLy8gY29uc3QgY2xhc3NpZnlWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gICAgIGxldCB2YWwgPSB2YWx1ZTtcbiAgICAvLyAgICAgaWYgKF9jbGFzc2VzLmxlbmd0aCA+IDIpIHtcbiAgICAvLyAgICAgICAgIGNvbnN0IG4gPSBfY2xhc3Nlcy5sZW5ndGgtMTtcbiAgICAvLyAgICAgICAgIGNvbnN0IGkgPSBnZXRDbGFzcyh2YWx1ZSk7XG4gICAgLy8gICAgICAgICBjb25zdCBtaW5jID0gX2NsYXNzZXNbMF0gKyAoKF9jbGFzc2VzWzFdLV9jbGFzc2VzWzBdKSAqICgwICsgKF9zcHJlYWQgKiAwLjUpKSk7ICAvLyBjZW50ZXIgb2YgMXN0IGNsYXNzXG4gICAgLy8gICAgICAgICBjb25zdCBtYXhjID0gX2NsYXNzZXNbbi0xXSArICgoX2NsYXNzZXNbbl0tX2NsYXNzZXNbbi0xXSkgKiAoMSAtIChfc3ByZWFkICogMC41KSkpOyAgLy8gY2VudGVyIG9mIGxhc3QgY2xhc3NcbiAgICAvLyAgICAgICAgIHZhbCA9IF9taW4gKyAoKCgoX2NsYXNzZXNbaV0gKyAoKF9jbGFzc2VzW2krMV0gLSBfY2xhc3Nlc1tpXSkgKiAwLjUpKSAtIG1pbmMpIC8gKG1heGMtbWluYykpICogKF9tYXggLSBfbWluKSk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgcmV0dXJuIHZhbDtcbiAgICAvLyB9O1xuXG4gICAgY29uc3QgZ2V0Q29sb3IgPSBmdW5jdGlvbiAodmFsLCBieXBhc3NNYXApIHtcbiAgICAgICAgbGV0IGNvbCwgdDtcbiAgICAgICAgaWYgKGJ5cGFzc01hcCA9PSBudWxsKSB7XG4gICAgICAgICAgICBieXBhc3NNYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYU4odmFsKSB8fCB2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfbmFjb2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFieXBhc3NNYXApIHtcbiAgICAgICAgICAgIGlmIChfY2xhc3NlcyAmJiBfY2xhc3Nlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgY2xhc3NcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gZ2V0Q2xhc3ModmFsKTtcbiAgICAgICAgICAgICAgICB0ID0gYyAvIChfY2xhc3Nlcy5sZW5ndGggLSAyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX21heCAhPT0gX21pbikge1xuICAgICAgICAgICAgICAgIC8vIGp1c3QgaW50ZXJwb2xhdGUgYmV0d2VlbiBtaW4vbWF4XG4gICAgICAgICAgICAgICAgdCA9ICh2YWwgLSBfbWluKSAvIChfbWF4IC0gX21pbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdCA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvbWFpbiBtYXBcbiAgICAgICAgdCA9IHRNYXBEb21haW4odCk7XG5cbiAgICAgICAgaWYgKCFieXBhc3NNYXApIHtcbiAgICAgICAgICAgIHQgPSB0TWFwTGlnaHRuZXNzKHQpOyAvLyBsaWdodG5lc3MgY29ycmVjdGlvblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9nYW1tYSAhPT0gMSkge1xuICAgICAgICAgICAgdCA9IHBvdyQzKHQsIF9nYW1tYSk7XG4gICAgICAgIH1cblxuICAgICAgICB0ID0gX3BhZGRpbmdbMF0gKyB0ICogKDEgLSBfcGFkZGluZ1swXSAtIF9wYWRkaW5nWzFdKTtcblxuICAgICAgICB0ID0gbGltaXQodCwgMCwgMSk7XG5cbiAgICAgICAgY29uc3QgayA9IE1hdGguZmxvb3IodCAqIDEwMDAwKTtcblxuICAgICAgICBpZiAoX3VzZUNhY2hlICYmIF9jb2xvckNhY2hlW2tdKSB7XG4gICAgICAgICAgICBjb2wgPSBfY29sb3JDYWNoZVtrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlKF9jb2xvcnMpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgLy9mb3IgaSBpbiBbMC4uX3Bvcy5sZW5ndGgtMV1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9wb3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IF9wb3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0IDw9IHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IF9jb2xvcnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCA+PSBwICYmIGkgPT09IF9wb3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gX2NvbG9yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ID4gcCAmJiB0IDwgX3Bvc1tpICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAodCAtIHApIC8gKF9wb3NbaSArIDFdIC0gcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBjaHJvbWEuaW50ZXJwb2xhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbG9yc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29sb3JzW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9tb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUoX2NvbG9ycykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb2wgPSBfY29sb3JzKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF91c2VDYWNoZSkge1xuICAgICAgICAgICAgICAgIF9jb2xvckNhY2hlW2tdID0gY29sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2w7XG4gICAgfTtcblxuICAgIHZhciByZXNldENhY2hlID0gKCkgPT4gKF9jb2xvckNhY2hlID0ge30pO1xuXG4gICAgc2V0Q29sb3JzKGNvbG9ycyk7XG5cbiAgICAvLyBwdWJsaWMgaW50ZXJmYWNlXG5cbiAgICBjb25zdCBmID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgY29uc3QgYyA9IGNocm9tYShnZXRDb2xvcih2KSk7XG4gICAgICAgIGlmIChfb3V0ICYmIGNbX291dF0pIHtcbiAgICAgICAgICAgIHJldHVybiBjW19vdXRdKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmLmNsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3Nlcykge1xuICAgICAgICBpZiAoY2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZShjbGFzc2VzKSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIF9jbGFzc2VzID0gY2xhc3NlcztcbiAgICAgICAgICAgICAgICBfZG9tYWluID0gW2NsYXNzZXNbMF0sIGNsYXNzZXNbY2xhc3Nlcy5sZW5ndGggLSAxXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBjaHJvbWEuYW5hbHl6ZShfZG9tYWluKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfY2xhc3NlcyA9IFtkLm1pbiwgZC5tYXhdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc2VzID0gY2hyb21hLmxpbWl0cyhkLCAnZScsIGNsYXNzZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfY2xhc3NlcztcbiAgICB9O1xuXG4gICAgZi5kb21haW4gPSBmdW5jdGlvbiAoZG9tYWluKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIF9kb21haW47XG4gICAgICAgIH1cbiAgICAgICAgX21pbiA9IGRvbWFpblswXTtcbiAgICAgICAgX21heCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV07XG4gICAgICAgIF9wb3MgPSBbXTtcbiAgICAgICAgY29uc3QgayA9IF9jb2xvcnMubGVuZ3RoO1xuICAgICAgICBpZiAoZG9tYWluLmxlbmd0aCA9PT0gayAmJiBfbWluICE9PSBfbWF4KSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb25zXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIEFycmF5LmZyb20oZG9tYWluKSkge1xuICAgICAgICAgICAgICAgIF9wb3MucHVzaCgoZCAtIF9taW4pIC8gKF9tYXggLSBfbWluKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGs7IGMrKykge1xuICAgICAgICAgICAgICAgIF9wb3MucHVzaChjIC8gKGsgLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9tYWluLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgZG9tYWluIG1hcFxuICAgICAgICAgICAgICAgIGNvbnN0IHRPdXQgPSBkb21haW4ubWFwKChkLCBpKSA9PiBpIC8gKGRvbWFpbi5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdEJyZWFrcyA9IGRvbWFpbi5tYXAoKGQpID0+IChkIC0gX21pbikgLyAoX21heCAtIF9taW4pKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRCcmVha3MuZXZlcnkoKHZhbCwgaSkgPT4gdE91dFtpXSA9PT0gdmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB0TWFwRG9tYWluID0gKHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0IDw9IDAgfHwgdCA+PSAxKSByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0ID49IHRCcmVha3NbaSArIDFdKSBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodCAtIHRCcmVha3NbaV0pIC8gKHRCcmVha3NbaSArIDFdIC0gdEJyZWFrc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSB0T3V0W2ldICsgZiAqICh0T3V0W2kgKyAxXSAtIHRPdXRbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX2RvbWFpbiA9IFtfbWluLCBfbWF4XTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGYubW9kZSA9IGZ1bmN0aW9uIChfbSkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBfbW9kZTtcbiAgICAgICAgfVxuICAgICAgICBfbW9kZSA9IF9tO1xuICAgICAgICByZXNldENhY2hlKCk7XG4gICAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLnJhbmdlID0gZnVuY3Rpb24gKGNvbG9ycywgX3Bvcykge1xuICAgICAgICBzZXRDb2xvcnMoY29sb3JzKTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGYub3V0ID0gZnVuY3Rpb24gKF9vKSB7XG4gICAgICAgIF9vdXQgPSBfbztcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIGYuc3ByZWFkID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3ByZWFkO1xuICAgICAgICB9XG4gICAgICAgIF9zcHJlYWQgPSB2YWw7XG4gICAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLmNvcnJlY3RMaWdodG5lc3MgPSBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICB2ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBfY29ycmVjdExpZ2h0bmVzcyA9IHY7XG4gICAgICAgIHJlc2V0Q2FjaGUoKTtcbiAgICAgICAgaWYgKF9jb3JyZWN0TGlnaHRuZXNzKSB7XG4gICAgICAgICAgICB0TWFwTGlnaHRuZXNzID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBMMCA9IGdldENvbG9yKDAsIHRydWUpLmxhYigpWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IEwxID0gZ2V0Q29sb3IoMSwgdHJ1ZSkubGFiKClbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgcG9sID0gTDAgPiBMMTtcbiAgICAgICAgICAgICAgICBsZXQgTF9hY3R1YWwgPSBnZXRDb2xvcih0LCB0cnVlKS5sYWIoKVswXTtcbiAgICAgICAgICAgICAgICBjb25zdCBMX2lkZWFsID0gTDAgKyAoTDEgLSBMMCkgKiB0O1xuICAgICAgICAgICAgICAgIGxldCBMX2RpZmYgPSBMX2FjdHVhbCAtIExfaWRlYWw7XG4gICAgICAgICAgICAgICAgbGV0IHQwID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgdDEgPSAxO1xuICAgICAgICAgICAgICAgIGxldCBtYXhfaXRlciA9IDIwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChNYXRoLmFicyhMX2RpZmYpID4gMWUtMiAmJiBtYXhfaXRlci0tID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExfZGlmZiAqPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMX2RpZmYgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdDAgPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgKz0gKHQxIC0gdCkgKiAwLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICs9ICh0MCAtIHQpICogMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgTF9hY3R1YWwgPSBnZXRDb2xvcih0LCB0cnVlKS5sYWIoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoTF9kaWZmID0gTF9hY3R1YWwgLSBMX2lkZWFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdE1hcExpZ2h0bmVzcyA9ICh0KSA9PiB0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICBmLnBhZGRpbmcgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICBpZiAocCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZShwKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBwID0gW3AsIHBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3BhZGRpbmcgPSBwO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX3BhZGRpbmc7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZi5jb2xvcnMgPSBmdW5jdGlvbiAobnVtQ29sb3JzLCBvdXQpIHtcbiAgICAgICAgLy8gSWYgbm8gYXJndW1lbnRzIGFyZSBnaXZlbiwgcmV0dXJuIHRoZSBvcmlnaW5hbCBjb2xvcnMgdGhhdCB3ZXJlIHByb3ZpZGVkXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgb3V0ID0gJ2hleCc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBfY29sb3JzLnNsaWNlKDApO1xuICAgICAgICB9IGVsc2UgaWYgKG51bUNvbG9ycyA9PT0gMSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gW2YoMC41KV07XG4gICAgICAgIH0gZWxzZSBpZiAobnVtQ29sb3JzID4gMSkge1xuICAgICAgICAgICAgY29uc3QgZG0gPSBfZG9tYWluWzBdO1xuICAgICAgICAgICAgY29uc3QgZGQgPSBfZG9tYWluWzFdIC0gZG07XG4gICAgICAgICAgICByZXN1bHQgPSBfX3JhbmdlX18oMCwgbnVtQ29sb3JzKS5tYXAoKGkpID0+XG4gICAgICAgICAgICAgICAgZihkbSArIChpIC8gKG51bUNvbG9ycyAtIDEpKSAqIGRkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJldHVybnMgYWxsIGNvbG9ycyBiYXNlZCBvbiB0aGUgZGVmaW5lZCBjbGFzc2VzXG4gICAgICAgICAgICBjb2xvcnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBzYW1wbGVzID0gW107XG4gICAgICAgICAgICBpZiAoX2NsYXNzZXMgJiYgX2NsYXNzZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMSwgZW5kID0gX2NsYXNzZXMubGVuZ3RoLCBhc2MgPSAxIDw9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgYXNjID8gaSA8IGVuZCA6IGkgPiBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGFzYyA/IGkrKyA6IGktLVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVzLnB1c2goKF9jbGFzc2VzW2kgLSAxXSArIF9jbGFzc2VzW2ldKSAqIDAuNSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVzID0gX2RvbWFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHNhbXBsZXMubWFwKCh2KSA9PiBmKHYpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaHJvbWFbb3V0XSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcCgoYykgPT4gY1tvdXRdKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIGYuY2FjaGUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgICAgICBfdXNlQ2FjaGUgPSBjO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX3VzZUNhY2hlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGYuZ2FtbWEgPSBmdW5jdGlvbiAoZykge1xuICAgICAgICBpZiAoZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBfZ2FtbWEgPSBnO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX2dhbW1hO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGYubm9kYXRhID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgaWYgKGQgIT0gbnVsbCkge1xuICAgICAgICAgICAgX25hY29sID0gY2hyb21hKGQpO1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX25hY29sO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmO1xufVxuXG5mdW5jdGlvbiBfX3JhbmdlX18obGVmdCwgcmlnaHQsIGluY2x1c2l2ZSkge1xuICAgIGxldCByYW5nZSA9IFtdO1xuICAgIGxldCBhc2NlbmRpbmcgPSBsZWZ0IDwgcmlnaHQ7XG4gICAgbGV0IGVuZCA9IHJpZ2h0IDtcbiAgICBmb3IgKGxldCBpID0gbGVmdDsgYXNjZW5kaW5nID8gaSA8IGVuZCA6IGkgPiBlbmQ7IGFzY2VuZGluZyA/IGkrKyA6IGktLSkge1xuICAgICAgICByYW5nZS5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG59XG5cbi8vXG4vLyBpbnRlcnBvbGF0ZXMgYmV0d2VlbiBhIHNldCBvZiBjb2xvcnMgdXppbmcgYSBiZXppZXIgc3BsaW5lXG4vL1xuXG5cbi8vIG50aCByb3cgb2YgdGhlIHBhc2NhbCB0cmlhbmdsZVxuY29uc3QgYmlub21fcm93ID0gZnVuY3Rpb24gKG4pIHtcbiAgICBsZXQgcm93ID0gWzEsIDFdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGxldCBuZXdyb3cgPSBbMV07XG4gICAgICAgIGZvciAobGV0IGogPSAxOyBqIDw9IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbmV3cm93W2pdID0gKHJvd1tqXSB8fCAwKSArIHJvd1tqIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgcm93ID0gbmV3cm93O1xuICAgIH1cbiAgICByZXR1cm4gcm93O1xufTtcblxuY29uc3QgYmV6aWVyID0gZnVuY3Rpb24gKGNvbG9ycykge1xuICAgIGxldCBJLCBsYWIwLCBsYWIxLCBsYWIyO1xuICAgIGNvbG9ycyA9IGNvbG9ycy5tYXAoKGMpID0+IG5ldyBDb2xvcihjKSk7XG4gICAgaWYgKGNvbG9ycy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgLy8gbGluZWFyIGludGVycG9sYXRpb25cbiAgICAgICAgW2xhYjAsIGxhYjFdID0gY29sb3JzLm1hcCgoYykgPT4gYy5sYWIoKSk7XG4gICAgICAgIEkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgY29uc3QgbGFiID0gWzAsIDEsIDJdLm1hcCgoaSkgPT4gbGFiMFtpXSArIHQgKiAobGFiMVtpXSAtIGxhYjBbaV0pKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobGFiLCAnbGFiJyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChjb2xvcnMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIC8vIHF1YWRyYXRpYyBiZXppZXIgaW50ZXJwb2xhdGlvblxuICAgICAgICBbbGFiMCwgbGFiMSwgbGFiMl0gPSBjb2xvcnMubWFwKChjKSA9PiBjLmxhYigpKTtcbiAgICAgICAgSSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBjb25zdCBsYWIgPSBbMCwgMSwgMl0ubWFwKFxuICAgICAgICAgICAgICAgIChpKSA9PlxuICAgICAgICAgICAgICAgICAgICAoMSAtIHQpICogKDEgLSB0KSAqIGxhYjBbaV0gK1xuICAgICAgICAgICAgICAgICAgICAyICogKDEgLSB0KSAqIHQgKiBsYWIxW2ldICtcbiAgICAgICAgICAgICAgICAgICAgdCAqIHQgKiBsYWIyW2ldXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihsYWIsICdsYWInKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGNvbG9ycy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgLy8gY3ViaWMgYmV6aWVyIGludGVycG9sYXRpb25cbiAgICAgICAgbGV0IGxhYjM7XG4gICAgICAgIFtsYWIwLCBsYWIxLCBsYWIyLCBsYWIzXSA9IGNvbG9ycy5tYXAoKGMpID0+IGMubGFiKCkpO1xuICAgICAgICBJID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhYiA9IFswLCAxLCAyXS5tYXAoXG4gICAgICAgICAgICAgICAgKGkpID0+XG4gICAgICAgICAgICAgICAgICAgICgxIC0gdCkgKiAoMSAtIHQpICogKDEgLSB0KSAqIGxhYjBbaV0gK1xuICAgICAgICAgICAgICAgICAgICAzICogKDEgLSB0KSAqICgxIC0gdCkgKiB0ICogbGFiMVtpXSArXG4gICAgICAgICAgICAgICAgICAgIDMgKiAoMSAtIHQpICogdCAqIHQgKiBsYWIyW2ldICtcbiAgICAgICAgICAgICAgICAgICAgdCAqIHQgKiB0ICogbGFiM1tpXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobGFiLCAnbGFiJyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChjb2xvcnMubGVuZ3RoID49IDUpIHtcbiAgICAgICAgLy8gZ2VuZXJhbCBjYXNlIChkZWdyZWUgbiBiZXppZXIpXG4gICAgICAgIGxldCBsYWJzLCByb3csIG47XG4gICAgICAgIGxhYnMgPSBjb2xvcnMubWFwKChjKSA9PiBjLmxhYigpKTtcbiAgICAgICAgbiA9IGNvbG9ycy5sZW5ndGggLSAxO1xuICAgICAgICByb3cgPSBiaW5vbV9yb3cobik7XG4gICAgICAgIEkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgY29uc3QgdSA9IDEgLSB0O1xuICAgICAgICAgICAgY29uc3QgbGFiID0gWzAsIDEsIDJdLm1hcCgoaSkgPT5cbiAgICAgICAgICAgICAgICBsYWJzLnJlZHVjZShcbiAgICAgICAgICAgICAgICAgICAgKHN1bSwgZWwsIGopID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKyByb3dbal0gKiB1ICoqIChuIC0gaikgKiB0ICoqIGogKiBlbFtpXSxcbiAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKGxhYiwgJ2xhYicpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdObyBwb2ludCBpbiBydW5uaW5nIGJlemllciB3aXRoIG9ubHkgb25lIGNvbG9yLicpO1xuICAgIH1cbiAgICByZXR1cm4gSTtcbn07XG5cbnZhciBiZXppZXIkMSA9IChjb2xvcnMpID0+IHtcbiAgICBjb25zdCBmID0gYmV6aWVyKGNvbG9ycyk7XG4gICAgZi5zY2FsZSA9ICgpID0+IHNjYWxlKGYpO1xuICAgIHJldHVybiBmO1xufTtcblxuY29uc3QgeyByb3VuZDogcm91bmQkMyB9ID0gTWF0aDtcblxuQ29sb3IucHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uIChybmQgPSB0cnVlKSB7XG4gICAgaWYgKHJuZCA9PT0gZmFsc2UpIHJldHVybiB0aGlzLl9yZ2Iuc2xpY2UoMCwgMyk7XG4gICAgcmV0dXJuIHRoaXMuX3JnYi5zbGljZSgwLCAzKS5tYXAocm91bmQkMyk7XG59O1xuXG5Db2xvci5wcm90b3R5cGUucmdiYSA9IGZ1bmN0aW9uIChybmQgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JnYi5zbGljZSgwLCA0KS5tYXAoKHYsIGkpID0+IHtcbiAgICAgICAgcmV0dXJuIGkgPCAzID8gKHJuZCA9PT0gZmFsc2UgPyB2IDogcm91bmQkMyh2KSkgOiB2O1xuICAgIH0pO1xufTtcblxuY29uc3QgcmdiID0gKC4uLmFyZ3MpID0+IG5ldyBDb2xvciguLi5hcmdzLCAncmdiJyk7XG5PYmplY3QuYXNzaWduKGNocm9tYSwgeyByZ2IgfSk7XG5cbmlucHV0LmZvcm1hdC5yZ2IgPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHJnYmEgPSB1bnBhY2soYXJncywgJ3JnYmEnKTtcbiAgICBpZiAocmdiYVszXSA9PT0gdW5kZWZpbmVkKSByZ2JhWzNdID0gMTtcbiAgICByZXR1cm4gcmdiYTtcbn07XG5cbmlucHV0LmF1dG9kZXRlY3QucHVzaCh7XG4gICAgcDogMyxcbiAgICB0ZXN0OiAoLi4uYXJncykgPT4ge1xuICAgICAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdyZ2JhJyk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGUoYXJncykgPT09ICdhcnJheScgJiZcbiAgICAgICAgICAgIChhcmdzLmxlbmd0aCA9PT0gMyB8fFxuICAgICAgICAgICAgICAgIChhcmdzLmxlbmd0aCA9PT0gNCAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlKGFyZ3NbM10pID09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbM10gPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBhcmdzWzNdIDw9IDEpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAncmdiJztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKlxuICogaW50ZXJwb2xhdGVzIGJldHdlZW4gYSBzZXQgb2YgY29sb3JzIHV6aW5nIGEgYmV6aWVyIHNwbGluZVxuICogYmxlbmQgbW9kZSBmb3JtdWxhcyB0YWtlbiBmcm9tIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE4MDExMDAxNDk0Ni9odHRwOi8vd3d3LnZlbnR1cmUtd2FyZS5jb20va2V2aW4vY29kaW5nL2xldHMtbGVhcm4tbWF0aC1waG90b3Nob3AtYmxlbmQtbW9kZXMvXG4gKi9cblxuXG5jb25zdCBibGVuZCA9IChib3R0b20sIHRvcCwgbW9kZSkgPT4ge1xuICAgIGlmICghYmxlbmRbbW9kZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGJsZW5kIG1vZGUgJyArIG1vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gYmxlbmRbbW9kZV0oYm90dG9tLCB0b3ApO1xufTtcblxuY29uc3QgYmxlbmRfZiA9IChmKSA9PiAoYm90dG9tLCB0b3ApID0+IHtcbiAgICBjb25zdCBjMCA9IGNocm9tYSh0b3ApLnJnYigpO1xuICAgIGNvbnN0IGMxID0gY2hyb21hKGJvdHRvbSkucmdiKCk7XG4gICAgcmV0dXJuIGNocm9tYS5yZ2IoZihjMCwgYzEpKTtcbn07XG5cbmNvbnN0IGVhY2ggPSAoZikgPT4gKGMwLCBjMSkgPT4ge1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIG91dFswXSA9IGYoYzBbMF0sIGMxWzBdKTtcbiAgICBvdXRbMV0gPSBmKGMwWzFdLCBjMVsxXSk7XG4gICAgb3V0WzJdID0gZihjMFsyXSwgYzFbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5jb25zdCBub3JtYWwgPSAoYSkgPT4gYTtcbmNvbnN0IG11bHRpcGx5ID0gKGEsIGIpID0+IChhICogYikgLyAyNTU7XG5jb25zdCBkYXJrZW4gPSAoYSwgYikgPT4gKGEgPiBiID8gYiA6IGEpO1xuY29uc3QgbGlnaHRlbiA9IChhLCBiKSA9PiAoYSA+IGIgPyBhIDogYik7XG5jb25zdCBzY3JlZW4gPSAoYSwgYikgPT4gMjU1ICogKDEgLSAoMSAtIGEgLyAyNTUpICogKDEgLSBiIC8gMjU1KSk7XG5jb25zdCBvdmVybGF5ID0gKGEsIGIpID0+XG4gICAgYiA8IDEyOCA/ICgyICogYSAqIGIpIC8gMjU1IDogMjU1ICogKDEgLSAyICogKDEgLSBhIC8gMjU1KSAqICgxIC0gYiAvIDI1NSkpO1xuY29uc3QgYnVybiA9IChhLCBiKSA9PiAyNTUgKiAoMSAtICgxIC0gYiAvIDI1NSkgLyAoYSAvIDI1NSkpO1xuY29uc3QgZG9kZ2UgPSAoYSwgYikgPT4ge1xuICAgIGlmIChhID09PSAyNTUpIHJldHVybiAyNTU7XG4gICAgYSA9ICgyNTUgKiAoYiAvIDI1NSkpIC8gKDEgLSBhIC8gMjU1KTtcbiAgICByZXR1cm4gYSA+IDI1NSA/IDI1NSA6IGE7XG59O1xuXG4vLyAjIGFkZCA9IChhLGIpIC0+XG4vLyAjICAgICBpZiAoYSArIGIgPiAyNTUpIHRoZW4gMjU1IGVsc2UgYSArIGJcblxuYmxlbmQubm9ybWFsID0gYmxlbmRfZihlYWNoKG5vcm1hbCkpO1xuYmxlbmQubXVsdGlwbHkgPSBibGVuZF9mKGVhY2gobXVsdGlwbHkpKTtcbmJsZW5kLnNjcmVlbiA9IGJsZW5kX2YoZWFjaChzY3JlZW4pKTtcbmJsZW5kLm92ZXJsYXkgPSBibGVuZF9mKGVhY2gob3ZlcmxheSkpO1xuYmxlbmQuZGFya2VuID0gYmxlbmRfZihlYWNoKGRhcmtlbikpO1xuYmxlbmQubGlnaHRlbiA9IGJsZW5kX2YoZWFjaChsaWdodGVuKSk7XG5ibGVuZC5kb2RnZSA9IGJsZW5kX2YoZWFjaChkb2RnZSkpO1xuYmxlbmQuYnVybiA9IGJsZW5kX2YoZWFjaChidXJuKSk7XG5cbi8vIGN1YmVoZWxpeCBpbnRlcnBvbGF0aW9uXG4vLyBiYXNlZCBvbiBELkEuIEdyZWVuIFwiQSBjb2xvdXIgc2NoZW1lIGZvciB0aGUgZGlzcGxheSBvZiBhc3Ryb25vbWljYWwgaW50ZW5zaXR5IGltYWdlc1wiXG4vLyBodHRwOi8vYXN0cm9uLXNvYy5pbi9idWxsZXRpbi8xMUp1bmUvMjg5MzkyMDExLnBkZlxuY29uc3QgeyBwb3c6IHBvdyQyLCBzaW46IHNpbiQxLCBjb3M6IGNvcyQxIH0gPSBNYXRoO1xuXG5mdW5jdGlvbiBjdWJlaGVsaXggKFxuICAgIHN0YXJ0ID0gMzAwLFxuICAgIHJvdGF0aW9ucyA9IC0xLjUsXG4gICAgaHVlID0gMSxcbiAgICBnYW1tYSA9IDEsXG4gICAgbGlnaHRuZXNzID0gWzAsIDFdXG4pIHtcbiAgICBsZXQgZGggPSAwLFxuICAgICAgICBkbDtcbiAgICBpZiAodHlwZShsaWdodG5lc3MpID09PSAnYXJyYXknKSB7XG4gICAgICAgIGRsID0gbGlnaHRuZXNzWzFdIC0gbGlnaHRuZXNzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRsID0gMDtcbiAgICAgICAgbGlnaHRuZXNzID0gW2xpZ2h0bmVzcywgbGlnaHRuZXNzXTtcbiAgICB9XG4gICAgY29uc3QgZiA9IGZ1bmN0aW9uIChmcmFjdCkge1xuICAgICAgICBjb25zdCBhID0gVFdPUEkgKiAoKHN0YXJ0ICsgMTIwKSAvIDM2MCArIHJvdGF0aW9ucyAqIGZyYWN0KTtcbiAgICAgICAgY29uc3QgbCA9IHBvdyQyKGxpZ2h0bmVzc1swXSArIGRsICogZnJhY3QsIGdhbW1hKTtcbiAgICAgICAgY29uc3QgaCA9IGRoICE9PSAwID8gaHVlWzBdICsgZnJhY3QgKiBkaCA6IGh1ZTtcbiAgICAgICAgY29uc3QgYW1wID0gKGggKiBsICogKDEgLSBsKSkgLyAyO1xuICAgICAgICBjb25zdCBjb3NfYSA9IGNvcyQxKGEpO1xuICAgICAgICBjb25zdCBzaW5fYSA9IHNpbiQxKGEpO1xuICAgICAgICBjb25zdCByID0gbCArIGFtcCAqICgtMC4xNDg2MSAqIGNvc19hICsgMS43ODI3NyAqIHNpbl9hKTtcbiAgICAgICAgY29uc3QgZyA9IGwgKyBhbXAgKiAoLTAuMjkyMjcgKiBjb3NfYSAtIDAuOTA2NDkgKiBzaW5fYSk7XG4gICAgICAgIGNvbnN0IGIgPSBsICsgYW1wICogKCsxLjk3Mjk0ICogY29zX2EpO1xuICAgICAgICByZXR1cm4gY2hyb21hKGNsaXBfcmdiKFtyICogMjU1LCBnICogMjU1LCBiICogMjU1LCAxXSkpO1xuICAgIH07XG4gICAgZi5zdGFydCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIGlmIChzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IHM7XG4gICAgICAgIHJldHVybiBmO1xuICAgIH07XG4gICAgZi5yb3RhdGlvbnMgPSBmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAociA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcm90YXRpb25zO1xuICAgICAgICB9XG4gICAgICAgIHJvdGF0aW9ucyA9IHI7XG4gICAgICAgIHJldHVybiBmO1xuICAgIH07XG4gICAgZi5nYW1tYSA9IGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIGlmIChnID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnYW1tYTtcbiAgICAgICAgfVxuICAgICAgICBnYW1tYSA9IGc7XG4gICAgICAgIHJldHVybiBmO1xuICAgIH07XG4gICAgZi5odWUgPSBmdW5jdGlvbiAoaCkge1xuICAgICAgICBpZiAoaCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gaHVlO1xuICAgICAgICB9XG4gICAgICAgIGh1ZSA9IGg7XG4gICAgICAgIGlmICh0eXBlKGh1ZSkgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIGRoID0gaHVlWzFdIC0gaHVlWzBdO1xuICAgICAgICAgICAgaWYgKGRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaHVlID0gaHVlWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmO1xuICAgIH07XG4gICAgZi5saWdodG5lc3MgPSBmdW5jdGlvbiAoaCkge1xuICAgICAgICBpZiAoaCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlnaHRuZXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlKGgpID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICBsaWdodG5lc3MgPSBoO1xuICAgICAgICAgICAgZGwgPSBoWzFdIC0gaFswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpZ2h0bmVzcyA9IFtoLCBoXTtcbiAgICAgICAgICAgIGRsID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZjtcbiAgICB9O1xuICAgIGYuc2NhbGUgPSAoKSA9PiBjaHJvbWEuc2NhbGUoZik7XG4gICAgZi5odWUoaHVlKTtcbiAgICByZXR1cm4gZjtcbn1cblxuY29uc3QgZGlnaXRzID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuXG5jb25zdCB7IGZsb29yOiBmbG9vciQxLCByYW5kb20gfSA9IE1hdGg7XG5cbnZhciByYW5kb20kMSA9ICgpID0+IHtcbiAgICBsZXQgY29kZSA9ICcjJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICBjb2RlICs9IGRpZ2l0cy5jaGFyQXQoZmxvb3IkMShyYW5kb20oKSAqIDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29sb3IoY29kZSwgJ2hleCcpO1xufTtcblxuY29uc3QgeyBsb2c6IGxvZyQxLCBwb3c6IHBvdyQxLCBmbG9vciwgYWJzOiBhYnMkMSB9ID0gTWF0aDtcblxuZnVuY3Rpb24gYW5hbHl6ZShkYXRhLCBrZXkgPSBudWxsKSB7XG4gICAgY29uc3QgciA9IHtcbiAgICAgICAgbWluOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICBtYXg6IE51bWJlci5NQVhfVkFMVUUgKiAtMSxcbiAgICAgICAgc3VtOiAwLFxuICAgICAgICB2YWx1ZXM6IFtdLFxuICAgICAgICBjb3VudDogMFxuICAgIH07XG4gICAgaWYgKHR5cGUoZGF0YSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGRhdGEgPSBPYmplY3QudmFsdWVzKGRhdGEpO1xuICAgIH1cbiAgICBkYXRhLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgICBpZiAoa2V5ICYmIHR5cGUodmFsKSA9PT0gJ29iamVjdCcpIHZhbCA9IHZhbFtrZXldO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQgJiYgdmFsICE9PSBudWxsICYmICFpc05hTih2YWwpKSB7XG4gICAgICAgICAgICByLnZhbHVlcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICByLnN1bSArPSB2YWw7XG4gICAgICAgICAgICBpZiAodmFsIDwgci5taW4pIHIubWluID0gdmFsO1xuICAgICAgICAgICAgaWYgKHZhbCA+IHIubWF4KSByLm1heCA9IHZhbDtcbiAgICAgICAgICAgIHIuY291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgci5kb21haW4gPSBbci5taW4sIHIubWF4XTtcblxuICAgIHIubGltaXRzID0gKG1vZGUsIG51bSkgPT4gbGltaXRzKHIsIG1vZGUsIG51bSk7XG5cbiAgICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gbGltaXRzKGRhdGEsIG1vZGUgPSAnZXF1YWwnLCBudW0gPSA3KSB7XG4gICAgaWYgKHR5cGUoZGF0YSkgPT0gJ2FycmF5Jykge1xuICAgICAgICBkYXRhID0gYW5hbHl6ZShkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgeyBtaW4sIG1heCB9ID0gZGF0YTtcbiAgICBjb25zdCB2YWx1ZXMgPSBkYXRhLnZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG5cbiAgICBpZiAobnVtID09PSAxKSB7XG4gICAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbWl0cyA9IFtdO1xuXG4gICAgaWYgKG1vZGUuc3Vic3RyKDAsIDEpID09PSAnYycpIHtcbiAgICAgICAgLy8gY29udGludW91c1xuICAgICAgICBsaW1pdHMucHVzaChtaW4pO1xuICAgICAgICBsaW1pdHMucHVzaChtYXgpO1xuICAgIH1cblxuICAgIGlmIChtb2RlLnN1YnN0cigwLCAxKSA9PT0gJ2UnKSB7XG4gICAgICAgIC8vIGVxdWFsIGludGVydmFsXG4gICAgICAgIGxpbWl0cy5wdXNoKG1pbik7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgICAgICAgIGxpbWl0cy5wdXNoKG1pbiArIChpIC8gbnVtKSAqIChtYXggLSBtaW4pKTtcbiAgICAgICAgfVxuICAgICAgICBsaW1pdHMucHVzaChtYXgpO1xuICAgIH0gZWxzZSBpZiAobW9kZS5zdWJzdHIoMCwgMSkgPT09ICdsJykge1xuICAgICAgICAvLyBsb2cgc2NhbGVcbiAgICAgICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ0xvZ2FyaXRobWljIHNjYWxlcyBhcmUgb25seSBwb3NzaWJsZSBmb3IgdmFsdWVzID4gMCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWluX2xvZyA9IE1hdGguTE9HMTBFICogbG9nJDEobWluKTtcbiAgICAgICAgY29uc3QgbWF4X2xvZyA9IE1hdGguTE9HMTBFICogbG9nJDEobWF4KTtcbiAgICAgICAgbGltaXRzLnB1c2gobWluKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW07IGkrKykge1xuICAgICAgICAgICAgbGltaXRzLnB1c2gocG93JDEoMTAsIG1pbl9sb2cgKyAoaSAvIG51bSkgKiAobWF4X2xvZyAtIG1pbl9sb2cpKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGltaXRzLnB1c2gobWF4KTtcbiAgICB9IGVsc2UgaWYgKG1vZGUuc3Vic3RyKDAsIDEpID09PSAncScpIHtcbiAgICAgICAgLy8gcXVhbnRpbGUgc2NhbGVcbiAgICAgICAgbGltaXRzLnB1c2gobWluKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW07IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcCA9ICgodmFsdWVzLmxlbmd0aCAtIDEpICogaSkgLyBudW07XG4gICAgICAgICAgICBjb25zdCBwYiA9IGZsb29yKHApO1xuICAgICAgICAgICAgaWYgKHBiID09PSBwKSB7XG4gICAgICAgICAgICAgICAgbGltaXRzLnB1c2godmFsdWVzW3BiXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHAgPiBwYlxuICAgICAgICAgICAgICAgIGNvbnN0IHByID0gcCAtIHBiO1xuICAgICAgICAgICAgICAgIGxpbWl0cy5wdXNoKHZhbHVlc1twYl0gKiAoMSAtIHByKSArIHZhbHVlc1twYiArIDFdICogcHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpbWl0cy5wdXNoKG1heCk7XG4gICAgfSBlbHNlIGlmIChtb2RlLnN1YnN0cigwLCAxKSA9PT0gJ2snKSB7XG4gICAgICAgIC8vIGstbWVhbnMgY2x1c3RlcmluZ1xuICAgICAgICAvKlxuICAgICAgICBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvblxuICAgICAgICBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZmlndWUvc291cmNlL2Jyb3dzZS90cnVuay9maWd1ZS5qcyMzMzZcbiAgICAgICAgc2ltcGxpZmllZCBmb3IgMS1kIGlucHV0IHZhbHVlc1xuICAgICAgICAqL1xuICAgICAgICBsZXQgY2x1c3RlcjtcbiAgICAgICAgY29uc3QgbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGFzc2lnbm1lbnRzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBjb25zdCBjbHVzdGVyU2l6ZXMgPSBuZXcgQXJyYXkobnVtKTtcbiAgICAgICAgbGV0IHJlcGVhdCA9IHRydWU7XG4gICAgICAgIGxldCBuYl9pdGVycyA9IDA7XG4gICAgICAgIGxldCBjZW50cm9pZHMgPSBudWxsO1xuXG4gICAgICAgIC8vIGdldCBzZWVkIHZhbHVlc1xuICAgICAgICBjZW50cm9pZHMgPSBbXTtcbiAgICAgICAgY2VudHJvaWRzLnB1c2gobWluKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW07IGkrKykge1xuICAgICAgICAgICAgY2VudHJvaWRzLnB1c2gobWluICsgKGkgLyBudW0pICogKG1heCAtIG1pbikpO1xuICAgICAgICB9XG4gICAgICAgIGNlbnRyb2lkcy5wdXNoKG1heCk7XG5cbiAgICAgICAgd2hpbGUgKHJlcGVhdCkge1xuICAgICAgICAgICAgLy8gYXNzaWdubWVudCBzdGVwXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bTsgaisrKSB7XG4gICAgICAgICAgICAgICAgY2x1c3RlclNpemVzW2pdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgbGV0IG1pbmRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgIGxldCBiZXN0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IGFicyQxKGNlbnRyb2lkc1tqXSAtIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5kaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5kaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QgPSBqO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJTaXplc1tiZXN0XSsrO1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ25tZW50c1tpXSA9IGJlc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgY2VudHJvaWRzIHN0ZXBcbiAgICAgICAgICAgIGNvbnN0IG5ld0NlbnRyb2lkcyA9IG5ldyBBcnJheShudW0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW07IGorKykge1xuICAgICAgICAgICAgICAgIG5ld0NlbnRyb2lkc1tqXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGNsdXN0ZXIgPSBhc3NpZ25tZW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2VudHJvaWRzW2NsdXN0ZXJdID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NlbnRyb2lkc1tjbHVzdGVyXSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdDZW50cm9pZHNbY2x1c3Rlcl0gKz0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtOyBqKyspIHtcbiAgICAgICAgICAgICAgICBuZXdDZW50cm9pZHNbal0gKj0gMSAvIGNsdXN0ZXJTaXplc1tqXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgY29udmVyZ2VuY2VcbiAgICAgICAgICAgIHJlcGVhdCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW07IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChuZXdDZW50cm9pZHNbal0gIT09IGNlbnRyb2lkc1tqXSkge1xuICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNlbnRyb2lkcyA9IG5ld0NlbnRyb2lkcztcbiAgICAgICAgICAgIG5iX2l0ZXJzKys7XG5cbiAgICAgICAgICAgIGlmIChuYl9pdGVycyA+IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlcGVhdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluaXNoZWQgay1tZWFucyBjbHVzdGVyaW5nXG4gICAgICAgIC8vIHRoZSBuZXh0IHBhcnQgaXMgYm9ycm93ZWQgZnJvbSBnYWJyaWVsZmxvci5pdFxuICAgICAgICBjb25zdCBrQ2x1c3RlcnMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW07IGorKykge1xuICAgICAgICAgICAga0NsdXN0ZXJzW2pdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNsdXN0ZXIgPSBhc3NpZ25tZW50c1tpXTtcbiAgICAgICAgICAgIGtDbHVzdGVyc1tjbHVzdGVyXS5wdXNoKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRtcEtNZWFuc0JyZWFrcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bTsgaisrKSB7XG4gICAgICAgICAgICB0bXBLTWVhbnNCcmVha3MucHVzaChrQ2x1c3RlcnNbal1bMF0pO1xuICAgICAgICAgICAgdG1wS01lYW5zQnJlYWtzLnB1c2goa0NsdXN0ZXJzW2pdW2tDbHVzdGVyc1tqXS5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgdG1wS01lYW5zQnJlYWtzID0gdG1wS01lYW5zQnJlYWtzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgbGltaXRzLnB1c2godG1wS01lYW5zQnJlYWtzWzBdKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0bXBLTWVhbnNCcmVha3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0bXBLTWVhbnNCcmVha3NbaV07XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHYpICYmIGxpbWl0cy5pbmRleE9mKHYpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGxpbWl0cy5wdXNoKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW1pdHM7XG59XG5cbnZhciBjb250cmFzdCA9IChhLCBiKSA9PiB7XG4gICAgLy8gV0NBRyBjb250cmFzdCByYXRpb1xuICAgIC8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI2NvbnRyYXN0LXJhdGlvZGVmXG4gICAgYSA9IG5ldyBDb2xvcihhKTtcbiAgICBiID0gbmV3IENvbG9yKGIpO1xuICAgIGNvbnN0IGwxID0gYS5sdW1pbmFuY2UoKTtcbiAgICBjb25zdCBsMiA9IGIubHVtaW5hbmNlKCk7XG4gICAgcmV0dXJuIGwxID4gbDIgPyAobDEgKyAwLjA1KSAvIChsMiArIDAuMDUpIDogKGwyICsgMC4wNSkgLyAobDEgKyAwLjA1KTtcbn07XG5cbmNvbnN0IHsgc3FydCwgcG93LCBtaW4sIG1heDogbWF4JDEsIGF0YW4yLCBhYnMsIGNvcywgc2luLCBleHAsIFBJIH0gPSBNYXRoO1xuXG5mdW5jdGlvbiBkZWx0YUUgKGEsIGIsIEtsID0gMSwgS2MgPSAxLCBLaCA9IDEpIHtcbiAgICAvLyBEZWx0YSBFIChDSUUgMjAwMClcbiAgICAvLyBzZWUgaHR0cDovL3d3dy5icnVjZWxpbmRibG9vbS5jb20vaW5kZXguaHRtbD9FcW5fRGVsdGFFX0NJRTIwMDAuaHRtbFxuICAgIHZhciByYWQyZGVnID0gZnVuY3Rpb24gKHJhZCkge1xuICAgICAgICByZXR1cm4gKDM2MCAqIHJhZCkgLyAoMiAqIFBJKTtcbiAgICB9O1xuICAgIHZhciBkZWcycmFkID0gZnVuY3Rpb24gKGRlZykge1xuICAgICAgICByZXR1cm4gKDIgKiBQSSAqIGRlZykgLyAzNjA7XG4gICAgfTtcbiAgICBhID0gbmV3IENvbG9yKGEpO1xuICAgIGIgPSBuZXcgQ29sb3IoYik7XG4gICAgY29uc3QgW0wxLCBhMSwgYjFdID0gQXJyYXkuZnJvbShhLmxhYigpKTtcbiAgICBjb25zdCBbTDIsIGEyLCBiMl0gPSBBcnJheS5mcm9tKGIubGFiKCkpO1xuICAgIGNvbnN0IGF2Z0wgPSAoTDEgKyBMMikgLyAyO1xuICAgIGNvbnN0IEMxID0gc3FydChwb3coYTEsIDIpICsgcG93KGIxLCAyKSk7XG4gICAgY29uc3QgQzIgPSBzcXJ0KHBvdyhhMiwgMikgKyBwb3coYjIsIDIpKTtcbiAgICBjb25zdCBhdmdDID0gKEMxICsgQzIpIC8gMjtcbiAgICBjb25zdCBHID0gMC41ICogKDEgLSBzcXJ0KHBvdyhhdmdDLCA3KSAvIChwb3coYXZnQywgNykgKyBwb3coMjUsIDcpKSkpO1xuICAgIGNvbnN0IGExcCA9IGExICogKDEgKyBHKTtcbiAgICBjb25zdCBhMnAgPSBhMiAqICgxICsgRyk7XG4gICAgY29uc3QgQzFwID0gc3FydChwb3coYTFwLCAyKSArIHBvdyhiMSwgMikpO1xuICAgIGNvbnN0IEMycCA9IHNxcnQocG93KGEycCwgMikgKyBwb3coYjIsIDIpKTtcbiAgICBjb25zdCBhdmdDcCA9IChDMXAgKyBDMnApIC8gMjtcbiAgICBjb25zdCBhcmN0YW4xID0gcmFkMmRlZyhhdGFuMihiMSwgYTFwKSk7XG4gICAgY29uc3QgYXJjdGFuMiA9IHJhZDJkZWcoYXRhbjIoYjIsIGEycCkpO1xuICAgIGNvbnN0IGgxcCA9IGFyY3RhbjEgPj0gMCA/IGFyY3RhbjEgOiBhcmN0YW4xICsgMzYwO1xuICAgIGNvbnN0IGgycCA9IGFyY3RhbjIgPj0gMCA/IGFyY3RhbjIgOiBhcmN0YW4yICsgMzYwO1xuICAgIGNvbnN0IGF2Z0hwID1cbiAgICAgICAgYWJzKGgxcCAtIGgycCkgPiAxODAgPyAoaDFwICsgaDJwICsgMzYwKSAvIDIgOiAoaDFwICsgaDJwKSAvIDI7XG4gICAgY29uc3QgVCA9XG4gICAgICAgIDEgLVxuICAgICAgICAwLjE3ICogY29zKGRlZzJyYWQoYXZnSHAgLSAzMCkpICtcbiAgICAgICAgMC4yNCAqIGNvcyhkZWcycmFkKDIgKiBhdmdIcCkpICtcbiAgICAgICAgMC4zMiAqIGNvcyhkZWcycmFkKDMgKiBhdmdIcCArIDYpKSAtXG4gICAgICAgIDAuMiAqIGNvcyhkZWcycmFkKDQgKiBhdmdIcCAtIDYzKSk7XG4gICAgbGV0IGRlbHRhSHAgPSBoMnAgLSBoMXA7XG4gICAgZGVsdGFIcCA9XG4gICAgICAgIGFicyhkZWx0YUhwKSA8PSAxODBcbiAgICAgICAgICAgID8gZGVsdGFIcFxuICAgICAgICAgICAgOiBoMnAgPD0gaDFwXG4gICAgICAgICAgICAgID8gZGVsdGFIcCArIDM2MFxuICAgICAgICAgICAgICA6IGRlbHRhSHAgLSAzNjA7XG4gICAgZGVsdGFIcCA9IDIgKiBzcXJ0KEMxcCAqIEMycCkgKiBzaW4oZGVnMnJhZChkZWx0YUhwKSAvIDIpO1xuICAgIGNvbnN0IGRlbHRhTCA9IEwyIC0gTDE7XG4gICAgY29uc3QgZGVsdGFDcCA9IEMycCAtIEMxcDtcbiAgICBjb25zdCBzbCA9IDEgKyAoMC4wMTUgKiBwb3coYXZnTCAtIDUwLCAyKSkgLyBzcXJ0KDIwICsgcG93KGF2Z0wgLSA1MCwgMikpO1xuICAgIGNvbnN0IHNjID0gMSArIDAuMDQ1ICogYXZnQ3A7XG4gICAgY29uc3Qgc2ggPSAxICsgMC4wMTUgKiBhdmdDcCAqIFQ7XG4gICAgY29uc3QgZGVsdGFUaGV0YSA9IDMwICogZXhwKC1wb3coKGF2Z0hwIC0gMjc1KSAvIDI1LCAyKSk7XG4gICAgY29uc3QgUmMgPSAyICogc3FydChwb3coYXZnQ3AsIDcpIC8gKHBvdyhhdmdDcCwgNykgKyBwb3coMjUsIDcpKSk7XG4gICAgY29uc3QgUnQgPSAtUmMgKiBzaW4oMiAqIGRlZzJyYWQoZGVsdGFUaGV0YSkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHNxcnQoXG4gICAgICAgIHBvdyhkZWx0YUwgLyAoS2wgKiBzbCksIDIpICtcbiAgICAgICAgICAgIHBvdyhkZWx0YUNwIC8gKEtjICogc2MpLCAyKSArXG4gICAgICAgICAgICBwb3coZGVsdGFIcCAvIChLaCAqIHNoKSwgMikgK1xuICAgICAgICAgICAgUnQgKiAoZGVsdGFDcCAvIChLYyAqIHNjKSkgKiAoZGVsdGFIcCAvIChLaCAqIHNoKSlcbiAgICApO1xuICAgIHJldHVybiBtYXgkMSgwLCBtaW4oMTAwLCByZXN1bHQpKTtcbn1cblxuLy8gc2ltcGxlIEV1Y2xpZGVhbiBkaXN0YW5jZVxuZnVuY3Rpb24gZGlzdGFuY2UgKGEsIGIsIG1vZGUgPSAnbGFiJykge1xuICAgIC8vIERlbHRhIEUgKENJRSAxOTc2KVxuICAgIC8vIHNlZSBodHRwOi8vd3d3LmJydWNlbGluZGJsb29tLmNvbS9pbmRleC5odG1sP0VxdWF0aW9ucy5odG1sXG4gICAgYSA9IG5ldyBDb2xvcihhKTtcbiAgICBiID0gbmV3IENvbG9yKGIpO1xuICAgIGNvbnN0IGwxID0gYS5nZXQobW9kZSk7XG4gICAgY29uc3QgbDIgPSBiLmdldChtb2RlKTtcbiAgICBsZXQgc3VtX3NxID0gMDtcbiAgICBmb3IgKGxldCBpIGluIGwxKSB7XG4gICAgICAgIGNvbnN0IGQgPSAobDFbaV0gfHwgMCkgLSAobDJbaV0gfHwgMCk7XG4gICAgICAgIHN1bV9zcSArPSBkICogZDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguc3FydChzdW1fc3EpO1xufVxuXG52YXIgdmFsaWQgPSAoLi4uYXJncykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBDb2xvciguLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbi8vIHNvbWUgcHJlLWRlZmluZWQgY29sb3Igc2NhbGVzOlxuXG52YXIgc2NhbGVzID0ge1xuICAgIGNvb2woKSB7XG4gICAgICAgIHJldHVybiBzY2FsZShbY2hyb21hLmhzbCgxODAsIDEsIDAuOSksIGNocm9tYS5oc2woMjUwLCAwLjcsIDAuNCldKTtcbiAgICB9LFxuICAgIGhvdCgpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlKFsnIzAwMCcsICcjZjAwJywgJyNmZjAnLCAnI2ZmZiddKS5tb2RlKFxuICAgICAgICAgICAgJ3JnYidcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG4vKipcbiAgICBDb2xvckJyZXdlciBjb2xvcnMgZm9yIGNocm9tYS5qc1xuXG4gICAgQ29weXJpZ2h0IChjKSAyMDAyIEN5bnRoaWEgQnJld2VyLCBNYXJrIEhhcnJvd2VyLCBhbmQgVGhlXG4gICAgUGVubnN5bHZhbmlhIFN0YXRlIFVuaXZlcnNpdHkuXG5cbiAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWRcbiAgICB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUlxuICAgIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gICAgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmNvbnN0IGNvbG9yYnJld2VyID0ge1xuICAgIC8vIHNlcXVlbnRpYWxcbiAgICBPclJkOiBbJyNmZmY3ZWMnLCAnI2ZlZThjOCcsICcjZmRkNDllJywgJyNmZGJiODQnLCAnI2ZjOGQ1OScsICcjZWY2NTQ4JywgJyNkNzMwMWYnLCAnI2IzMDAwMCcsICcjN2YwMDAwJ10sXG4gICAgUHVCdTogWycjZmZmN2ZiJywgJyNlY2U3ZjInLCAnI2QwZDFlNicsICcjYTZiZGRiJywgJyM3NGE5Y2YnLCAnIzM2OTBjMCcsICcjMDU3MGIwJywgJyMwNDVhOGQnLCAnIzAyMzg1OCddLFxuICAgIEJ1UHU6IFsnI2Y3ZmNmZCcsICcjZTBlY2Y0JywgJyNiZmQzZTYnLCAnIzllYmNkYScsICcjOGM5NmM2JywgJyM4YzZiYjEnLCAnIzg4NDE5ZCcsICcjODEwZjdjJywgJyM0ZDAwNGInXSxcbiAgICBPcmFuZ2VzOiBbJyNmZmY1ZWInLCAnI2ZlZTZjZScsICcjZmRkMGEyJywgJyNmZGFlNmInLCAnI2ZkOGQzYycsICcjZjE2OTEzJywgJyNkOTQ4MDEnLCAnI2E2MzYwMycsICcjN2YyNzA0J10sXG4gICAgQnVHbjogWycjZjdmY2ZkJywgJyNlNWY1ZjknLCAnI2NjZWNlNicsICcjOTlkOGM5JywgJyM2NmMyYTQnLCAnIzQxYWU3NicsICcjMjM4YjQ1JywgJyMwMDZkMmMnLCAnIzAwNDQxYiddLFxuICAgIFlsT3JCcjogWycjZmZmZmU1JywgJyNmZmY3YmMnLCAnI2ZlZTM5MScsICcjZmVjNDRmJywgJyNmZTk5MjknLCAnI2VjNzAxNCcsICcjY2M0YzAyJywgJyM5OTM0MDQnLCAnIzY2MjUwNiddLFxuICAgIFlsR246IFsnI2ZmZmZlNScsICcjZjdmY2I5JywgJyNkOWYwYTMnLCAnI2FkZGQ4ZScsICcjNzhjNjc5JywgJyM0MWFiNWQnLCAnIzIzODQ0MycsICcjMDA2ODM3JywgJyMwMDQ1MjknXSxcbiAgICBSZWRzOiBbJyNmZmY1ZjAnLCAnI2ZlZTBkMicsICcjZmNiYmExJywgJyNmYzkyNzInLCAnI2ZiNmE0YScsICcjZWYzYjJjJywgJyNjYjE4MWQnLCAnI2E1MGYxNScsICcjNjcwMDBkJ10sXG4gICAgUmRQdTogWycjZmZmN2YzJywgJyNmZGUwZGQnLCAnI2ZjYzVjMCcsICcjZmE5ZmI1JywgJyNmNzY4YTEnLCAnI2RkMzQ5NycsICcjYWUwMTdlJywgJyM3YTAxNzcnLCAnIzQ5MDA2YSddLFxuICAgIEdyZWVuczogWycjZjdmY2Y1JywgJyNlNWY1ZTAnLCAnI2M3ZTljMCcsICcjYTFkOTliJywgJyM3NGM0NzYnLCAnIzQxYWI1ZCcsICcjMjM4YjQ1JywgJyMwMDZkMmMnLCAnIzAwNDQxYiddLFxuICAgIFlsR25CdTogWycjZmZmZmQ5JywgJyNlZGY4YjEnLCAnI2M3ZTliNCcsICcjN2ZjZGJiJywgJyM0MWI2YzQnLCAnIzFkOTFjMCcsICcjMjI1ZWE4JywgJyMyNTM0OTQnLCAnIzA4MWQ1OCddLFxuICAgIFB1cnBsZXM6IFsnI2ZjZmJmZCcsICcjZWZlZGY1JywgJyNkYWRhZWInLCAnI2JjYmRkYycsICcjOWU5YWM4JywgJyM4MDdkYmEnLCAnIzZhNTFhMycsICcjNTQyNzhmJywgJyMzZjAwN2QnXSxcbiAgICBHbkJ1OiBbJyNmN2ZjZjAnLCAnI2UwZjNkYicsICcjY2NlYmM1JywgJyNhOGRkYjUnLCAnIzdiY2NjNCcsICcjNGViM2QzJywgJyMyYjhjYmUnLCAnIzA4NjhhYycsICcjMDg0MDgxJ10sXG4gICAgR3JleXM6IFsnI2ZmZmZmZicsICcjZjBmMGYwJywgJyNkOWQ5ZDknLCAnI2JkYmRiZCcsICcjOTY5Njk2JywgJyM3MzczNzMnLCAnIzUyNTI1MicsICcjMjUyNTI1JywgJyMwMDAwMDAnXSxcbiAgICBZbE9yUmQ6IFsnI2ZmZmZjYycsICcjZmZlZGEwJywgJyNmZWQ5NzYnLCAnI2ZlYjI0YycsICcjZmQ4ZDNjJywgJyNmYzRlMmEnLCAnI2UzMWExYycsICcjYmQwMDI2JywgJyM4MDAwMjYnXSxcbiAgICBQdVJkOiBbJyNmN2Y0ZjknLCAnI2U3ZTFlZicsICcjZDRiOWRhJywgJyNjOTk0YzcnLCAnI2RmNjViMCcsICcjZTcyOThhJywgJyNjZTEyNTYnLCAnIzk4MDA0MycsICcjNjcwMDFmJ10sXG4gICAgQmx1ZXM6IFsnI2Y3ZmJmZicsICcjZGVlYmY3JywgJyNjNmRiZWYnLCAnIzllY2FlMScsICcjNmJhZWQ2JywgJyM0MjkyYzYnLCAnIzIxNzFiNScsICcjMDg1MTljJywgJyMwODMwNmInXSxcbiAgICBQdUJ1R246IFsnI2ZmZjdmYicsICcjZWNlMmYwJywgJyNkMGQxZTYnLCAnI2E2YmRkYicsICcjNjdhOWNmJywgJyMzNjkwYzAnLCAnIzAyODE4YScsICcjMDE2YzU5JywgJyMwMTQ2MzYnXSxcbiAgICBWaXJpZGlzOiBbJyM0NDAxNTQnLCAnIzQ4Mjc3NycsICcjM2Y0YThhJywgJyMzMTY3OGUnLCAnIzI2ODM4ZicsICcjMWY5ZDhhJywgJyM2Y2NlNWEnLCAnI2I2ZGUyYicsICcjZmVlODI1J10sXG5cbiAgICAvLyBkaXZlcmdpbmdcbiAgICBTcGVjdHJhbDogWycjOWUwMTQyJywgJyNkNTNlNGYnLCAnI2Y0NmQ0MycsICcjZmRhZTYxJywgJyNmZWUwOGInLCAnI2ZmZmZiZicsICcjZTZmNTk4JywgJyNhYmRkYTQnLCAnIzY2YzJhNScsICcjMzI4OGJkJywgJyM1ZTRmYTInXSxcbiAgICBSZFlsR246IFsnI2E1MDAyNicsICcjZDczMDI3JywgJyNmNDZkNDMnLCAnI2ZkYWU2MScsICcjZmVlMDhiJywgJyNmZmZmYmYnLCAnI2Q5ZWY4YicsICcjYTZkOTZhJywgJyM2NmJkNjMnLCAnIzFhOTg1MCcsICcjMDA2ODM3J10sXG4gICAgUmRCdTogWycjNjcwMDFmJywgJyNiMjE4MmInLCAnI2Q2NjA0ZCcsICcjZjRhNTgyJywgJyNmZGRiYzcnLCAnI2Y3ZjdmNycsICcjZDFlNWYwJywgJyM5MmM1ZGUnLCAnIzQzOTNjMycsICcjMjE2NmFjJywgJyMwNTMwNjEnXSxcbiAgICBQaVlHOiBbJyM4ZTAxNTInLCAnI2M1MWI3ZCcsICcjZGU3N2FlJywgJyNmMWI2ZGEnLCAnI2ZkZTBlZicsICcjZjdmN2Y3JywgJyNlNmY1ZDAnLCAnI2I4ZTE4NicsICcjN2ZiYzQxJywgJyM0ZDkyMjEnLCAnIzI3NjQxOSddLFxuICAgIFBSR246IFsnIzQwMDA0YicsICcjNzYyYTgzJywgJyM5OTcwYWInLCAnI2MyYTVjZicsICcjZTdkNGU4JywgJyNmN2Y3ZjcnLCAnI2Q5ZjBkMycsICcjYTZkYmEwJywgJyM1YWFlNjEnLCAnIzFiNzgzNycsICcjMDA0NDFiJ10sXG4gICAgUmRZbEJ1OiBbJyNhNTAwMjYnLCAnI2Q3MzAyNycsICcjZjQ2ZDQzJywgJyNmZGFlNjEnLCAnI2ZlZTA5MCcsICcjZmZmZmJmJywgJyNlMGYzZjgnLCAnI2FiZDllOScsICcjNzRhZGQxJywgJyM0NTc1YjQnLCAnIzMxMzY5NSddLFxuICAgIEJyQkc6IFsnIzU0MzAwNScsICcjOGM1MTBhJywgJyNiZjgxMmQnLCAnI2RmYzI3ZCcsICcjZjZlOGMzJywgJyNmNWY1ZjUnLCAnI2M3ZWFlNScsICcjODBjZGMxJywgJyMzNTk3OGYnLCAnIzAxNjY1ZScsICcjMDAzYzMwJ10sXG4gICAgUmRHeTogWycjNjcwMDFmJywgJyNiMjE4MmInLCAnI2Q2NjA0ZCcsICcjZjRhNTgyJywgJyNmZGRiYzcnLCAnI2ZmZmZmZicsICcjZTBlMGUwJywgJyNiYWJhYmEnLCAnIzg3ODc4NycsICcjNGQ0ZDRkJywgJyMxYTFhMWEnXSxcbiAgICBQdU9yOiBbJyM3ZjNiMDgnLCAnI2IzNTgwNicsICcjZTA4MjE0JywgJyNmZGI4NjMnLCAnI2ZlZTBiNicsICcjZjdmN2Y3JywgJyNkOGRhZWInLCAnI2IyYWJkMicsICcjODA3M2FjJywgJyM1NDI3ODgnLCAnIzJkMDA0YiddLFxuXG4gICAgLy8gcXVhbGl0YXRpdmVcbiAgICBTZXQyOiBbJyM2NmMyYTUnLCAnI2ZjOGQ2MicsICcjOGRhMGNiJywgJyNlNzhhYzMnLCAnI2E2ZDg1NCcsICcjZmZkOTJmJywgJyNlNWM0OTQnLCAnI2IzYjNiMyddLFxuICAgIEFjY2VudDogWycjN2ZjOTdmJywgJyNiZWFlZDQnLCAnI2ZkYzA4NicsICcjZmZmZjk5JywgJyMzODZjYjAnLCAnI2YwMDI3ZicsICcjYmY1YjE3JywgJyM2NjY2NjYnXSxcbiAgICBTZXQxOiBbJyNlNDFhMWMnLCAnIzM3N2ViOCcsICcjNGRhZjRhJywgJyM5ODRlYTMnLCAnI2ZmN2YwMCcsICcjZmZmZjMzJywgJyNhNjU2MjgnLCAnI2Y3ODFiZicsICcjOTk5OTk5J10sXG4gICAgU2V0MzogWycjOGRkM2M3JywgJyNmZmZmYjMnLCAnI2JlYmFkYScsICcjZmI4MDcyJywgJyM4MGIxZDMnLCAnI2ZkYjQ2MicsICcjYjNkZTY5JywgJyNmY2NkZTUnLCAnI2Q5ZDlkOScsICcjYmM4MGJkJywgJyNjY2ViYzUnLCAnI2ZmZWQ2ZiddLFxuICAgIERhcmsyOiBbJyMxYjllNzcnLCAnI2Q5NWYwMicsICcjNzU3MGIzJywgJyNlNzI5OGEnLCAnIzY2YTYxZScsICcjZTZhYjAyJywgJyNhNjc2MWQnLCAnIzY2NjY2NiddLFxuICAgIFBhaXJlZDogWycjYTZjZWUzJywgJyMxZjc4YjQnLCAnI2IyZGY4YScsICcjMzNhMDJjJywgJyNmYjlhOTknLCAnI2UzMWExYycsICcjZmRiZjZmJywgJyNmZjdmMDAnLCAnI2NhYjJkNicsICcjNmEzZDlhJywgJyNmZmZmOTknLCAnI2IxNTkyOCddLFxuICAgIFBhc3RlbDI6IFsnI2IzZTJjZCcsICcjZmRjZGFjJywgJyNjYmQ1ZTgnLCAnI2Y0Y2FlNCcsICcjZTZmNWM5JywgJyNmZmYyYWUnLCAnI2YxZTJjYycsICcjY2NjY2NjJ10sXG4gICAgUGFzdGVsMTogWycjZmJiNGFlJywgJyNiM2NkZTMnLCAnI2NjZWJjNScsICcjZGVjYmU0JywgJyNmZWQ5YTYnLCAnI2ZmZmZjYycsICcjZTVkOGJkJywgJyNmZGRhZWMnLCAnI2YyZjJmMiddXG59O1xuXG4vLyBhZGQgbG93ZXJjYXNlIGFsaWFzZXMgZm9yIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hlc1xuZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKGNvbG9yYnJld2VyKSkge1xuICAgIGNvbG9yYnJld2VyW2tleS50b0xvd2VyQ2FzZSgpXSA9IGNvbG9yYnJld2VyW2tleV07XG59XG5cbmNvbnN0IGNteWsycmdiID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhcmdzID0gdW5wYWNrKGFyZ3MsICdjbXlrJyk7XG4gICAgY29uc3QgW2MsIG0sIHksIGtdID0gYXJncztcbiAgICBjb25zdCBhbHBoYSA9IGFyZ3MubGVuZ3RoID4gNCA/IGFyZ3NbNF0gOiAxO1xuICAgIGlmIChrID09PSAxKSByZXR1cm4gWzAsIDAsIDAsIGFscGhhXTtcbiAgICByZXR1cm4gW1xuICAgICAgICBjID49IDEgPyAwIDogMjU1ICogKDEgLSBjKSAqICgxIC0gayksIC8vIHJcbiAgICAgICAgbSA+PSAxID8gMCA6IDI1NSAqICgxIC0gbSkgKiAoMSAtIGspLCAvLyBnXG4gICAgICAgIHkgPj0gMSA/IDAgOiAyNTUgKiAoMSAtIHkpICogKDEgLSBrKSwgLy8gYlxuICAgICAgICBhbHBoYVxuICAgIF07XG59O1xuXG5jb25zdCB7IG1heCB9ID0gTWF0aDtcblxuY29uc3QgcmdiMmNteWsgPSAoLi4uYXJncykgPT4ge1xuICAgIGxldCBbciwgZywgYl0gPSB1bnBhY2soYXJncywgJ3JnYicpO1xuICAgIHIgPSByIC8gMjU1O1xuICAgIGcgPSBnIC8gMjU1O1xuICAgIGIgPSBiIC8gMjU1O1xuICAgIGNvbnN0IGsgPSAxIC0gbWF4KHIsIG1heChnLCBiKSk7XG4gICAgY29uc3QgZiA9IGsgPCAxID8gMSAvICgxIC0gaykgOiAwO1xuICAgIGNvbnN0IGMgPSAoMSAtIHIgLSBrKSAqIGY7XG4gICAgY29uc3QgbSA9ICgxIC0gZyAtIGspICogZjtcbiAgICBjb25zdCB5ID0gKDEgLSBiIC0gaykgKiBmO1xuICAgIHJldHVybiBbYywgbSwgeSwga107XG59O1xuXG5Db2xvci5wcm90b3R5cGUuY215ayA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmdiMmNteWsodGhpcy5fcmdiKTtcbn07XG5cbmNvbnN0IGNteWsgPSAoLi4uYXJncykgPT4gbmV3IENvbG9yKC4uLmFyZ3MsICdjbXlrJyk7XG5PYmplY3QuYXNzaWduKGNocm9tYSwgeyBjbXlrIH0pO1xuXG5pbnB1dC5mb3JtYXQuY215ayA9IGNteWsycmdiO1xuXG5pbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDIsXG4gICAgdGVzdDogKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgYXJncyA9IHVucGFjayhhcmdzLCAnY215aycpO1xuICAgICAgICBpZiAodHlwZShhcmdzKSA9PT0gJ2FycmF5JyAmJiBhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuICdjbXlrJztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKlxuICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAqIC0gaHNsMmNzcyhoLHMsbClcbiAqIC0gaHNsMmNzcyhoLHMsbCxhKVxuICogLSBoc2wyY3NzKFtoLHMsbF0sIG1vZGUpXG4gKiAtIGhzbDJjc3MoW2gscyxsLGFdLCBtb2RlKVxuICogLSBoc2wyY3NzKHtoLHMsbCxhfSwgbW9kZSlcbiAqL1xuY29uc3QgaHNsMmNzcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgaHNsYSA9IHVucGFjayhhcmdzLCAnaHNsYScpO1xuICAgIGxldCBtb2RlID0gbGFzdChhcmdzKSB8fCAnbHNhJztcbiAgICBoc2xhWzBdID0gcm5kMihoc2xhWzBdIHx8IDApICsgJ2RlZyc7XG4gICAgaHNsYVsxXSA9IHJuZDIoaHNsYVsxXSAqIDEwMCkgKyAnJSc7XG4gICAgaHNsYVsyXSA9IHJuZDIoaHNsYVsyXSAqIDEwMCkgKyAnJSc7XG4gICAgaWYgKG1vZGUgPT09ICdoc2xhJyB8fCAoaHNsYS5sZW5ndGggPiAzICYmIGhzbGFbM10gPCAxKSkge1xuICAgICAgICBoc2xhWzNdID0gJy8gJyArIChoc2xhLmxlbmd0aCA+IDMgPyBoc2xhWzNdIDogMSk7XG4gICAgICAgIG1vZGUgPSAnaHNsYSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaHNsYS5sZW5ndGggPSAzO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bW9kZS5zdWJzdHIoMCwgMyl9KCR7aHNsYS5qb2luKCcgJyl9KWA7XG59O1xuXG4vKlxuICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAqIC0gbGFiMmNzcyhsLGEsYilcbiAqIC0gbGFiMmNzcyhsLGEsYixhbHBoYSlcbiAqIC0gbGFiMmNzcyhbbCxhLGJdLCBtb2RlKVxuICogLSBsYWIyY3NzKFtsLGEsYixhbHBoYV0sIG1vZGUpXG4gKi9cbmNvbnN0IGxhYjJjc3MgPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGxhYmEgPSB1bnBhY2soYXJncywgJ2xhYicpO1xuICAgIGxldCBtb2RlID0gbGFzdChhcmdzKSB8fCAnbGFiJztcbiAgICBsYWJhWzBdID0gcm5kMihsYWJhWzBdKSArICclJztcbiAgICBsYWJhWzFdID0gcm5kMihsYWJhWzFdKTtcbiAgICBsYWJhWzJdID0gcm5kMihsYWJhWzJdKTtcbiAgICBpZiAobW9kZSA9PT0gJ2xhYmEnIHx8IChsYWJhLmxlbmd0aCA+IDMgJiYgbGFiYVszXSA8IDEpKSB7XG4gICAgICAgIGxhYmFbM10gPSAnLyAnICsgKGxhYmEubGVuZ3RoID4gMyA/IGxhYmFbM10gOiAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsYWJhLmxlbmd0aCA9IDM7XG4gICAgfVxuICAgIHJldHVybiBgbGFiKCR7bGFiYS5qb2luKCcgJyl9KWA7XG59O1xuXG4vKlxuICogc3VwcG9ydGVkIGFyZ3VtZW50czpcbiAqIC0gbGFiMmNzcyhsLGEsYilcbiAqIC0gbGFiMmNzcyhsLGEsYixhbHBoYSlcbiAqIC0gbGFiMmNzcyhbbCxhLGJdLCBtb2RlKVxuICogLSBsYWIyY3NzKFtsLGEsYixhbHBoYV0sIG1vZGUpXG4gKi9cbmNvbnN0IGxjaDJjc3MgPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGxjaGEgPSB1bnBhY2soYXJncywgJ2xjaCcpO1xuICAgIGxldCBtb2RlID0gbGFzdChhcmdzKSB8fCAnbGFiJztcbiAgICBsY2hhWzBdID0gcm5kMihsY2hhWzBdKSArICclJztcbiAgICBsY2hhWzFdID0gcm5kMihsY2hhWzFdKTtcbiAgICBsY2hhWzJdID0gcm5kMihsY2hhWzJdKSArICdkZWcnOyAvLyBhZGQgZGVnIHVuaXQgdG8gaHVlXG4gICAgaWYgKG1vZGUgPT09ICdsY2hhJyB8fCAobGNoYS5sZW5ndGggPiAzICYmIGxjaGFbM10gPCAxKSkge1xuICAgICAgICBsY2hhWzNdID0gJy8gJyArIChsY2hhLmxlbmd0aCA+IDMgPyBsY2hhWzNdIDogMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGNoYS5sZW5ndGggPSAzO1xuICAgIH1cbiAgICByZXR1cm4gYGxjaCgke2xjaGEuam9pbignICcpfSlgO1xufTtcblxuY29uc3Qgb2tsYWIyY3NzJDEgPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGxhYmEgPSB1bnBhY2soYXJncywgJ2xhYicpO1xuICAgIGxhYmFbMF0gPSBybmQyKGxhYmFbMF0gKiAxMDApICsgJyUnO1xuICAgIGxhYmFbMV0gPSBybmQzKGxhYmFbMV0pO1xuICAgIGxhYmFbMl0gPSBybmQzKGxhYmFbMl0pO1xuICAgIGlmIChsYWJhLmxlbmd0aCA+IDMgJiYgbGFiYVszXSA8IDEpIHtcbiAgICAgICAgbGFiYVszXSA9ICcvICcgKyAobGFiYS5sZW5ndGggPiAzID8gbGFiYVszXSA6IDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmEubGVuZ3RoID0gMztcbiAgICB9XG4gICAgcmV0dXJuIGBva2xhYigke2xhYmEuam9pbignICcpfSlgO1xufTtcblxuY29uc3QgcmdiMm9rbGNoID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBbciwgZywgYiwgLi4ucmVzdF0gPSB1bnBhY2soYXJncywgJ3JnYicpO1xuICAgIGNvbnN0IFtsLCBhLCBiX10gPSByZ2Iyb2tsYWIociwgZywgYik7XG4gICAgY29uc3QgW0wsIGMsIGhdID0gbGFiMmxjaChsLCBhLCBiXyk7XG4gICAgcmV0dXJuIFtMLCBjLCBoLCAuLi4ocmVzdC5sZW5ndGggPiAwICYmIHJlc3RbMF0gPCAxID8gW3Jlc3RbMF1dIDogW10pXTtcbn07XG5cbmNvbnN0IG9rbGFiMmNzcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgbGFiYSA9IHVucGFjayhhcmdzLCAnbGFiJyk7XG4gICAgbGFiYVswXSA9IHJuZDIobGFiYVswXSAqIDEwMCkgKyAnJSc7XG4gICAgbGFiYVsxXSA9IHJuZDMobGFiYVsxXSk7XG4gICAgbGFiYVsyXSA9IHJuZDIobGFiYVsyXSkgKyAnZGVnJztcbiAgICBpZiAobGFiYS5sZW5ndGggPiAzICYmIGxhYmFbM10gPCAxKSB7XG4gICAgICAgIGxhYmFbM10gPSAnLyAnICsgKGxhYmEubGVuZ3RoID4gMyA/IGxhYmFbM10gOiAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsYWJhLmxlbmd0aCA9IDM7XG4gICAgfVxuICAgIHJldHVybiBgb2tsY2goJHtsYWJhLmpvaW4oJyAnKX0pYDtcbn07XG5cbmNvbnN0IHsgcm91bmQ6IHJvdW5kJDIgfSA9IE1hdGg7XG5cbi8qXG4gKiBzdXBwb3J0ZWQgYXJndW1lbnRzOlxuICogLSByZ2IyY3NzKHIsZyxiKVxuICogLSByZ2IyY3NzKHIsZyxiLGEpXG4gKiAtIHJnYjJjc3MoW3IsZyxiXSwgbW9kZSlcbiAqIC0gcmdiMmNzcyhbcixnLGIsYV0sIG1vZGUpXG4gKiAtIHJnYjJjc3Moe3IsZyxiLGF9LCBtb2RlKVxuICovXG5jb25zdCByZ2IyY3NzID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCByZ2JhID0gdW5wYWNrKGFyZ3MsICdyZ2JhJyk7XG4gICAgbGV0IG1vZGUgPSBsYXN0KGFyZ3MpIHx8ICdyZ2InO1xuICAgIGlmIChtb2RlLnN1YnN0cigwLCAzKSA9PT0gJ2hzbCcpIHtcbiAgICAgICAgcmV0dXJuIGhzbDJjc3MocmdiMmhzbCQxKHJnYmEpLCBtb2RlKTtcbiAgICB9XG4gICAgaWYgKG1vZGUuc3Vic3RyKDAsIDMpID09PSAnbGFiJykge1xuICAgICAgICAvLyBjaGFuZ2UgdG8gRDUwIGxhYiB3aGl0ZXBvaW50IHNpbmNlIHRoaXMgaXMgd2hhdCBXM0MgaXMgdXNpbmcgZm9yIENTUyBMYWIgY29sb3JzXG4gICAgICAgIGNvbnN0IHByZXZXaGl0ZVBvaW50ID0gZ2V0TGFiV2hpdGVQb2ludCgpO1xuICAgICAgICBzZXRMYWJXaGl0ZVBvaW50KCdkNTAnKTtcbiAgICAgICAgY29uc3QgY3NzQ29sb3IgPSBsYWIyY3NzKHJnYjJsYWIocmdiYSksIG1vZGUpO1xuICAgICAgICBzZXRMYWJXaGl0ZVBvaW50KHByZXZXaGl0ZVBvaW50KTtcbiAgICAgICAgcmV0dXJuIGNzc0NvbG9yO1xuICAgIH1cbiAgICBpZiAobW9kZS5zdWJzdHIoMCwgMykgPT09ICdsY2gnKSB7XG4gICAgICAgIC8vIGNoYW5nZSB0byBENTAgbGFiIHdoaXRlcG9pbnQgc2luY2UgdGhpcyBpcyB3aGF0IFczQyBpcyB1c2luZyBmb3IgQ1NTIExhYiBjb2xvcnNcbiAgICAgICAgY29uc3QgcHJldldoaXRlUG9pbnQgPSBnZXRMYWJXaGl0ZVBvaW50KCk7XG4gICAgICAgIHNldExhYldoaXRlUG9pbnQoJ2Q1MCcpO1xuICAgICAgICBjb25zdCBjc3NDb2xvciA9IGxjaDJjc3MocmdiMmxjaChyZ2JhKSwgbW9kZSk7XG4gICAgICAgIHNldExhYldoaXRlUG9pbnQocHJldldoaXRlUG9pbnQpO1xuICAgICAgICByZXR1cm4gY3NzQ29sb3I7XG4gICAgfVxuICAgIGlmIChtb2RlLnN1YnN0cigwLCA1KSA9PT0gJ29rbGFiJykge1xuICAgICAgICByZXR1cm4gb2tsYWIyY3NzJDEocmdiMm9rbGFiKHJnYmEpKTtcbiAgICB9XG4gICAgaWYgKG1vZGUuc3Vic3RyKDAsIDUpID09PSAnb2tsY2gnKSB7XG4gICAgICAgIHJldHVybiBva2xhYjJjc3MocmdiMm9rbGNoKHJnYmEpKTtcbiAgICB9XG4gICAgcmdiYVswXSA9IHJvdW5kJDIocmdiYVswXSk7XG4gICAgcmdiYVsxXSA9IHJvdW5kJDIocmdiYVsxXSk7XG4gICAgcmdiYVsyXSA9IHJvdW5kJDIocmdiYVsyXSk7XG4gICAgaWYgKG1vZGUgPT09ICdyZ2JhJyB8fCAocmdiYS5sZW5ndGggPiAzICYmIHJnYmFbM10gPCAxKSkge1xuICAgICAgICByZ2JhWzNdID0gJy8gJyArIChyZ2JhLmxlbmd0aCA+IDMgPyByZ2JhWzNdIDogMSk7XG4gICAgICAgIG1vZGUgPSAncmdiYSc7XG4gICAgfVxuICAgIHJldHVybiBgJHttb2RlLnN1YnN0cigwLCAzKX0oJHtyZ2JhLnNsaWNlKDAsIG1vZGUgPT09ICdyZ2InID8gMyA6IDQpLmpvaW4oJyAnKX0pYDtcbn07XG5cbmNvbnN0IG9rbGNoMnJnYiA9ICguLi5hcmdzKSA9PiB7XG4gICAgYXJncyA9IHVucGFjayhhcmdzLCAnbGNoJyk7XG4gICAgY29uc3QgW2wsIGMsIGgsIC4uLnJlc3RdID0gYXJncztcbiAgICBjb25zdCBbTCwgYSwgYl9dID0gbGNoMmxhYihsLCBjLCBoKTtcbiAgICBjb25zdCBbciwgZywgYl0gPSBva2xhYjJyZ2IoTCwgYSwgYl8pO1xuICAgIHJldHVybiBbciwgZywgYiwgLi4uKHJlc3QubGVuZ3RoID4gMCAmJiByZXN0WzBdIDwgMSA/IFtyZXN0WzBdXSA6IFtdKV07XG59O1xuXG5jb25zdCBSRV9SR0IgPSAvXnJnYlxcKFxccyooLT9cXGQrKSBcXHMqKC0/XFxkKylcXHMqIFxccyooLT9cXGQrKVxccypcXCkkLztcbmNvbnN0IFJFX1JHQl9MRUdBQ1kgPSAvXnJnYlxcKFxccyooLT9cXGQrKSxcXHMqKC0/XFxkKylcXHMqLFxccyooLT9cXGQrKVxccypcXCkkLztcblxuY29uc3QgUkVfUkdCQSA9XG4gICAgL15yZ2JhP1xcKFxccyooLT9cXGQrKSBcXHMqKC0/XFxkKylcXHMqIFxccyooLT9cXGQrKVxccypcXC9cXHMqKFswMV18WzAxXT9cXC5cXGQrKVxcKSQvO1xuY29uc3QgUkVfUkdCQV9MRUdBQ1kgPVxuICAgIC9ecmdiYVxcKFxccyooLT9cXGQrKSxcXHMqKC0/XFxkKylcXHMqLFxccyooLT9cXGQrKVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcblxuY29uc3QgUkVfUkdCX1BDVCA9XG4gICAgL15yZ2JcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklIFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqIFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqXFwpJC87XG5jb25zdCBSRV9SR0JfUENUX0xFR0FDWSA9XG4gICAgL15yZ2JcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqXFwpJC87XG5cbmNvbnN0IFJFX1JHQkFfUENUID1cbiAgICAvXnJnYmE/XFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJSBcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKiBcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKlxcL1xccyooWzAxXXxbMDFdP1xcLlxcZCspXFwpJC87XG5jb25zdCBSRV9SR0JBX1BDVF9MRUdBQ1kgPVxuICAgIC9ecmdiYVxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSUsXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKihbMDFdfFswMV0/XFwuXFxkKylcXCkkLztcblxuY29uc3QgUkVfSFNMID1cbiAgICAvXmhzbFxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KWRlZyBcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKiBcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKlxcKSQvO1xuY29uc3QgUkVfSFNMX0xFR0FDWSA9XG4gICAgL15oc2xcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyksXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkkLztcblxuY29uc3QgUkVfSFNMQSA9XG4gICAgL15oc2xhP1xcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/KWRlZyBcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKiBcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyklXFxzKlxcL1xccyooWzAxXXxbMDFdP1xcLlxcZCspXFwpJC87XG5jb25zdCBSRV9IU0xBX0xFR0FDWSA9XG4gICAgL15oc2xhXFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8pLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooLT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooWzAxXXxbMDFdP1xcLlxcZCspXFwpJC87XG5cbmNvbnN0IFJFX0xBQiA9XG4gICAgL15sYWJcXChcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyU/KSBcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyU/KSBcXHMqKC0/XFxkKyg/OlxcLlxcZCspPyU/KVxccyooPzpcXC9cXHMqKFxcZCsoPzpcXC5cXGQrKT8pKT9cXCk/JC87XG5jb25zdCBSRV9MQ0ggPVxuICAgIC9ebGNoXFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8lPykgXFxzKigoPzotP1xcZCsoPzpcXC5cXGQrKT8lPyl8bm9uZSkgXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8oPzpkZWcpP3xub25lKVxccyooPzpcXC9cXHMqKFxcZCsoPzpcXC5cXGQrKT8pKT9cXCk/JC87XG5jb25zdCBSRV9PS0xBQiA9XG4gICAgL15va2xhYlxcKFxccyooLT9cXGQrKD86XFwuXFxkKyk/JT8pIFxccyooLT9cXGQrKD86XFwuXFxkKyk/JT8pIFxccyooLT9cXGQrKD86XFwuXFxkKyk/JT8pXFxzKig/OlxcL1xccyooXFxkKyg/OlxcLlxcZCspPykpP1xcKT8kLztcbmNvbnN0IFJFX09LTENIID1cbiAgICAvXm9rbGNoXFwoXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8lPykgXFxzKig/OigtP1xcZCsoPzpcXC5cXGQrKT8lPyl8bm9uZSkgXFxzKigtP1xcZCsoPzpcXC5cXGQrKT8oPzpkZWcpP3xub25lKVxccyooPzpcXC9cXHMqKFxcZCsoPzpcXC5cXGQrKT8pKT9cXCk/JC87XG5cbmNvbnN0IHsgcm91bmQ6IHJvdW5kJDEgfSA9IE1hdGg7XG5cbmNvbnN0IHJvdW5kUkdCID0gKHJnYikgPT4ge1xuICAgIHJldHVybiByZ2IubWFwKCh2LCBpKSA9PiAoaSA8PSAyID8gbGltaXQocm91bmQkMSh2KSwgMCwgMjU1KSA6IHYpKTtcbn07XG5cbmNvbnN0IHBlcmNlbnRUb0Fic29sdXRlID0gKHBjdCwgbWluID0gMCwgbWF4ID0gMTAwLCBzaWduZWQgPSBmYWxzZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcGN0ID09PSAnc3RyaW5nJyAmJiBwY3QuZW5kc1dpdGgoJyUnKSkge1xuICAgICAgICBwY3QgPSBwYXJzZUZsb2F0KHBjdC5zdWJzdHJpbmcoMCwgcGN0Lmxlbmd0aCAtIDEpKSAvIDEwMDtcbiAgICAgICAgaWYgKHNpZ25lZCkge1xuICAgICAgICAgICAgLy8gc2lnbmVkIHBlcmNlbnRhZ2VzIGFyZSBpbiB0aGUgcmFuZ2UgLTEwMCUgdG8gMTAwJVxuICAgICAgICAgICAgcGN0ID0gbWluICsgKHBjdCArIDEpICogMC41ICogKG1heCAtIG1pbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwY3QgPSBtaW4gKyBwY3QgKiAobWF4IC0gbWluKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gK3BjdDtcbn07XG5cbmNvbnN0IG5vbmVUb1ZhbHVlID0gKHYsIG5vbmVWYWx1ZSkgPT4ge1xuICAgIHJldHVybiB2ID09PSAnbm9uZScgPyBub25lVmFsdWUgOiB2O1xufTtcblxuY29uc3QgY3NzMnJnYiA9IChjc3MpID0+IHtcbiAgICBjc3MgPSBjc3MudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgbGV0IG07XG5cbiAgICBpZiAoaW5wdXQuZm9ybWF0Lm5hbWVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuZm9ybWF0Lm5hbWVkKGNzcyk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICAvLyByZ2IoMjUwIDIwIDApIG9yIHJnYigyNTAsMjAsMClcbiAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfUkdCKSkgfHwgKG0gPSBjc3MubWF0Y2goUkVfUkdCX0xFR0FDWSkpKSB7XG4gICAgICAgIGNvbnN0IHJnYiA9IG0uc2xpY2UoMSwgNCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICByZ2JbaV0gPSArcmdiW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJnYlszXSA9IDE7IC8vIGRlZmF1bHQgYWxwaGFcbiAgICAgICAgcmV0dXJuIHJnYjtcbiAgICB9XG5cbiAgICAvLyByZ2JhKDI1MCwyMCwwLDAuNClcbiAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfUkdCQSkpIHx8IChtID0gY3NzLm1hdGNoKFJFX1JHQkFfTEVHQUNZKSkpIHtcbiAgICAgICAgY29uc3QgcmdiID0gbS5zbGljZSgxLCA1KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHJnYltpXSA9ICtyZ2JbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJnYjtcbiAgICB9XG5cbiAgICAvLyByZ2IoMTAwJSwwJSwwJSlcbiAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfUkdCX1BDVCkpIHx8IChtID0gY3NzLm1hdGNoKFJFX1JHQl9QQ1RfTEVHQUNZKSkpIHtcbiAgICAgICAgY29uc3QgcmdiID0gbS5zbGljZSgxLCA0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIHJnYltpXSA9IHJvdW5kJDEocmdiW2ldICogMi41NSk7XG4gICAgICAgIH1cbiAgICAgICAgcmdiWzNdID0gMTsgLy8gZGVmYXVsdCBhbHBoYVxuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH1cblxuICAgIC8vIHJnYmEoMTAwJSwwJSwwJSwwLjQpXG4gICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX1JHQkFfUENUKSkgfHwgKG0gPSBjc3MubWF0Y2goUkVfUkdCQV9QQ1RfTEVHQUNZKSkpIHtcbiAgICAgICAgY29uc3QgcmdiID0gbS5zbGljZSgxLCA1KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIHJnYltpXSA9IHJvdW5kJDEocmdiW2ldICogMi41NSk7XG4gICAgICAgIH1cbiAgICAgICAgcmdiWzNdID0gK3JnYlszXTtcbiAgICAgICAgcmV0dXJuIHJnYjtcbiAgICB9XG5cbiAgICAvLyBoc2woMCwxMDAlLDUwJSlcbiAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfSFNMKSkgfHwgKG0gPSBjc3MubWF0Y2goUkVfSFNMX0xFR0FDWSkpKSB7XG4gICAgICAgIGNvbnN0IGhzbCA9IG0uc2xpY2UoMSwgNCk7XG4gICAgICAgIGhzbFsxXSAqPSAwLjAxO1xuICAgICAgICBoc2xbMl0gKj0gMC4wMTtcbiAgICAgICAgY29uc3QgcmdiID0gaHNsMnJnYihoc2wpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgcmdiW2ldID0gcm91bmQkMShyZ2JbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJnYlszXSA9IDE7XG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuXG4gICAgLy8gaHNsYSgwLDEwMCUsNTAlLDAuNSlcbiAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfSFNMQSkpIHx8IChtID0gY3NzLm1hdGNoKFJFX0hTTEFfTEVHQUNZKSkpIHtcbiAgICAgICAgY29uc3QgaHNsID0gbS5zbGljZSgxLCA0KTtcbiAgICAgICAgaHNsWzFdICo9IDAuMDE7XG4gICAgICAgIGhzbFsyXSAqPSAwLjAxO1xuICAgICAgICBjb25zdCByZ2IgPSBoc2wycmdiKGhzbCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICByZ2JbaV0gPSByb3VuZCQxKHJnYltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmdiWzNdID0gK21bNF07IC8vIGRlZmF1bHQgYWxwaGEgPSAxXG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuXG4gICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX0xBQikpKSB7XG4gICAgICAgIGNvbnN0IGxhYiA9IG0uc2xpY2UoMSwgNCk7XG4gICAgICAgIGxhYlswXSA9IHBlcmNlbnRUb0Fic29sdXRlKGxhYlswXSwgMCwgMTAwKTtcbiAgICAgICAgbGFiWzFdID0gcGVyY2VudFRvQWJzb2x1dGUobGFiWzFdLCAtMTI1LCAxMjUsIHRydWUpO1xuICAgICAgICBsYWJbMl0gPSBwZXJjZW50VG9BYnNvbHV0ZShsYWJbMl0sIC0xMjUsIDEyNSwgdHJ1ZSk7XG4gICAgICAgIC8vIGNvbnZlcnQgdG8gRDUwIExhYiB3aGl0ZXBvaW50XG4gICAgICAgIGNvbnN0IHdwID0gZ2V0TGFiV2hpdGVQb2ludCgpO1xuICAgICAgICBzZXRMYWJXaGl0ZVBvaW50KCdkNTAnKTtcbiAgICAgICAgY29uc3QgcmdiID0gcm91bmRSR0IobGFiMnJnYihsYWIpKTtcbiAgICAgICAgLy8gY29udmVydCBiYWNrIHRvIG9yaWdpbmFsIExhYiB3aGl0ZXBvaW50XG4gICAgICAgIHNldExhYldoaXRlUG9pbnQod3ApO1xuICAgICAgICByZ2JbM10gPSBtWzRdICE9PSB1bmRlZmluZWQgPyArbVs0XSA6IDE7XG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuXG4gICAgaWYgKChtID0gY3NzLm1hdGNoKFJFX0xDSCkpKSB7XG4gICAgICAgIGNvbnN0IGxjaCA9IG0uc2xpY2UoMSwgNCk7XG4gICAgICAgIGxjaFswXSA9IHBlcmNlbnRUb0Fic29sdXRlKGxjaFswXSwgMCwgMTAwKTtcbiAgICAgICAgbGNoWzFdID0gcGVyY2VudFRvQWJzb2x1dGUobm9uZVRvVmFsdWUobGNoWzFdLCAwKSwgMCwgMTUwLCBmYWxzZSk7XG4gICAgICAgIGxjaFsyXSA9ICtub25lVG9WYWx1ZShsY2hbMl0ucmVwbGFjZSgnZGVnJywgJycpLCAwKTtcbiAgICAgICAgLy8gY29udmVydCB0byBENTAgTGFiIHdoaXRlcG9pbnRcbiAgICAgICAgY29uc3Qgd3AgPSBnZXRMYWJXaGl0ZVBvaW50KCk7XG4gICAgICAgIHNldExhYldoaXRlUG9pbnQoJ2Q1MCcpO1xuICAgICAgICBjb25zdCByZ2IgPSByb3VuZFJHQihsY2gycmdiKGxjaCkpO1xuICAgICAgICAvLyBjb252ZXJ0IGJhY2sgdG8gb3JpZ2luYWwgTGFiIHdoaXRlcG9pbnRcbiAgICAgICAgc2V0TGFiV2hpdGVQb2ludCh3cCk7XG4gICAgICAgIHJnYlszXSA9IG1bNF0gIT09IHVuZGVmaW5lZCA/ICttWzRdIDogMTtcbiAgICAgICAgcmV0dXJuIHJnYjtcbiAgICB9XG5cbiAgICBpZiAoKG0gPSBjc3MubWF0Y2goUkVfT0tMQUIpKSkge1xuICAgICAgICBjb25zdCBva2xhYiA9IG0uc2xpY2UoMSwgNCk7XG4gICAgICAgIG9rbGFiWzBdID0gcGVyY2VudFRvQWJzb2x1dGUob2tsYWJbMF0sIDAsIDEpO1xuICAgICAgICBva2xhYlsxXSA9IHBlcmNlbnRUb0Fic29sdXRlKG9rbGFiWzFdLCAtMC40LCAwLjQsIHRydWUpO1xuICAgICAgICBva2xhYlsyXSA9IHBlcmNlbnRUb0Fic29sdXRlKG9rbGFiWzJdLCAtMC40LCAwLjQsIHRydWUpO1xuICAgICAgICBjb25zdCByZ2IgPSByb3VuZFJHQihva2xhYjJyZ2Iob2tsYWIpKTtcbiAgICAgICAgcmdiWzNdID0gbVs0XSAhPT0gdW5kZWZpbmVkID8gK21bNF0gOiAxO1xuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH1cblxuICAgIGlmICgobSA9IGNzcy5tYXRjaChSRV9PS0xDSCkpKSB7XG4gICAgICAgIGNvbnN0IG9rbGNoID0gbS5zbGljZSgxLCA0KTtcbiAgICAgICAgb2tsY2hbMF0gPSBwZXJjZW50VG9BYnNvbHV0ZShva2xjaFswXSwgMCwgMSk7XG4gICAgICAgIG9rbGNoWzFdID0gcGVyY2VudFRvQWJzb2x1dGUobm9uZVRvVmFsdWUob2tsY2hbMV0sIDApLCAwLCAwLjQsIGZhbHNlKTtcbiAgICAgICAgb2tsY2hbMl0gPSArbm9uZVRvVmFsdWUob2tsY2hbMl0ucmVwbGFjZSgnZGVnJywgJycpLCAwKTtcbiAgICAgICAgY29uc3QgcmdiID0gcm91bmRSR0Iob2tsY2gycmdiKG9rbGNoKSk7XG4gICAgICAgIHJnYlszXSA9IG1bNF0gIT09IHVuZGVmaW5lZCA/ICttWzRdIDogMTtcbiAgICAgICAgcmV0dXJuIHJnYjtcbiAgICB9XG59O1xuXG5jc3MycmdiLnRlc3QgPSAocykgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIC8vIG1vZGVyblxuICAgICAgICBSRV9SR0IudGVzdChzKSB8fFxuICAgICAgICBSRV9SR0JBLnRlc3QocykgfHxcbiAgICAgICAgUkVfUkdCX1BDVC50ZXN0KHMpIHx8XG4gICAgICAgIFJFX1JHQkFfUENULnRlc3QocykgfHxcbiAgICAgICAgUkVfSFNMLnRlc3QocykgfHxcbiAgICAgICAgUkVfSFNMQS50ZXN0KHMpIHx8XG4gICAgICAgIFJFX0xBQi50ZXN0KHMpIHx8XG4gICAgICAgIFJFX0xDSC50ZXN0KHMpIHx8XG4gICAgICAgIFJFX09LTEFCLnRlc3QocykgfHxcbiAgICAgICAgUkVfT0tMQ0gudGVzdChzKSB8fFxuICAgICAgICAvLyBsZWdhY3lcbiAgICAgICAgUkVfUkdCX0xFR0FDWS50ZXN0KHMpIHx8XG4gICAgICAgIFJFX1JHQkFfTEVHQUNZLnRlc3QocykgfHxcbiAgICAgICAgUkVfUkdCX1BDVF9MRUdBQ1kudGVzdChzKSB8fFxuICAgICAgICBSRV9SR0JBX1BDVF9MRUdBQ1kudGVzdChzKSB8fFxuICAgICAgICBSRV9IU0xfTEVHQUNZLnRlc3QocykgfHxcbiAgICAgICAgUkVfSFNMQV9MRUdBQ1kudGVzdChzKVxuICAgICk7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuY3NzID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICByZXR1cm4gcmdiMmNzcyh0aGlzLl9yZ2IsIG1vZGUpO1xufTtcblxuY29uc3QgY3NzID0gKC4uLmFyZ3MpID0+IG5ldyBDb2xvciguLi5hcmdzLCAnY3NzJyk7XG5jaHJvbWEuY3NzID0gY3NzO1xuXG5pbnB1dC5mb3JtYXQuY3NzID0gY3NzMnJnYjtcblxuaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICBwOiA1LFxuICAgIHRlc3Q6IChoLCAuLi5yZXN0KSA9PiB7XG4gICAgICAgIGlmICghcmVzdC5sZW5ndGggJiYgdHlwZShoKSA9PT0gJ3N0cmluZycgJiYgY3NzMnJnYi50ZXN0KGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Nzcyc7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuaW5wdXQuZm9ybWF0LmdsID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCByZ2IgPSB1bnBhY2soYXJncywgJ3JnYmEnKTtcbiAgICByZ2JbMF0gKj0gMjU1O1xuICAgIHJnYlsxXSAqPSAyNTU7XG4gICAgcmdiWzJdICo9IDI1NTtcbiAgICByZXR1cm4gcmdiO1xufTtcblxuY29uc3QgZ2wgPSAoLi4uYXJncykgPT4gbmV3IENvbG9yKC4uLmFyZ3MsICdnbCcpO1xuY2hyb21hLmdsID0gZ2w7XG5cbkNvbG9yLnByb3RvdHlwZS5nbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmV0dXJuIFtyZ2JbMF0gLyAyNTUsIHJnYlsxXSAvIDI1NSwgcmdiWzJdIC8gMjU1LCByZ2JbM11dO1xufTtcblxuQ29sb3IucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgcmV0dXJuIHJnYjJoZXgodGhpcy5fcmdiLCBtb2RlKTtcbn07XG5cbmNvbnN0IGhleCA9ICguLi5hcmdzKSA9PiBuZXcgQ29sb3IoLi4uYXJncywgJ2hleCcpO1xuY2hyb21hLmhleCA9IGhleDtcblxuaW5wdXQuZm9ybWF0LmhleCA9IGhleDJyZ2I7XG5pbnB1dC5hdXRvZGV0ZWN0LnB1c2goe1xuICAgIHA6IDQsXG4gICAgdGVzdDogKGgsIC4uLnJlc3QpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXJlc3QubGVuZ3RoICYmXG4gICAgICAgICAgICB0eXBlKGgpID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgWzMsIDQsIDUsIDYsIDcsIDgsIDldLmluZGV4T2YoaC5sZW5ndGgpID49IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2hleCc7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLypcbiAqIEJhc2VkIG9uIGltcGxlbWVudGF0aW9uIGJ5IE5laWwgQmFydGxldHRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWlsYmFydGxldHQvY29sb3ItdGVtcGVyYXR1cmVcbiAqL1xuXG5jb25zdCB7IGxvZyB9ID0gTWF0aDtcblxuY29uc3QgdGVtcGVyYXR1cmUycmdiID0gKGtlbHZpbikgPT4ge1xuICAgIGNvbnN0IHRlbXAgPSBrZWx2aW4gLyAxMDA7XG4gICAgbGV0IHIsIGcsIGI7XG4gICAgaWYgKHRlbXAgPCA2Nikge1xuICAgICAgICByID0gMjU1O1xuICAgICAgICBnID1cbiAgICAgICAgICAgIHRlbXAgPCA2XG4gICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgOiAtMTU1LjI1NDg1NTYyNzA5MTc5IC1cbiAgICAgICAgICAgICAgICAgIDAuNDQ1OTY5NTA0Njk1NzkxMzMgKiAoZyA9IHRlbXAgLSAyKSArXG4gICAgICAgICAgICAgICAgICAxMDQuNDkyMTYxOTkzOTM4ODggKiBsb2coZyk7XG4gICAgICAgIGIgPVxuICAgICAgICAgICAgdGVtcCA8IDIwXG4gICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgOiAtMjU0Ljc2OTM1MTg0MTIwOTAyICtcbiAgICAgICAgICAgICAgICAgIDAuODI3NDA5NjA2NDAwNzM5NSAqIChiID0gdGVtcCAtIDEwKSArXG4gICAgICAgICAgICAgICAgICAxMTUuNjc5OTQ0MDEwNjYxNDcgKiBsb2coYik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgciA9XG4gICAgICAgICAgICAzNTEuOTc2OTA1NjY4MDU2OTMgK1xuICAgICAgICAgICAgMC4xMTQyMDY0NTM3ODQxNjUgKiAociA9IHRlbXAgLSA1NSkgLVxuICAgICAgICAgICAgNDAuMjUzNjYzMDkzMzIxMjcgKiBsb2cocik7XG4gICAgICAgIGcgPVxuICAgICAgICAgICAgMzI1LjQ0OTQxMjU3MTE5NzQgK1xuICAgICAgICAgICAgMC4wNzk0MzQ1NjUzNjY2MjM0MiAqIChnID0gdGVtcCAtIDUwKSAtXG4gICAgICAgICAgICAyOC4wODUyOTYzNTA3OTU3ICogbG9nKGcpO1xuICAgICAgICBiID0gMjU1O1xuICAgIH1cbiAgICByZXR1cm4gW3IsIGcsIGIsIDFdO1xufTtcblxuLypcbiAqIEJhc2VkIG9uIGltcGxlbWVudGF0aW9uIGJ5IE5laWwgQmFydGxldHRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWlsYmFydGxldHQvY29sb3ItdGVtcGVyYXR1cmVcbiAqKi9cblxuY29uc3QgeyByb3VuZCB9ID0gTWF0aDtcblxuY29uc3QgcmdiMnRlbXBlcmF0dXJlID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCByZ2IgPSB1bnBhY2soYXJncywgJ3JnYicpO1xuICAgIGNvbnN0IHIgPSByZ2JbMF0sXG4gICAgICAgIGIgPSByZ2JbMl07XG4gICAgbGV0IG1pblRlbXAgPSAxMDAwO1xuICAgIGxldCBtYXhUZW1wID0gNDAwMDA7XG4gICAgY29uc3QgZXBzID0gMC40O1xuICAgIGxldCB0ZW1wO1xuICAgIHdoaWxlIChtYXhUZW1wIC0gbWluVGVtcCA+IGVwcykge1xuICAgICAgICB0ZW1wID0gKG1heFRlbXAgKyBtaW5UZW1wKSAqIDAuNTtcbiAgICAgICAgY29uc3QgcmdiID0gdGVtcGVyYXR1cmUycmdiKHRlbXApO1xuICAgICAgICBpZiAocmdiWzJdIC8gcmdiWzBdID49IGIgLyByKSB7XG4gICAgICAgICAgICBtYXhUZW1wID0gdGVtcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pblRlbXAgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb3VuZCh0ZW1wKTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS50ZW1wID1cbiAgICBDb2xvci5wcm90b3R5cGUua2VsdmluID1cbiAgICBDb2xvci5wcm90b3R5cGUudGVtcGVyYXR1cmUgPVxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmdiMnRlbXBlcmF0dXJlKHRoaXMuX3JnYik7XG4gICAgICAgIH07XG5cbmNvbnN0IHRlbXAgPSAoLi4uYXJncykgPT4gbmV3IENvbG9yKC4uLmFyZ3MsICd0ZW1wJyk7XG5PYmplY3QuYXNzaWduKGNocm9tYSwgeyB0ZW1wLCBrZWx2aW46IHRlbXAsIHRlbXBlcmF0dXJlOiB0ZW1wIH0pO1xuXG5pbnB1dC5mb3JtYXQudGVtcCA9XG4gICAgaW5wdXQuZm9ybWF0LmtlbHZpbiA9XG4gICAgaW5wdXQuZm9ybWF0LnRlbXBlcmF0dXJlID1cbiAgICAgICAgdGVtcGVyYXR1cmUycmdiO1xuXG5Db2xvci5wcm90b3R5cGUub2tsY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJnYjJva2xjaCh0aGlzLl9yZ2IpO1xufTtcblxuY29uc3Qgb2tsY2ggPSAoLi4uYXJncykgPT4gbmV3IENvbG9yKC4uLmFyZ3MsICdva2xjaCcpO1xuT2JqZWN0LmFzc2lnbihjaHJvbWEsIHsgb2tsY2ggfSk7XG5cbmlucHV0LmZvcm1hdC5va2xjaCA9IG9rbGNoMnJnYjtcblxuaW5wdXQuYXV0b2RldGVjdC5wdXNoKHtcbiAgICBwOiAyLFxuICAgIHRlc3Q6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGFyZ3MgPSB1bnBhY2soYXJncywgJ29rbGNoJyk7XG4gICAgICAgIGlmICh0eXBlKGFyZ3MpID09PSAnYXJyYXknICYmIGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ29rbGNoJztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vLyBmZWVsIGZyZWUgdG8gY29tbWVudCBvdXQgYW55dGhpbmcgdG8gcm9sbHVwXG4vLyBhIHNtYWxsZXIgY2hyb21hLmpzIGJ1bmRsZVxuXG5PYmplY3QuYXNzaWduKGNocm9tYSwge1xuICAgIGFuYWx5emUsXG4gICAgYXZlcmFnZSxcbiAgICBiZXppZXI6IGJlemllciQxLFxuICAgIGJsZW5kLFxuICAgIGJyZXdlcjogY29sb3JicmV3ZXIsXG4gICAgQ29sb3IsXG4gICAgY29sb3JzOiB3M2N4MTEsXG4gICAgY29udHJhc3QsXG4gICAgY3ViZWhlbGl4LFxuICAgIGRlbHRhRSxcbiAgICBkaXN0YW5jZSxcbiAgICBpbnB1dCxcbiAgICBpbnRlcnBvbGF0ZTogbWl4LFxuICAgIGxpbWl0cyxcbiAgICBtaXgsXG4gICAgcmFuZG9tOiByYW5kb20kMSxcbiAgICBzY2FsZSxcbiAgICBzY2FsZXMsXG4gICAgdmFsaWRcbn0pO1xuXG5mdW5jdGlvbiByZXBsYWNlTmFOKGFycmF5KSB7XG4gICAgLy8gZml4ZXMgYSBOYU4gZm9yIDAgdmFsdWVzIGluIENocm9tYUpTXG4gICAgYXJyYXlbMF0gPSAwO1xuICAgIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb05hbWVkT2JqZWN0KGhzdikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGh1ZTogaHN2WzBdLFxuICAgICAgICBzYXR1cmF0aW9uOiBoc3ZbMV0sXG4gICAgICAgIGJyaWdodG5lc3M6IGhzdlsyXSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb2xvcnNXaXRoTG9jayhwcm9wcywgb3B0aW9ucywgcmVzdWx0cykge1xuICAgIGNvbnN0IGxvY2tIU1YgPSBpc05hTihjaHJvbWEuaGV4KGAke29wdGlvbnMubG9ja0hleH1gKS5oc3YoKVswXSlcbiAgICAgICAgPyBjb252ZXJ0VG9OYW1lZE9iamVjdChyZXBsYWNlTmFOKGNocm9tYS5oZXgoYCR7b3B0aW9ucy5sb2NrSGV4fWApLmhzdigpKSlcbiAgICAgICAgOiBjb252ZXJ0VG9OYW1lZE9iamVjdChjaHJvbWEuaGV4KGAke29wdGlvbnMubG9ja0hleH1gKS5oc3YoKSk7XG4gICAgbGV0IHNob3J0ZXN0RGlzdGFuY2UgPSA5OTk5OTk7XG4gICAgbGV0IGxvY2tlZENvbG9yID0ge1xuICAgICAgICBodWU6IHsgc3RlcDogMCwgdmFsdWU6IDAgfSxcbiAgICAgICAgc2F0dXJhdGlvbjogeyBzdGVwOiAwLCB2YWx1ZTogMCB9LFxuICAgICAgICBicmlnaHRuZXNzOiB7IHN0ZXA6IDAsIHZhbHVlOiAwIH0sXG4gICAgICAgIHN0ZXA6IDAsXG4gICAgICAgIGlzTWFqb3I6IGZhbHNlLFxuICAgICAgICBpc0xvY2tlZDogZmFsc2VcbiAgICB9O1xuICAgIGxldCBsb2NrZWRJbmRleDtcbiAgICBjb25zdCBsYXN0Q29sb3IgPSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV07XG4gICAgcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChjb2xvciwgaW5kZXgpIHtcbiAgICAgICAgY29uc3QgeyBodWUsIHNhdHVyYXRpb24sIGJyaWdodG5lc3MgfSA9IGNvbG9yO1xuICAgICAgICBjb25zdCBoZXggPSBjaHJvbWEuaHN2KGh1ZS52YWx1ZSwgc2F0dXJhdGlvbi52YWx1ZSwgYnJpZ2h0bmVzcy52YWx1ZSk7XG4gICAgICAgIGlmIChvcHRpb25zLmxvY2tIZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBjaHJvbWEuZGlzdGFuY2UoaGV4LCBvcHRpb25zLmxvY2tIZXgpO1xuICAgICAgICAgICAgaWYgKHNob3J0ZXN0RGlzdGFuY2UgPiBkaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHNob3J0ZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBsb2NrZWRDb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgICAgIGxvY2tlZEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBkaWZmZXJlbmNlID0ge1xuICAgICAgICBodWU6IGxvY2tIU1YuaHVlIC0gbG9ja2VkQ29sb3IuaHVlLnZhbHVlLFxuICAgICAgICBzYXR1cmF0aW9uOiBsb2NrSFNWLnNhdHVyYXRpb24gLSBsb2NrZWRDb2xvci5zYXR1cmF0aW9uLnZhbHVlLFxuICAgICAgICBicmlnaHRuZXNzOiBsb2NrSFNWLmJyaWdodG5lc3MgLSBsb2NrZWRDb2xvci5icmlnaHRuZXNzLnZhbHVlLFxuICAgIH07XG4gICAgY29uc3QgYWRqdXN0ZWRDb2xvclNldCA9IHJlc3VsdHMubWFwKGZ1bmN0aW9uIChjb2xvciwgaW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChpbmRleCA8IGxvY2tlZEluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBodWVEaWZmZXJlbmNlID0gZGlzdHJpYnV0ZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGluZGV4LFxuICAgICAgICAgICAgICAgIHJhbmdlQTogWzAsIGxvY2tlZEluZGV4XSxcbiAgICAgICAgICAgICAgICByYW5nZUI6IFswLCBkaWZmZXJlbmNlLmh1ZV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNhdHVyYXRpb25EaWZmZXJlbmNlID0gZGlzdHJpYnV0ZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGluZGV4LFxuICAgICAgICAgICAgICAgIHJhbmdlQTogWzAsIGxvY2tlZEluZGV4XSxcbiAgICAgICAgICAgICAgICByYW5nZUI6IFswLCBkaWZmZXJlbmNlLnNhdHVyYXRpb25dLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBicmlnaHRuZXNzRGlmZmVyZW5jZSA9IGRpc3RyaWJ1dGUoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpbmRleCxcbiAgICAgICAgICAgICAgICByYW5nZUE6IFswLCBsb2NrZWRJbmRleF0sXG4gICAgICAgICAgICAgICAgcmFuZ2VCOiBbMCwgZGlmZmVyZW5jZS5icmlnaHRuZXNzXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBodWU6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogY29sb3IuaHVlLnN0ZXAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2xvci5odWUudmFsdWUgKyBodWVEaWZmZXJlbmNlID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb2xvci5odWUudmFsdWUgKyBodWVEaWZmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzYXR1cmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IGNvbG9yLnNhdHVyYXRpb24uc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbG9yLnNhdHVyYXRpb24udmFsdWUgKyBzYXR1cmF0aW9uRGlmZmVyZW5jZSA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29sb3Iuc2F0dXJhdGlvbi52YWx1ZSArIHNhdHVyYXRpb25EaWZmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBicmlnaHRuZXNzOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IGNvbG9yLmJyaWdodG5lc3Muc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbG9yLmJyaWdodG5lc3MudmFsdWUgKyBicmlnaHRuZXNzRGlmZmVyZW5jZSA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29sb3IuYnJpZ2h0bmVzcy52YWx1ZSArIGJyaWdodG5lc3NEaWZmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdGVwOiBjb2xvci5zdGVwLFxuICAgICAgICAgICAgICAgIGlzTWFqb3I6IGNvbG9yLmlzTWFqb3IsXG4gICAgICAgICAgICAgICAgaXNMb2NrZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gbG9ja2VkSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaHVlOiB7IHN0ZXA6IGNvbG9yLmh1ZS5zdGVwLCB2YWx1ZTogbG9ja0hTVi5odWUgfSxcbiAgICAgICAgICAgICAgICBzYXR1cmF0aW9uOiB7IHN0ZXA6IGNvbG9yLnNhdHVyYXRpb24uc3RlcCwgdmFsdWU6IGxvY2tIU1Yuc2F0dXJhdGlvbiB9LFxuICAgICAgICAgICAgICAgIGJyaWdodG5lc3M6IHsgc3RlcDogY29sb3IuYnJpZ2h0bmVzcy5zdGVwLCB2YWx1ZTogbG9ja0hTVi5icmlnaHRuZXNzIH0sXG4gICAgICAgICAgICAgICAgc3RlcDogY29sb3Iuc3RlcCxcbiAgICAgICAgICAgICAgICBpc01ham9yOiBjb2xvci5pc01ham9yLFxuICAgICAgICAgICAgICAgIGlzTG9ja2VkOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGh1ZURpZmZlcmVuY2UgPSBkaXN0cmlidXRlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaW5kZXgsXG4gICAgICAgICAgICAgICAgcmFuZ2VBOiBbbG9ja2VkSW5kZXgsIGxhc3RDb2xvci5zdGVwICsgKCgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWlub3JTdGVwcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgfHwgMCldLFxuICAgICAgICAgICAgICAgIHJhbmdlQjogW2RpZmZlcmVuY2UuaHVlLCAwXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2F0dXJhdGlvbkRpZmZlcmVuY2UgPSBkaXN0cmlidXRlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaW5kZXgsXG4gICAgICAgICAgICAgICAgcmFuZ2VBOiBbbG9ja2VkSW5kZXgsIGxhc3RDb2xvci5zdGVwICsgKCgoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWlub3JTdGVwcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxlbmd0aCkgfHwgMCldLFxuICAgICAgICAgICAgICAgIHJhbmdlQjogW2RpZmZlcmVuY2Uuc2F0dXJhdGlvbiwgMF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGJyaWdodG5lc3NEaWZmZXJlbmNlID0gZGlzdHJpYnV0ZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGluZGV4LFxuICAgICAgICAgICAgICAgIHJhbmdlQTogW2xvY2tlZEluZGV4LCBsYXN0Q29sb3Iuc3RlcCArICgoKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pbm9yU3RlcHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpIHx8IDApXSxcbiAgICAgICAgICAgICAgICByYW5nZUI6IFtkaWZmZXJlbmNlLmJyaWdodG5lc3MsIDBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGh1ZToge1xuICAgICAgICAgICAgICAgICAgICBzdGVwOiBjb2xvci5odWUuc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbG9yLmh1ZS52YWx1ZSArIGh1ZURpZmZlcmVuY2UgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvci5odWUudmFsdWUgKyBodWVEaWZmZXJlbmNlIDwgMzYwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbG9yLmh1ZS52YWx1ZSArIGh1ZURpZmZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNhdHVyYXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogY29sb3Iuc2F0dXJhdGlvbi5zdGVwLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29sb3Iuc2F0dXJhdGlvbi52YWx1ZSArIHNhdHVyYXRpb25EaWZmZXJlbmNlIDwgMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb2xvci5zYXR1cmF0aW9uLnZhbHVlICsgc2F0dXJhdGlvbkRpZmZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJyaWdodG5lc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogY29sb3IuYnJpZ2h0bmVzcy5zdGVwLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29sb3IuYnJpZ2h0bmVzcy52YWx1ZSArIGJyaWdodG5lc3NEaWZmZXJlbmNlIDwgMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb2xvci5icmlnaHRuZXNzLnZhbHVlICsgYnJpZ2h0bmVzc0RpZmZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0ZXA6IGNvbG9yLnN0ZXAsXG4gICAgICAgICAgICAgICAgaXNNYWpvcjogY29sb3IuaXNNYWpvcixcbiAgICAgICAgICAgICAgICBpc0xvY2tlZDogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFkanVzdGVkQ29sb3JTZXQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlKHByb3BzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGNvbnN0IHsgbG9ja0hleCwgbG9ja0hleEludmVydGVkLCBwcm92aWRlSW52ZXJ0ZWQgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYWxnb3JpdGhtUmVzdWx0ID0gW107XG4gICAgY29uc3QgZ2VuZXJhdGVkID0gZ2VuZXJhdGVDb2xvcnMocHJvcHMsIG9wdGlvbnMpO1xuICAgIGlmIChsb2NrSGV4KSB7XG4gICAgICAgIGFsZ29yaXRobVJlc3VsdC5wdXNoKGdlbmVyYXRlQ29sb3JzV2l0aExvY2socHJvcHMsIG9wdGlvbnMsIGdlbmVyYXRlZCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWxnb3JpdGhtUmVzdWx0LnB1c2goZ2VuZXJhdGVkKTtcbiAgICB9XG4gICAgaWYgKHByb3ZpZGVJbnZlcnRlZCkge1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWRJbnZlcnRlZCA9IGdlbmVyYXRlQ29sb3JzKHByb3BzLCBvcHRpb25zLCB0cnVlKTtcbiAgICAgICAgbG9ja0hleEludmVydGVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYWxnb3JpdGhtUmVzdWx0LnB1c2goZ2VuZXJhdGVkSW52ZXJ0ZWQpXG4gICAgICAgICAgICA6IGFsZ29yaXRobVJlc3VsdC5wdXNoKGdlbmVyYXRlQ29sb3JzV2l0aExvY2socHJvcHMsIG9wdGlvbnMsIGdlbmVyYXRlZEludmVydGVkKSk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0VG9Db2xvcnMocHJvcHMsIG9wdGlvbnMsIGFsZ29yaXRobVJlc3VsdCk7XG59XG5cbmV4cG9ydCB7IGdlbmVyYXRlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@k-vyn/coloralgorithm/dist/bundle.js\n");

/***/ })

};
;